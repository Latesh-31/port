"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/stats-gl";
exports.ids = ["vendor-chunks/stats-gl"];
exports.modules = {

/***/ "(ssr)/./node_modules/stats-gl/dist/main.cjs":
/*!*********************************************!*\
  !*** ./node_modules/stats-gl/dist/main.cjs ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst panel = __webpack_require__(/*! ./panel.cjs */ \"(ssr)/./node_modules/stats-gl/dist/panel.cjs\");\nconst _Stats = class _Stats2 {\n  constructor({\n    trackGPU = false,\n    logsPerSecond = 30,\n    samplesLog = 60,\n    samplesGraph = 10,\n    precision = 2,\n    minimal = false,\n    horizontal = true,\n    mode = 0\n  } = {}) {\n    this.gl = null;\n    this.ext = null;\n    this.activeQuery = null;\n    this.gpuQueries = [];\n    this.threeRendererPatched = false;\n    this.frames = 0;\n    this.renderCount = 0;\n    this.isRunningCPUProfiling = false;\n    this.totalCpuDuration = 0;\n    this.totalGpuDuration = 0;\n    this.totalGpuDurationCompute = 0;\n    this.totalFps = 0;\n    this.gpuPanel = null;\n    this.gpuPanelCompute = null;\n    this.averageFps = { logs: [], graph: [] };\n    this.averageCpu = { logs: [], graph: [] };\n    this.averageGpu = { logs: [], graph: [] };\n    this.averageGpuCompute = { logs: [], graph: [] };\n    this.handleClick = (event) => {\n      event.preventDefault();\n      this.showPanel(++this.mode % this.dom.children.length);\n    };\n    this.handleResize = () => {\n      this.resizePanel(this.fpsPanel, 0);\n      this.resizePanel(this.msPanel, 1);\n      if (this.gpuPanel)\n        this.resizePanel(this.gpuPanel, 2);\n      if (this.gpuPanelCompute)\n        this.resizePanel(this.gpuPanelCompute, 3);\n    };\n    this.mode = mode;\n    this.horizontal = horizontal;\n    this.minimal = minimal;\n    this.trackGPU = trackGPU;\n    this.samplesLog = samplesLog;\n    this.samplesGraph = samplesGraph;\n    this.precision = precision;\n    this.logsPerSecond = logsPerSecond;\n    this.dom = document.createElement(\"div\");\n    this.initializeDOM();\n    this.beginTime = performance.now();\n    this.prevTime = this.beginTime;\n    this.prevCpuTime = this.beginTime;\n    this.fpsPanel = this.addPanel(new _Stats2.Panel(\"FPS\", \"#0ff\", \"#002\"), 0);\n    this.msPanel = this.addPanel(new _Stats2.Panel(\"CPU\", \"#0f0\", \"#020\"), 1);\n    this.setupEventListeners();\n  }\n  initializeDOM() {\n    this.dom.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      opacity: 0.9;\n      z-index: 10000;\n      ${this.minimal ? \"cursor: pointer;\" : \"\"}\n    `;\n  }\n  setupEventListeners() {\n    if (this.minimal) {\n      this.dom.addEventListener(\"click\", this.handleClick);\n      this.showPanel(this.mode);\n    } else {\n      window.addEventListener(\"resize\", this.handleResize);\n    }\n  }\n  async init(canvasOrGL) {\n    if (!canvasOrGL) {\n      console.error('Stats: The \"canvas\" parameter is undefined.');\n      return;\n    }\n    if (this.handleThreeRenderer(canvasOrGL))\n      return;\n    if (await this.handleWebGPURenderer(canvasOrGL))\n      return;\n    if (!this.initializeWebGL(canvasOrGL))\n      return;\n  }\n  handleThreeRenderer(renderer) {\n    if (renderer.isWebGLRenderer && !this.threeRendererPatched) {\n      this.patchThreeRenderer(renderer);\n      this.gl = renderer.getContext();\n      if (this.trackGPU) {\n        this.initializeGPUTracking();\n      }\n      return true;\n    }\n    return false;\n  }\n  async handleWebGPURenderer(renderer) {\n    if (renderer.isWebGPURenderer) {\n      if (this.trackGPU) {\n        renderer.backend.trackTimestamp = true;\n        if (await renderer.hasFeatureAsync(\"timestamp-query\")) {\n          this.initializeWebGPUPanels();\n        }\n      }\n      this.info = renderer.info;\n      return true;\n    }\n    return false;\n  }\n  initializeWebGPUPanels() {\n    this.gpuPanel = this.addPanel(new _Stats2.Panel(\"GPU\", \"#ff0\", \"#220\"), 2);\n    this.gpuPanelCompute = this.addPanel(\n      new _Stats2.Panel(\"CPT\", \"#e1e1e1\", \"#212121\"),\n      3\n    );\n  }\n  initializeWebGL(canvasOrGL) {\n    if (canvasOrGL instanceof WebGL2RenderingContext) {\n      this.gl = canvasOrGL;\n    } else if (canvasOrGL instanceof HTMLCanvasElement || canvasOrGL instanceof OffscreenCanvas) {\n      this.gl = canvasOrGL.getContext(\"webgl2\");\n      if (!this.gl) {\n        console.error(\"Stats: Unable to obtain WebGL2 context.\");\n        return false;\n      }\n    } else {\n      console.error(\n        \"Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.\"\n      );\n      return false;\n    }\n    return true;\n  }\n  initializeGPUTracking() {\n    if (this.gl) {\n      this.ext = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\");\n      if (this.ext) {\n        this.gpuPanel = this.addPanel(new _Stats2.Panel(\"GPU\", \"#ff0\", \"#220\"), 2);\n      }\n    }\n  }\n  begin() {\n    if (!this.isRunningCPUProfiling) {\n      this.beginProfiling(\"cpu-started\");\n    }\n    if (!this.gl || !this.ext)\n      return;\n    if (this.activeQuery) {\n      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n    }\n    this.activeQuery = this.gl.createQuery();\n    if (this.activeQuery) {\n      this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery);\n    }\n  }\n  end() {\n    this.renderCount++;\n    if (this.gl && this.ext && this.activeQuery) {\n      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n      this.gpuQueries.push({ query: this.activeQuery });\n      this.activeQuery = null;\n    }\n  }\n  update() {\n    if (!this.info) {\n      this.processGpuQueries();\n    } else {\n      this.processWebGPUTimestamps();\n    }\n    this.endProfiling(\"cpu-started\", \"cpu-finished\", \"cpu-duration\");\n    this.updateAverages();\n    this.resetCounters();\n  }\n  processWebGPUTimestamps() {\n    this.totalGpuDuration = this.info.render.timestamp;\n    this.totalGpuDurationCompute = this.info.compute.timestamp;\n    this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute);\n  }\n  updateAverages() {\n    this.addToAverage(this.totalCpuDuration, this.averageCpu);\n    this.addToAverage(this.totalGpuDuration, this.averageGpu);\n  }\n  resetCounters() {\n    this.renderCount = 0;\n    if (this.totalCpuDuration === 0) {\n      this.beginProfiling(\"cpu-started\");\n    }\n    this.totalCpuDuration = 0;\n    this.totalFps = 0;\n    this.beginTime = this.endInternal();\n  }\n  resizePanel(panel2, offset) {\n    panel2.canvas.style.position = \"absolute\";\n    if (this.minimal) {\n      panel2.canvas.style.display = \"none\";\n    } else {\n      panel2.canvas.style.display = \"block\";\n      if (this.horizontal) {\n        panel2.canvas.style.top = \"0px\";\n        panel2.canvas.style.left = offset * panel2.WIDTH / panel2.PR + \"px\";\n      } else {\n        panel2.canvas.style.left = \"0px\";\n        panel2.canvas.style.top = offset * panel2.HEIGHT / panel2.PR + \"px\";\n      }\n    }\n  }\n  addPanel(panel2, offset) {\n    if (panel2.canvas) {\n      this.dom.appendChild(panel2.canvas);\n      this.resizePanel(panel2, offset);\n    }\n    return panel2;\n  }\n  showPanel(id) {\n    for (let i = 0; i < this.dom.children.length; i++) {\n      const child = this.dom.children[i];\n      child.style.display = i === id ? \"block\" : \"none\";\n    }\n    this.mode = id;\n  }\n  processGpuQueries() {\n    if (!this.gl || !this.ext)\n      return;\n    this.totalGpuDuration = 0;\n    this.gpuQueries.forEach((queryInfo, index) => {\n      if (this.gl) {\n        const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);\n        const disjoint = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);\n        if (available && !disjoint) {\n          const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);\n          const duration = elapsed * 1e-6;\n          this.totalGpuDuration += duration;\n          this.gl.deleteQuery(queryInfo.query);\n          this.gpuQueries.splice(index, 1);\n        }\n      }\n    });\n  }\n  endInternal() {\n    this.frames++;\n    const time = (performance || Date).now();\n    const elapsed = time - this.prevTime;\n    if (time >= this.prevCpuTime + 1e3 / this.logsPerSecond) {\n      const fps = Math.round(this.frames * 1e3 / elapsed);\n      this.addToAverage(fps, this.averageFps);\n      this.updatePanel(this.fpsPanel, this.averageFps, 0);\n      this.updatePanel(this.msPanel, this.averageCpu, this.precision);\n      this.updatePanel(this.gpuPanel, this.averageGpu, this.precision);\n      if (this.gpuPanelCompute) {\n        this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute);\n      }\n      this.frames = 0;\n      this.prevCpuTime = time;\n      this.prevTime = time;\n    }\n    return time;\n  }\n  addToAverage(value, averageArray) {\n    averageArray.logs.push(value);\n    if (averageArray.logs.length > this.samplesLog) {\n      averageArray.logs.shift();\n    }\n    averageArray.graph.push(value);\n    if (averageArray.graph.length > this.samplesGraph) {\n      averageArray.graph.shift();\n    }\n  }\n  beginProfiling(marker) {\n    if (window.performance) {\n      window.performance.mark(marker);\n      this.isRunningCPUProfiling = true;\n    }\n  }\n  endProfiling(startMarker, endMarker, measureName) {\n    if (window.performance && endMarker && this.isRunningCPUProfiling) {\n      window.performance.mark(endMarker);\n      const cpuMeasure = performance.measure(measureName, startMarker, endMarker);\n      this.totalCpuDuration += cpuMeasure.duration;\n      this.isRunningCPUProfiling = false;\n    }\n  }\n  updatePanel(panel2, averageArray, precision = 2) {\n    if (averageArray.logs.length > 0) {\n      let sumLog = 0;\n      let max = 0.01;\n      for (let i = 0; i < averageArray.logs.length; i++) {\n        sumLog += averageArray.logs[i];\n        if (averageArray.logs[i] > max) {\n          max = averageArray.logs[i];\n        }\n      }\n      let sumGraph = 0;\n      let maxGraph = 0.01;\n      for (let i = 0; i < averageArray.graph.length; i++) {\n        sumGraph += averageArray.graph[i];\n        if (averageArray.graph[i] > maxGraph) {\n          maxGraph = averageArray.graph[i];\n        }\n      }\n      if (panel2) {\n        panel2.update(sumLog / Math.min(averageArray.logs.length, this.samplesLog), sumGraph / Math.min(averageArray.graph.length, this.samplesGraph), max, maxGraph, precision);\n      }\n    }\n  }\n  get domElement() {\n    return this.dom;\n  }\n  patchThreeRenderer(renderer) {\n    const originalRenderMethod = renderer.render;\n    const statsInstance = this;\n    renderer.render = function(scene, camera) {\n      statsInstance.begin();\n      originalRenderMethod.call(this, scene, camera);\n      statsInstance.end();\n    };\n    this.threeRendererPatched = true;\n  }\n};\n_Stats.Panel = panel.Panel;\nlet Stats = _Stats;\nmodule.exports = Stats;\n//# sourceMappingURL=main.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhdHMtZ2wvZGlzdC9tYWluLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxpRUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQ0FBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpdmluZy1ibHVlcHJpbnQtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3N0YXRzLWdsL2Rpc3QvbWFpbi5janM/YTg4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHBhbmVsID0gcmVxdWlyZShcIi4vcGFuZWwuY2pzXCIpO1xuY29uc3QgX1N0YXRzID0gY2xhc3MgX1N0YXRzMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0cmFja0dQVSA9IGZhbHNlLFxuICAgIGxvZ3NQZXJTZWNvbmQgPSAzMCxcbiAgICBzYW1wbGVzTG9nID0gNjAsXG4gICAgc2FtcGxlc0dyYXBoID0gMTAsXG4gICAgcHJlY2lzaW9uID0gMixcbiAgICBtaW5pbWFsID0gZmFsc2UsXG4gICAgaG9yaXpvbnRhbCA9IHRydWUsXG4gICAgbW9kZSA9IDBcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5nbCA9IG51bGw7XG4gICAgdGhpcy5leHQgPSBudWxsO1xuICAgIHRoaXMuYWN0aXZlUXVlcnkgPSBudWxsO1xuICAgIHRoaXMuZ3B1UXVlcmllcyA9IFtdO1xuICAgIHRoaXMudGhyZWVSZW5kZXJlclBhdGNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZyYW1lcyA9IDA7XG4gICAgdGhpcy5yZW5kZXJDb3VudCA9IDA7XG4gICAgdGhpcy5pc1J1bm5pbmdDUFVQcm9maWxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnRvdGFsQ3B1RHVyYXRpb24gPSAwO1xuICAgIHRoaXMudG90YWxHcHVEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50b3RhbEdwdUR1cmF0aW9uQ29tcHV0ZSA9IDA7XG4gICAgdGhpcy50b3RhbEZwcyA9IDA7XG4gICAgdGhpcy5ncHVQYW5lbCA9IG51bGw7XG4gICAgdGhpcy5ncHVQYW5lbENvbXB1dGUgPSBudWxsO1xuICAgIHRoaXMuYXZlcmFnZUZwcyA9IHsgbG9nczogW10sIGdyYXBoOiBbXSB9O1xuICAgIHRoaXMuYXZlcmFnZUNwdSA9IHsgbG9nczogW10sIGdyYXBoOiBbXSB9O1xuICAgIHRoaXMuYXZlcmFnZUdwdSA9IHsgbG9nczogW10sIGdyYXBoOiBbXSB9O1xuICAgIHRoaXMuYXZlcmFnZUdwdUNvbXB1dGUgPSB7IGxvZ3M6IFtdLCBncmFwaDogW10gfTtcbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zaG93UGFuZWwoKyt0aGlzLm1vZGUgJSB0aGlzLmRvbS5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlc2l6ZVBhbmVsKHRoaXMuZnBzUGFuZWwsIDApO1xuICAgICAgdGhpcy5yZXNpemVQYW5lbCh0aGlzLm1zUGFuZWwsIDEpO1xuICAgICAgaWYgKHRoaXMuZ3B1UGFuZWwpXG4gICAgICAgIHRoaXMucmVzaXplUGFuZWwodGhpcy5ncHVQYW5lbCwgMik7XG4gICAgICBpZiAodGhpcy5ncHVQYW5lbENvbXB1dGUpXG4gICAgICAgIHRoaXMucmVzaXplUGFuZWwodGhpcy5ncHVQYW5lbENvbXB1dGUsIDMpO1xuICAgIH07XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuICAgIHRoaXMubWluaW1hbCA9IG1pbmltYWw7XG4gICAgdGhpcy50cmFja0dQVSA9IHRyYWNrR1BVO1xuICAgIHRoaXMuc2FtcGxlc0xvZyA9IHNhbXBsZXNMb2c7XG4gICAgdGhpcy5zYW1wbGVzR3JhcGggPSBzYW1wbGVzR3JhcGg7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgdGhpcy5sb2dzUGVyU2Vjb25kID0gbG9nc1BlclNlY29uZDtcbiAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5pbml0aWFsaXplRE9NKCk7XG4gICAgdGhpcy5iZWdpblRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLnByZXZUaW1lID0gdGhpcy5iZWdpblRpbWU7XG4gICAgdGhpcy5wcmV2Q3B1VGltZSA9IHRoaXMuYmVnaW5UaW1lO1xuICAgIHRoaXMuZnBzUGFuZWwgPSB0aGlzLmFkZFBhbmVsKG5ldyBfU3RhdHMyLlBhbmVsKFwiRlBTXCIsIFwiIzBmZlwiLCBcIiMwMDJcIiksIDApO1xuICAgIHRoaXMubXNQYW5lbCA9IHRoaXMuYWRkUGFuZWwobmV3IF9TdGF0czIuUGFuZWwoXCJDUFVcIiwgXCIjMGYwXCIsIFwiIzAyMFwiKSwgMSk7XG4gICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgaW5pdGlhbGl6ZURPTSgpIHtcbiAgICB0aGlzLmRvbS5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIG9wYWNpdHk6IDAuOTtcbiAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgJHt0aGlzLm1pbmltYWwgPyBcImN1cnNvcjogcG9pbnRlcjtcIiA6IFwiXCJ9XG4gICAgYDtcbiAgfVxuICBzZXR1cEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLm1pbmltYWwpIHtcbiAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICAgIHRoaXMuc2hvd1BhbmVsKHRoaXMubW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaW5pdChjYW52YXNPckdMKSB7XG4gICAgaWYgKCFjYW52YXNPckdMKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTdGF0czogVGhlIFwiY2FudmFzXCIgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFuZGxlVGhyZWVSZW5kZXJlcihjYW52YXNPckdMKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoYXdhaXQgdGhpcy5oYW5kbGVXZWJHUFVSZW5kZXJlcihjYW52YXNPckdMKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZVdlYkdMKGNhbnZhc09yR0wpKVxuICAgICAgcmV0dXJuO1xuICB9XG4gIGhhbmRsZVRocmVlUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICBpZiAocmVuZGVyZXIuaXNXZWJHTFJlbmRlcmVyICYmICF0aGlzLnRocmVlUmVuZGVyZXJQYXRjaGVkKSB7XG4gICAgICB0aGlzLnBhdGNoVGhyZWVSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgICB0aGlzLmdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuICAgICAgaWYgKHRoaXMudHJhY2tHUFUpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplR1BVVHJhY2tpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgaGFuZGxlV2ViR1BVUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICBpZiAocmVuZGVyZXIuaXNXZWJHUFVSZW5kZXJlcikge1xuICAgICAgaWYgKHRoaXMudHJhY2tHUFUpIHtcbiAgICAgICAgcmVuZGVyZXIuYmFja2VuZC50cmFja1RpbWVzdGFtcCA9IHRydWU7XG4gICAgICAgIGlmIChhd2FpdCByZW5kZXJlci5oYXNGZWF0dXJlQXN5bmMoXCJ0aW1lc3RhbXAtcXVlcnlcIikpIHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVXZWJHUFVQYW5lbHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5pbmZvID0gcmVuZGVyZXIuaW5mbztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaW5pdGlhbGl6ZVdlYkdQVVBhbmVscygpIHtcbiAgICB0aGlzLmdwdVBhbmVsID0gdGhpcy5hZGRQYW5lbChuZXcgX1N0YXRzMi5QYW5lbChcIkdQVVwiLCBcIiNmZjBcIiwgXCIjMjIwXCIpLCAyKTtcbiAgICB0aGlzLmdwdVBhbmVsQ29tcHV0ZSA9IHRoaXMuYWRkUGFuZWwoXG4gICAgICBuZXcgX1N0YXRzMi5QYW5lbChcIkNQVFwiLCBcIiNlMWUxZTFcIiwgXCIjMjEyMTIxXCIpLFxuICAgICAgM1xuICAgICk7XG4gIH1cbiAgaW5pdGlhbGl6ZVdlYkdMKGNhbnZhc09yR0wpIHtcbiAgICBpZiAoY2FudmFzT3JHTCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgIHRoaXMuZ2wgPSBjYW52YXNPckdMO1xuICAgIH0gZWxzZSBpZiAoY2FudmFzT3JHTCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IGNhbnZhc09yR0wgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHRoaXMuZ2wgPSBjYW52YXNPckdMLmdldENvbnRleHQoXCJ3ZWJnbDJcIik7XG4gICAgICBpZiAoIXRoaXMuZ2wpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlN0YXRzOiBVbmFibGUgdG8gb2J0YWluIFdlYkdMMiBjb250ZXh0LlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlN0YXRzOiBJbnZhbGlkIGlucHV0IHR5cGUuIEV4cGVjdGVkIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIEhUTUxDYW52YXNFbGVtZW50LCBvciBPZmZzY3JlZW5DYW52YXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGluaXRpYWxpemVHUFVUcmFja2luZygpIHtcbiAgICBpZiAodGhpcy5nbCkge1xuICAgICAgdGhpcy5leHQgPSB0aGlzLmdsLmdldEV4dGVuc2lvbihcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIik7XG4gICAgICBpZiAodGhpcy5leHQpIHtcbiAgICAgICAgdGhpcy5ncHVQYW5lbCA9IHRoaXMuYWRkUGFuZWwobmV3IF9TdGF0czIuUGFuZWwoXCJHUFVcIiwgXCIjZmYwXCIsIFwiIzIyMFwiKSwgMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJlZ2luKCkge1xuICAgIGlmICghdGhpcy5pc1J1bm5pbmdDUFVQcm9maWxpbmcpIHtcbiAgICAgIHRoaXMuYmVnaW5Qcm9maWxpbmcoXCJjcHUtc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmdsIHx8ICF0aGlzLmV4dClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5hY3RpdmVRdWVyeSkge1xuICAgICAgdGhpcy5nbC5lbmRRdWVyeSh0aGlzLmV4dC5USU1FX0VMQVBTRURfRVhUKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVRdWVyeSA9IHRoaXMuZ2wuY3JlYXRlUXVlcnkoKTtcbiAgICBpZiAodGhpcy5hY3RpdmVRdWVyeSkge1xuICAgICAgdGhpcy5nbC5iZWdpblF1ZXJ5KHRoaXMuZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHRoaXMuYWN0aXZlUXVlcnkpO1xuICAgIH1cbiAgfVxuICBlbmQoKSB7XG4gICAgdGhpcy5yZW5kZXJDb3VudCsrO1xuICAgIGlmICh0aGlzLmdsICYmIHRoaXMuZXh0ICYmIHRoaXMuYWN0aXZlUXVlcnkpIHtcbiAgICAgIHRoaXMuZ2wuZW5kUXVlcnkodGhpcy5leHQuVElNRV9FTEFQU0VEX0VYVCk7XG4gICAgICB0aGlzLmdwdVF1ZXJpZXMucHVzaCh7IHF1ZXJ5OiB0aGlzLmFjdGl2ZVF1ZXJ5IH0pO1xuICAgICAgdGhpcy5hY3RpdmVRdWVyeSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5mbykge1xuICAgICAgdGhpcy5wcm9jZXNzR3B1UXVlcmllcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb2Nlc3NXZWJHUFVUaW1lc3RhbXBzKCk7XG4gICAgfVxuICAgIHRoaXMuZW5kUHJvZmlsaW5nKFwiY3B1LXN0YXJ0ZWRcIiwgXCJjcHUtZmluaXNoZWRcIiwgXCJjcHUtZHVyYXRpb25cIik7XG4gICAgdGhpcy51cGRhdGVBdmVyYWdlcygpO1xuICAgIHRoaXMucmVzZXRDb3VudGVycygpO1xuICB9XG4gIHByb2Nlc3NXZWJHUFVUaW1lc3RhbXBzKCkge1xuICAgIHRoaXMudG90YWxHcHVEdXJhdGlvbiA9IHRoaXMuaW5mby5yZW5kZXIudGltZXN0YW1wO1xuICAgIHRoaXMudG90YWxHcHVEdXJhdGlvbkNvbXB1dGUgPSB0aGlzLmluZm8uY29tcHV0ZS50aW1lc3RhbXA7XG4gICAgdGhpcy5hZGRUb0F2ZXJhZ2UodGhpcy50b3RhbEdwdUR1cmF0aW9uQ29tcHV0ZSwgdGhpcy5hdmVyYWdlR3B1Q29tcHV0ZSk7XG4gIH1cbiAgdXBkYXRlQXZlcmFnZXMoKSB7XG4gICAgdGhpcy5hZGRUb0F2ZXJhZ2UodGhpcy50b3RhbENwdUR1cmF0aW9uLCB0aGlzLmF2ZXJhZ2VDcHUpO1xuICAgIHRoaXMuYWRkVG9BdmVyYWdlKHRoaXMudG90YWxHcHVEdXJhdGlvbiwgdGhpcy5hdmVyYWdlR3B1KTtcbiAgfVxuICByZXNldENvdW50ZXJzKCkge1xuICAgIHRoaXMucmVuZGVyQ291bnQgPSAwO1xuICAgIGlmICh0aGlzLnRvdGFsQ3B1RHVyYXRpb24gPT09IDApIHtcbiAgICAgIHRoaXMuYmVnaW5Qcm9maWxpbmcoXCJjcHUtc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy50b3RhbENwdUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRvdGFsRnBzID0gMDtcbiAgICB0aGlzLmJlZ2luVGltZSA9IHRoaXMuZW5kSW50ZXJuYWwoKTtcbiAgfVxuICByZXNpemVQYW5lbChwYW5lbDIsIG9mZnNldCkge1xuICAgIHBhbmVsMi5jYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgaWYgKHRoaXMubWluaW1hbCkge1xuICAgICAgcGFuZWwyLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhbmVsMi5jYW52YXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgcGFuZWwyLmNhbnZhcy5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICBwYW5lbDIuY2FudmFzLnN0eWxlLmxlZnQgPSBvZmZzZXQgKiBwYW5lbDIuV0lEVEggLyBwYW5lbDIuUFIgKyBcInB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYW5lbDIuY2FudmFzLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgICBwYW5lbDIuY2FudmFzLnN0eWxlLnRvcCA9IG9mZnNldCAqIHBhbmVsMi5IRUlHSFQgLyBwYW5lbDIuUFIgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFkZFBhbmVsKHBhbmVsMiwgb2Zmc2V0KSB7XG4gICAgaWYgKHBhbmVsMi5jYW52YXMpIHtcbiAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHBhbmVsMi5jYW52YXMpO1xuICAgICAgdGhpcy5yZXNpemVQYW5lbChwYW5lbDIsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBwYW5lbDI7XG4gIH1cbiAgc2hvd1BhbmVsKGlkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRvbS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmRvbS5jaGlsZHJlbltpXTtcbiAgICAgIGNoaWxkLnN0eWxlLmRpc3BsYXkgPSBpID09PSBpZCA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBpZDtcbiAgfVxuICBwcm9jZXNzR3B1UXVlcmllcygpIHtcbiAgICBpZiAoIXRoaXMuZ2wgfHwgIXRoaXMuZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudG90YWxHcHVEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5ncHVRdWVyaWVzLmZvckVhY2goKHF1ZXJ5SW5mbywgaW5kZXgpID0+IHtcbiAgICAgIGlmICh0aGlzLmdsKSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHRoaXMuZ2wuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnlJbmZvLnF1ZXJ5LCB0aGlzLmdsLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO1xuICAgICAgICBjb25zdCBkaXNqb2ludCA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZXh0LkdQVV9ESVNKT0lOVF9FWFQpO1xuICAgICAgICBpZiAoYXZhaWxhYmxlICYmICFkaXNqb2ludCkge1xuICAgICAgICAgIGNvbnN0IGVsYXBzZWQgPSB0aGlzLmdsLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5SW5mby5xdWVyeSwgdGhpcy5nbC5RVUVSWV9SRVNVTFQpO1xuICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gZWxhcHNlZCAqIDFlLTY7XG4gICAgICAgICAgdGhpcy50b3RhbEdwdUR1cmF0aW9uICs9IGR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlUXVlcnkocXVlcnlJbmZvLnF1ZXJ5KTtcbiAgICAgICAgICB0aGlzLmdwdVF1ZXJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGVuZEludGVybmFsKCkge1xuICAgIHRoaXMuZnJhbWVzKys7XG4gICAgY29uc3QgdGltZSA9IChwZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkID0gdGltZSAtIHRoaXMucHJldlRpbWU7XG4gICAgaWYgKHRpbWUgPj0gdGhpcy5wcmV2Q3B1VGltZSArIDFlMyAvIHRoaXMubG9nc1BlclNlY29uZCkge1xuICAgICAgY29uc3QgZnBzID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lcyAqIDFlMyAvIGVsYXBzZWQpO1xuICAgICAgdGhpcy5hZGRUb0F2ZXJhZ2UoZnBzLCB0aGlzLmF2ZXJhZ2VGcHMpO1xuICAgICAgdGhpcy51cGRhdGVQYW5lbCh0aGlzLmZwc1BhbmVsLCB0aGlzLmF2ZXJhZ2VGcHMsIDApO1xuICAgICAgdGhpcy51cGRhdGVQYW5lbCh0aGlzLm1zUGFuZWwsIHRoaXMuYXZlcmFnZUNwdSwgdGhpcy5wcmVjaXNpb24pO1xuICAgICAgdGhpcy51cGRhdGVQYW5lbCh0aGlzLmdwdVBhbmVsLCB0aGlzLmF2ZXJhZ2VHcHUsIHRoaXMucHJlY2lzaW9uKTtcbiAgICAgIGlmICh0aGlzLmdwdVBhbmVsQ29tcHV0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhbmVsKHRoaXMuZ3B1UGFuZWxDb21wdXRlLCB0aGlzLmF2ZXJhZ2VHcHVDb21wdXRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhbWVzID0gMDtcbiAgICAgIHRoaXMucHJldkNwdVRpbWUgPSB0aW1lO1xuICAgICAgdGhpcy5wcmV2VGltZSA9IHRpbWU7XG4gICAgfVxuICAgIHJldHVybiB0aW1lO1xuICB9XG4gIGFkZFRvQXZlcmFnZSh2YWx1ZSwgYXZlcmFnZUFycmF5KSB7XG4gICAgYXZlcmFnZUFycmF5LmxvZ3MucHVzaCh2YWx1ZSk7XG4gICAgaWYgKGF2ZXJhZ2VBcnJheS5sb2dzLmxlbmd0aCA+IHRoaXMuc2FtcGxlc0xvZykge1xuICAgICAgYXZlcmFnZUFycmF5LmxvZ3Muc2hpZnQoKTtcbiAgICB9XG4gICAgYXZlcmFnZUFycmF5LmdyYXBoLnB1c2godmFsdWUpO1xuICAgIGlmIChhdmVyYWdlQXJyYXkuZ3JhcGgubGVuZ3RoID4gdGhpcy5zYW1wbGVzR3JhcGgpIHtcbiAgICAgIGF2ZXJhZ2VBcnJheS5ncmFwaC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuICBiZWdpblByb2ZpbGluZyhtYXJrZXIpIHtcbiAgICBpZiAod2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2UubWFyayhtYXJrZXIpO1xuICAgICAgdGhpcy5pc1J1bm5pbmdDUFVQcm9maWxpbmcgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBlbmRQcm9maWxpbmcoc3RhcnRNYXJrZXIsIGVuZE1hcmtlciwgbWVhc3VyZU5hbWUpIHtcbiAgICBpZiAod2luZG93LnBlcmZvcm1hbmNlICYmIGVuZE1hcmtlciAmJiB0aGlzLmlzUnVubmluZ0NQVVByb2ZpbGluZykge1xuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm1hcmsoZW5kTWFya2VyKTtcbiAgICAgIGNvbnN0IGNwdU1lYXN1cmUgPSBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVOYW1lLCBzdGFydE1hcmtlciwgZW5kTWFya2VyKTtcbiAgICAgIHRoaXMudG90YWxDcHVEdXJhdGlvbiArPSBjcHVNZWFzdXJlLmR1cmF0aW9uO1xuICAgICAgdGhpcy5pc1J1bm5pbmdDUFVQcm9maWxpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFuZWwocGFuZWwyLCBhdmVyYWdlQXJyYXksIHByZWNpc2lvbiA9IDIpIHtcbiAgICBpZiAoYXZlcmFnZUFycmF5LmxvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHN1bUxvZyA9IDA7XG4gICAgICBsZXQgbWF4ID0gMC4wMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXZlcmFnZUFycmF5LmxvZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtTG9nICs9IGF2ZXJhZ2VBcnJheS5sb2dzW2ldO1xuICAgICAgICBpZiAoYXZlcmFnZUFycmF5LmxvZ3NbaV0gPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSBhdmVyYWdlQXJyYXkubG9nc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHN1bUdyYXBoID0gMDtcbiAgICAgIGxldCBtYXhHcmFwaCA9IDAuMDE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF2ZXJhZ2VBcnJheS5ncmFwaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW1HcmFwaCArPSBhdmVyYWdlQXJyYXkuZ3JhcGhbaV07XG4gICAgICAgIGlmIChhdmVyYWdlQXJyYXkuZ3JhcGhbaV0gPiBtYXhHcmFwaCkge1xuICAgICAgICAgIG1heEdyYXBoID0gYXZlcmFnZUFycmF5LmdyYXBoW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFuZWwyKSB7XG4gICAgICAgIHBhbmVsMi51cGRhdGUoc3VtTG9nIC8gTWF0aC5taW4oYXZlcmFnZUFycmF5LmxvZ3MubGVuZ3RoLCB0aGlzLnNhbXBsZXNMb2cpLCBzdW1HcmFwaCAvIE1hdGgubWluKGF2ZXJhZ2VBcnJheS5ncmFwaC5sZW5ndGgsIHRoaXMuc2FtcGxlc0dyYXBoKSwgbWF4LCBtYXhHcmFwaCwgcHJlY2lzaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGRvbUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tO1xuICB9XG4gIHBhdGNoVGhyZWVSZW5kZXJlcihyZW5kZXJlcikge1xuICAgIGNvbnN0IG9yaWdpbmFsUmVuZGVyTWV0aG9kID0gcmVuZGVyZXIucmVuZGVyO1xuICAgIGNvbnN0IHN0YXRzSW5zdGFuY2UgPSB0aGlzO1xuICAgIHJlbmRlcmVyLnJlbmRlciA9IGZ1bmN0aW9uKHNjZW5lLCBjYW1lcmEpIHtcbiAgICAgIHN0YXRzSW5zdGFuY2UuYmVnaW4oKTtcbiAgICAgIG9yaWdpbmFsUmVuZGVyTWV0aG9kLmNhbGwodGhpcywgc2NlbmUsIGNhbWVyYSk7XG4gICAgICBzdGF0c0luc3RhbmNlLmVuZCgpO1xuICAgIH07XG4gICAgdGhpcy50aHJlZVJlbmRlcmVyUGF0Y2hlZCA9IHRydWU7XG4gIH1cbn07XG5fU3RhdHMuUGFuZWwgPSBwYW5lbC5QYW5lbDtcbmxldCBTdGF0cyA9IF9TdGF0cztcbm1vZHVsZS5leHBvcnRzID0gU3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/stats-gl/dist/main.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/stats-gl/dist/panel.cjs":
/*!**********************************************!*\
  !*** ./node_modules/stats-gl/dist/panel.cjs ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\nclass Panel {\n  constructor(name, fg, bg) {\n    this.name = name;\n    this.fg = fg;\n    this.bg = bg;\n    this.gradient = null;\n    this.PR = Math.round(window.devicePixelRatio || 1);\n    this.WIDTH = 90 * this.PR;\n    this.HEIGHT = 48 * this.PR;\n    this.TEXT_X = 3 * this.PR;\n    this.TEXT_Y = 2 * this.PR;\n    this.GRAPH_X = 3 * this.PR;\n    this.GRAPH_Y = 15 * this.PR;\n    this.GRAPH_WIDTH = 84 * this.PR;\n    this.GRAPH_HEIGHT = 30 * this.PR;\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = this.WIDTH;\n    this.canvas.height = this.HEIGHT;\n    this.canvas.style.width = \"90px\";\n    this.canvas.style.height = \"48px\";\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.cssText = \"width:90px;height:48px\";\n    this.context = this.canvas.getContext(\"2d\");\n    this.initializeCanvas();\n  }\n  createGradient() {\n    if (!this.context)\n      throw new Error(\"No context\");\n    const gradient = this.context.createLinearGradient(\n      0,\n      this.GRAPH_Y,\n      0,\n      this.GRAPH_Y + this.GRAPH_HEIGHT\n    );\n    let startColor;\n    const endColor = this.fg;\n    switch (this.fg.toLowerCase()) {\n      case \"#0ff\":\n        startColor = \"#006666\";\n        break;\n      case \"#0f0\":\n        startColor = \"#006600\";\n        break;\n      case \"#ff0\":\n        startColor = \"#666600\";\n        break;\n      case \"#e1e1e1\":\n        startColor = \"#666666\";\n        break;\n      default:\n        startColor = this.bg;\n        break;\n    }\n    gradient.addColorStop(0, startColor);\n    gradient.addColorStop(1, endColor);\n    return gradient;\n  }\n  initializeCanvas() {\n    if (!this.context)\n      return;\n    this.context.font = \"bold \" + 9 * this.PR + \"px Helvetica,Arial,sans-serif\";\n    this.context.textBaseline = \"top\";\n    this.gradient = this.createGradient();\n    this.context.fillStyle = this.bg;\n    this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);\n    this.context.fillStyle = this.fg;\n    this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y);\n    this.context.fillStyle = this.fg;\n    this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);\n    this.context.fillStyle = this.bg;\n    this.context.globalAlpha = 0.9;\n    this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);\n  }\n  update(value, valueGraph, maxValue, maxGraph, decimals = 0) {\n    if (!this.context || !this.gradient)\n      return;\n    const min = Math.min(Infinity, value);\n    const max = Math.max(maxValue, value);\n    maxGraph = Math.max(maxGraph, valueGraph);\n    this.context.globalAlpha = 1;\n    this.context.fillStyle = this.bg;\n    this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);\n    this.context.fillStyle = this.fg;\n    this.context.fillText(\n      `${value.toFixed(decimals)} ${this.name} (${min.toFixed(decimals)}-${parseFloat(\n        max.toFixed(decimals)\n      )})`,\n      this.TEXT_X,\n      this.TEXT_Y\n    );\n    this.context.drawImage(\n      this.canvas,\n      this.GRAPH_X + this.PR,\n      this.GRAPH_Y,\n      this.GRAPH_WIDTH - this.PR,\n      this.GRAPH_HEIGHT,\n      this.GRAPH_X,\n      this.GRAPH_Y,\n      this.GRAPH_WIDTH - this.PR,\n      this.GRAPH_HEIGHT\n    );\n    const columnHeight = this.GRAPH_HEIGHT - (1 - valueGraph / maxGraph) * this.GRAPH_HEIGHT;\n    if (columnHeight > 0) {\n      this.context.globalAlpha = 1;\n      this.context.fillStyle = this.gradient;\n      this.context.fillRect(\n        this.GRAPH_X + this.GRAPH_WIDTH - this.PR,\n        this.GRAPH_Y + this.GRAPH_HEIGHT - columnHeight,\n        this.PR,\n        columnHeight\n      );\n    }\n  }\n}\nexports.Panel = Panel;\n//# sourceMappingURL=panel.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhdHMtZ2wvZGlzdC9wYW5lbC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixxREFBcUQsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUIsRUFBRSxXQUFXLEdBQUcsc0JBQXNCLEdBQUc7QUFDM0U7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGl2aW5nLWJsdWVwcmludC1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvc3RhdHMtZ2wvZGlzdC9wYW5lbC5janM/OThmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSk7XG5jbGFzcyBQYW5lbCB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGZnLCBiZykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5mZyA9IGZnO1xuICAgIHRoaXMuYmcgPSBiZztcbiAgICB0aGlzLmdyYWRpZW50ID0gbnVsbDtcbiAgICB0aGlzLlBSID0gTWF0aC5yb3VuZCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICB0aGlzLldJRFRIID0gOTAgKiB0aGlzLlBSO1xuICAgIHRoaXMuSEVJR0hUID0gNDggKiB0aGlzLlBSO1xuICAgIHRoaXMuVEVYVF9YID0gMyAqIHRoaXMuUFI7XG4gICAgdGhpcy5URVhUX1kgPSAyICogdGhpcy5QUjtcbiAgICB0aGlzLkdSQVBIX1ggPSAzICogdGhpcy5QUjtcbiAgICB0aGlzLkdSQVBIX1kgPSAxNSAqIHRoaXMuUFI7XG4gICAgdGhpcy5HUkFQSF9XSURUSCA9IDg0ICogdGhpcy5QUjtcbiAgICB0aGlzLkdSQVBIX0hFSUdIVCA9IDMwICogdGhpcy5QUjtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLldJRFRIO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuSEVJR0hUO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gXCI5MHB4XCI7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCI0OHB4XCI7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUuY3NzVGV4dCA9IFwid2lkdGg6OTBweDtoZWlnaHQ6NDhweFwiO1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB0aGlzLmluaXRpYWxpemVDYW52YXMoKTtcbiAgfVxuICBjcmVhdGVHcmFkaWVudCgpIHtcbiAgICBpZiAoIXRoaXMuY29udGV4dClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNvbnRleHRcIik7XG4gICAgY29uc3QgZ3JhZGllbnQgPSB0aGlzLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAwLFxuICAgICAgdGhpcy5HUkFQSF9ZLFxuICAgICAgMCxcbiAgICAgIHRoaXMuR1JBUEhfWSArIHRoaXMuR1JBUEhfSEVJR0hUXG4gICAgKTtcbiAgICBsZXQgc3RhcnRDb2xvcjtcbiAgICBjb25zdCBlbmRDb2xvciA9IHRoaXMuZmc7XG4gICAgc3dpdGNoICh0aGlzLmZnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCIjMGZmXCI6XG4gICAgICAgIHN0YXJ0Q29sb3IgPSBcIiMwMDY2NjZcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiIzBmMFwiOlxuICAgICAgICBzdGFydENvbG9yID0gXCIjMDA2NjAwXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIiNmZjBcIjpcbiAgICAgICAgc3RhcnRDb2xvciA9IFwiIzY2NjYwMFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIjZTFlMWUxXCI6XG4gICAgICAgIHN0YXJ0Q29sb3IgPSBcIiM2NjY2NjZcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdGFydENvbG9yID0gdGhpcy5iZztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBzdGFydENvbG9yKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgZW5kQ29sb3IpO1xuICAgIHJldHVybiBncmFkaWVudDtcbiAgfVxuICBpbml0aWFsaXplQ2FudmFzKCkge1xuICAgIGlmICghdGhpcy5jb250ZXh0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY29udGV4dC5mb250ID0gXCJib2xkIFwiICsgOSAqIHRoaXMuUFIgKyBcInB4IEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy5jb250ZXh0LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgdGhpcy5ncmFkaWVudCA9IHRoaXMuY3JlYXRlR3JhZGllbnQoKTtcbiAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5iZztcbiAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xuICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmZnO1xuICAgIHRoaXMuY29udGV4dC5maWxsVGV4dCh0aGlzLm5hbWUsIHRoaXMuVEVYVF9YLCB0aGlzLlRFWFRfWSk7XG4gICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZmc7XG4gICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KHRoaXMuR1JBUEhfWCwgdGhpcy5HUkFQSF9ZLCB0aGlzLkdSQVBIX1dJRFRILCB0aGlzLkdSQVBIX0hFSUdIVCk7XG4gICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuYmc7XG4gICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gMC45O1xuICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh0aGlzLkdSQVBIX1gsIHRoaXMuR1JBUEhfWSwgdGhpcy5HUkFQSF9XSURUSCwgdGhpcy5HUkFQSF9IRUlHSFQpO1xuICB9XG4gIHVwZGF0ZSh2YWx1ZSwgdmFsdWVHcmFwaCwgbWF4VmFsdWUsIG1heEdyYXBoLCBkZWNpbWFscyA9IDApIHtcbiAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy5ncmFkaWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihJbmZpbml0eSwgdmFsdWUpO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KG1heFZhbHVlLCB2YWx1ZSk7XG4gICAgbWF4R3JhcGggPSBNYXRoLm1heChtYXhHcmFwaCwgdmFsdWVHcmFwaCk7XG4gICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gMTtcbiAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5iZztcbiAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy5XSURUSCwgdGhpcy5HUkFQSF9ZKTtcbiAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5mZztcbiAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoXG4gICAgICBgJHt2YWx1ZS50b0ZpeGVkKGRlY2ltYWxzKX0gJHt0aGlzLm5hbWV9ICgke21pbi50b0ZpeGVkKGRlY2ltYWxzKX0tJHtwYXJzZUZsb2F0KFxuICAgICAgICBtYXgudG9GaXhlZChkZWNpbWFscylcbiAgICAgICl9KWAsXG4gICAgICB0aGlzLlRFWFRfWCxcbiAgICAgIHRoaXMuVEVYVF9ZXG4gICAgKTtcbiAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgdGhpcy5jYW52YXMsXG4gICAgICB0aGlzLkdSQVBIX1ggKyB0aGlzLlBSLFxuICAgICAgdGhpcy5HUkFQSF9ZLFxuICAgICAgdGhpcy5HUkFQSF9XSURUSCAtIHRoaXMuUFIsXG4gICAgICB0aGlzLkdSQVBIX0hFSUdIVCxcbiAgICAgIHRoaXMuR1JBUEhfWCxcbiAgICAgIHRoaXMuR1JBUEhfWSxcbiAgICAgIHRoaXMuR1JBUEhfV0lEVEggLSB0aGlzLlBSLFxuICAgICAgdGhpcy5HUkFQSF9IRUlHSFRcbiAgICApO1xuICAgIGNvbnN0IGNvbHVtbkhlaWdodCA9IHRoaXMuR1JBUEhfSEVJR0hUIC0gKDEgLSB2YWx1ZUdyYXBoIC8gbWF4R3JhcGgpICogdGhpcy5HUkFQSF9IRUlHSFQ7XG4gICAgaWYgKGNvbHVtbkhlaWdodCA+IDApIHtcbiAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5ncmFkaWVudDtcbiAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdChcbiAgICAgICAgdGhpcy5HUkFQSF9YICsgdGhpcy5HUkFQSF9XSURUSCAtIHRoaXMuUFIsXG4gICAgICAgIHRoaXMuR1JBUEhfWSArIHRoaXMuR1JBUEhfSEVJR0hUIC0gY29sdW1uSGVpZ2h0LFxuICAgICAgICB0aGlzLlBSLFxuICAgICAgICBjb2x1bW5IZWlnaHRcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBhbmVsID0gUGFuZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYW5lbC5janMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/stats-gl/dist/panel.cjs\n");

/***/ })

};
;