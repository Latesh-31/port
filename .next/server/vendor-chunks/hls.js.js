/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hls.js";
exports.ids = ["vendor-chunks/hls.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/hls.js/dist/hls.js":
/*!*****************************************!*\
  !*** ./node_modules/hls.js/dist/hls.js ***!
  \*****************************************/
/***/ ((module) => {

eval("(function __HLS_WORKER_BUNDLE__(__IN_WORKER__){\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  function _construct(t, e, r) {\n    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n    var o = [null];\n    o.push.apply(o, e);\n    var p = new (t.bind.apply(t, o))();\n    return r && _setPrototypeOf(p, r.prototype), p;\n  }\n  function _defineProperties(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n  }\n  function _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n      writable: false\n    }), e;\n  }\n  function _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n      value: t,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    }) : e[r] = t, e;\n  }\n  function _extends() {\n    return _extends = Object.assign ? Object.assign.bind() : function (n) {\n      for (var e = 1; e < arguments.length; e++) {\n        var t = arguments[e];\n        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n      }\n      return n;\n    }, _extends.apply(null, arguments);\n  }\n  function _getPrototypeOf(t) {\n    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, _getPrototypeOf(t);\n  }\n  function _inheritsLoose(t, o) {\n    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);\n  }\n  function _isNativeFunction(t) {\n    try {\n      return -1 !== Function.toString.call(t).indexOf(\"[native code]\");\n    } catch (n) {\n      return \"function\" == typeof t;\n    }\n  }\n  function _isNativeReflectConstruct() {\n    try {\n      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function () {\n      return !!t;\n    })();\n  }\n  function ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var o = Object.getOwnPropertySymbols(e);\n      r && (o = o.filter(function (r) {\n        return Object.getOwnPropertyDescriptor(e, r).enumerable;\n      })), t.push.apply(t, o);\n    }\n    return t;\n  }\n  function _objectSpread2(e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = null != arguments[r] ? arguments[r] : {};\n      r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n        _defineProperty(e, r, t[r]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n      });\n    }\n    return e;\n  }\n  function _setPrototypeOf(t, e) {\n    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, _setPrototypeOf(t, e);\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r);\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n  }\n  function _wrapNativeSuper(t) {\n    var r = \"function\" == typeof Map ? new Map() : void 0;\n    return _wrapNativeSuper = function (t) {\n      if (null === t || !_isNativeFunction(t)) return t;\n      if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n      if (void 0 !== r) {\n        if (r.has(t)) return r.get(t);\n        r.set(t, Wrapper);\n      }\n      function Wrapper() {\n        return _construct(t, arguments, _getPrototypeOf(this).constructor);\n      }\n      return Wrapper.prototype = Object.create(t.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      }), _setPrototypeOf(Wrapper, t);\n    }, _wrapNativeSuper(t);\n  }\n\n  /**\n   * Generate a random v4 UUID\n   *\n   * @returns A random v4 UUID\n   *\n   * @group Utils\n   *\n   * @beta\n   */\n  function uuid() {\n    try {\n      return crypto.randomUUID();\n    } catch (error) {\n      try {\n        var url = URL.createObjectURL(new Blob());\n        var _uuid = url.toString();\n        URL.revokeObjectURL(url);\n        return _uuid.slice(_uuid.lastIndexOf('/') + 1);\n      } catch (error) {\n        var dt = new Date().getTime();\n        var _uuid2 = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n          var r = (dt + Math.random() * 16) % 16 | 0;\n          dt = Math.floor(dt / 16);\n          return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n        });\n        return _uuid2;\n      }\n    }\n  }\n\n  function getDefaultExportFromCjs (x) {\n  \treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n  }\n\n  var eventemitter3 = {exports: {}};\n\n  var hasRequiredEventemitter3;\n\n  function requireEventemitter3 () {\n  \tif (hasRequiredEventemitter3) return eventemitter3.exports;\n  \thasRequiredEventemitter3 = 1;\n  \t(function (module) {\n\n  \t\tvar has = Object.prototype.hasOwnProperty\n  \t\t  , prefix = '~';\n\n  \t\t/**\n  \t\t * Constructor to create a storage for our `EE` objects.\n  \t\t * An `Events` instance is a plain object whose properties are event names.\n  \t\t *\n  \t\t * @constructor\n  \t\t * @private\n  \t\t */\n  \t\tfunction Events() {}\n\n  \t\t//\n  \t\t// We try to not inherit from `Object.prototype`. In some engines creating an\n  \t\t// instance in this way is faster than calling `Object.create(null)` directly.\n  \t\t// If `Object.create(null)` is not supported we prefix the event names with a\n  \t\t// character to make sure that the built-in object properties are not\n  \t\t// overridden or used as an attack vector.\n  \t\t//\n  \t\tif (Object.create) {\n  \t\t  Events.prototype = Object.create(null);\n\n  \t\t  //\n  \t\t  // This hack is needed because the `__proto__` property is still inherited in\n  \t\t  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  \t\t  //\n  \t\t  if (!new Events().__proto__) prefix = false;\n  \t\t}\n\n  \t\t/**\n  \t\t * Representation of a single event listener.\n  \t\t *\n  \t\t * @param {Function} fn The listener function.\n  \t\t * @param {*} context The context to invoke the listener with.\n  \t\t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n  \t\t * @constructor\n  \t\t * @private\n  \t\t */\n  \t\tfunction EE(fn, context, once) {\n  \t\t  this.fn = fn;\n  \t\t  this.context = context;\n  \t\t  this.once = once || false;\n  \t\t}\n\n  \t\t/**\n  \t\t * Add a listener for a given event.\n  \t\t *\n  \t\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n  \t\t * @param {(String|Symbol)} event The event name.\n  \t\t * @param {Function} fn The listener function.\n  \t\t * @param {*} context The context to invoke the listener with.\n  \t\t * @param {Boolean} once Specify if the listener is a one-time listener.\n  \t\t * @returns {EventEmitter}\n  \t\t * @private\n  \t\t */\n  \t\tfunction addListener(emitter, event, fn, context, once) {\n  \t\t  if (typeof fn !== 'function') {\n  \t\t    throw new TypeError('The listener must be a function');\n  \t\t  }\n\n  \t\t  var listener = new EE(fn, context || emitter, once)\n  \t\t    , evt = prefix ? prefix + event : event;\n\n  \t\t  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  \t\t  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  \t\t  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  \t\t  return emitter;\n  \t\t}\n\n  \t\t/**\n  \t\t * Clear event by name.\n  \t\t *\n  \t\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n  \t\t * @param {(String|Symbol)} evt The Event name.\n  \t\t * @private\n  \t\t */\n  \t\tfunction clearEvent(emitter, evt) {\n  \t\t  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  \t\t  else delete emitter._events[evt];\n  \t\t}\n\n  \t\t/**\n  \t\t * Minimal `EventEmitter` interface that is molded against the Node.js\n  \t\t * `EventEmitter` interface.\n  \t\t *\n  \t\t * @constructor\n  \t\t * @public\n  \t\t */\n  \t\tfunction EventEmitter() {\n  \t\t  this._events = new Events();\n  \t\t  this._eventsCount = 0;\n  \t\t}\n\n  \t\t/**\n  \t\t * Return an array listing the events for which the emitter has registered\n  \t\t * listeners.\n  \t\t *\n  \t\t * @returns {Array}\n  \t\t * @public\n  \t\t */\n  \t\tEventEmitter.prototype.eventNames = function eventNames() {\n  \t\t  var names = []\n  \t\t    , events\n  \t\t    , name;\n\n  \t\t  if (this._eventsCount === 0) return names;\n\n  \t\t  for (name in (events = this._events)) {\n  \t\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  \t\t  }\n\n  \t\t  if (Object.getOwnPropertySymbols) {\n  \t\t    return names.concat(Object.getOwnPropertySymbols(events));\n  \t\t  }\n\n  \t\t  return names;\n  \t\t};\n\n  \t\t/**\n  \t\t * Return the listeners registered for a given event.\n  \t\t *\n  \t\t * @param {(String|Symbol)} event The event name.\n  \t\t * @returns {Array} The registered listeners.\n  \t\t * @public\n  \t\t */\n  \t\tEventEmitter.prototype.listeners = function listeners(event) {\n  \t\t  var evt = prefix ? prefix + event : event\n  \t\t    , handlers = this._events[evt];\n\n  \t\t  if (!handlers) return [];\n  \t\t  if (handlers.fn) return [handlers.fn];\n\n  \t\t  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n  \t\t    ee[i] = handlers[i].fn;\n  \t\t  }\n\n  \t\t  return ee;\n  \t\t};\n\n  \t\t/**\n  \t\t * Return the number of listeners listening to a given event.\n  \t\t *\n  \t\t * @param {(String|Symbol)} event The event name.\n  \t\t * @returns {Number} The number of listeners.\n  \t\t * @public\n  \t\t */\n  \t\tEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  \t\t  var evt = prefix ? prefix + event : event\n  \t\t    , listeners = this._events[evt];\n\n  \t\t  if (!listeners) return 0;\n  \t\t  if (listeners.fn) return 1;\n  \t\t  return listeners.length;\n  \t\t};\n\n  \t\t/**\n  \t\t * Calls each of the listeners registered for a given event.\n  \t\t *\n  \t\t * @param {(String|Symbol)} event The event name.\n  \t\t * @returns {Boolean} `true` if the event had listeners, else `false`.\n  \t\t * @public\n  \t\t */\n  \t\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  \t\t  var evt = prefix ? prefix + event : event;\n\n  \t\t  if (!this._events[evt]) return false;\n\n  \t\t  var listeners = this._events[evt]\n  \t\t    , len = arguments.length\n  \t\t    , args\n  \t\t    , i;\n\n  \t\t  if (listeners.fn) {\n  \t\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n  \t\t    switch (len) {\n  \t\t      case 1: return listeners.fn.call(listeners.context), true;\n  \t\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n  \t\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n  \t\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n  \t\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n  \t\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n  \t\t    }\n\n  \t\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n  \t\t      args[i - 1] = arguments[i];\n  \t\t    }\n\n  \t\t    listeners.fn.apply(listeners.context, args);\n  \t\t  } else {\n  \t\t    var length = listeners.length\n  \t\t      , j;\n\n  \t\t    for (i = 0; i < length; i++) {\n  \t\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n  \t\t      switch (len) {\n  \t\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n  \t\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n  \t\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n  \t\t        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n  \t\t        default:\n  \t\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n  \t\t            args[j - 1] = arguments[j];\n  \t\t          }\n\n  \t\t          listeners[i].fn.apply(listeners[i].context, args);\n  \t\t      }\n  \t\t    }\n  \t\t  }\n\n  \t\t  return true;\n  \t\t};\n\n  \t\t/**\n  \t\t * Add a listener for a given event.\n  \t\t *\n  \t\t * @param {(String|Symbol)} event The event name.\n  \t\t * @param {Function} fn The listener function.\n  \t\t * @param {*} [context=this] The context to invoke the listener with.\n  \t\t * @returns {EventEmitter} `this`.\n  \t\t * @public\n  \t\t */\n  \t\tEventEmitter.prototype.on = function on(event, fn, context) {\n  \t\t  return addListener(this, event, fn, context, false);\n  \t\t};\n\n  \t\t/**\n  \t\t * Add a one-time listener for a given event.\n  \t\t *\n  \t\t * @param {(String|Symbol)} event The event name.\n  \t\t * @param {Function} fn The listener function.\n  \t\t * @param {*} [context=this] The context to invoke the listener with.\n  \t\t * @returns {EventEmitter} `this`.\n  \t\t * @public\n  \t\t */\n  \t\tEventEmitter.prototype.once = function once(event, fn, context) {\n  \t\t  return addListener(this, event, fn, context, true);\n  \t\t};\n\n  \t\t/**\n  \t\t * Remove the listeners of a given event.\n  \t\t *\n  \t\t * @param {(String|Symbol)} event The event name.\n  \t\t * @param {Function} fn Only remove the listeners that match this function.\n  \t\t * @param {*} context Only remove the listeners that have this context.\n  \t\t * @param {Boolean} once Only remove one-time listeners.\n  \t\t * @returns {EventEmitter} `this`.\n  \t\t * @public\n  \t\t */\n  \t\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  \t\t  var evt = prefix ? prefix + event : event;\n\n  \t\t  if (!this._events[evt]) return this;\n  \t\t  if (!fn) {\n  \t\t    clearEvent(this, evt);\n  \t\t    return this;\n  \t\t  }\n\n  \t\t  var listeners = this._events[evt];\n\n  \t\t  if (listeners.fn) {\n  \t\t    if (\n  \t\t      listeners.fn === fn &&\n  \t\t      (!once || listeners.once) &&\n  \t\t      (!context || listeners.context === context)\n  \t\t    ) {\n  \t\t      clearEvent(this, evt);\n  \t\t    }\n  \t\t  } else {\n  \t\t    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n  \t\t      if (\n  \t\t        listeners[i].fn !== fn ||\n  \t\t        (once && !listeners[i].once) ||\n  \t\t        (context && listeners[i].context !== context)\n  \t\t      ) {\n  \t\t        events.push(listeners[i]);\n  \t\t      }\n  \t\t    }\n\n  \t\t    //\n  \t\t    // Reset the array, or remove it completely if we have no more listeners.\n  \t\t    //\n  \t\t    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n  \t\t    else clearEvent(this, evt);\n  \t\t  }\n\n  \t\t  return this;\n  \t\t};\n\n  \t\t/**\n  \t\t * Remove all listeners, or those of the specified event.\n  \t\t *\n  \t\t * @param {(String|Symbol)} [event] The event name.\n  \t\t * @returns {EventEmitter} `this`.\n  \t\t * @public\n  \t\t */\n  \t\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  \t\t  var evt;\n\n  \t\t  if (event) {\n  \t\t    evt = prefix ? prefix + event : event;\n  \t\t    if (this._events[evt]) clearEvent(this, evt);\n  \t\t  } else {\n  \t\t    this._events = new Events();\n  \t\t    this._eventsCount = 0;\n  \t\t  }\n\n  \t\t  return this;\n  \t\t};\n\n  \t\t//\n  \t\t// Alias methods names because people roll like that.\n  \t\t//\n  \t\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  \t\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  \t\t//\n  \t\t// Expose the prefix.\n  \t\t//\n  \t\tEventEmitter.prefixed = prefix;\n\n  \t\t//\n  \t\t// Allow `EventEmitter` to be imported as module namespace.\n  \t\t//\n  \t\tEventEmitter.EventEmitter = EventEmitter;\n\n  \t\t//\n  \t\t// Expose the module.\n  \t\t//\n  \t\t{\n  \t\t  module.exports = EventEmitter;\n  \t\t} \n  \t} (eventemitter3));\n  \treturn eventemitter3.exports;\n  }\n\n  var eventemitter3Exports = requireEventemitter3();\n  var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\n\n  var urlToolkit = {exports: {}};\n\n  var hasRequiredUrlToolkit;\n\n  function requireUrlToolkit () {\n  \tif (hasRequiredUrlToolkit) return urlToolkit.exports;\n  \thasRequiredUrlToolkit = 1;\n  \t(function (module, exports) {\n  \t\t// see https://tools.ietf.org/html/rfc1808\n\n  \t\t(function (root) {\n  \t\t  var URL_REGEX =\n  \t\t    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n  \t\t  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n  \t\t  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  \t\t  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n  \t\t  var URLToolkit = {\n  \t\t    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n  \t\t    // E.g\n  \t\t    // With opts.alwaysNormalize = false (default, spec compliant)\n  \t\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n  \t\t    // With opts.alwaysNormalize = true (not spec compliant)\n  \t\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n  \t\t    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n  \t\t      opts = opts || {};\n  \t\t      // remove any remaining space and CRLF\n  \t\t      baseURL = baseURL.trim();\n  \t\t      relativeURL = relativeURL.trim();\n  \t\t      if (!relativeURL) {\n  \t\t        // 2a) If the embedded URL is entirely empty, it inherits the\n  \t\t        // entire base URL (i.e., is set equal to the base URL)\n  \t\t        // and we are done.\n  \t\t        if (!opts.alwaysNormalize) {\n  \t\t          return baseURL;\n  \t\t        }\n  \t\t        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n  \t\t        if (!basePartsForNormalise) {\n  \t\t          throw new Error('Error trying to parse base URL.');\n  \t\t        }\n  \t\t        basePartsForNormalise.path = URLToolkit.normalizePath(\n  \t\t          basePartsForNormalise.path\n  \t\t        );\n  \t\t        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n  \t\t      }\n  \t\t      var relativeParts = URLToolkit.parseURL(relativeURL);\n  \t\t      if (!relativeParts) {\n  \t\t        throw new Error('Error trying to parse relative URL.');\n  \t\t      }\n  \t\t      if (relativeParts.scheme) {\n  \t\t        // 2b) If the embedded URL starts with a scheme name, it is\n  \t\t        // interpreted as an absolute URL and we are done.\n  \t\t        if (!opts.alwaysNormalize) {\n  \t\t          return relativeURL;\n  \t\t        }\n  \t\t        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n  \t\t        return URLToolkit.buildURLFromParts(relativeParts);\n  \t\t      }\n  \t\t      var baseParts = URLToolkit.parseURL(baseURL);\n  \t\t      if (!baseParts) {\n  \t\t        throw new Error('Error trying to parse base URL.');\n  \t\t      }\n  \t\t      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n  \t\t        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n  \t\t        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n  \t\t        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n  \t\t        baseParts.netLoc = pathParts[1];\n  \t\t        baseParts.path = pathParts[2];\n  \t\t      }\n  \t\t      if (baseParts.netLoc && !baseParts.path) {\n  \t\t        baseParts.path = '/';\n  \t\t      }\n  \t\t      var builtParts = {\n  \t\t        // 2c) Otherwise, the embedded URL inherits the scheme of\n  \t\t        // the base URL.\n  \t\t        scheme: baseParts.scheme,\n  \t\t        netLoc: relativeParts.netLoc,\n  \t\t        path: null,\n  \t\t        params: relativeParts.params,\n  \t\t        query: relativeParts.query,\n  \t\t        fragment: relativeParts.fragment,\n  \t\t      };\n  \t\t      if (!relativeParts.netLoc) {\n  \t\t        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n  \t\t        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n  \t\t        // (if any) of the base URL.\n  \t\t        builtParts.netLoc = baseParts.netLoc;\n  \t\t        // 4) If the embedded URL path is preceded by a slash \"/\", the\n  \t\t        // path is not relative and we skip to Step 7.\n  \t\t        if (relativeParts.path[0] !== '/') {\n  \t\t          if (!relativeParts.path) {\n  \t\t            // 5) If the embedded URL path is empty (and not preceded by a\n  \t\t            // slash), then the embedded URL inherits the base URL path\n  \t\t            builtParts.path = baseParts.path;\n  \t\t            // 5a) if the embedded URL's <params> is non-empty, we skip to\n  \t\t            // step 7; otherwise, it inherits the <params> of the base\n  \t\t            // URL (if any) and\n  \t\t            if (!relativeParts.params) {\n  \t\t              builtParts.params = baseParts.params;\n  \t\t              // 5b) if the embedded URL's <query> is non-empty, we skip to\n  \t\t              // step 7; otherwise, it inherits the <query> of the base\n  \t\t              // URL (if any) and we skip to step 7.\n  \t\t              if (!relativeParts.query) {\n  \t\t                builtParts.query = baseParts.query;\n  \t\t              }\n  \t\t            }\n  \t\t          } else {\n  \t\t            // 6) The last segment of the base URL's path (anything\n  \t\t            // following the rightmost slash \"/\", or the entire path if no\n  \t\t            // slash is present) is removed and the embedded URL's path is\n  \t\t            // appended in its place.\n  \t\t            var baseURLPath = baseParts.path;\n  \t\t            var newPath =\n  \t\t              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n  \t\t              relativeParts.path;\n  \t\t            builtParts.path = URLToolkit.normalizePath(newPath);\n  \t\t          }\n  \t\t        }\n  \t\t      }\n  \t\t      if (builtParts.path === null) {\n  \t\t        builtParts.path = opts.alwaysNormalize\n  \t\t          ? URLToolkit.normalizePath(relativeParts.path)\n  \t\t          : relativeParts.path;\n  \t\t      }\n  \t\t      return URLToolkit.buildURLFromParts(builtParts);\n  \t\t    },\n  \t\t    parseURL: function (url) {\n  \t\t      var parts = URL_REGEX.exec(url);\n  \t\t      if (!parts) {\n  \t\t        return null;\n  \t\t      }\n  \t\t      return {\n  \t\t        scheme: parts[1] || '',\n  \t\t        netLoc: parts[2] || '',\n  \t\t        path: parts[3] || '',\n  \t\t        params: parts[4] || '',\n  \t\t        query: parts[5] || '',\n  \t\t        fragment: parts[6] || '',\n  \t\t      };\n  \t\t    },\n  \t\t    normalizePath: function (path) {\n  \t\t      // The following operations are\n  \t\t      // then applied, in order, to the new path:\n  \t\t      // 6a) All occurrences of \"./\", where \".\" is a complete path\n  \t\t      // segment, are removed.\n  \t\t      // 6b) If the path ends with \".\" as a complete path segment,\n  \t\t      // that \".\" is removed.\n  \t\t      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n  \t\t      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n  \t\t      // complete path segment not equal to \"..\", are removed.\n  \t\t      // Removal of these path segments is performed iteratively,\n  \t\t      // removing the leftmost matching pattern on each iteration,\n  \t\t      // until no matching pattern remains.\n  \t\t      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n  \t\t      // complete path segment not equal to \"..\", that\n  \t\t      // \"<segment>/..\" is removed.\n  \t\t      while (\n  \t\t        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n  \t\t      ) {}\n  \t\t      return path.split('').reverse().join('');\n  \t\t    },\n  \t\t    buildURLFromParts: function (parts) {\n  \t\t      return (\n  \t\t        parts.scheme +\n  \t\t        parts.netLoc +\n  \t\t        parts.path +\n  \t\t        parts.params +\n  \t\t        parts.query +\n  \t\t        parts.fragment\n  \t\t      );\n  \t\t    },\n  \t\t  };\n\n  \t\t  module.exports = URLToolkit;\n  \t\t})(); \n  \t} (urlToolkit));\n  \treturn urlToolkit.exports;\n  }\n\n  var urlToolkitExports = requireUrlToolkit();\n\n  // https://caniuse.com/mdn-javascript_builtins_number_isfinite\n  var isFiniteNumber = Number.isFinite || function (value) {\n    return typeof value === 'number' && isFinite(value);\n  };\n\n  // https://caniuse.com/mdn-javascript_builtins_number_issafeinteger\n  var isSafeInteger = Number.isSafeInteger || function (value) {\n    return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;\n  };\n  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n  var ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n    // Identifier for a network error (loading error / timeout ...)\n    ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n    // Identifier for a media Error (video/parsing/mediasource error)\n    ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n    // EME (encrypted media extensions) errors\n    ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n    // Identifier for a mux Error (demuxing/remuxing)\n    ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n    // Identifier for all other errors\n    ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n    return ErrorTypes;\n  }({});\n  var ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n    ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n    ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n    ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n    ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n    ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n    ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n    ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n    ErrorDetails[\"KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR\"] = \"keySystemDestroyMediaKeysError\";\n    ErrorDetails[\"KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR\"] = \"keySystemDestroyCloseSessionError\";\n    ErrorDetails[\"KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR\"] = \"keySystemDestroyRemoveSessionError\";\n    // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n    ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n    // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n    ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n    // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\n    ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n    // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\n    ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n    // Identifier for a level which contains no fragments - data: { url: faulty URL, reason: \"no fragments found in level\", level: index of the bad level }\n    ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n    // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n    ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n    // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n    ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n    // Identifier for a level parse error - data: { url : faulty URL, error: Error, reason: error message }\n    ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n    // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\n    ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n    // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n    ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n    // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n    ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n    // Identifier for a subtitle track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n    ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n    // Identifier for a subtitle track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n    ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n    // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n    ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n    // Identifier for fragment load timeout error - data: { frag : fragment object}\n    ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n    // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\n    ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n    // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\n    // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\n    ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n    // Identifier for a fragment or part load skipped because of a GAP tag or attribute\n    ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n    // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }\n    ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n    // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n    ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n    // Identifier for decrypt key load timeout error - data: { frag : fragment object}\n    ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n    // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : { error : exception , mimeType : mimeType }\n    ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n    // Triggered when source buffer(s) could not be created using level (manifest CODECS attribute), parsed media, or best guess codec(s) - data: { reason : error reason }\n    ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n    // Identifier for a buffer append error - data: append error description\n    ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n    // Identifier for a buffer appending error event - data: appending error description\n    ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n    // Identifier for a buffer stalled error event\n    ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n    // Identifier for a buffer full event\n    ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n    // Identifier for a buffer seek over hole event\n    ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n    // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)\n    ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n    // Identifier for a Interstitial Asset List load error - data: { url: faulty URL, response: { code: error code, text: error text } }\n    ErrorDetails[\"ASSET_LIST_LOAD_ERROR\"] = \"assetListLoadError\";\n    // Identifier for a Interstitial Asset List load timeout - data: { url: faulty URL, response: { code: error code, text: error text } }\n    ErrorDetails[\"ASSET_LIST_LOAD_TIMEOUT\"] = \"assetListLoadTimeout\";\n    // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}\n    ErrorDetails[\"ASSET_LIST_PARSING_ERROR\"] = \"assetListParsingError\";\n    // Identifier for a Interstitial Asset List parsing error - data: { url : faulty URL, reason : error reason, response : { code: error code, text: error text }}\n    ErrorDetails[\"INTERSTITIAL_ASSET_ITEM_ERROR\"] = \"interstitialAssetItemError\";\n    // Identifier for an internal exception happening inside hls.js while handling an event\n    ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n    // Identifier for an internal call to abort a loader\n    ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n    // Triggered when attachMedia fails\n    ErrorDetails[\"ATTACH_MEDIA_ERROR\"] = \"attachMediaError\";\n    // Uncategorized error\n    ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n    return ErrorDetails;\n  }({});\n\n  var Events = /*#__PURE__*/function (Events) {\n    // Fired before MediaSource is attaching to media element\n    Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n    // Fired when MediaSource has been successfully attached to media element\n    Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n    // Fired before detaching MediaSource from media element\n    Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n    // Fired when MediaSource has been detached from media element\n    Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n    // Fired when HTMLMediaElement dispatches \"ended\" event, or stalls at end of VOD program\n    Events[\"MEDIA_ENDED\"] = \"hlsMediaEnded\";\n    // Fired after playback stall is resolved with playing, seeked, or ended event following BUFFER_STALLED_ERROR\n    Events[\"STALL_RESOLVED\"] = \"hlsStallResolved\";\n    // Fired when the buffer is going to be reset\n    Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n    // Fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}\n    Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n    // fired when sourcebuffers have been created - data: { tracks : tracks }\n    Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n    // fired when we append a segment to the buffer - data: { segment: segment object }\n    Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n    // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}\n    Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n    // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }\n    Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n    // fired when all buffers are full to the end of the program, after calling MediaSource.endOfStream() (unless restricted)\n    Events[\"BUFFERED_TO_END\"] = \"hlsBufferedToEnd\";\n    // fired when the media buffer should be flushed - data { startOffset, endOffset }\n    Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n    // fired when the media buffer has been flushed - data: { }\n    Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n    // fired to signal that a manifest loading starts - data: { url : manifestURL}\n    Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n    // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks ], url : manifestURL, stats : LoaderStats }\n    Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n    // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}\n    Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n    // fired when a level switch is requested - data: { level : id of new level }\n    Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n    // fired when a level switch is effective - data: { level : id of new level }\n    Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n    // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}\n    Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n    // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : LoaderStats }\n    Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n    // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }\n    Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n    // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }\n    Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n    // fired to notify that levels have changed after removing a level - data: { levels : [available quality levels] }\n    Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n    // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }\n    Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n    // fired when an audio track switching is requested - data: { id : audio track id }\n    Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n    // fired when an audio track switch actually occurs - data: { id : audio track id }\n    Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n    // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }\n    Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n    // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : LoaderStats }\n    Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n    // fired when an audio tracks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }\n    Events[\"AUDIO_TRACK_UPDATED\"] = \"hlsAudioTrackUpdated\";\n    // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }\n    Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n    // fired to notify that subtitle tracks were cleared as a result of stopping the media\n    Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n    // fired when an subtitle track switch occurs - data: { id : subtitle track id }\n    Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n    // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }\n    Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n    // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : LoaderStats }\n    Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n    // fired when a subtitle  racks's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, id : track id }\n    Events[\"SUBTITLE_TRACK_UPDATED\"] = \"hlsSubtitleTrackUpdated\";\n    // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }\n    Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n    // fired when a set of VTTCues to be managed externally has been parsed - data: { type: string, track: string, cues: [ VTTCue ] }\n    Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n    // fired when a text track to be managed externally is found - data: { tracks: [ { label: string, kind: string, default: boolean } ] }\n    Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n    // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, timescale: timescale, frag : fragment object }\n    Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n    // fired when a fragment loading starts - data: { frag : fragment object }\n    Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n    // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }\n    // FRAG_LOAD_PROGRESS = 'hlsFragLoadProgress',\n    // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }\n    Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n    // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : LoaderStats }\n    Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n    // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }\n    Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n    // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }\n    Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n    // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }\n    Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n    // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\n    Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n    // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}\n    // FRAG_PARSING_DATA = 'hlsFragParsingData',\n    // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }\n    Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n    // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : LoaderStats }\n    Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n    // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }\n    Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n    // Identifier for a FPS drop event - data: { currentDropped, currentDecoded, totalDroppedFrames }\n    Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n    // triggered when FPS drop triggers auto level capping - data: { level, droppedLevel }\n    Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n    // triggered when maxAutoLevel changes - data { autoLevelCapping, levels, maxAutoLevel, minAutoLevel, maxHdcpLevel }\n    Events[\"MAX_AUTO_LEVEL_UPDATED\"] = \"hlsMaxAutoLevelUpdated\";\n    // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }\n    Events[\"ERROR\"] = \"hlsError\";\n    // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }\n    Events[\"DESTROYING\"] = \"hlsDestroying\";\n    // fired when a decrypt key loading starts - data: { frag : fragment object }\n    Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n    // fired when a decrypt key loading is completed - data: { frag : fragment object, keyInfo : KeyLoaderInfo }\n    Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n    // deprecated; please use BACK_BUFFER_REACHED - data : { bufferEnd: number }\n    Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n    // fired when the back buffer is reached as defined by the backBufferLength config option - data : { bufferEnd: number }\n    Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n    // fired after steering manifest has been loaded - data: { steeringManifest: SteeringManifest object, url: steering manifest URL }\n    Events[\"STEERING_MANIFEST_LOADED\"] = \"hlsSteeringManifestLoaded\";\n    // fired when asset list has begun loading\n    Events[\"ASSET_LIST_LOADING\"] = \"hlsAssetListLoading\";\n    // fired when a valid asset list is loaded\n    Events[\"ASSET_LIST_LOADED\"] = \"hlsAssetListLoaded\";\n    // fired when the list of Interstitial Events and Interstitial Schedule is updated\n    Events[\"INTERSTITIALS_UPDATED\"] = \"hlsInterstitialsUpdated\";\n    // fired when the buffer reaches an Interstitial Schedule boundary (both Primary segments and Interstitial Assets)\n    Events[\"INTERSTITIALS_BUFFERED_TO_BOUNDARY\"] = \"hlsInterstitialsBufferedToBoundary\";\n    // fired when a player instance for an Interstitial Asset has been created\n    Events[\"INTERSTITIAL_ASSET_PLAYER_CREATED\"] = \"hlsInterstitialAssetPlayerCreated\";\n    // Interstitial playback started\n    Events[\"INTERSTITIAL_STARTED\"] = \"hlsInterstitialStarted\";\n    // InterstitialAsset playback started\n    Events[\"INTERSTITIAL_ASSET_STARTED\"] = \"hlsInterstitialAssetStarted\";\n    // InterstitialAsset playback ended\n    Events[\"INTERSTITIAL_ASSET_ENDED\"] = \"hlsInterstitialAssetEnded\";\n    // InterstitialAsset playback errored\n    Events[\"INTERSTITIAL_ASSET_ERROR\"] = \"hlsInterstitialAssetError\";\n    // Interstitial playback ended\n    Events[\"INTERSTITIAL_ENDED\"] = \"hlsInterstitialEnded\";\n    // Interstitial schedule resumed primary playback\n    Events[\"INTERSTITIALS_PRIMARY_RESUMED\"] = \"hlsInterstitialsPrimaryResumed\";\n    // Interstitial players dispatch this event when playout limit is reached\n    Events[\"PLAYOUT_LIMIT_REACHED\"] = \"hlsPlayoutLimitReached\";\n    // Event DateRange cue \"enter\" event dispatched\n    Events[\"EVENT_CUE_ENTER\"] = \"hlsEventCueEnter\";\n    return Events;\n  }({});\n\n  /**\n   * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n   */\n\n  var PlaylistContextType = {\n    MANIFEST: \"manifest\",\n    LEVEL: \"level\",\n    AUDIO_TRACK: \"audioTrack\",\n    SUBTITLE_TRACK: \"subtitleTrack\"\n  };\n  var PlaylistLevelType = {\n    MAIN: \"main\",\n    AUDIO: \"audio\",\n    SUBTITLE: \"subtitle\"\n  };\n\n  /*\n   * compute an Exponential Weighted moving average\n   * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n   *  - heavily inspired from shaka-player\n   */\n  var EWMA = /*#__PURE__*/function () {\n    //  About half of the estimated value will be from the last |halfLife| samples by weight.\n    function EWMA(halfLife, estimate, weight) {\n      if (estimate === void 0) {\n        estimate = 0;\n      }\n      if (weight === void 0) {\n        weight = 0;\n      }\n      this.halfLife = void 0;\n      this.alpha_ = void 0;\n      this.estimate_ = void 0;\n      this.totalWeight_ = void 0;\n      this.halfLife = halfLife;\n      // Larger values of alpha expire historical data more slowly.\n      this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n      this.estimate_ = estimate;\n      this.totalWeight_ = weight;\n    }\n    var _proto = EWMA.prototype;\n    _proto.sample = function sample(weight, value) {\n      var adjAlpha = Math.pow(this.alpha_, weight);\n      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n      this.totalWeight_ += weight;\n    };\n    _proto.getTotalWeight = function getTotalWeight() {\n      return this.totalWeight_;\n    };\n    _proto.getEstimate = function getEstimate() {\n      if (this.alpha_) {\n        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n        if (zeroFactor) {\n          return this.estimate_ / zeroFactor;\n        }\n      }\n      return this.estimate_;\n    };\n    return EWMA;\n  }();\n\n  var EwmaBandWidthEstimator = /*#__PURE__*/function () {\n    function EwmaBandWidthEstimator(slow, fast, defaultEstimate, defaultTTFB) {\n      if (defaultTTFB === void 0) {\n        defaultTTFB = 100;\n      }\n      this.defaultEstimate_ = void 0;\n      this.minWeight_ = void 0;\n      this.minDelayMs_ = void 0;\n      this.slow_ = void 0;\n      this.fast_ = void 0;\n      this.defaultTTFB_ = void 0;\n      this.ttfb_ = void 0;\n      this.defaultEstimate_ = defaultEstimate;\n      this.minWeight_ = 0.001;\n      this.minDelayMs_ = 50;\n      this.slow_ = new EWMA(slow);\n      this.fast_ = new EWMA(fast);\n      this.defaultTTFB_ = defaultTTFB;\n      this.ttfb_ = new EWMA(slow);\n    }\n    var _proto = EwmaBandWidthEstimator.prototype;\n    _proto.update = function update(slow, fast) {\n      var slow_ = this.slow_,\n        fast_ = this.fast_,\n        ttfb_ = this.ttfb_;\n      if (slow_.halfLife !== slow) {\n        this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n      }\n      if (fast_.halfLife !== fast) {\n        this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n      }\n      if (ttfb_.halfLife !== slow) {\n        this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n      }\n    };\n    _proto.sample = function sample(durationMs, numBytes) {\n      durationMs = Math.max(durationMs, this.minDelayMs_);\n      var numBits = 8 * numBytes;\n      // weight is duration in seconds\n      var durationS = durationMs / 1000;\n      // value is bandwidth in bits/s\n      var bandwidthInBps = numBits / durationS;\n      this.fast_.sample(durationS, bandwidthInBps);\n      this.slow_.sample(durationS, bandwidthInBps);\n    };\n    _proto.sampleTTFB = function sampleTTFB(ttfb) {\n      // weight is frequency curve applied to TTFB in seconds\n      // (longer times have less weight with expected input under 1 second)\n      var seconds = ttfb / 1000;\n      var weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n      this.ttfb_.sample(weight, Math.max(ttfb, 5));\n    };\n    _proto.canEstimate = function canEstimate() {\n      return this.fast_.getTotalWeight() >= this.minWeight_;\n    };\n    _proto.getEstimate = function getEstimate() {\n      if (this.canEstimate()) {\n        // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n        // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n        // Take the minimum of these two estimates.  This should have the effect of\n        // adapting down quickly, but up more slowly.\n        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n      } else {\n        return this.defaultEstimate_;\n      }\n    };\n    _proto.getEstimateTTFB = function getEstimateTTFB() {\n      if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n        return this.ttfb_.getEstimate();\n      } else {\n        return this.defaultTTFB_;\n      }\n    };\n    _proto.destroy = function destroy() {};\n    return _createClass(EwmaBandWidthEstimator, [{\n      key: \"defaultEstimate\",\n      get: function get() {\n        return this.defaultEstimate_;\n      }\n    }]);\n  }();\n\n  var Logger = function Logger(label, logger) {\n    this.trace = void 0;\n    this.debug = void 0;\n    this.log = void 0;\n    this.warn = void 0;\n    this.info = void 0;\n    this.error = void 0;\n    var lb = \"[\" + label + \"]:\";\n    this.trace = noop;\n    this.debug = logger.debug.bind(null, lb);\n    this.log = logger.log.bind(null, lb);\n    this.warn = logger.warn.bind(null, lb);\n    this.info = logger.info.bind(null, lb);\n    this.error = logger.error.bind(null, lb);\n  };\n  var noop = function noop() {};\n  var fakeLogger = {\n    trace: noop,\n    debug: noop,\n    log: noop,\n    warn: noop,\n    info: noop,\n    error: noop\n  };\n  function createLogger() {\n    return _extends({}, fakeLogger);\n  }\n\n  // let lastCallTime;\n  // function formatMsgWithTimeInfo(type, msg) {\n  //   const now = Date.now();\n  //   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n  //   lastCallTime = now;\n  //   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n  //   return msg;\n  // }\n\n  function consolePrintFn(type, id) {\n    var func = self.console[type];\n    return func ? func.bind(self.console, (id ? '[' + id + '] ' : '') + \"[\" + type + \"] >\") : noop;\n  }\n  function getLoggerFn(key, debugConfig, id) {\n    return debugConfig[key] ? debugConfig[key].bind(debugConfig) : consolePrintFn(key, id);\n  }\n  var exportedLogger = createLogger();\n  function enableLogs(debugConfig, context, id) {\n    // check that console is available\n    var newLogger = createLogger();\n    if (typeof console === 'object' && debugConfig === true || typeof debugConfig === 'object') {\n      var keys = [\n      // Remove out from list here to hard-disable a log-level\n      // 'trace',\n      'debug', 'log', 'info', 'warn', 'error'];\n      keys.forEach(function (key) {\n        newLogger[key] = getLoggerFn(key, debugConfig, id);\n      });\n      // Some browsers don't allow to use bind on console object anyway\n      // fallback to default if needed\n      try {\n        newLogger.log(\"Debug logs enabled for \\\"\" + context + \"\\\" in hls.js version \" + \"1.6.15\");\n      } catch (e) {\n        /* log fn threw an exception. All logger methods are no-ops. */\n        return createLogger();\n      }\n      // global exported logger uses the same functions as new logger without `id`\n      keys.forEach(function (key) {\n        exportedLogger[key] = getLoggerFn(key, debugConfig);\n      });\n    } else {\n      // Reset global exported logger\n      _extends(exportedLogger, newLogger);\n    }\n    return newLogger;\n  }\n  var logger = exportedLogger;\n\n  function getMediaSource(preferManagedMediaSource) {\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    if (typeof self === 'undefined') return undefined;\n    var mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;\n    return mms || self.MediaSource || self.WebKitMediaSource;\n  }\n  function isManagedMediaSource(source) {\n    return typeof self !== 'undefined' && source === self.ManagedMediaSource;\n  }\n  function isCompatibleTrackChange(currentTracks, requiredTracks) {\n    var trackNames = Object.keys(currentTracks);\n    var requiredTrackNames = Object.keys(requiredTracks);\n    var trackCount = trackNames.length;\n    var requiredTrackCount = requiredTrackNames.length;\n    return !trackCount || !requiredTrackCount || trackCount === requiredTrackCount && !trackNames.some(function (name) {\n      return requiredTrackNames.indexOf(name) === -1;\n    });\n  }\n\n  // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n  // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n  /* utf.js - UTF-8 <=> UTF-16 convertion\n   *\n   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n   * Version: 1.0\n   * LastModified: Dec 25 1999\n   * This library is free.  You can redistribute it and/or modify it.\n   */\n  /**\n   * Converts a UTF-8 array to a string.\n   *\n   * @param array - The UTF-8 array to convert\n   *\n   * @returns The string\n   *\n   * @group Utils\n   *\n   * @beta\n   */\n  function utf8ArrayToStr(array, exitOnNull) {\n    if (exitOnNull === void 0) {\n      exitOnNull = false;\n    }\n    if (typeof TextDecoder !== 'undefined') {\n      var decoder = new TextDecoder('utf-8');\n      var decoded = decoder.decode(array);\n      if (exitOnNull) {\n        // grab up to the first null\n        var idx = decoded.indexOf('\\0');\n        return idx !== -1 ? decoded.substring(0, idx) : decoded;\n      }\n      // remove any null characters\n      return decoded.replace(/\\0/g, '');\n    }\n    var len = array.length;\n    var c;\n    var char2;\n    var char3;\n    var out = '';\n    var i = 0;\n    while (i < len) {\n      c = array[i++];\n      if (c === 0x00 && exitOnNull) {\n        return out;\n      } else if (c === 0x00 || c === 0x03) {\n        // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n        continue;\n      }\n      switch (c >> 4) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n          // 0xxxxxxx\n          out += String.fromCharCode(c);\n          break;\n        case 12:\n        case 13:\n          // 110x xxxx   10xx xxxx\n          char2 = array[i++];\n          out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n          break;\n        case 14:\n          // 1110 xxxx  10xx xxxx  10xx xxxx\n          char2 = array[i++];\n          char3 = array[i++];\n          out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n          break;\n      }\n    }\n    return out;\n  }\n\n  /**\n   *  hex dump helper class\n   */\n\n  function arrayToHex(array) {\n    var str = '';\n    for (var i = 0; i < array.length; i++) {\n      var h = array[i].toString(16);\n      if (h.length < 2) {\n        h = '0' + h;\n      }\n      str += h;\n    }\n    return str;\n  }\n  function hexToArrayBuffer(str) {\n    return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n  }\n\n  var LoadStats = function LoadStats() {\n    this.aborted = false;\n    this.loaded = 0;\n    this.retry = 0;\n    this.total = 0;\n    this.chunkCount = 0;\n    this.bwEstimate = 0;\n    this.loading = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n    this.parsing = {\n      start: 0,\n      end: 0\n    };\n    this.buffering = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n  };\n\n  var ElementaryStreamTypes = {\n    AUDIO: \"audio\",\n    VIDEO: \"video\",\n    AUDIOVIDEO: \"audiovideo\"\n  };\n  var BaseSegment = /*#__PURE__*/function () {\n    function BaseSegment(base) {\n      this._byteRange = null;\n      this._url = null;\n      this._stats = null;\n      this._streams = null;\n      // baseurl is the URL to the playlist\n      this.base = void 0;\n      // relurl is the portion of the URL that comes from inside the playlist.\n      this.relurl = void 0;\n      if (typeof base === 'string') {\n        base = {\n          url: base\n        };\n      }\n      this.base = base;\n      makeEnumerable(this, 'stats');\n    }\n\n    // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n    var _proto = BaseSegment.prototype;\n    _proto.setByteRange = function setByteRange(value, previous) {\n      var params = value.split('@', 2);\n      var start;\n      if (params.length === 1) {\n        start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;\n      } else {\n        start = parseInt(params[1]);\n      }\n      this._byteRange = [start, parseInt(params[0]) + start];\n    };\n    _proto.clearElementaryStreamInfo = function clearElementaryStreamInfo() {\n      var elementaryStreams = this.elementaryStreams;\n      elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n      elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n      elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n    };\n    return _createClass(BaseSegment, [{\n      key: \"baseurl\",\n      get: function get() {\n        return this.base.url;\n      }\n    }, {\n      key: \"byteRange\",\n      get: function get() {\n        if (this._byteRange === null) {\n          return [];\n        }\n        return this._byteRange;\n      }\n    }, {\n      key: \"byteRangeStartOffset\",\n      get: function get() {\n        return this.byteRange[0];\n      }\n    }, {\n      key: \"byteRangeEndOffset\",\n      get: function get() {\n        return this.byteRange[1];\n      }\n    }, {\n      key: \"elementaryStreams\",\n      get: function get() {\n        if (this._streams === null) {\n          var _this$_streams;\n          this._streams = (_this$_streams = {}, _this$_streams[ElementaryStreamTypes.AUDIO] = null, _this$_streams[ElementaryStreamTypes.VIDEO] = null, _this$_streams[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$_streams);\n        }\n        return this._streams;\n      },\n      set: function set(value) {\n        this._streams = value;\n      }\n    }, {\n      key: \"hasStats\",\n      get: function get() {\n        return this._stats !== null;\n      }\n    }, {\n      key: \"hasStreams\",\n      get: function get() {\n        return this._streams !== null;\n      }\n    }, {\n      key: \"stats\",\n      get: function get() {\n        if (this._stats === null) {\n          this._stats = new LoadStats();\n        }\n        return this._stats;\n      },\n      set: function set(value) {\n        this._stats = value;\n      }\n    }, {\n      key: \"url\",\n      get: function get() {\n        if (!this._url && this.baseurl && this.relurl) {\n          this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n            alwaysNormalize: true\n          });\n        }\n        return this._url || '';\n      },\n      set: function set(value) {\n        this._url = value;\n      }\n    }]);\n  }();\n  function isMediaFragment(frag) {\n    return frag.sn !== 'initSegment';\n  }\n\n  /**\n   * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n   */\n  var Fragment = /*#__PURE__*/function (_BaseSegment2) {\n    function Fragment(type, base) {\n      var _this;\n      _this = _BaseSegment2.call(this, base) || this;\n      _this._decryptdata = null;\n      _this._programDateTime = null;\n      _this._ref = null;\n      // Approximate bit rate of the fragment expressed in bits per second (bps) as indicated by the last EXT-X-BITRATE (kbps) tag\n      _this._bitrate = void 0;\n      _this.rawProgramDateTime = null;\n      _this.tagList = [];\n      // EXTINF has to be present for a m3u8 to be considered valid\n      _this.duration = 0;\n      // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n      _this.sn = 0;\n      // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n      // core difference from the private field _decryptdata is the lack of the initialized IV\n      // _decryptdata will set the IV for this segment based on the segment number in the fragment\n      _this.levelkeys = void 0;\n      // A string representing the fragment type\n      _this.type = void 0;\n      // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n      _this.loader = null;\n      // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n      _this.keyLoader = null;\n      // The level/track index to which the fragment belongs\n      _this.level = -1;\n      // The continuity counter of the fragment\n      _this.cc = 0;\n      // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n      _this.startPTS = void 0;\n      // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n      _this.endPTS = void 0;\n      // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n      _this.startDTS = void 0;\n      // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n      _this.endDTS = void 0;\n      // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n      _this.start = 0;\n      // The offset time (seconds) of the fragment from the start of the Playlist\n      _this.playlistOffset = 0;\n      // Set by `updateFragPTSDTS` in level-helper\n      _this.deltaPTS = void 0;\n      // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n      _this.maxStartPTS = void 0;\n      // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n      _this.minEndPTS = void 0;\n      // Init Segment bytes (unset for media segments)\n      _this.data = void 0;\n      // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n      _this.bitrateTest = false;\n      // #EXTINF  segment title\n      _this.title = null;\n      // The Media Initialization Section for this segment\n      _this.initSegment = null;\n      // Fragment is the last fragment in the media playlist\n      _this.endList = void 0;\n      // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n      _this.gap = void 0;\n      // Deprecated\n      _this.urlId = 0;\n      _this.type = type;\n      return _this;\n    }\n    _inheritsLoose(Fragment, _BaseSegment2);\n    var _proto2 = Fragment.prototype;\n    _proto2.addStart = function addStart(value) {\n      this.setStart(this.start + value);\n    };\n    _proto2.setStart = function setStart(value) {\n      this.start = value;\n      if (this._ref) {\n        this._ref.start = value;\n      }\n    };\n    _proto2.setDuration = function setDuration(value) {\n      this.duration = value;\n      if (this._ref) {\n        this._ref.duration = value;\n      }\n    };\n    _proto2.setKeyFormat = function setKeyFormat(keyFormat) {\n      var levelkeys = this.levelkeys;\n      if (levelkeys) {\n        var _this$_decryptdata;\n        var key = levelkeys[keyFormat];\n        if (key && !((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.keyId)) {\n          this._decryptdata = key.getDecryptData(this.sn, levelkeys);\n        }\n      }\n    };\n    _proto2.abortRequests = function abortRequests() {\n      var _this$loader, _this$keyLoader;\n      (_this$loader = this.loader) == null || _this$loader.abort();\n      (_this$keyLoader = this.keyLoader) == null || _this$keyLoader.abort();\n    };\n    _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {\n      if (partial === void 0) {\n        partial = false;\n      }\n      var elementaryStreams = this.elementaryStreams;\n      var info = elementaryStreams[type];\n      if (!info) {\n        elementaryStreams[type] = {\n          startPTS: startPTS,\n          endPTS: endPTS,\n          startDTS: startDTS,\n          endDTS: endDTS,\n          partial: partial\n        };\n        return;\n      }\n      info.startPTS = Math.min(info.startPTS, startPTS);\n      info.endPTS = Math.max(info.endPTS, endPTS);\n      info.startDTS = Math.min(info.startDTS, startDTS);\n      info.endDTS = Math.max(info.endDTS, endDTS);\n    };\n    return _createClass(Fragment, [{\n      key: \"byteLength\",\n      get: function get() {\n        if (this.hasStats) {\n          var total = this.stats.total;\n          if (total) {\n            return total;\n          }\n        }\n        if (this.byteRange.length) {\n          var start = this.byteRange[0];\n          var end = this.byteRange[1];\n          if (isFiniteNumber(start) && isFiniteNumber(end)) {\n            return end - start;\n          }\n        }\n        return null;\n      }\n    }, {\n      key: \"bitrate\",\n      get: function get() {\n        if (this.byteLength) {\n          return this.byteLength * 8 / this.duration;\n        }\n        if (this._bitrate) {\n          return this._bitrate;\n        }\n        return null;\n      },\n      set: function set(value) {\n        this._bitrate = value;\n      }\n    }, {\n      key: \"decryptdata\",\n      get: function get() {\n        var _this$_decryptdata2;\n        var levelkeys = this.levelkeys;\n        if (!levelkeys || levelkeys.NONE) {\n          return null;\n        }\n        if (levelkeys.identity) {\n          if (!this._decryptdata) {\n            this._decryptdata = levelkeys.identity.getDecryptData(this.sn);\n          }\n        } else if (!((_this$_decryptdata2 = this._decryptdata) != null && _this$_decryptdata2.keyId)) {\n          var keyFormats = Object.keys(levelkeys);\n          if (keyFormats.length === 1) {\n            var levelKey = this._decryptdata = levelkeys[keyFormats[0]] || null;\n            if (levelKey) {\n              this._decryptdata = levelKey.getDecryptData(this.sn, levelkeys);\n            }\n          }\n        }\n        return this._decryptdata;\n      }\n    }, {\n      key: \"end\",\n      get: function get() {\n        return this.start + this.duration;\n      }\n    }, {\n      key: \"endProgramDateTime\",\n      get: function get() {\n        if (this.programDateTime === null) {\n          return null;\n        }\n        var duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n        return this.programDateTime + duration * 1000;\n      }\n    }, {\n      key: \"encrypted\",\n      get: function get() {\n        var _this$_decryptdata3;\n        // At the m3u8-parser level we need to add support for manifest signalled keyformats\n        // when we want the fragment to start reporting that it is encrypted.\n        // Currently, keyFormat will only be set for identity keys\n        if ((_this$_decryptdata3 = this._decryptdata) != null && _this$_decryptdata3.encrypted) {\n          return true;\n        } else if (this.levelkeys) {\n          var _this$levelkeys$keyFo;\n          var keyFormats = Object.keys(this.levelkeys);\n          var len = keyFormats.length;\n          if (len > 1 || len === 1 && (_this$levelkeys$keyFo = this.levelkeys[keyFormats[0]]) != null && _this$levelkeys$keyFo.encrypted) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }, {\n      key: \"programDateTime\",\n      get: function get() {\n        if (this._programDateTime === null && this.rawProgramDateTime) {\n          this.programDateTime = Date.parse(this.rawProgramDateTime);\n        }\n        return this._programDateTime;\n      },\n      set: function set(value) {\n        if (!isFiniteNumber(value)) {\n          this._programDateTime = this.rawProgramDateTime = null;\n          return;\n        }\n        this._programDateTime = value;\n      }\n    }, {\n      key: \"ref\",\n      get: function get() {\n        if (!isMediaFragment(this)) {\n          return null;\n        }\n        if (!this._ref) {\n          this._ref = {\n            base: this.base,\n            start: this.start,\n            duration: this.duration,\n            sn: this.sn,\n            programDateTime: this.programDateTime\n          };\n        }\n        return this._ref;\n      }\n    }]);\n  }(BaseSegment);\n\n  /**\n   * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n   */\n  var Part = /*#__PURE__*/function (_BaseSegment3) {\n    function Part(partAttrs, frag, base, index, previous) {\n      var _this2;\n      _this2 = _BaseSegment3.call(this, base) || this;\n      _this2.fragOffset = 0;\n      _this2.duration = 0;\n      _this2.gap = false;\n      _this2.independent = false;\n      _this2.relurl = void 0;\n      _this2.fragment = void 0;\n      _this2.index = void 0;\n      _this2.duration = partAttrs.decimalFloatingPoint('DURATION');\n      _this2.gap = partAttrs.bool('GAP');\n      _this2.independent = partAttrs.bool('INDEPENDENT');\n      _this2.relurl = partAttrs.enumeratedString('URI');\n      _this2.fragment = frag;\n      _this2.index = index;\n      var byteRange = partAttrs.enumeratedString('BYTERANGE');\n      if (byteRange) {\n        _this2.setByteRange(byteRange, previous);\n      }\n      if (previous) {\n        _this2.fragOffset = previous.fragOffset + previous.duration;\n      }\n      return _this2;\n    }\n    _inheritsLoose(Part, _BaseSegment3);\n    return _createClass(Part, [{\n      key: \"start\",\n      get: function get() {\n        return this.fragment.start + this.fragOffset;\n      }\n    }, {\n      key: \"end\",\n      get: function get() {\n        return this.start + this.duration;\n      }\n    }, {\n      key: \"loaded\",\n      get: function get() {\n        var elementaryStreams = this.elementaryStreams;\n        return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n      }\n    }]);\n  }(BaseSegment);\n  function getOwnPropertyDescriptorFromPrototypeChain(object, property) {\n    var prototype = Object.getPrototypeOf(object);\n    if (prototype) {\n      var propertyDescriptor = Object.getOwnPropertyDescriptor(prototype, property);\n      if (propertyDescriptor) {\n        return propertyDescriptor;\n      }\n      return getOwnPropertyDescriptorFromPrototypeChain(prototype, property);\n    }\n  }\n  function makeEnumerable(object, property) {\n    var d = getOwnPropertyDescriptorFromPrototypeChain(object, property);\n    if (d) {\n      d.enumerable = true;\n      Object.defineProperty(object, property, d);\n    }\n  }\n\n  var UINT32_MAX$1 = Math.pow(2, 32) - 1;\n  var push = [].push;\n\n  // We are using fixed track IDs for driving the MP4 remuxer\n  // instead of following the TS PIDs.\n  // There is no reason not to do this and some browsers/SourceBuffer-demuxers\n  // may not like if there are TrackID \"switches\"\n  // See https://github.com/video-dev/hls.js/issues/1331\n  // Here we are mapping our internal track types to constant MP4 track IDs\n  // With MSE currently one can only have one track of each, and we are muxing\n  // whatever video/audio rendition in them.\n  var RemuxerTrackIdConfig = {\n    video: 1,\n    audio: 2,\n    id3: 3,\n    text: 4\n  };\n  function bin2str(data) {\n    return String.fromCharCode.apply(null, data);\n  }\n  function readUint16(buffer, offset) {\n    var val = buffer[offset] << 8 | buffer[offset + 1];\n    return val < 0 ? 65536 + val : val;\n  }\n  function readUint32(buffer, offset) {\n    var val = readSint32(buffer, offset);\n    return val < 0 ? 4294967296 + val : val;\n  }\n  function readUint64(buffer, offset) {\n    var result = readUint32(buffer, offset);\n    result *= Math.pow(2, 32);\n    result += readUint32(buffer, offset + 4);\n    return result;\n  }\n  function readSint32(buffer, offset) {\n    return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n  }\n\n  // Find \"moof\" box\n  function hasMoofData(data) {\n    var end = data.byteLength;\n    for (var i = 0; i < end;) {\n      var size = readUint32(data, i);\n      if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {\n        return true;\n      }\n      i = size > 1 ? i + size : end;\n    }\n    return false;\n  }\n\n  // Find the data for a box specified by its path\n  function findBox(data, path) {\n    var results = [];\n    if (!path.length) {\n      // short-circuit the search for empty paths\n      return results;\n    }\n    var end = data.byteLength;\n    for (var i = 0; i < end;) {\n      var size = readUint32(data, i);\n      var type = bin2str(data.subarray(i + 4, i + 8));\n      var endbox = size > 1 ? i + size : end;\n      if (type === path[0]) {\n        if (path.length === 1) {\n          // this is the end of the path and we've found the box we were\n          // looking for\n          results.push(data.subarray(i + 8, endbox));\n        } else {\n          // recursively search for the next box along the path\n          var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n          if (subresults.length) {\n            push.apply(results, subresults);\n          }\n        }\n      }\n      i = endbox;\n    }\n\n    // we've finished searching all of data\n    return results;\n  }\n  function parseSegmentIndex(sidx) {\n    var references = [];\n    var version = sidx[0];\n\n    // set initial offset, we skip the reference ID (not needed)\n    var index = 8;\n    var timescale = readUint32(sidx, index);\n    index += 4;\n    var earliestPresentationTime = 0;\n    var firstOffset = 0;\n    if (version === 0) {\n      earliestPresentationTime = readUint32(sidx, index);\n      firstOffset = readUint32(sidx, index + 4);\n      index += 8;\n    } else {\n      earliestPresentationTime = readUint64(sidx, index);\n      firstOffset = readUint64(sidx, index + 8);\n      index += 16;\n    }\n\n    // skip reserved\n    index += 2;\n    var startByte = sidx.length + firstOffset;\n    var referencesCount = readUint16(sidx, index);\n    index += 2;\n    for (var i = 0; i < referencesCount; i++) {\n      var referenceIndex = index;\n      var referenceInfo = readUint32(sidx, referenceIndex);\n      referenceIndex += 4;\n      var referenceSize = referenceInfo & 0x7fffffff;\n      var referenceType = (referenceInfo & 0x80000000) >>> 31;\n      if (referenceType === 1) {\n        logger.warn('SIDX has hierarchical references (not supported)');\n        return null;\n      }\n      var subsegmentDuration = readUint32(sidx, referenceIndex);\n      referenceIndex += 4;\n      references.push({\n        referenceSize: referenceSize,\n        subsegmentDuration: subsegmentDuration,\n        // unscaled\n        info: {\n          duration: subsegmentDuration / timescale,\n          start: startByte,\n          end: startByte + referenceSize - 1\n        }\n      });\n      startByte += referenceSize;\n\n      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n      // for |sapDelta|.\n      referenceIndex += 4;\n\n      // skip to next ref\n      index = referenceIndex;\n    }\n    return {\n      earliestPresentationTime: earliestPresentationTime,\n      timescale: timescale,\n      version: version,\n      referencesCount: referencesCount,\n      references: references\n    };\n  }\n\n  /**\n   * Parses an MP4 initialization segment and extracts stream type and\n   * timescale values for any declared tracks. Timescale values indicate the\n   * number of clock ticks per second to assume for time-based values\n   * elsewhere in the MP4.\n   *\n   * To determine the start time of an MP4, you need two pieces of\n   * information: the timescale unit and the earliest base media decode\n   * time. Multiple timescales can be specified within an MP4 but the\n   * base media decode time is always expressed in the timescale from\n   * the media header box for the track:\n   * ```\n   * moov > trak > mdia > mdhd.timescale\n   * moov > trak > mdia > hdlr\n   * ```\n   * @param initSegment the bytes of the init segment\n   * @returns a hash of track type to timescale values or null if\n   * the init segment is malformed.\n   */\n\n  function parseInitSegment(initSegment) {\n    var result = [];\n    var traks = findBox(initSegment, ['moov', 'trak']);\n    for (var i = 0; i < traks.length; i++) {\n      var trak = traks[i];\n      var tkhd = findBox(trak, ['tkhd'])[0];\n      if (tkhd) {\n        var version = tkhd[0];\n        var trackId = readUint32(tkhd, version === 0 ? 12 : 20);\n        var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n        if (mdhd) {\n          version = mdhd[0];\n          var timescale = readUint32(mdhd, version === 0 ? 12 : 20);\n          var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n          if (hdlr) {\n            var hdlrType = bin2str(hdlr.subarray(8, 12));\n            var type = {\n              soun: ElementaryStreamTypes.AUDIO,\n              vide: ElementaryStreamTypes.VIDEO\n            }[hdlrType];\n            // Parse codec details\n            var stsdBox = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n            var stsd = parseStsd(stsdBox);\n            if (type) {\n              // Add 'audio', 'video', and 'audiovideo' track records that will map to SourceBuffers\n              result[trackId] = {\n                timescale: timescale,\n                type: type,\n                stsd: stsd\n              };\n              result[type] = _objectSpread2({\n                timescale: timescale,\n                id: trackId\n              }, stsd);\n            } else {\n              // Add 'meta' and other track records\n              result[trackId] = {\n                timescale: timescale,\n                type: hdlrType,\n                stsd: stsd\n              };\n            }\n          }\n        }\n      }\n    }\n    var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n    trex.forEach(function (trex) {\n      var trackId = readUint32(trex, 4);\n      var track = result[trackId];\n      if (track) {\n        track.default = {\n          duration: readUint32(trex, 12),\n          flags: readUint32(trex, 20)\n        };\n      }\n    });\n    return result;\n  }\n  function parseStsd(stsd) {\n    var sampleEntries = stsd.subarray(8);\n    var sampleEntriesEnd = sampleEntries.subarray(8 + 78);\n    var fourCC = bin2str(sampleEntries.subarray(4, 8));\n    var codec = fourCC;\n    var supplemental;\n    var encrypted = fourCC === 'enca' || fourCC === 'encv';\n    if (encrypted) {\n      var encBox = findBox(sampleEntries, [fourCC])[0];\n      var encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);\n      var sinfs = findBox(encBoxChildren, ['sinf']);\n      sinfs.forEach(function (sinf) {\n        var schm = findBox(sinf, ['schm'])[0];\n        if (schm) {\n          var scheme = bin2str(schm.subarray(4, 8));\n          if (scheme === 'cbcs' || scheme === 'cenc') {\n            var frma = findBox(sinf, ['frma'])[0];\n            if (frma) {\n              // for encrypted content codec fourCC will be in frma\n              codec = bin2str(frma);\n            }\n          }\n        }\n      });\n    }\n    var codecFourCC = codec;\n    switch (codec) {\n      case 'avc1':\n      case 'avc2':\n      case 'avc3':\n      case 'avc4':\n        {\n          // extract profile + compatibility + level out of avcC box\n          var avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];\n          if (avcCBox && avcCBox.length > 3) {\n            codec += '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);\n            supplemental = parseSupplementalDoViCodec(codecFourCC === 'avc1' ? 'dva1' : 'dvav', sampleEntriesEnd);\n          }\n          break;\n        }\n      case 'mp4a':\n        {\n          var codecBox = findBox(sampleEntries, [fourCC])[0];\n          var esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];\n          if (esdsBox && esdsBox.length > 7) {\n            var i = 4;\n            // ES Descriptor tag\n            if (esdsBox[i++] !== 0x03) {\n              break;\n            }\n            i = skipBERInteger(esdsBox, i);\n            i += 2; // skip es_id;\n            var flags = esdsBox[i++];\n            if (flags & 0x80) {\n              i += 2; // skip dependency es_id\n            }\n            if (flags & 0x40) {\n              i += esdsBox[i++]; // skip URL\n            }\n            // Decoder config descriptor\n            if (esdsBox[i++] !== 0x04) {\n              break;\n            }\n            i = skipBERInteger(esdsBox, i);\n            var objectType = esdsBox[i++];\n            if (objectType === 0x40) {\n              codec += '.' + toHex(objectType);\n            } else {\n              break;\n            }\n            i += 12;\n            // Decoder specific info\n            if (esdsBox[i++] !== 0x05) {\n              break;\n            }\n            i = skipBERInteger(esdsBox, i);\n            var firstByte = esdsBox[i++];\n            var audioObjectType = (firstByte & 0xf8) >> 3;\n            if (audioObjectType === 31) {\n              audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);\n            }\n            codec += '.' + audioObjectType;\n          }\n          break;\n        }\n      case 'hvc1':\n      case 'hev1':\n        {\n          var hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];\n          if (hvcCBox && hvcCBox.length > 12) {\n            var profileByte = hvcCBox[1];\n            var profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];\n            var generalProfileIdc = profileByte & 0x1f;\n            var profileCompat = readUint32(hvcCBox, 2);\n            var tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';\n            var levelIDC = hvcCBox[12];\n            var constraintIndicator = hvcCBox.subarray(6, 12);\n            codec += '.' + profileSpace + generalProfileIdc;\n            codec += '.' + reverse32BitInt(profileCompat).toString(16).toUpperCase();\n            codec += '.' + tierFlag + levelIDC;\n            var constraintString = '';\n            for (var _i = constraintIndicator.length; _i--;) {\n              var _byte = constraintIndicator[_i];\n              if (_byte || constraintString) {\n                var encodedByte = _byte.toString(16).toUpperCase();\n                constraintString = '.' + encodedByte + constraintString;\n              }\n            }\n            codec += constraintString;\n          }\n          supplemental = parseSupplementalDoViCodec(codecFourCC == 'hev1' ? 'dvhe' : 'dvh1', sampleEntriesEnd);\n          break;\n        }\n      case 'dvh1':\n      case 'dvhe':\n      case 'dvav':\n      case 'dva1':\n      case 'dav1':\n        {\n          codec = parseSupplementalDoViCodec(codec, sampleEntriesEnd) || codec;\n          break;\n        }\n      case 'vp09':\n        {\n          var vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];\n          if (vpcCBox && vpcCBox.length > 6) {\n            var profile = vpcCBox[4];\n            var level = vpcCBox[5];\n            var bitDepth = vpcCBox[6] >> 4 & 0x0f;\n            codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level) + '.' + addLeadingZero(bitDepth);\n          }\n          break;\n        }\n      case 'av01':\n        {\n          var av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];\n          if (av1CBox && av1CBox.length > 2) {\n            var _profile = av1CBox[1] >>> 5;\n            var _level = av1CBox[1] & 0x1f;\n            var _tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';\n            var highBitDepth = (av1CBox[2] & 0x40) >> 6;\n            var twelveBit = (av1CBox[2] & 0x20) >> 5;\n            var _bitDepth = _profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;\n            var monochrome = (av1CBox[2] & 0x10) >> 4;\n            var chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\n            var chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\n            var chromaSamplePosition = av1CBox[2] & 0x03;\n            // TODO: parse color_description_present_flag\n            // default it to BT.709/limited range for now\n            // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n            var colorPrimaries = 1;\n            var transferCharacteristics = 1;\n            var matrixCoefficients = 1;\n            var videoFullRangeFlag = 0;\n            codec += '.' + _profile + '.' + addLeadingZero(_level) + _tierFlag + '.' + addLeadingZero(_bitDepth) + '.' + monochrome + '.' + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + '.' + addLeadingZero(colorPrimaries) + '.' + addLeadingZero(transferCharacteristics) + '.' + addLeadingZero(matrixCoefficients) + '.' + videoFullRangeFlag;\n            supplemental = parseSupplementalDoViCodec('dav1', sampleEntriesEnd);\n          }\n          break;\n        }\n    }\n    return {\n      codec: codec,\n      encrypted: encrypted,\n      supplemental: supplemental\n    };\n  }\n  function parseSupplementalDoViCodec(fourCC, sampleEntriesEnd) {\n    var dvvCResult = findBox(sampleEntriesEnd, ['dvvC']); // used by DoVi Profile 8 to 10\n    var dvXCBox = dvvCResult.length ? dvvCResult[0] : findBox(sampleEntriesEnd, ['dvcC'])[0]; // used by DoVi Profiles up to 7 and 20\n    if (dvXCBox) {\n      var doViProfile = dvXCBox[2] >> 1 & 0x7f;\n      var doViLevel = dvXCBox[2] << 5 & 0x20 | dvXCBox[3] >> 3 & 0x1f;\n      return fourCC + '.' + addLeadingZero(doViProfile) + '.' + addLeadingZero(doViLevel);\n    }\n  }\n  function reverse32BitInt(val) {\n    var result = 0;\n    for (var i = 0; i < 32; i++) {\n      result |= (val >> i & 1) << 32 - 1 - i;\n    }\n    return result >>> 0;\n  }\n  function skipBERInteger(bytes, i) {\n    var limit = i + 5;\n    while (bytes[i++] & 0x80 && i < limit) {\n      /* do nothing */\n    }\n    return i;\n  }\n  function toHex(x) {\n    return ('0' + x.toString(16).toUpperCase()).slice(-2);\n  }\n  function addLeadingZero(num) {\n    return (num < 10 ? '0' : '') + num;\n  }\n  function patchEncyptionData(initSegment, decryptdata) {\n    if (!initSegment || !decryptdata) {\n      return;\n    }\n    var keyId = decryptdata.keyId;\n    if (keyId && decryptdata.isCommonEncryption) {\n      applyToTencBoxes(initSegment, function (tenc, isAudio) {\n        // Look for default key id (keyID offset is always 8 within the tenc box):\n        var tencKeyId = tenc.subarray(8, 24);\n        if (!tencKeyId.some(function (b) {\n          return b !== 0;\n        })) {\n          logger.log(\"[eme] Patching keyId in 'enc\" + (isAudio ? 'a' : 'v') + \">sinf>>tenc' box: \" + arrayToHex(tencKeyId) + \" -> \" + arrayToHex(keyId));\n          tenc.set(keyId, 8);\n        }\n      });\n    }\n  }\n  function parseKeyIdsFromTenc(initSegment) {\n    var keyIds = [];\n    applyToTencBoxes(initSegment, function (tenc) {\n      return keyIds.push(tenc.subarray(8, 24));\n    });\n    return keyIds;\n  }\n  function applyToTencBoxes(initSegment, predicate) {\n    var traks = findBox(initSegment, ['moov', 'trak']);\n    traks.forEach(function (trak) {\n      var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n      if (!stsd) return;\n      var sampleEntries = stsd.subarray(8);\n      var encBoxes = findBox(sampleEntries, ['enca']);\n      var isAudio = encBoxes.length > 0;\n      if (!isAudio) {\n        encBoxes = findBox(sampleEntries, ['encv']);\n      }\n      encBoxes.forEach(function (enc) {\n        var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n        var sinfBoxes = findBox(encBoxChildren, ['sinf']);\n        sinfBoxes.forEach(function (sinf) {\n          var tenc = parseSinf(sinf);\n          if (tenc) {\n            predicate(tenc, isAudio);\n          }\n        });\n      });\n    });\n  }\n  function parseSinf(sinf) {\n    var schm = findBox(sinf, ['schm'])[0];\n    if (schm) {\n      var scheme = bin2str(schm.subarray(4, 8));\n      if (scheme === 'cbcs' || scheme === 'cenc') {\n        var tenc = findBox(sinf, ['schi', 'tenc'])[0];\n        if (tenc) {\n          return tenc;\n        }\n      }\n    }\n  }\n\n  /*\n    For Reference:\n    aligned(8) class TrackFragmentHeaderBox\n             extends FullBox(tfhd, 0, tf_flags){\n       unsigned int(32)  track_ID;\n       // all the following are optional fields\n       unsigned int(64)  base_data_offset;\n       unsigned int(32)  sample_description_index;\n       unsigned int(32)  default_sample_duration;\n       unsigned int(32)  default_sample_size;\n       unsigned int(32)  default_sample_flags\n    }\n   */\n\n  function getSampleData(data, initData, logger) {\n    var tracks = {};\n    var trafs = findBox(data, ['moof', 'traf']);\n    for (var i = 0; i < trafs.length; i++) {\n      var traf = trafs[i];\n      // There is only one tfhd & trun per traf\n      // This is true for CMAF style content, and we should perhaps check the ftyp\n      // and only look for a single trun then, but for ISOBMFF we should check\n      // for multiple track runs.\n      var tfhd = findBox(traf, ['tfhd'])[0];\n      // get the track id from the tfhd\n      var id = readUint32(tfhd, 4);\n      var track = initData[id];\n      if (!track) {\n        continue;\n      }\n      tracks[id] || (tracks[id] = {\n        start: NaN,\n        duration: 0,\n        sampleCount: 0,\n        timescale: track.timescale,\n        type: track.type\n      });\n      var trackTimes = tracks[id];\n      // get start DTS\n      var tfdt = findBox(traf, ['tfdt'])[0];\n      if (tfdt) {\n        var version = tfdt[0];\n        var baseTime = readUint32(tfdt, 4);\n        if (version === 1) {\n          // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n          // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n          // https://github.com/video-dev/hls.js/issues/5303\n          if (baseTime === UINT32_MAX$1) {\n            logger.warn(\"[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time\");\n          } else {\n            baseTime *= UINT32_MAX$1 + 1;\n            baseTime += readUint32(tfdt, 8);\n          }\n        }\n        if (isFiniteNumber(baseTime) && (!isFiniteNumber(trackTimes.start) || baseTime < trackTimes.start)) {\n          trackTimes.start = baseTime;\n        }\n      }\n      var trackDefault = track.default;\n      var tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n      var defaultSampleDuration = (trackDefault == null ? void 0 : trackDefault.duration) || 0;\n      if (tfhdFlags & 0x000008) {\n        // 0x000008 indicates the presence of the default_sample_duration field\n        if (tfhdFlags & 0x000002) {\n          // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n          // If present, the default_sample_duration exists at byte offset 12\n          defaultSampleDuration = readUint32(tfhd, 12);\n        } else {\n          // Otherwise, the duration is at byte offset 8\n          defaultSampleDuration = readUint32(tfhd, 8);\n        }\n      }\n      var truns = findBox(traf, ['trun']);\n      var sampleDTS = trackTimes.start || 0;\n      var rawDuration = 0;\n      var sampleDuration = defaultSampleDuration;\n      for (var j = 0; j < truns.length; j++) {\n        var trun = truns[j];\n        var sampleCount = readUint32(trun, 4);\n        var sampleIndex = trackTimes.sampleCount;\n        trackTimes.sampleCount += sampleCount;\n        // Get duration from samples\n        var dataOffsetPresent = trun[3] & 0x01;\n        var firstSampleFlagsPresent = trun[3] & 0x04;\n        var sampleDurationPresent = trun[2] & 0x01;\n        var sampleSizePresent = trun[2] & 0x02;\n        var sampleFlagsPresent = trun[2] & 0x04;\n        var sampleCompositionTimeOffsetPresent = trun[2] & 0x08;\n        var offset = 8;\n        var remaining = sampleCount;\n        if (dataOffsetPresent) {\n          offset += 4;\n        }\n        if (firstSampleFlagsPresent && sampleCount) {\n          var isNonSyncSample = trun[offset + 1] & 0x01;\n          if (!isNonSyncSample && trackTimes.keyFrameIndex === undefined) {\n            trackTimes.keyFrameIndex = sampleIndex;\n          }\n          offset += 4;\n          if (sampleDurationPresent) {\n            sampleDuration = readUint32(trun, offset);\n            offset += 4;\n          } else {\n            sampleDuration = defaultSampleDuration;\n          }\n          if (sampleSizePresent) {\n            offset += 4;\n          }\n          if (sampleCompositionTimeOffsetPresent) {\n            offset += 4;\n          }\n          sampleDTS += sampleDuration;\n          rawDuration += sampleDuration;\n          remaining--;\n        }\n        while (remaining--) {\n          if (sampleDurationPresent) {\n            sampleDuration = readUint32(trun, offset);\n            offset += 4;\n          } else {\n            sampleDuration = defaultSampleDuration;\n          }\n          if (sampleSizePresent) {\n            offset += 4;\n          }\n          if (sampleFlagsPresent) {\n            var _isNonSyncSample = trun[offset + 1] & 0x01;\n            if (!_isNonSyncSample) {\n              if (trackTimes.keyFrameIndex === undefined) {\n                trackTimes.keyFrameIndex = trackTimes.sampleCount - (remaining + 1);\n                trackTimes.keyFrameStart = sampleDTS;\n              }\n            }\n            offset += 4;\n          }\n          if (sampleCompositionTimeOffsetPresent) {\n            offset += 4;\n          }\n          sampleDTS += sampleDuration;\n          rawDuration += sampleDuration;\n        }\n        if (!rawDuration && defaultSampleDuration) {\n          rawDuration += defaultSampleDuration * sampleCount;\n        }\n      }\n      trackTimes.duration += rawDuration;\n    }\n    if (!Object.keys(tracks).some(function (trackId) {\n      return tracks[trackId].duration;\n    })) {\n      // If duration samples are not available in the traf use sidx subsegment_duration\n      var sidxMinStart = Infinity;\n      var sidxMaxEnd = 0;\n      var sidxs = findBox(data, ['sidx']);\n      for (var _i2 = 0; _i2 < sidxs.length; _i2++) {\n        var sidx = parseSegmentIndex(sidxs[_i2]);\n        if (sidx != null && sidx.references) {\n          sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);\n          var subSegmentDuration = sidx.references.reduce(function (dur, ref) {\n            return dur + ref.info.duration || 0;\n          }, 0);\n          sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);\n        }\n      }\n      if (sidxMaxEnd && isFiniteNumber(sidxMaxEnd)) {\n        Object.keys(tracks).forEach(function (trackId) {\n          if (!tracks[trackId].duration) {\n            tracks[trackId].duration = sidxMaxEnd * tracks[trackId].timescale - tracks[trackId].start;\n          }\n        });\n      }\n    }\n    return tracks;\n  }\n\n  // TODO: Check if the last moof+mdat pair is part of the valid range\n  function segmentValidRange(data) {\n    var segmentedRange = {\n      valid: null,\n      remainder: null\n    };\n    var moofs = findBox(data, ['moof']);\n    if (moofs.length < 2) {\n      segmentedRange.remainder = data;\n      return segmentedRange;\n    }\n    var last = moofs[moofs.length - 1];\n    // Offset by 8 bytes; findBox offsets the start by as much\n    segmentedRange.valid = data.slice(0, last.byteOffset - 8);\n    segmentedRange.remainder = data.slice(last.byteOffset - 8);\n    return segmentedRange;\n  }\n  function appendUint8Array(data1, data2) {\n    var temp = new Uint8Array(data1.length + data2.length);\n    temp.set(data1);\n    temp.set(data2, data1.length);\n    return temp;\n  }\n  function parseSamples(timeOffset, track) {\n    var seiSamples = [];\n    var videoData = track.samples;\n    var timescale = track.timescale;\n    var trackId = track.id;\n    var isHEVCFlavor = false;\n    var moofs = findBox(videoData, ['moof']);\n    moofs.map(function (moof) {\n      var moofOffset = moof.byteOffset - 8;\n      var trafs = findBox(moof, ['traf']);\n      trafs.map(function (traf) {\n        // get the base media decode time from the tfdt\n        var baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {\n          var version = tfdt[0];\n          var result = readUint32(tfdt, 4);\n          if (version === 1) {\n            result *= Math.pow(2, 32);\n            result += readUint32(tfdt, 8);\n          }\n          return result / timescale;\n        })[0];\n        if (baseTime !== undefined) {\n          timeOffset = baseTime;\n        }\n        return findBox(traf, ['tfhd']).map(function (tfhd) {\n          var id = readUint32(tfhd, 4);\n          var tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n          var baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n          var sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n          var defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n          var defaultSampleDuration = 0;\n          var defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n          var defaultSampleSize = 0;\n          var defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n          var tfhdOffset = 8;\n          if (id === trackId) {\n            if (baseDataOffsetPresent) {\n              tfhdOffset += 8;\n            }\n            if (sampleDescriptionIndexPresent) {\n              tfhdOffset += 4;\n            }\n            if (defaultSampleDurationPresent) {\n              defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n              tfhdOffset += 4;\n            }\n            if (defaultSampleSizePresent) {\n              defaultSampleSize = readUint32(tfhd, tfhdOffset);\n              tfhdOffset += 4;\n            }\n            if (defaultSampleFlagsPresent) {\n              tfhdOffset += 4;\n            }\n            if (track.type === 'video') {\n              isHEVCFlavor = isHEVC(track.codec);\n            }\n            findBox(traf, ['trun']).map(function (trun) {\n              var version = trun[0];\n              var flags = readUint32(trun, 0) & 0xffffff;\n              var dataOffsetPresent = (flags & 0x000001) !== 0;\n              var dataOffset = 0;\n              var firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n              var sampleDurationPresent = (flags & 0x000100) !== 0;\n              var sampleDuration = 0;\n              var sampleSizePresent = (flags & 0x000200) !== 0;\n              var sampleSize = 0;\n              var sampleFlagsPresent = (flags & 0x000400) !== 0;\n              var sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n              var compositionOffset = 0;\n              var sampleCount = readUint32(trun, 4);\n              var trunOffset = 8; // past version, flags, and sample count\n\n              if (dataOffsetPresent) {\n                dataOffset = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              }\n              if (firstSampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              var sampleOffset = dataOffset + moofOffset;\n              for (var ix = 0; ix < sampleCount; ix++) {\n                if (sampleDurationPresent) {\n                  sampleDuration = readUint32(trun, trunOffset);\n                  trunOffset += 4;\n                } else {\n                  sampleDuration = defaultSampleDuration;\n                }\n                if (sampleSizePresent) {\n                  sampleSize = readUint32(trun, trunOffset);\n                  trunOffset += 4;\n                } else {\n                  sampleSize = defaultSampleSize;\n                }\n                if (sampleFlagsPresent) {\n                  trunOffset += 4;\n                }\n                if (sampleCompositionOffsetsPresent) {\n                  if (version === 0) {\n                    compositionOffset = readUint32(trun, trunOffset);\n                  } else {\n                    compositionOffset = readSint32(trun, trunOffset);\n                  }\n                  trunOffset += 4;\n                }\n                if (track.type === ElementaryStreamTypes.VIDEO) {\n                  var naluTotalSize = 0;\n                  while (naluTotalSize < sampleSize) {\n                    var naluSize = readUint32(videoData, sampleOffset);\n                    sampleOffset += 4;\n                    if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                      var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                      parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                    }\n                    sampleOffset += naluSize;\n                    naluTotalSize += naluSize + 4;\n                  }\n                }\n                timeOffset += sampleDuration / timescale;\n              }\n            });\n          }\n        });\n      });\n    });\n    return seiSamples;\n  }\n  function isHEVC(codec) {\n    if (!codec) {\n      return false;\n    }\n    var baseCodec = codec.substring(0, 4);\n    return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n    // Dolby Vision\n    baseCodec === 'dvh1' || baseCodec === 'dvhe';\n  }\n  function isSEIMessage(isHEVCFlavor, naluHeader) {\n    if (isHEVCFlavor) {\n      var naluType = naluHeader >> 1 & 0x3f;\n      return naluType === 39 || naluType === 40;\n    } else {\n      var _naluType = naluHeader & 0x1f;\n      return _naluType === 6;\n    }\n  }\n  function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n    var data = discardEPB(unescapedData);\n    var seiPtr = 0;\n    // skip nal header\n    seiPtr += headerSize;\n    var payloadType = 0;\n    var payloadSize = 0;\n    var b = 0;\n    while (seiPtr < data.length) {\n      payloadType = 0;\n      do {\n        if (seiPtr >= data.length) {\n          break;\n        }\n        b = data[seiPtr++];\n        payloadType += b;\n      } while (b === 0xff);\n\n      // Parse payload size.\n      payloadSize = 0;\n      do {\n        if (seiPtr >= data.length) {\n          break;\n        }\n        b = data[seiPtr++];\n        payloadSize += b;\n      } while (b === 0xff);\n      var leftOver = data.length - seiPtr;\n      // Create a variable to process the payload\n      var payPtr = seiPtr;\n\n      // Increment the seiPtr to the end of the payload\n      if (payloadSize < leftOver) {\n        seiPtr += payloadSize;\n      } else if (payloadSize > leftOver) {\n        // Some type of corruption has happened?\n        logger.error(\"Malformed SEI payload. \" + payloadSize + \" is too small, only \" + leftOver + \" bytes left to parse.\");\n        // We might be able to parse some data, but let's be safe and ignore it.\n        break;\n      }\n      if (payloadType === 4) {\n        var countryCode = data[payPtr++];\n        if (countryCode === 181) {\n          var providerCode = readUint16(data, payPtr);\n          payPtr += 2;\n          if (providerCode === 49) {\n            var userStructure = readUint32(data, payPtr);\n            payPtr += 4;\n            if (userStructure === 0x47413934) {\n              var userDataType = data[payPtr++];\n\n              // Raw CEA-608 bytes wrapped in CEA-708 packet\n              if (userDataType === 3) {\n                var firstByte = data[payPtr++];\n                var totalCCs = 0x1f & firstByte;\n                var enabled = 0x40 & firstByte;\n                var totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n                var byteArray = new Uint8Array(totalBytes);\n                if (enabled) {\n                  byteArray[0] = firstByte;\n                  for (var i = 1; i < totalBytes; i++) {\n                    byteArray[i] = data[payPtr++];\n                  }\n                }\n                samples.push({\n                  type: userDataType,\n                  payloadType: payloadType,\n                  pts: pts,\n                  bytes: byteArray\n                });\n              }\n            }\n          }\n        }\n      } else if (payloadType === 5) {\n        if (payloadSize > 16) {\n          var uuidStrArray = [];\n          for (var _i3 = 0; _i3 < 16; _i3++) {\n            var _b = data[payPtr++].toString(16);\n            uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n            if (_i3 === 3 || _i3 === 5 || _i3 === 7 || _i3 === 9) {\n              uuidStrArray.push('-');\n            }\n          }\n          var length = payloadSize - 16;\n          var userDataBytes = new Uint8Array(length);\n          for (var _i4 = 0; _i4 < length; _i4++) {\n            userDataBytes[_i4] = data[payPtr++];\n          }\n          samples.push({\n            payloadType: payloadType,\n            pts: pts,\n            uuid: uuidStrArray.join(''),\n            userData: utf8ArrayToStr(userDataBytes),\n            userDataBytes: userDataBytes\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * remove Emulation Prevention bytes from a RBSP\n   */\n  function discardEPB(data) {\n    var length = data.byteLength;\n    var EPBPositions = [];\n    var i = 1;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        EPBPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (EPBPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    var newLength = length - EPBPositions.length;\n    var newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === EPBPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        EPBPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n    return newData;\n  }\n  function parseEmsg(data) {\n    var version = data[0];\n    var schemeIdUri = '';\n    var value = '';\n    var timeScale = 0;\n    var presentationTimeDelta = 0;\n    var presentationTime = 0;\n    var eventDuration = 0;\n    var id = 0;\n    var offset = 0;\n    if (version === 0) {\n      while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n      while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n      timeScale = readUint32(data, 12);\n      presentationTimeDelta = readUint32(data, 16);\n      eventDuration = readUint32(data, 20);\n      id = readUint32(data, 24);\n      offset = 28;\n    } else if (version === 1) {\n      offset += 4;\n      timeScale = readUint32(data, offset);\n      offset += 4;\n      var leftPresentationTime = readUint32(data, offset);\n      offset += 4;\n      var rightPresentationTime = readUint32(data, offset);\n      offset += 4;\n      presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;\n      if (!isSafeInteger(presentationTime)) {\n        presentationTime = Number.MAX_SAFE_INTEGER;\n        logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n      }\n      eventDuration = readUint32(data, offset);\n      offset += 4;\n      id = readUint32(data, offset);\n      offset += 4;\n      while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n      while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    var payload = data.subarray(offset, data.byteLength);\n    return {\n      schemeIdUri: schemeIdUri,\n      value: value,\n      timeScale: timeScale,\n      presentationTime: presentationTime,\n      presentationTimeDelta: presentationTimeDelta,\n      eventDuration: eventDuration,\n      id: id,\n      payload: payload\n    };\n  }\n  function mp4Box(type) {\n    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      payload[_key - 1] = arguments[_key];\n    }\n    var len = payload.length;\n    var size = 8;\n    var i = len;\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n    var result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    for (i = 0, size = 8; i < len; i++) {\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n  function mp4pssh(systemId, keyids, data) {\n    if (systemId.byteLength !== 16) {\n      throw new RangeError('Invalid system id');\n    }\n    var version;\n    var kids;\n    {\n      version = 0;\n      kids = new Uint8Array();\n    }\n    var kidCount;\n    if (version > 0) {\n      kidCount = new Uint8Array(4);\n      if (keyids.length > 0) {\n        new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n      }\n    } else {\n      kidCount = new Uint8Array();\n    }\n    var dataSize = new Uint8Array(4);\n    if (data.byteLength > 0) {\n      new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n    }\n    return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags\n    ]), systemId,\n    // 16 bytes\n    kidCount, kids, dataSize, data);\n  }\n  function parseMultiPssh(initData) {\n    var results = [];\n    if (initData instanceof ArrayBuffer) {\n      var length = initData.byteLength;\n      var offset = 0;\n      while (offset + 32 < length) {\n        var view = new DataView(initData, offset);\n        var pssh = parsePssh(view);\n        results.push(pssh);\n        offset += pssh.size;\n      }\n    }\n    return results;\n  }\n  function parsePssh(view) {\n    var size = view.getUint32(0);\n    var offset = view.byteOffset;\n    var length = view.byteLength;\n    if (length < size) {\n      return {\n        offset: offset,\n        size: length\n      };\n    }\n    var type = view.getUint32(4);\n    if (type !== 0x70737368) {\n      return {\n        offset: offset,\n        size: size\n      };\n    }\n    var version = view.getUint32(8) >>> 24;\n    if (version !== 0 && version !== 1) {\n      return {\n        offset: offset,\n        size: size\n      };\n    }\n    var buffer = view.buffer;\n    var systemId = arrayToHex(new Uint8Array(buffer, offset + 12, 16));\n    var kids = null;\n    var data = null;\n    var dataSizeOffset = 0;\n    if (version === 0) {\n      dataSizeOffset = 28;\n    } else {\n      var kidCounts = view.getUint32(28);\n      if (!kidCounts || length < 32 + kidCounts * 16) {\n        return {\n          offset: offset,\n          size: size\n        };\n      }\n      kids = [];\n      for (var i = 0; i < kidCounts; i++) {\n        kids.push(new Uint8Array(buffer, offset + 32 + i * 16, 16));\n      }\n      dataSizeOffset = 32 + kidCounts * 16;\n    }\n    if (!dataSizeOffset) {\n      return {\n        offset: offset,\n        size: size\n      };\n    }\n    var dataSizeOrKidCount = view.getUint32(dataSizeOffset);\n    if (size - 32 < dataSizeOrKidCount) {\n      return {\n        offset: offset,\n        size: size\n      };\n    }\n    data = new Uint8Array(buffer, offset + dataSizeOffset + 4, dataSizeOrKidCount);\n    return {\n      version: version,\n      systemId: systemId,\n      kids: kids,\n      data: data,\n      offset: offset,\n      size: size\n    };\n  }\n\n  var userAgentHevcSupportIsInaccurate = function userAgentHevcSupportIsInaccurate() {\n    return /\\(Windows.+Firefox\\//i.test(navigator.userAgent);\n  };\n\n  // from http://mp4ra.org/codecs.html\n  // values indicate codec selection preference (lower is higher priority)\n  var sampleEntryCodesISO = {\n    audio: {\n      a3ds: 1,\n      'ac-3': 0.95,\n      'ac-4': 1,\n      alac: 0.9,\n      alaw: 1,\n      dra1: 1,\n      'dts+': 1,\n      'dts-': 1,\n      dtsc: 1,\n      dtse: 1,\n      dtsh: 1,\n      'ec-3': 0.9,\n      enca: 1,\n      fLaC: 0.9,\n      // MP4-RA listed codec entry for FLAC\n      flac: 0.9,\n      // legacy browser codec name for FLAC\n      FLAC: 0.9,\n      // some manifests may list \"FLAC\" with Apple's tools\n      g719: 1,\n      g726: 1,\n      m4ae: 1,\n      mha1: 1,\n      mha2: 1,\n      mhm1: 1,\n      mhm2: 1,\n      mlpa: 1,\n      mp4a: 1,\n      'raw ': 1,\n      Opus: 1,\n      opus: 1,\n      // browsers expect this to be lowercase despite MP4RA says 'Opus'\n      samr: 1,\n      sawb: 1,\n      sawp: 1,\n      sevc: 1,\n      sqcp: 1,\n      ssmv: 1,\n      twos: 1,\n      ulaw: 1\n    },\n    video: {\n      avc1: 1,\n      avc2: 1,\n      avc3: 1,\n      avc4: 1,\n      avcp: 1,\n      av01: 0.8,\n      dav1: 0.8,\n      drac: 1,\n      dva1: 1,\n      dvav: 1,\n      dvh1: 0.7,\n      dvhe: 0.7,\n      encv: 1,\n      hev1: 0.75,\n      hvc1: 0.75,\n      mjp2: 1,\n      mp4v: 1,\n      mvc1: 1,\n      mvc2: 1,\n      mvc3: 1,\n      mvc4: 1,\n      resv: 1,\n      rv60: 1,\n      s263: 1,\n      svc1: 1,\n      svc2: 1,\n      'vc-1': 1,\n      vp08: 1,\n      vp09: 0.9\n    },\n    text: {\n      stpp: 1,\n      wvtt: 1\n    }\n  };\n  function isCodecType(codec, type) {\n    var typeCodes = sampleEntryCodesISO[type];\n    return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\n  }\n  function areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource) {\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    return !codecs.split(',').some(function (codec) {\n      return !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource);\n    });\n  }\n  function isCodecMediaSourceSupported(codec, type, preferManagedMediaSource) {\n    var _MediaSource$isTypeSu;\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    var MediaSource = getMediaSource(preferManagedMediaSource);\n    return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;\n  }\n  function mimeTypeForCodec(codec, type) {\n    return type + \"/mp4;codecs=\" + codec;\n  }\n  function videoCodecPreferenceValue(videoCodec) {\n    if (videoCodec) {\n      var fourCC = videoCodec.substring(0, 4);\n      return sampleEntryCodesISO.video[fourCC];\n    }\n    return 2;\n  }\n  function codecsSetSelectionPreferenceValue(codecSet) {\n    var limitedHevcSupport = userAgentHevcSupportIsInaccurate();\n    return codecSet.split(',').reduce(function (num, fourCC) {\n      var lowerPriority = limitedHevcSupport && isHEVC(fourCC);\n      var preferenceValue = lowerPriority ? 9 : sampleEntryCodesISO.video[fourCC];\n      if (preferenceValue) {\n        return (preferenceValue * 2 + num) / (num ? 3 : 2);\n      }\n      return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\n    }, 0);\n  }\n  var CODEC_COMPATIBLE_NAMES = {};\n  function getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource) {\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\n      return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];\n    }\n    var codecsToCheck = {\n      // Idealy fLaC and Opus would be first (spec-compliant) but\n      // some browsers will report that fLaC is supported then fail.\n      // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n      flac: ['flac', 'fLaC', 'FLAC'],\n      opus: ['opus', 'Opus'],\n      // Replace audio codec info if browser does not support mp4a.40.34,\n      // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs=\"mp3\"'\n      'mp4a.40.34': ['mp3']\n    }[lowerCaseCodec];\n    for (var i = 0; i < codecsToCheck.length; i++) {\n      var _getMediaSource;\n      if (isCodecMediaSourceSupported(codecsToCheck[i], 'audio', preferManagedMediaSource)) {\n        CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\n        return codecsToCheck[i];\n      } else if (codecsToCheck[i] === 'mp3' && (_getMediaSource = getMediaSource(preferManagedMediaSource)) != null && _getMediaSource.isTypeSupported('audio/mpeg')) {\n        return '';\n      }\n    }\n    return lowerCaseCodec;\n  }\n  var AUDIO_CODEC_REGEXP = /flac|opus|mp4a\\.40\\.34/i;\n  function getCodecCompatibleName(codec, preferManagedMediaSource) {\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    return codec.replace(AUDIO_CODEC_REGEXP, function (m) {\n      return getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource);\n    });\n  }\n  function replaceVideoCodec(originalCodecs, newVideoCodec) {\n    var codecs = [];\n    if (originalCodecs) {\n      var allCodecs = originalCodecs.split(',');\n      for (var i = 0; i < allCodecs.length; i++) {\n        if (!isCodecType(allCodecs[i], 'video')) {\n          codecs.push(allCodecs[i]);\n        }\n      }\n    }\n    if (newVideoCodec) {\n      codecs.push(newVideoCodec);\n    }\n    return codecs.join(',');\n  }\n  function pickMostCompleteCodecName(parsedCodec, levelCodec) {\n    // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\n    // so use level codec is parsed codec is unavailable or incomplete\n    if (parsedCodec && (parsedCodec.length > 4 || ['ac-3', 'ec-3', 'alac', 'fLaC', 'Opus'].indexOf(parsedCodec) !== -1)) {\n      if (isCodecSupportedAsType(parsedCodec, 'audio') || isCodecSupportedAsType(parsedCodec, 'video')) {\n        return parsedCodec;\n      }\n    }\n    if (levelCodec) {\n      var levelCodecs = levelCodec.split(',');\n      if (levelCodecs.length > 1) {\n        if (parsedCodec) {\n          for (var i = levelCodecs.length; i--;) {\n            if (levelCodecs[i].substring(0, 4) === parsedCodec.substring(0, 4)) {\n              return levelCodecs[i];\n            }\n          }\n        }\n        return levelCodecs[0];\n      }\n    }\n    return levelCodec || parsedCodec;\n  }\n  function isCodecSupportedAsType(codec, type) {\n    return isCodecType(codec, type) && isCodecMediaSourceSupported(codec, type);\n  }\n  function convertAVC1ToAVCOTI(videoCodecs) {\n    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n    // Examples: avc1.66.30 to avc1.42001e and avc1.77.30,avc1.66.30 to avc1.4d001e,avc1.42001e.\n    var codecs = videoCodecs.split(',');\n    for (var i = 0; i < codecs.length; i++) {\n      var avcdata = codecs[i].split('.');\n      // only convert codec strings starting with avc1 (Examples: avc1.64001f,dvh1.05.07)\n      if (avcdata.length > 2 && avcdata[0] === 'avc1') {\n        codecs[i] = \"avc1.\" + parseInt(avcdata[1]).toString(16) + ('000' + parseInt(avcdata[2]).toString(16)).slice(-4);\n      }\n    }\n    return codecs.join(',');\n  }\n  function fillInMissingAV01Params(videoCodec) {\n    // Used to fill in incomplete AV1 playlist CODECS strings for mediaCapabilities.decodingInfo queries\n    if (videoCodec.startsWith('av01.')) {\n      var av1params = videoCodec.split('.');\n      var placeholders = ['0', '111', '01', '01', '01', '0'];\n      for (var i = av1params.length; i > 4 && i < 10; i++) {\n        av1params[i] = placeholders[i - 4];\n      }\n      return av1params.join('.');\n    }\n    return videoCodec;\n  }\n  function getM2TSSupportedAudioTypes(preferManagedMediaSource) {\n    var MediaSource = getMediaSource(preferManagedMediaSource) || {\n      isTypeSupported: function isTypeSupported() {\n        return false;\n      }\n    };\n    return {\n      mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n      ac3: MediaSource.isTypeSupported('audio/mp4; codecs=\"ac-3\"') \n    };\n  }\n  function getCodecsForMimeType(mimeType) {\n    return mimeType.replace(/^.+codecs=[\"']?([^\"']+).*$/, '$1');\n  }\n\n  // @ts-ignore\n  var supportedResult = {\n    supported: true,\n    powerEfficient: true,\n    smooth: true\n    // keySystemAccess: null,\n  };\n\n  // @ts-ignore\n  var unsupportedResult = {\n    supported: false,\n    smooth: false,\n    powerEfficient: false\n    // keySystemAccess: null,\n  };\n  var SUPPORTED_INFO_DEFAULT = {\n    supported: true,\n    configurations: [],\n    decodingInfoResults: [supportedResult]\n  };\n  function getUnsupportedResult(error, configurations) {\n    return {\n      supported: false,\n      configurations: configurations,\n      decodingInfoResults: [unsupportedResult],\n      error: error\n    };\n  }\n  function requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {\n    // Only test support when configuration is exceeds minimum options\n    var videoCodecs = level.videoCodec;\n    var audioGroups = level.audioCodec ? level.audioGroups : null;\n    var audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n    var channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n    var maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;\n    var audioChannels = null;\n    if (audioGroups != null && audioGroups.length) {\n      try {\n        if (audioGroups.length === 1 && audioGroups[0]) {\n          audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;\n        } else {\n          audioChannels = audioGroups.reduce(function (acc, groupId) {\n            if (groupId) {\n              var audioTrackGroup = audioTracksByGroup.groups[groupId];\n              if (!audioTrackGroup) {\n                throw new Error(\"Audio track group \" + groupId + \" not found\");\n              }\n              // Sum all channel key values\n              Object.keys(audioTrackGroup.channels).forEach(function (key) {\n                acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];\n              });\n            }\n            return acc;\n          }, {\n            2: 0\n          });\n        }\n      } catch (error) {\n        return true;\n      }\n    }\n    return videoCodecs !== undefined && (\n    // Force media capabilities check for HEVC to avoid failure on Windows\n    videoCodecs.split(',').some(function (videoCodec) {\n      return isHEVC(videoCodec);\n    }) || level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== 'SDR' && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some(function (channels) {\n      return parseInt(channels) > maxChannels;\n    });\n  }\n  function getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities, cache) {\n    if (cache === void 0) {\n      cache = {};\n    }\n    var videoCodecs = level.videoCodec;\n    if (!videoCodecs && !level.audioCodec || !mediaCapabilities) {\n      return Promise.resolve(SUPPORTED_INFO_DEFAULT);\n    }\n    var configurations = [];\n    var videoDecodeList = makeVideoConfigurations(level);\n    var videoCount = videoDecodeList.length;\n    var audioDecodeList = makeAudioConfigurations(level, audioTracksByGroup, videoCount > 0);\n    var audioCount = audioDecodeList.length;\n    for (var i = videoCount || 1 * audioCount || 1; i--;) {\n      var configuration = {\n        type: 'media-source'\n      };\n      if (videoCount) {\n        configuration.video = videoDecodeList[i % videoCount];\n      }\n      if (audioCount) {\n        configuration.audio = audioDecodeList[i % audioCount];\n        var audioBitrate = configuration.audio.bitrate;\n        if (configuration.video && audioBitrate) {\n          configuration.video.bitrate -= audioBitrate;\n        }\n      }\n      configurations.push(configuration);\n    }\n    if (videoCodecs) {\n      // Override Windows Firefox HEVC MediaCapabilities result (https://github.com/video-dev/hls.js/issues/7046)\n      var ua = navigator.userAgent;\n      if (videoCodecs.split(',').some(function (videoCodec) {\n        return isHEVC(videoCodec);\n      }) && userAgentHevcSupportIsInaccurate()) {\n        return Promise.resolve(getUnsupportedResult(new Error(\"Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (\" + ua + \")\"), configurations));\n      }\n    }\n    return Promise.all(configurations.map(function (configuration) {\n      // Cache MediaCapabilities promises\n      var decodingInfoKey = getMediaDecodingInfoKey(configuration);\n      return cache[decodingInfoKey] || (cache[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));\n    })).then(function (decodingInfoResults) {\n      return {\n        supported: !decodingInfoResults.some(function (info) {\n          return !info.supported;\n        }),\n        configurations: configurations,\n        decodingInfoResults: decodingInfoResults\n      };\n    }).catch(function (error) {\n      return {\n        supported: false,\n        configurations: configurations,\n        decodingInfoResults: [],\n        error: error\n      };\n    });\n  }\n  function makeVideoConfigurations(level) {\n    var _level$videoCodec;\n    var videoCodecs = (_level$videoCodec = level.videoCodec) == null ? void 0 : _level$videoCodec.split(',');\n    var bitrate = getVariantDecodingBitrate(level);\n    var width = level.width || 640;\n    var height = level.height || 480;\n    // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.\n    var framerate = level.frameRate || 30;\n    var videoRange = level.videoRange.toLowerCase();\n    return videoCodecs ? videoCodecs.map(function (videoCodec) {\n      var videoConfiguration = {\n        contentType: mimeTypeForCodec(fillInMissingAV01Params(videoCodec), 'video'),\n        width: width,\n        height: height,\n        bitrate: bitrate,\n        framerate: framerate\n      };\n      if (videoRange !== 'sdr') {\n        videoConfiguration.transferFunction = videoRange;\n      }\n      return videoConfiguration;\n    }) : [];\n  }\n  function makeAudioConfigurations(level, audioTracksByGroup, hasVideo) {\n    var _level$audioCodec;\n    var audioCodecs = (_level$audioCodec = level.audioCodec) == null ? void 0 : _level$audioCodec.split(',');\n    var combinedBitrate = getVariantDecodingBitrate(level);\n    if (audioCodecs && level.audioGroups) {\n      return level.audioGroups.reduce(function (configurations, audioGroupId) {\n        var _audioTracksByGroup$g;\n        var tracks = audioGroupId ? (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks : null;\n        if (tracks) {\n          return tracks.reduce(function (configs, audioTrack) {\n            if (audioTrack.groupId === audioGroupId) {\n              var channelsNumber = parseFloat(audioTrack.channels || '');\n              audioCodecs.forEach(function (audioCodec) {\n                var audioConfiguration = {\n                  contentType: mimeTypeForCodec(audioCodec, 'audio'),\n                  bitrate: hasVideo ? estimatedAudioBitrate(audioCodec, combinedBitrate) : combinedBitrate\n                };\n                if (channelsNumber) {\n                  audioConfiguration.channels = '' + channelsNumber;\n                }\n                configs.push(audioConfiguration);\n              });\n            }\n            return configs;\n          }, configurations);\n        }\n        return configurations;\n      }, []);\n    }\n    return [];\n  }\n  function estimatedAudioBitrate(audioCodec, levelBitrate) {\n    if (levelBitrate <= 1) {\n      return 1;\n    }\n    var audioBitrate = 128000;\n    if (audioCodec === 'ec-3') {\n      audioBitrate = 768000;\n    } else if (audioCodec === 'ac-3') {\n      audioBitrate = 640000;\n    }\n    return Math.min(levelBitrate / 2, audioBitrate); // Don't exceed some % of level bitrate\n  }\n  function getVariantDecodingBitrate(level) {\n    return Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate) / 1000) * 1000 || 1;\n  }\n  function getMediaDecodingInfoKey(config) {\n    var key = '';\n    var audio = config.audio,\n      video = config.video;\n    if (video) {\n      var codec = getCodecsForMimeType(video.contentType);\n      key += codec + \"_r\" + video.height + \"x\" + video.width + \"f\" + Math.ceil(video.framerate) + (video.transferFunction || 'sd') + \"_\" + Math.ceil(video.bitrate / 1e5);\n    }\n    if (audio) {\n      var _codec = getCodecsForMimeType(audio.contentType);\n      key += \"\" + (video ? '_' : '') + _codec + \"_c\" + audio.channels;\n    }\n    return key;\n  }\n\n  var HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\n  function isHdcpLevel(value) {\n    return HdcpLevels.indexOf(value) > -1;\n  }\n  var VideoRangeValues = ['SDR', 'PQ', 'HLG'];\n  function isVideoRange(value) {\n    return !!value && VideoRangeValues.indexOf(value) > -1;\n  }\n  var HlsSkip = {\n    No: \"\",\n    Yes: \"YES\",\n    v2: \"v2\"\n  };\n  function getSkipValue(details) {\n    var canSkipUntil = details.canSkipUntil,\n      canSkipDateRanges = details.canSkipDateRanges,\n      age = details.age;\n    // A Client SHOULD NOT request a Playlist Delta Update unless it already\n    // has a version of the Playlist that is no older than one-half of the Skip Boundary.\n    // @see: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-6.3.7\n    var playlistRecentEnough = age < canSkipUntil / 2;\n    if (canSkipUntil && playlistRecentEnough) {\n      if (canSkipDateRanges) {\n        return HlsSkip.v2;\n      }\n      return HlsSkip.Yes;\n    }\n    return HlsSkip.No;\n  }\n  var HlsUrlParameters = /*#__PURE__*/function () {\n    function HlsUrlParameters(msn, part, skip) {\n      this.msn = void 0;\n      this.part = void 0;\n      this.skip = void 0;\n      this.msn = msn;\n      this.part = part;\n      this.skip = skip;\n    }\n    var _proto = HlsUrlParameters.prototype;\n    _proto.addDirectives = function addDirectives(uri) {\n      var url = new self.URL(uri);\n      if (this.msn !== undefined) {\n        url.searchParams.set('_HLS_msn', this.msn.toString());\n      }\n      if (this.part !== undefined) {\n        url.searchParams.set('_HLS_part', this.part.toString());\n      }\n      if (this.skip) {\n        url.searchParams.set('_HLS_skip', this.skip);\n      }\n      return url.href;\n    };\n    return HlsUrlParameters;\n  }();\n  var Level = /*#__PURE__*/function () {\n    function Level(data) {\n      this._attrs = void 0;\n      this.audioCodec = void 0;\n      this.bitrate = void 0;\n      this.codecSet = void 0;\n      this.url = void 0;\n      this.frameRate = void 0;\n      this.height = void 0;\n      this.id = void 0;\n      this.name = void 0;\n      this.supplemental = void 0;\n      this.videoCodec = void 0;\n      this.width = void 0;\n      this.details = void 0;\n      this.fragmentError = 0;\n      this.loadError = 0;\n      this.loaded = void 0;\n      this.realBitrate = 0;\n      this.supportedPromise = void 0;\n      this.supportedResult = void 0;\n      this._avgBitrate = 0;\n      this._audioGroups = void 0;\n      this._subtitleGroups = void 0;\n      // Deprecated (retained for backwards compatibility)\n      this._urlId = 0;\n      this.url = [data.url];\n      this._attrs = [data.attrs];\n      this.bitrate = data.bitrate;\n      if (data.details) {\n        this.details = data.details;\n      }\n      this.id = data.id || 0;\n      this.name = data.name;\n      this.width = data.width || 0;\n      this.height = data.height || 0;\n      this.frameRate = data.attrs.optionalFloat('FRAME-RATE', 0);\n      this._avgBitrate = data.attrs.decimalInteger('AVERAGE-BANDWIDTH');\n      this.audioCodec = data.audioCodec;\n      this.videoCodec = data.videoCodec;\n      this.codecSet = [data.videoCodec, data.audioCodec].filter(function (c) {\n        return !!c;\n      }).map(function (s) {\n        return s.substring(0, 4);\n      }).join(',');\n      if ('supplemental' in data) {\n        var _data$supplemental;\n        this.supplemental = data.supplemental;\n        var supplementalVideo = (_data$supplemental = data.supplemental) == null ? void 0 : _data$supplemental.videoCodec;\n        if (supplementalVideo && supplementalVideo !== data.videoCodec) {\n          this.codecSet += \",\" + supplementalVideo.substring(0, 4);\n        }\n      }\n      this.addGroupId('audio', data.attrs.AUDIO);\n      this.addGroupId('text', data.attrs.SUBTITLES);\n    }\n    var _proto2 = Level.prototype;\n    _proto2.hasAudioGroup = function hasAudioGroup(groupId) {\n      return hasGroup(this._audioGroups, groupId);\n    };\n    _proto2.hasSubtitleGroup = function hasSubtitleGroup(groupId) {\n      return hasGroup(this._subtitleGroups, groupId);\n    };\n    _proto2.addGroupId = function addGroupId(type, groupId) {\n      if (!groupId) {\n        return;\n      }\n      if (type === 'audio') {\n        var audioGroups = this._audioGroups;\n        if (!audioGroups) {\n          audioGroups = this._audioGroups = [];\n        }\n        if (audioGroups.indexOf(groupId) === -1) {\n          audioGroups.push(groupId);\n        }\n      } else if (type === 'text') {\n        var subtitleGroups = this._subtitleGroups;\n        if (!subtitleGroups) {\n          subtitleGroups = this._subtitleGroups = [];\n        }\n        if (subtitleGroups.indexOf(groupId) === -1) {\n          subtitleGroups.push(groupId);\n        }\n      }\n    }\n\n    // Deprecated methods (retained for backwards compatibility)\n    ;\n    _proto2.addFallback = function addFallback() {};\n    return _createClass(Level, [{\n      key: \"maxBitrate\",\n      get: function get() {\n        return Math.max(this.realBitrate, this.bitrate);\n      }\n    }, {\n      key: \"averageBitrate\",\n      get: function get() {\n        return this._avgBitrate || this.realBitrate || this.bitrate;\n      }\n    }, {\n      key: \"attrs\",\n      get: function get() {\n        return this._attrs[0];\n      }\n    }, {\n      key: \"codecs\",\n      get: function get() {\n        return this.attrs.CODECS || '';\n      }\n    }, {\n      key: \"pathwayId\",\n      get: function get() {\n        return this.attrs['PATHWAY-ID'] || '.';\n      }\n    }, {\n      key: \"videoRange\",\n      get: function get() {\n        return this.attrs['VIDEO-RANGE'] || 'SDR';\n      }\n    }, {\n      key: \"score\",\n      get: function get() {\n        return this.attrs.optionalFloat('SCORE', 0);\n      }\n    }, {\n      key: \"uri\",\n      get: function get() {\n        return this.url[0] || '';\n      }\n    }, {\n      key: \"audioGroups\",\n      get: function get() {\n        return this._audioGroups;\n      }\n    }, {\n      key: \"subtitleGroups\",\n      get: function get() {\n        return this._subtitleGroups;\n      }\n    }, {\n      key: \"urlId\",\n      get: function get() {\n        return 0;\n      },\n      set: function set(value) {}\n    }, {\n      key: \"audioGroupIds\",\n      get: function get() {\n        return this.audioGroups ? [this.audioGroupId] : undefined;\n      }\n    }, {\n      key: \"textGroupIds\",\n      get: function get() {\n        return this.subtitleGroups ? [this.textGroupId] : undefined;\n      }\n    }, {\n      key: \"audioGroupId\",\n      get: function get() {\n        var _this$audioGroups;\n        return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];\n      }\n    }, {\n      key: \"textGroupId\",\n      get: function get() {\n        var _this$subtitleGroups;\n        return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];\n      }\n    }]);\n  }();\n  function hasGroup(groups, groupId) {\n    if (!groupId || !groups) {\n      return false;\n    }\n    return groups.indexOf(groupId) !== -1;\n  }\n\n  /**\n   * @returns Whether we can detect and validate HDR capability within the window context\n   */\n  function isHdrSupported() {\n    if (typeof matchMedia === 'function') {\n      var mediaQueryList = matchMedia('(dynamic-range: high)');\n      var badQuery = matchMedia('bad query');\n      if (mediaQueryList.media !== badQuery.media) {\n        return mediaQueryList.matches === true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Sanitizes inputs to return the active video selection options for HDR/SDR.\n   * When both inputs are null:\n   *\n   *    `{ preferHDR: false, allowedVideoRanges: [] }`\n   *\n   * When `currentVideoRange` non-null, maintain the active range:\n   *\n   *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`\n   *\n   * When VideoSelectionOption non-null:\n   *\n   *  - Allow all video ranges if `allowedVideoRanges` unspecified.\n   *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.\n   *  - Else check window for HDR support and set `preferHDR` to the result.\n   *\n   * @param currentVideoRange\n   * @param videoPreference\n   */\n  function getVideoSelectionOptions(currentVideoRange, videoPreference) {\n    var preferHDR = false;\n    var allowedVideoRanges = [];\n    if (currentVideoRange) {\n      preferHDR = currentVideoRange !== 'SDR';\n      allowedVideoRanges = [currentVideoRange];\n    }\n    if (videoPreference) {\n      allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);\n      var allowAutoPreferHDR = allowedVideoRanges.join('') !== 'SDR' && !videoPreference.videoCodec;\n      preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : allowAutoPreferHDR && isHdrSupported();\n      if (!preferHDR) {\n        allowedVideoRanges = ['SDR'];\n      }\n    }\n    return {\n      preferHDR: preferHDR,\n      allowedVideoRanges: allowedVideoRanges\n    };\n  }\n\n  var omitCircularRefsReplacer = function omitCircularRefsReplacer(replacer) {\n    var known = new WeakSet();\n    return function (_, value) {\n      if (replacer) {\n        value = replacer(_, value);\n      }\n      if (typeof value === 'object' && value !== null) {\n        if (known.has(value)) {\n          return;\n        }\n        known.add(value);\n      }\n      return value;\n    };\n  };\n  var stringify = function stringify(object, replacer) {\n    return JSON.stringify(object, omitCircularRefsReplacer(replacer));\n  };\n\n  function getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {\n    var codecSets = Object.keys(codecTiers);\n    var channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n    var audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n    var videoCodecPreference = videoPreference == null ? void 0 : videoPreference.videoCodec;\n    var preferStereo = channelsPreference && parseInt(channelsPreference) === 2;\n    // Use first level set to determine stereo, and minimum resolution and framerate\n    var hasStereo = false;\n    var hasCurrentVideoRange = false;\n    var minHeight = Infinity;\n    var minFramerate = Infinity;\n    var minBitrate = Infinity;\n    var minIndex = Infinity;\n    var selectedScore = 0;\n    var videoRanges = [];\n    var _getVideoSelectionOpt = getVideoSelectionOptions(currentVideoRange, videoPreference),\n      preferHDR = _getVideoSelectionOpt.preferHDR,\n      allowedVideoRanges = _getVideoSelectionOpt.allowedVideoRanges;\n    var _loop = function _loop() {\n      var tier = codecTiers[codecSets[i]];\n      hasStereo || (hasStereo = tier.channels[2] > 0);\n      minHeight = Math.min(minHeight, tier.minHeight);\n      minFramerate = Math.min(minFramerate, tier.minFramerate);\n      minBitrate = Math.min(minBitrate, tier.minBitrate);\n      var matchingVideoRanges = allowedVideoRanges.filter(function (range) {\n        return tier.videoRanges[range] > 0;\n      });\n      if (matchingVideoRanges.length > 0) {\n        hasCurrentVideoRange = true;\n      }\n    };\n    for (var i = codecSets.length; i--;) {\n      _loop();\n    }\n    minHeight = isFiniteNumber(minHeight) ? minHeight : 0;\n    minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;\n    var maxHeight = Math.max(1080, minHeight);\n    var maxFramerate = Math.max(30, minFramerate);\n    minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;\n    currentBw = Math.max(minBitrate, currentBw);\n    // If there are no variants with matching preference, set currentVideoRange to undefined\n    if (!hasCurrentVideoRange) {\n      currentVideoRange = undefined;\n    }\n    var hasMultipleSets = codecSets.length > 1;\n    var codecSet = codecSets.reduce(function (selected, candidate) {\n      // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present\n      var candidateTier = codecTiers[candidate];\n      if (candidate === selected) {\n        return selected;\n      }\n      videoRanges = hasCurrentVideoRange ? allowedVideoRanges.filter(function (range) {\n        return candidateTier.videoRanges[range] > 0;\n      }) : [];\n      if (hasMultipleSets) {\n        if (candidateTier.minBitrate > currentBw) {\n          logStartCodecCandidateIgnored(candidate, \"min bitrate of \" + candidateTier.minBitrate + \" > current estimate of \" + currentBw);\n          return selected;\n        }\n        if (!candidateTier.hasDefaultAudio) {\n          logStartCodecCandidateIgnored(candidate, \"no renditions with default or auto-select sound found\");\n          return selected;\n        }\n        if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {\n          logStartCodecCandidateIgnored(candidate, \"audio codec preference \\\"\" + audioCodecPreference + \"\\\" not found\");\n          return selected;\n        }\n        if (channelsPreference && !preferStereo) {\n          if (!candidateTier.channels[channelsPreference]) {\n            logStartCodecCandidateIgnored(candidate, \"no renditions with \" + channelsPreference + \" channel sound found (channels options: \" + Object.keys(candidateTier.channels) + \")\");\n            return selected;\n          }\n        } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels['2'] === 0) {\n          logStartCodecCandidateIgnored(candidate, \"no renditions with stereo sound found\");\n          return selected;\n        }\n        if (candidateTier.minHeight > maxHeight) {\n          logStartCodecCandidateIgnored(candidate, \"min resolution of \" + candidateTier.minHeight + \" > maximum of \" + maxHeight);\n          return selected;\n        }\n        if (candidateTier.minFramerate > maxFramerate) {\n          logStartCodecCandidateIgnored(candidate, \"min framerate of \" + candidateTier.minFramerate + \" > maximum of \" + maxFramerate);\n          return selected;\n        }\n        if (!videoRanges.some(function (range) {\n          return candidateTier.videoRanges[range] > 0;\n        })) {\n          logStartCodecCandidateIgnored(candidate, \"no variants with VIDEO-RANGE of \" + stringify(videoRanges) + \" found\");\n          return selected;\n        }\n        if (videoCodecPreference && candidate.indexOf(videoCodecPreference.substring(0, 4)) % 5 !== 0) {\n          logStartCodecCandidateIgnored(candidate, \"video codec preference \\\"\" + videoCodecPreference + \"\\\" not found\");\n          return selected;\n        }\n        if (candidateTier.maxScore < selectedScore) {\n          logStartCodecCandidateIgnored(candidate, \"max score of \" + candidateTier.maxScore + \" < selected max of \" + selectedScore);\n          return selected;\n        }\n      }\n      // Remove candiates with less preferred codecs or more errors\n      if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {\n        return selected;\n      }\n      minIndex = candidateTier.minIndex;\n      selectedScore = candidateTier.maxScore;\n      return candidate;\n    }, undefined);\n    return {\n      codecSet: codecSet,\n      videoRanges: videoRanges,\n      preferHDR: preferHDR,\n      minFramerate: minFramerate,\n      minBitrate: minBitrate,\n      minIndex: minIndex\n    };\n  }\n  function logStartCodecCandidateIgnored(codeSet, reason) {\n    logger.log(\"[abr] start candidates with \\\"\" + codeSet + \"\\\" ignored because \" + reason);\n  }\n  function getAudioTracksByGroup(allAudioTracks) {\n    return allAudioTracks.reduce(function (audioTracksByGroup, track) {\n      var trackGroup = audioTracksByGroup.groups[track.groupId];\n      if (!trackGroup) {\n        trackGroup = audioTracksByGroup.groups[track.groupId] = {\n          tracks: [],\n          channels: {\n            2: 0\n          },\n          hasDefault: false,\n          hasAutoSelect: false\n        };\n      }\n      trackGroup.tracks.push(track);\n      var channelsKey = track.channels || '2';\n      trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;\n      trackGroup.hasDefault = trackGroup.hasDefault || track.default;\n      trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;\n      if (trackGroup.hasDefault) {\n        audioTracksByGroup.hasDefaultAudio = true;\n      }\n      if (trackGroup.hasAutoSelect) {\n        audioTracksByGroup.hasAutoSelectAudio = true;\n      }\n      return audioTracksByGroup;\n    }, {\n      hasDefaultAudio: false,\n      hasAutoSelectAudio: false,\n      groups: {}\n    });\n  }\n  function getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {\n    return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce(function (tiers, level, index) {\n      if (!level.codecSet) {\n        return tiers;\n      }\n      var audioGroups = level.audioGroups;\n      var tier = tiers[level.codecSet];\n      if (!tier) {\n        tiers[level.codecSet] = tier = {\n          minBitrate: Infinity,\n          minHeight: Infinity,\n          minFramerate: Infinity,\n          minIndex: index,\n          maxScore: 0,\n          videoRanges: {\n            SDR: 0\n          },\n          channels: {\n            '2': 0\n          },\n          hasDefaultAudio: !audioGroups,\n          fragmentError: 0\n        };\n      }\n      tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);\n      var lesserWidthOrHeight = Math.min(level.height, level.width);\n      tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);\n      tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);\n      tier.minIndex = Math.min(tier.minIndex, index);\n      tier.maxScore = Math.max(tier.maxScore, level.score);\n      tier.fragmentError += level.fragmentError;\n      tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;\n      if (audioGroups) {\n        audioGroups.forEach(function (audioGroupId) {\n          if (!audioGroupId) {\n            return;\n          }\n          var audioGroup = audioTracksByGroup.groups[audioGroupId];\n          if (!audioGroup) {\n            return;\n          }\n          // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants\n          tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;\n          Object.keys(audioGroup.channels).forEach(function (channels) {\n            tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];\n          });\n        });\n      }\n      return tiers;\n    }, {});\n  }\n  function getBasicSelectionOption(option) {\n    if (!option) {\n      return option;\n    }\n    var _ref = option,\n      lang = _ref.lang,\n      assocLang = _ref.assocLang,\n      characteristics = _ref.characteristics,\n      channels = _ref.channels,\n      audioCodec = _ref.audioCodec;\n    return {\n      lang: lang,\n      assocLang: assocLang,\n      characteristics: characteristics,\n      channels: channels,\n      audioCodec: audioCodec\n    };\n  }\n  function findMatchingOption(option, tracks, matchPredicate) {\n    if ('attrs' in option) {\n      var index = tracks.indexOf(option);\n      if (index !== -1) {\n        return index;\n      }\n    }\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n      if (matchesOption(option, track, matchPredicate)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function matchesOption(option, track, matchPredicate) {\n    var groupId = option.groupId,\n      name = option.name,\n      lang = option.lang,\n      assocLang = option.assocLang,\n      isDefault = option.default;\n    var forced = option.forced;\n    return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || languagesMatch(lang, track.lang)) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (!('characteristics' in option) || characteristicsMatch(option.characteristics || '', track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));\n  }\n  function languagesMatch(languageA, languageB) {\n    if (languageB === void 0) {\n      languageB = '--';\n    }\n    if (languageA.length === languageB.length) {\n      return languageA === languageB;\n    }\n    return languageA.startsWith(languageB) || languageB.startsWith(languageA);\n  }\n  function characteristicsMatch(characteristicsA, characteristicsB) {\n    if (characteristicsB === void 0) {\n      characteristicsB = '';\n    }\n    var arrA = characteristicsA.split(',');\n    var arrB = characteristicsB.split(',');\n    // Expects each item to be unique:\n    return arrA.length === arrB.length && !arrA.some(function (el) {\n      return arrB.indexOf(el) === -1;\n    });\n  }\n  function audioMatchPredicate(option, track) {\n    var audioCodec = option.audioCodec,\n      channels = option.channels;\n    return (audioCodec === undefined || (track.audioCodec || '').substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || '2'));\n  }\n  function findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {\n    var currentLevel = levels[searchIndex];\n    // Are there variants with same URI as current level?\n    // If so, find a match that does not require any level URI change\n    var variants = levels.reduce(function (variantMap, level, index) {\n      var uri = level.uri;\n      var renditions = variantMap[uri] || (variantMap[uri] = []);\n      renditions.push(index);\n      return variantMap;\n    }, {});\n    var renditions = variants[currentLevel.uri];\n    if (renditions.length > 1) {\n      searchIndex = Math.max.apply(Math, renditions);\n    }\n    // Find best match\n    var currentVideoRange = currentLevel.videoRange;\n    var currentFrameRate = currentLevel.frameRate;\n    var currentVideoCodec = currentLevel.codecSet.substring(0, 4);\n    var matchingVideo = searchDownAndUpList(levels, searchIndex, function (level) {\n      if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {\n        return false;\n      }\n      var audioGroups = level.audioGroups;\n      var tracks = allAudioTracks.filter(function (track) {\n        return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;\n      });\n      return findMatchingOption(option, tracks, matchPredicate) > -1;\n    });\n    if (matchingVideo > -1) {\n      return matchingVideo;\n    }\n    return searchDownAndUpList(levels, searchIndex, function (level) {\n      var audioGroups = level.audioGroups;\n      var tracks = allAudioTracks.filter(function (track) {\n        return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;\n      });\n      return findMatchingOption(option, tracks, matchPredicate) > -1;\n    });\n  }\n  function searchDownAndUpList(arr, searchIndex, predicate) {\n    for (var i = searchIndex; i > -1; i--) {\n      if (predicate(arr[i])) {\n        return i;\n      }\n    }\n    for (var _i = searchIndex + 1; _i < arr.length; _i++) {\n      if (predicate(arr[_i])) {\n        return _i;\n      }\n    }\n    return -1;\n  }\n  function useAlternateAudio(audioTrackUrl, hls) {\n    var _hls$loadLevelObj;\n    return !!audioTrackUrl && audioTrackUrl !== ((_hls$loadLevelObj = hls.loadLevelObj) == null ? void 0 : _hls$loadLevelObj.uri);\n  }\n\n  var AbrController = /*#__PURE__*/function (_Logger) {\n    function AbrController(_hls) {\n      var _this;\n      _this = _Logger.call(this, 'abr', _hls.logger) || this;\n      _this.hls = void 0;\n      _this.lastLevelLoadSec = 0;\n      _this.lastLoadedFragLevel = -1;\n      _this.firstSelection = -1;\n      _this._nextAutoLevel = -1;\n      _this.nextAutoLevelKey = '';\n      _this.audioTracksByGroup = null;\n      _this.codecTiers = null;\n      _this.timer = -1;\n      _this.fragCurrent = null;\n      _this.partCurrent = null;\n      _this.bitrateTestDelay = 0;\n      _this.rebufferNotice = -1;\n      _this.supportedCache = {};\n      _this.bwEstimator = void 0;\n      /*\n          This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n          quickly enough to prevent underbuffering\n        */\n      _this._abandonRulesCheck = function (levelLoaded) {\n        var _ref;\n        var _this2 = _this,\n          frag = _this2.fragCurrent,\n          part = _this2.partCurrent,\n          hls = _this2.hls;\n        var autoLevelEnabled = hls.autoLevelEnabled,\n          media = hls.media;\n        if (!frag || !media) {\n          return;\n        }\n        var now = performance.now();\n        var stats = part ? part.stats : frag.stats;\n        var duration = part ? part.duration : frag.duration;\n        var timeLoading = now - stats.loading.start;\n        var minAutoLevel = hls.minAutoLevel;\n        var loadingFragForLevel = frag.level;\n        var currentAutoLevel = _this._nextAutoLevel;\n        // If frag loading is aborted, complete, or from lowest level, stop timer and return\n        if (stats.aborted || stats.loaded && stats.loaded === stats.total || loadingFragForLevel <= minAutoLevel) {\n          _this.clearTimer();\n          // reset forced auto level value so that next level will be selected\n          _this._nextAutoLevel = -1;\n          return;\n        }\n\n        // This check only runs if we're in ABR mode\n        if (!autoLevelEnabled) {\n          return;\n        }\n\n        // Must be loading/loaded a new level or be in a playing state\n        var fragBlockingSwitch = currentAutoLevel > -1 && currentAutoLevel !== loadingFragForLevel;\n        var levelChange = !!levelLoaded || fragBlockingSwitch;\n        if (!levelChange && (media.paused || !media.playbackRate || !media.readyState)) {\n          return;\n        }\n        var bufferInfo = hls.mainForwardBufferInfo;\n        if (!levelChange && bufferInfo === null) {\n          return;\n        }\n        var ttfbEstimate = _this.bwEstimator.getEstimateTTFB();\n        var playbackRate = Math.abs(media.playbackRate);\n        // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n        if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n          return;\n        }\n\n        // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n        var bufferStarvationDelay = bufferInfo ? bufferInfo.len / playbackRate : 0;\n        var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n        var loadedFirstByte = stats.loaded && ttfb > -1;\n        var bwEstimate = _this.getBwEstimate();\n        var levels = hls.levels;\n        var level = levels[loadingFragForLevel];\n        var expectedLen = Math.max(stats.loaded, Math.round(duration * (frag.bitrate || level.averageBitrate) / 8));\n        var timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;\n        if (timeStreaming < 1 && loadedFirstByte) {\n          timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n        }\n        var loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n        // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n        var ttfbSeconds = ttfbEstimate / 1000;\n        var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbSeconds;\n        // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n        if (fragLoadedDelay <= bufferStarvationDelay) {\n          return;\n        }\n        var bwe = loadRate ? loadRate * 8 : bwEstimate;\n        var live = ((_ref = (levelLoaded == null ? void 0 : levelLoaded.details) || _this.hls.latestLevelDetails) == null ? void 0 : _ref.live) === true;\n        var abrBandWidthUpFactor = _this.hls.config.abrBandWidthUpFactor;\n        var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n        var nextLoadLevel;\n        // Iterate through lower level and try to find the largest one that avoids rebuffering\n        for (nextLoadLevel = loadingFragForLevel - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n          // compute time to load next fragment at lower level\n          // 8 = bits per byte (bps/Bps)\n          var levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n          var requiresLevelLoad = !levels[nextLoadLevel].details || live;\n          fragLevelNextLoadedDelay = _this.getTimeToLoadFrag(ttfbSeconds, bwe, duration * levelNextBitrate, requiresLevelLoad);\n          if (fragLevelNextLoadedDelay < Math.min(bufferStarvationDelay, duration + ttfbSeconds)) {\n            break;\n          }\n        }\n        // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n        // to load the current one\n        if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n          return;\n        }\n\n        // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n        if (fragLevelNextLoadedDelay > duration * 10) {\n          return;\n        }\n        if (loadedFirstByte) {\n          // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n          _this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n        } else {\n          // If there has been no loading progress, sample TTFB\n          _this.bwEstimator.sampleTTFB(timeLoading);\n        }\n        var nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;\n        if (_this.getBwEstimate() * abrBandWidthUpFactor > nextLoadLevelBitrate) {\n          _this.resetEstimator(nextLoadLevelBitrate);\n        }\n        var bestSwitchLevel = _this.findBestLevel(nextLoadLevelBitrate, minAutoLevel, nextLoadLevel, 0, bufferStarvationDelay, 1, 1);\n        if (bestSwitchLevel > -1) {\n          nextLoadLevel = bestSwitchLevel;\n        }\n        _this.warn(\"Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + loadingFragForLevel + \" is loading too slowly;\\n      Fragment duration: \" + frag.duration.toFixed(3) + \"\\n      Time to underbuffer: \" + bufferStarvationDelay.toFixed(3) + \" s\\n      Estimated load time for current fragment: \" + fragLoadedDelay.toFixed(3) + \" s\\n      Estimated load time for down switch fragment: \" + fragLevelNextLoadedDelay.toFixed(3) + \" s\\n      TTFB estimate: \" + (ttfb | 0) + \" ms\\n      Current BW estimate: \" + (isFiniteNumber(bwEstimate) ? bwEstimate | 0 : 'Unknown') + \" bps\\n      New BW estimate: \" + (_this.getBwEstimate() | 0) + \" bps\\n      Switching to level \" + nextLoadLevel + \" @ \" + (nextLoadLevelBitrate | 0) + \" bps\");\n        hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;\n        _this.clearTimer();\n        var abortAndSwitch = function abortAndSwitch() {\n          // Are nextLoadLevel details available or is stream-controller still in \"WAITING_LEVEL\" state?\n          _this.clearTimer();\n          if (_this.fragCurrent === frag && _this.hls.loadLevel === nextLoadLevel && nextLoadLevel > 0) {\n            var _bufferStarvationDelay = _this.getStarvationDelay();\n            _this.warn(\"Aborting inflight request \" + (nextLoadLevel > 0 ? 'and switching down' : '') + \"\\n      Fragment duration: \" + frag.duration.toFixed(3) + \" s\\n      Time to underbuffer: \" + _bufferStarvationDelay.toFixed(3) + \" s\");\n            frag.abortRequests();\n            _this.fragCurrent = _this.partCurrent = null;\n            if (nextLoadLevel > minAutoLevel) {\n              var lowestSwitchLevel = _this.findBestLevel(_this.hls.levels[minAutoLevel].bitrate, minAutoLevel, nextLoadLevel, 0, _bufferStarvationDelay, 1, 1);\n              if (lowestSwitchLevel === -1) {\n                lowestSwitchLevel = minAutoLevel;\n              }\n              _this.hls.nextLoadLevel = _this.hls.nextAutoLevel = lowestSwitchLevel;\n              _this.resetEstimator(_this.hls.levels[lowestSwitchLevel].bitrate);\n            }\n          }\n        };\n        if (fragBlockingSwitch || fragLoadedDelay > fragLevelNextLoadedDelay * 2) {\n          abortAndSwitch();\n        } else {\n          _this.timer = self.setInterval(abortAndSwitch, fragLevelNextLoadedDelay * 1000);\n        }\n        hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n          frag: frag,\n          part: part,\n          stats: stats\n        });\n      };\n      _this.hls = _hls;\n      _this.bwEstimator = _this.initEstimator();\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(AbrController, _Logger);\n    var _proto = AbrController.prototype;\n    _proto.resetEstimator = function resetEstimator(abrEwmaDefaultEstimate) {\n      if (abrEwmaDefaultEstimate) {\n        this.log(\"setting initial bwe to \" + abrEwmaDefaultEstimate);\n        this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;\n      }\n      this.firstSelection = -1;\n      this.bwEstimator = this.initEstimator();\n    };\n    _proto.initEstimator = function initEstimator() {\n      var config = this.hls.config;\n      return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.clearTimer();\n      // @ts-ignore\n      this.hls = this._abandonRulesCheck = this.supportedCache = null;\n      this.fragCurrent = this.partCurrent = null;\n    };\n    _proto.onManifestLoading = function onManifestLoading(event, data) {\n      this.lastLoadedFragLevel = -1;\n      this.firstSelection = -1;\n      this.lastLevelLoadSec = 0;\n      this.supportedCache = {};\n      this.fragCurrent = this.partCurrent = null;\n      this.onLevelsUpdated();\n      this.clearTimer();\n    };\n    _proto.onLevelsUpdated = function onLevelsUpdated() {\n      if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {\n        this.lastLoadedFragLevel = this.fragCurrent.level;\n      }\n      this._nextAutoLevel = -1;\n      this.onMaxAutoLevelUpdated();\n      this.codecTiers = null;\n      this.audioTracksByGroup = null;\n    };\n    _proto.onMaxAutoLevelUpdated = function onMaxAutoLevelUpdated() {\n      this.firstSelection = -1;\n      this.nextAutoLevelKey = '';\n    };\n    _proto.onFragLoading = function onFragLoading(event, data) {\n      var frag = data.frag;\n      if (this.ignoreFragment(frag)) {\n        return;\n      }\n      if (!frag.bitrateTest) {\n        var _data$part;\n        this.fragCurrent = frag;\n        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n      }\n      this.clearTimer();\n      this.timer = self.setInterval(this._abandonRulesCheck, 100);\n    };\n    _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n      this.clearTimer();\n    };\n    _proto.onError = function onError(event, data) {\n      if (data.fatal) {\n        return;\n      }\n      switch (data.details) {\n        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n        case ErrorDetails.BUFFER_APPEND_ERROR:\n          // Reset last loaded level so that a new selection can be made after calling recoverMediaError\n          this.lastLoadedFragLevel = -1;\n          this.firstSelection = -1;\n          break;\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n          {\n            var frag = data.frag;\n            var fragCurrent = this.fragCurrent,\n              part = this.partCurrent;\n            if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {\n              var now = performance.now();\n              var stats = part ? part.stats : frag.stats;\n              var timeLoading = now - stats.loading.start;\n              var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n              var loadedFirstByte = stats.loaded && ttfb > -1;\n              if (loadedFirstByte) {\n                var ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n                this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n              } else {\n                this.bwEstimator.sampleTTFB(timeLoading);\n              }\n            }\n            break;\n          }\n      }\n    };\n    _proto.getTimeToLoadFrag = function getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n      var fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n      var playlistLoadSec = isSwitch ? timeToFirstByteSec + this.lastLevelLoadSec : 0;\n      return fragLoadSec + playlistLoadSec;\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      var config = this.hls.config;\n      var loading = data.stats.loading;\n      var timeLoadingMs = loading.end - loading.first;\n      if (isFiniteNumber(timeLoadingMs)) {\n        this.lastLevelLoadSec = timeLoadingMs / 1000;\n      }\n      if (data.details.live) {\n        this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n      } else {\n        this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n      }\n      if (this.timer > -1) {\n        this._abandonRulesCheck(data.levelInfo);\n      }\n    };\n    _proto.onFragLoaded = function onFragLoaded(event, _ref2) {\n      var frag = _ref2.frag,\n        part = _ref2.part;\n      var stats = part ? part.stats : frag.stats;\n      if (frag.type === PlaylistLevelType.MAIN) {\n        this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n      }\n      if (this.ignoreFragment(frag)) {\n        return;\n      }\n      // stop monitoring bw once frag loaded\n      this.clearTimer();\n      // reset forced auto level value so that next level will be selected\n      if (frag.level === this._nextAutoLevel) {\n        this._nextAutoLevel = -1;\n      }\n      this.firstSelection = -1;\n\n      // compute level average bitrate\n      if (this.hls.config.abrMaxWithRealBitrate) {\n        var duration = part ? part.duration : frag.duration;\n        var level = this.hls.levels[frag.level];\n        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n        level.loaded = {\n          bytes: loadedBytes,\n          duration: loadedDuration\n        };\n        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n      }\n      if (frag.bitrateTest) {\n        var fragBufferedData = {\n          stats: stats,\n          frag: frag,\n          part: part,\n          id: frag.type\n        };\n        this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n        frag.bitrateTest = false;\n      } else {\n        // store level id after successful fragment load for playback\n        this.lastLoadedFragLevel = frag.level;\n      }\n    };\n    _proto.onFragBuffered = function onFragBuffered(event, data) {\n      var frag = data.frag,\n        part = data.part;\n      var stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n      if (stats.aborted) {\n        return;\n      }\n      if (this.ignoreFragment(frag)) {\n        return;\n      }\n      // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n      // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n      // is used. If we used buffering in that case, our BW estimate sample will be very large.\n      var processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n      this.bwEstimator.sample(processingMs, stats.loaded);\n      stats.bwEstimate = this.getBwEstimate();\n      if (frag.bitrateTest) {\n        this.bitrateTestDelay = processingMs / 1000;\n      } else {\n        this.bitrateTestDelay = 0;\n      }\n    };\n    _proto.ignoreFragment = function ignoreFragment(frag) {\n      // Only count non-alt-audio frags which were actually buffered in our BW calculations\n      return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n    };\n    _proto.clearTimer = function clearTimer() {\n      if (this.timer > -1) {\n        self.clearInterval(this.timer);\n        this.timer = -1;\n      }\n    };\n    _proto.getAutoLevelKey = function getAutoLevelKey() {\n      return this.getBwEstimate() + \"_\" + this.getStarvationDelay().toFixed(2);\n    };\n    _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {\n      var fragCurrent = this.fragCurrent,\n        partCurrent = this.partCurrent,\n        hls = this.hls;\n      if (hls.levels.length <= 1) {\n        return hls.loadLevel;\n      }\n      var maxAutoLevel = hls.maxAutoLevel,\n        config = hls.config,\n        minAutoLevel = hls.minAutoLevel;\n      var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n      var avgbw = this.getBwEstimate();\n      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n      var bufferStarvationDelay = this.getStarvationDelay();\n      var bwFactor = config.abrBandWidthFactor;\n      var bwUpFactor = config.abrBandWidthUpFactor;\n\n      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n      if (bufferStarvationDelay) {\n        var _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);\n        if (_bestLevel >= 0) {\n          this.rebufferNotice = -1;\n          return _bestLevel;\n        }\n      }\n      // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering\n      var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n      if (!bufferStarvationDelay) {\n        // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n        var bitrateTestDelay = this.bitrateTestDelay;\n        if (bitrateTestDelay) {\n          // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n          // max video loading delay used in  automatic start level selection :\n          // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n          // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n          // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n          var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n          maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n          this.info(\"bitrate test took \" + Math.round(1000 * bitrateTestDelay) + \"ms, set first fragment max fetchDuration to \" + Math.round(1000 * maxStarvationDelay) + \" ms\");\n          // don't use conservative factor on bitrate test\n          bwFactor = bwUpFactor = 1;\n        }\n      }\n      var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);\n      if (this.rebufferNotice !== bestLevel) {\n        this.rebufferNotice = bestLevel;\n        this.info((bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty') + \", optimal quality level \" + bestLevel);\n      }\n      if (bestLevel > -1) {\n        return bestLevel;\n      }\n      // If no matching level found, see if min auto level would be a better option\n      var minLevel = hls.levels[minAutoLevel];\n      var autoLevel = hls.loadLevelObj;\n      if (autoLevel && (minLevel == null ? void 0 : minLevel.bitrate) < autoLevel.bitrate) {\n        return minAutoLevel;\n      }\n      // or if bitrate is not lower, continue to use loadLevel\n      return hls.loadLevel;\n    };\n    _proto.getStarvationDelay = function getStarvationDelay() {\n      var hls = this.hls;\n      var media = hls.media;\n      if (!media) {\n        return Infinity;\n      }\n      // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n      // if we're playing back at the normal rate.\n      var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n      var bufferInfo = hls.mainForwardBufferInfo;\n      return (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n    };\n    _proto.getBwEstimate = function getBwEstimate() {\n      return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n    };\n    _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {\n      var _this$hls$latestLevel,\n        _this3 = this;\n      var maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;\n      var lastLoadedFragLevel = this.lastLoadedFragLevel;\n      var selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;\n      var fragCurrent = this.fragCurrent,\n        partCurrent = this.partCurrent;\n      var _this$hls = this.hls,\n        levels = _this$hls.levels,\n        allAudioTracks = _this$hls.allAudioTracks,\n        loadLevel = _this$hls.loadLevel,\n        config = _this$hls.config;\n      if (levels.length === 1) {\n        return 0;\n      }\n      var level = levels[selectionBaseLevel];\n      var live = !!((_this$hls$latestLevel = this.hls.latestLevelDetails) != null && _this$hls$latestLevel.live);\n      var firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;\n      var currentCodecSet;\n      var currentVideoRange = 'SDR';\n      var currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;\n      var audioPreference = config.audioPreference,\n        videoPreference = config.videoPreference;\n      var audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));\n      var minStartIndex = -1;\n      if (firstSelection) {\n        if (this.firstSelection !== -1) {\n          return this.firstSelection;\n        }\n        var codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));\n        var startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);\n        var codecSet = startTier.codecSet,\n          videoRanges = startTier.videoRanges,\n          minFramerate = startTier.minFramerate,\n          minBitrate = startTier.minBitrate,\n          minIndex = startTier.minIndex,\n          preferHDR = startTier.preferHDR;\n        minStartIndex = minIndex;\n        currentCodecSet = codecSet;\n        currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];\n        currentFrameRate = minFramerate;\n        currentBw = Math.max(currentBw, minBitrate);\n        this.log(\"picked start tier \" + stringify(startTier));\n      } else {\n        currentCodecSet = level == null ? void 0 : level.codecSet;\n        currentVideoRange = level == null ? void 0 : level.videoRange;\n      }\n      var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n      var ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n      var levelsSkipped = [];\n      var _loop = function _loop() {\n          var _levelInfo$supportedR;\n          var levelInfo = levels[i];\n          var upSwitch = i > selectionBaseLevel;\n          if (!levelInfo) {\n            return 0; // continue\n          }\n          if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {\n            var mediaCapabilities = navigator.mediaCapabilities;\n            if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === 'function' && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {\n              levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities, _this3.supportedCache);\n              levelInfo.supportedPromise.then(function (decodingInfo) {\n                if (!_this3.hls) {\n                  return;\n                }\n                levelInfo.supportedResult = decodingInfo;\n                var levels = _this3.hls.levels;\n                var index = levels.indexOf(levelInfo);\n                if (decodingInfo.error) {\n                  _this3.warn(\"MediaCapabilities decodingInfo error: \\\"\" + decodingInfo.error + \"\\\" for level \" + index + \" \" + stringify(decodingInfo));\n                } else if (!decodingInfo.supported) {\n                  _this3.warn(\"Unsupported MediaCapabilities decodingInfo result for level \" + index + \" \" + stringify(decodingInfo));\n                  if (index > -1 && levels.length > 1) {\n                    _this3.log(\"Removing unsupported level \" + index);\n                    _this3.hls.removeLevel(index);\n                    if (_this3.hls.loadLevel === -1) {\n                      _this3.hls.nextLoadLevel = 0;\n                    }\n                  }\n                } else if (decodingInfo.decodingInfoResults.some(function (info) {\n                  return info.smooth === false || info.powerEfficient === false;\n                })) {\n                  _this3.log(\"MediaCapabilities decodingInfo for level \" + index + \" not smooth or powerEfficient: \" + stringify(decodingInfo));\n                }\n              }).catch(function (error) {\n                _this3.warn(\"Error handling MediaCapabilities decodingInfo: \" + error);\n              });\n            } else {\n              levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;\n            }\n          }\n\n          // skip candidates which change codec-family or video-range,\n          // and which decrease or increase frame-rate for up and down-switch respectfully\n          if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || (_levelInfo$supportedR = levelInfo.supportedResult) != null && (_levelInfo$supportedR = _levelInfo$supportedR.decodingInfoResults) != null && _levelInfo$supportedR.some(function (info) {\n            return info.smooth === false;\n          })) {\n            if (!firstSelection || i !== minStartIndex) {\n              levelsSkipped.push(i);\n              return 0; // continue\n            }\n          }\n          var levelDetails = levelInfo.details;\n          var avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n          var adjustedbw;\n          // follow algorithm captured from stagefright :\n          // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n          // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n          // consider only 80% of the available bandwidth, but if we are switching up,\n          // be even more conservative (70%) to avoid overestimating and immediately\n          // switching back.\n          if (!upSwitch) {\n            adjustedbw = bwFactor * currentBw;\n          } else {\n            adjustedbw = bwUpFactor * currentBw;\n          }\n\n          // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)\n          var bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levelInfo.averageBitrate : levelInfo.maxBitrate;\n          var fetchDuration = _this3.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n          var canSwitchWithinTolerance =\n          // if adjusted bw is greater than level bitrate AND\n          adjustedbw >= bitrate && (\n          // no level change, or new level has no error history\n          i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (\n          // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n          // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n          // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n          fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !_this3.bitrateTestDelay || fetchDuration < maxFetchDuration);\n          if (canSwitchWithinTolerance) {\n            var forcedAutoLevel = _this3.forcedAutoLevel;\n            if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {\n              if (levelsSkipped.length) {\n                _this3.trace(\"Skipped level(s) \" + levelsSkipped.join(',') + \" of \" + maxAutoLevel + \" max with CODECS and VIDEO-RANGE:\\\"\" + levels[levelsSkipped[0]].codecs + \"\\\" \" + levels[levelsSkipped[0]].videoRange + \"; not compatible with \\\"\" + currentCodecSet + \"\\\" \" + currentVideoRange);\n              }\n              _this3.info(\"switch candidate:\" + selectionBaseLevel + \"->\" + i + \" adjustedbw(\" + Math.round(adjustedbw) + \")-bitrate=\" + Math.round(adjustedbw - bitrate) + \" ttfb:\" + ttfbEstimateSec.toFixed(1) + \" avgDuration:\" + avgDuration.toFixed(1) + \" maxFetchDuration:\" + maxFetchDuration.toFixed(1) + \" fetchDuration:\" + fetchDuration.toFixed(1) + \" firstSelection:\" + firstSelection + \" codecSet:\" + levelInfo.codecSet + \" videoRange:\" + levelInfo.videoRange + \" hls.loadLevel:\" + loadLevel);\n            }\n            if (firstSelection) {\n              _this3.firstSelection = i;\n            }\n            // as we are looping from highest to lowest, this will return the best achievable quality level\n            return {\n              v: i\n            };\n          }\n        },\n        _ret;\n      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {\n        _ret = _loop();\n        if (_ret === 0) continue;\n        if (_ret) return _ret.v;\n      }\n      // not enough time budget even with quality level 0 ... rebuffering might happen\n      return -1;\n    };\n    _proto.deriveNextAutoLevel = function deriveNextAutoLevel(nextLevel) {\n      var _this$hls2 = this.hls,\n        maxAutoLevel = _this$hls2.maxAutoLevel,\n        minAutoLevel = _this$hls2.minAutoLevel;\n      return Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);\n    };\n    return _createClass(AbrController, [{\n      key: \"firstAutoLevel\",\n      get: function get() {\n        var _this$hls3 = this.hls,\n          maxAutoLevel = _this$hls3.maxAutoLevel,\n          minAutoLevel = _this$hls3.minAutoLevel;\n        var bwEstimate = this.getBwEstimate();\n        var maxStartDelay = this.hls.config.maxStarvationDelay;\n        var abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);\n        if (abrAutoLevel > -1) {\n          return abrAutoLevel;\n        }\n        var firstLevel = this.hls.firstLevel;\n        var clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);\n        this.warn(\"Could not find best starting auto level. Defaulting to first in playlist \" + firstLevel + \" clamped to \" + clamped);\n        return clamped;\n      }\n    }, {\n      key: \"forcedAutoLevel\",\n      get: function get() {\n        if (this.nextAutoLevelKey) {\n          return -1;\n        }\n        return this._nextAutoLevel;\n      }\n\n      // return next auto level\n    }, {\n      key: \"nextAutoLevel\",\n      get: function get() {\n        var forcedAutoLevel = this.forcedAutoLevel;\n        var bwEstimator = this.bwEstimator;\n        var useEstimate = bwEstimator.canEstimate();\n        var loadedFirstFrag = this.lastLoadedFragLevel > -1;\n        // in case next auto level has been forced, and bw not available or not reliable, return forced value\n        if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {\n          return forcedAutoLevel;\n        }\n\n        // compute next level using ABR logic\n        var nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n\n        // use forced auto level while it hasn't errored more than ABR selection\n        if (forcedAutoLevel !== -1) {\n          var levels = this.hls.levels;\n          if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n            return forcedAutoLevel;\n          }\n        }\n\n        // save result until state has changed\n        this._nextAutoLevel = nextABRAutoLevel;\n        this.nextAutoLevelKey = this.getAutoLevelKey();\n        return nextABRAutoLevel;\n      },\n      set: function set(nextLevel) {\n        var value = this.deriveNextAutoLevel(nextLevel);\n        if (this._nextAutoLevel !== value) {\n          this.nextAutoLevelKey = '';\n          this._nextAutoLevel = value;\n        }\n      }\n    }]);\n  }(Logger);\n\n  var BinarySearch = {\n    /**\n     * Searches for an item in an array which matches a certain condition.\n     * This requires the condition to only match one item in the array,\n     * and for the array to be ordered.\n     *\n     * @param list The array to search.\n     * @param comparisonFn\n     *      Called and provided a candidate item as the first argument.\n     *      Should return:\n     *          > -1 if the item should be located at a lower index than the provided item.\n     *          > 1 if the item should be located at a higher index than the provided item.\n     *          > 0 if the item is the item you're looking for.\n     *\n     * @returns the object if found, otherwise returns null\n     */\n    search: function search(list, comparisonFn) {\n      var minIndex = 0;\n      var maxIndex = list.length - 1;\n      var currentIndex = null;\n      var currentElement = null;\n      while (minIndex <= maxIndex) {\n        currentIndex = (minIndex + maxIndex) / 2 | 0;\n        currentElement = list[currentIndex];\n        var comparisonResult = comparisonFn(currentElement);\n        if (comparisonResult > 0) {\n          minIndex = currentIndex + 1;\n        } else if (comparisonResult < 0) {\n          maxIndex = currentIndex - 1;\n        } else {\n          return currentElement;\n        }\n      }\n      return null;\n    }\n  };\n\n  /**\n   * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n   * @param fragments - The array of candidate fragments\n   * @param PDTValue - The PDT value which must be exceeded\n   * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n   */\n  function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n    if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n      return null;\n    }\n\n    // if less than start\n    var startPDT = fragments[0].programDateTime;\n    if (PDTValue < (startPDT || 0)) {\n      return null;\n    }\n    var endPDT = fragments[fragments.length - 1].endProgramDateTime;\n    if (PDTValue >= (endPDT || 0)) {\n      return null;\n    }\n    for (var seg = 0; seg < fragments.length; ++seg) {\n      var frag = fragments[seg];\n      if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n        return frag;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n   * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n   * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n   * @param fragPrevious - The last frag successfully appended\n   * @param fragments - The array of candidate fragments\n   * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n   * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n   * @returns a matching fragment or null\n   */\n  function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance, nextFragLookupTolerance) {\n    if (bufferEnd === void 0) {\n      bufferEnd = 0;\n    }\n    if (maxFragLookUpTolerance === void 0) {\n      maxFragLookUpTolerance = 0;\n    }\n    if (nextFragLookupTolerance === void 0) {\n      nextFragLookupTolerance = 0.005;\n    }\n    var fragNext = null;\n    if (fragPrevious) {\n      fragNext = fragments[1 + fragPrevious.sn - fragments[0].sn] || null;\n      // check for buffer-end rounding error\n      var bufferEdgeError = fragPrevious.endDTS - bufferEnd;\n      if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {\n        bufferEnd += 0.0000015;\n      }\n      if (fragNext && fragPrevious.level !== fragNext.level && fragNext.end <= fragPrevious.end) {\n        fragNext = fragments[2 + fragPrevious.sn - fragments[0].sn] || null;\n      }\n    } else if (bufferEnd === 0 && fragments[0].start === 0) {\n      fragNext = fragments[0];\n    }\n    // Prefer the next fragment if it's within tolerance\n    if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {\n      return fragNext;\n    }\n    // We might be seeking past the tolerance so find the best match\n    var foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n    if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n      return foundFragment;\n    }\n    // If no match was found return the next fragment after fragPrevious, or null\n    return fragNext;\n  }\n  function fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {\n    if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {\n      var firstDuration = fragPrevious.tagList.reduce(function (duration, tag) {\n        if (tag[0] === 'INF') {\n          duration += parseFloat(tag[1]);\n        }\n        return duration;\n      }, nextFragLookupTolerance);\n      return fragNext.start <= firstDuration;\n    }\n    return false;\n  }\n\n  /**\n   * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n   * @param candidate - The fragment to test\n   * @param bufferEnd - The end of the current buffered range the playhead is currently within\n   * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n   * @returns 0 if it matches, 1 if too low, -1 if too high\n   */\n  function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {\n    if (bufferEnd === void 0) {\n      bufferEnd = 0;\n    }\n    if (maxFragLookUpTolerance === void 0) {\n      maxFragLookUpTolerance = 0;\n    }\n    // eagerly accept an accurate match (no tolerance)\n    if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n      return 0;\n    }\n    // offset should be within fragment boundary - config.maxFragLookUpTolerance\n    // this is to cope with situations like\n    // bufferEnd = 9.991\n    // frag[] : [0,10]\n    // frag[1] : [10,20]\n    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n    //              frag start               frag start+duration\n    //                  |-----------------------------|\n    //              <--->                         <--->\n    //  ...--------><-----------------------------><---------....\n    // previous frag         matching fragment         next frag\n    //  return -1             return 0                 return 1\n    // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n      return 1;\n    } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n      // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n   * This function tests the candidate's program date time values, as represented in Unix time\n   * @param candidate - The fragment to test\n   * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n   * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n   * @returns true if contiguous, false otherwise\n   */\n  function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n    // endProgramDateTime can be null, default to zero\n    var endProgramDateTime = candidate.endProgramDateTime || 0;\n    return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n  }\n  function findNearestWithCC(details, cc, pos) {\n    if (details) {\n      if (details.startCC <= cc && details.endCC >= cc) {\n        var fragments = details.fragments;\n        var fragmentHint = details.fragmentHint;\n        if (fragmentHint) {\n          fragments = fragments.concat(fragmentHint);\n        }\n        var closest;\n        BinarySearch.search(fragments, function (candidate) {\n          if (candidate.cc < cc) {\n            return 1;\n          }\n          if (candidate.cc > cc) {\n            return -1;\n          }\n          closest = candidate;\n          if (candidate.end <= pos) {\n            return 1;\n          }\n          if (candidate.start > pos) {\n            return -1;\n          }\n          return 0;\n        });\n        return closest || null;\n      }\n    }\n    return null;\n  }\n\n  function isTimeoutError(error) {\n    switch (error.details) {\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n      case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n        return true;\n    }\n    return false;\n  }\n  function isKeyError(error) {\n    return error.details.startsWith('key');\n  }\n  function isUnusableKeyError(error) {\n    return isKeyError(error) && !!error.frag && !error.frag.decryptdata;\n  }\n  function getRetryConfig(loadPolicy, error) {\n    var isTimeout = isTimeoutError(error);\n    return loadPolicy.default[(isTimeout ? 'timeout' : 'error') + \"Retry\"];\n  }\n  function getRetryDelay(retryConfig, retryCount) {\n    // exponential backoff capped to max retry delay\n    var backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n    return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n  }\n  function getLoaderConfigWithoutReties(loderConfig) {\n    return _objectSpread2(_objectSpread2({}, loderConfig), {\n      errorRetry: null,\n      timeoutRetry: null\n    });\n  }\n  function shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {\n    if (!retryConfig) {\n      return false;\n    }\n    var httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;\n    var retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n    return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;\n  }\n  function retryForHttpStatus(httpStatus) {\n    // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n    return offlineHttpStatus(httpStatus) || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n  }\n  function offlineHttpStatus(httpStatus) {\n    return httpStatus === 0 && navigator.onLine === false;\n  }\n\n  var NetworkErrorAction = {\n    DoNothing: 0,\n    SendAlternateToPenaltyBox: 2,\n    RemoveAlternatePermanently: 3,\n    RetryRequest: 5\n  };\n  var ErrorActionFlags = {\n    None: 0,\n    MoveAllAlternatesMatchingHost: 1,\n    MoveAllAlternatesMatchingHDCP: 2,\n    MoveAllAlternatesMatchingKey: 4};\n  var ErrorController = /*#__PURE__*/function (_Logger) {\n    function ErrorController(hls) {\n      var _this;\n      _this = _Logger.call(this, 'error-controller', hls.logger) || this;\n      _this.hls = void 0;\n      _this.playlistError = 0;\n      _this.hls = hls;\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(ErrorController, _Logger);\n    var _proto = ErrorController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.ERROR, this.onError, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      hls.off(Events.ERROR, this.onError, this);\n      hls.off(Events.ERROR, this.onErrorOut, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      // @ts-ignore\n      this.hls = null;\n    };\n    _proto.startLoad = function startLoad(startPosition) {};\n    _proto.stopLoad = function stopLoad() {\n      this.playlistError = 0;\n    };\n    _proto.getVariantLevelIndex = function getVariantLevelIndex(frag) {\n      if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN) {\n        return frag.level;\n      }\n      return this.getVariantIndex();\n    };\n    _proto.getVariantIndex = function getVariantIndex() {\n      var _hls$loadLevelObj;\n      var hls = this.hls;\n      var currentLevel = hls.currentLevel;\n      if ((_hls$loadLevelObj = hls.loadLevelObj) != null && _hls$loadLevelObj.details || currentLevel === -1) {\n        return hls.loadLevel;\n      }\n      return currentLevel;\n    };\n    _proto.variantHasKey = function variantHasKey(level, keyInError) {\n      if (level) {\n        var _level$details;\n        if ((_level$details = level.details) != null && _level$details.hasKey(keyInError)) {\n          return true;\n        }\n        var audioGroupsIds = level.audioGroups;\n        if (audioGroupsIds) {\n          var audioTracks = this.hls.allAudioTracks.filter(function (track) {\n            return audioGroupsIds.indexOf(track.groupId) >= 0;\n          });\n          return audioTracks.some(function (track) {\n            var _track$details;\n            return (_track$details = track.details) == null ? void 0 : _track$details.hasKey(keyInError);\n          });\n        }\n      }\n      return false;\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.playlistError = 0;\n    };\n    _proto.onLevelUpdated = function onLevelUpdated() {\n      this.playlistError = 0;\n    };\n    _proto.onError = function onError(event, data) {\n      var _data$frag;\n      if (data.fatal) {\n        return;\n      }\n      var hls = this.hls;\n      var context = data.context;\n      switch (data.details) {\n        case ErrorDetails.FRAG_LOAD_ERROR:\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_ERROR:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n          data.errorAction = this.getFragRetryOrSwitchAction(data);\n          return;\n        case ErrorDetails.FRAG_PARSING_ERROR:\n          // ignore empty segment errors marked as gap\n          if ((_data$frag = data.frag) != null && _data$frag.gap) {\n            data.errorAction = createDoNothingErrorAction();\n            return;\n          }\n        // falls through\n        case ErrorDetails.FRAG_GAP:\n        case ErrorDetails.FRAG_DECRYPT_ERROR:\n          {\n            // Switch level if possible, otherwise allow retry count to reach max error retries\n            data.errorAction = this.getFragRetryOrSwitchAction(data);\n            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n            return;\n          }\n        case ErrorDetails.LEVEL_EMPTY_ERROR:\n        case ErrorDetails.LEVEL_PARSING_ERROR:\n          {\n            var _data$context;\n            // Only retry when empty and live\n            var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n            if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context = _data$context.levelDetails) != null && _data$context.live)) {\n              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n            } else {\n              // Escalate to fatal if not retrying or switching\n              data.levelRetry = false;\n              data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n            }\n          }\n          return;\n        case ErrorDetails.LEVEL_LOAD_ERROR:\n        case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n          if (typeof (context == null ? void 0 : context.level) === 'number') {\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n          }\n          return;\n        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n        case ErrorDetails.SUBTITLE_LOAD_ERROR:\n        case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n          if (context) {\n            var level = hls.loadLevelObj;\n            if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {\n              // Perform Pathway switch or Redundant failover if possible for fastest recovery\n              // otherwise allow playlist retry count to reach max error retries\n              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n              data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n              data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n              return;\n            }\n          }\n          return;\n        case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n          {\n            data.errorAction = {\n              action: NetworkErrorAction.SendAlternateToPenaltyBox,\n              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP\n            };\n          }\n          return;\n        case ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED:\n        case ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR:\n        case ErrorDetails.KEY_SYSTEM_NO_SESSION:\n          {\n            data.errorAction = {\n              action: NetworkErrorAction.SendAlternateToPenaltyBox,\n              flags: ErrorActionFlags.MoveAllAlternatesMatchingKey\n            };\n          }\n          return;\n        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n        case ErrorDetails.REMUX_ALLOC_ERROR:\n        case ErrorDetails.BUFFER_APPEND_ERROR:\n          // Buffer-controller can set errorAction when append errors can be ignored or resolved locally\n          if (!data.errorAction) {\n            var _data$level;\n            data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n          }\n          return;\n        case ErrorDetails.INTERNAL_EXCEPTION:\n        case ErrorDetails.BUFFER_APPENDING_ERROR:\n        case ErrorDetails.BUFFER_FULL_ERROR:\n        case ErrorDetails.LEVEL_SWITCH_ERROR:\n        case ErrorDetails.BUFFER_STALLED_ERROR:\n        case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n        case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n          data.errorAction = createDoNothingErrorAction();\n          return;\n      }\n      if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n        // Do not retry level. Should be fatal if ErrorDetails.KEY_SYSTEM_<ERROR> not handled with early return above.\n        data.levelRetry = false;\n        data.errorAction = createDoNothingErrorAction();\n      }\n    };\n    _proto.getPlaylistRetryOrSwitchAction = function getPlaylistRetryOrSwitchAction(data, levelIndex) {\n      var hls = this.hls;\n      var retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n      var retryCount = this.playlistError++;\n      var retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);\n      if (retry) {\n        return {\n          action: NetworkErrorAction.RetryRequest,\n          flags: ErrorActionFlags.None,\n          retryConfig: retryConfig,\n          retryCount: retryCount\n        };\n      }\n      var errorAction = this.getLevelSwitchAction(data, levelIndex);\n      if (retryConfig) {\n        errorAction.retryConfig = retryConfig;\n        errorAction.retryCount = retryCount;\n      }\n      return errorAction;\n    };\n    _proto.getFragRetryOrSwitchAction = function getFragRetryOrSwitchAction(data) {\n      var hls = this.hls;\n      // Share fragment error count accross media options (main, audio, subs)\n      // This allows for level based rendition switching when media option assets fail\n      var variantLevelIndex = this.getVariantLevelIndex(data.frag);\n      var level = hls.levels[variantLevelIndex];\n      var _hls$config = hls.config,\n        fragLoadPolicy = _hls$config.fragLoadPolicy,\n        keyLoadPolicy = _hls$config.keyLoadPolicy;\n      var retryConfig = getRetryConfig(isKeyError(data) ? keyLoadPolicy : fragLoadPolicy, data);\n      var fragmentErrors = hls.levels.reduce(function (acc, level) {\n        return acc + level.fragmentError;\n      }, 0);\n      // Switch levels when out of retried or level index out of bounds\n      if (level) {\n        if (data.details !== ErrorDetails.FRAG_GAP) {\n          level.fragmentError++;\n        }\n        if (!isUnusableKeyError(data)) {\n          var retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);\n          if (retry) {\n            return {\n              action: NetworkErrorAction.RetryRequest,\n              flags: ErrorActionFlags.None,\n              retryConfig: retryConfig,\n              retryCount: fragmentErrors\n            };\n          }\n        }\n      }\n      // Reach max retry count, or Missing level reference\n      // Switch to valid index\n      var errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n      // Add retry details to allow skipping of FRAG_PARSING_ERROR\n      if (retryConfig) {\n        errorAction.retryConfig = retryConfig;\n        errorAction.retryCount = fragmentErrors;\n      }\n      return errorAction;\n    };\n    _proto.getLevelSwitchAction = function getLevelSwitchAction(data, levelIndex) {\n      var hls = this.hls;\n      if (levelIndex === null || levelIndex === undefined) {\n        levelIndex = hls.loadLevel;\n      }\n      var level = this.hls.levels[levelIndex];\n      if (level) {\n        var _data$frag2, _data$context2;\n        var errorDetails = data.details;\n        level.loadError++;\n        if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {\n          level.fragmentError++;\n        }\n        // Search for next level to retry\n        var nextLevel = -1;\n        var levels = hls.levels,\n          loadLevel = hls.loadLevel,\n          minAutoLevel = hls.minAutoLevel,\n          maxAutoLevel = hls.maxAutoLevel;\n        if (!hls.autoLevelEnabled && !hls.config.preserveManualLevelOnError) {\n          hls.loadLevel = -1;\n        }\n        var fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n        // Find alternate audio codec if available on audio codec error\n        var isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === 'audio' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n        var findAudioCodecAlternate = isAudioCodecError && levels.some(function (_ref) {\n          var audioCodec = _ref.audioCodec;\n          return level.audioCodec !== audioCodec;\n        });\n        // Find alternate video codec if available on video codec error\n        var isVideoCodecError = data.sourceBufferName === 'video' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n        var findVideoCodecAlternate = isVideoCodecError && levels.some(function (_ref2) {\n          var codecSet = _ref2.codecSet,\n            audioCodec = _ref2.audioCodec;\n          return level.codecSet !== codecSet && level.audioCodec === audioCodec;\n        });\n        var _ref3 = (_data$context2 = data.context) != null ? _data$context2 : {},\n          playlistErrorType = _ref3.type,\n          playlistErrorGroupId = _ref3.groupId;\n        var _loop = function _loop() {\n            var candidate = (i + loadLevel) % levels.length;\n            if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n              var _level$audioGroups, _level$subtitleGroups;\n              var levelCandidate = levels[candidate];\n              // Skip level switch if GAP tag is found in next level at same position\n              if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {\n                var levelDetails = levels[candidate].details;\n                if (levelDetails) {\n                  var fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n                  if (fragCandidate != null && fragCandidate.gap) {\n                    return 0; // continue\n                  }\n                }\n              } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {\n                // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n                return 0; // continue\n              } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(function (groupId) {\n                return levelCandidate.hasAudioGroup(groupId);\n              }) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(function (groupId) {\n                return levelCandidate.hasSubtitleGroup(groupId);\n              }) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet || !findAudioCodecAlternate && level.codecSet !== levelCandidate.codecSet) {\n                // For video/audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n                return 0; // continue\n              }\n              nextLevel = candidate;\n              return 1; // break\n            }\n          },\n          _ret;\n        for (var i = levels.length; i--;) {\n          _ret = _loop();\n          if (_ret === 0) continue;\n          if (_ret === 1) break;\n        }\n        if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n          data.levelRetry = true;\n          this.playlistError = 0;\n          return {\n            action: NetworkErrorAction.SendAlternateToPenaltyBox,\n            flags: ErrorActionFlags.None,\n            nextAutoLevel: nextLevel\n          };\n        }\n      }\n      // No levels to switch / Manual level selection / Level not found\n      // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n      return {\n        action: NetworkErrorAction.SendAlternateToPenaltyBox,\n        flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n      };\n    };\n    _proto.onErrorOut = function onErrorOut(event, data) {\n      var _data$errorAction;\n      switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n        case NetworkErrorAction.DoNothing:\n          break;\n        case NetworkErrorAction.SendAlternateToPenaltyBox:\n          this.sendAlternateToPenaltyBox(data);\n          if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n            data.fatal = true;\n          } else if (/MediaSource readyState: ended/.test(data.error.message)) {\n            this.warn(\"MediaSource ended after \\\"\" + data.sourceBufferName + \"\\\" sourceBuffer append error. Attempting to recover from media error.\");\n            this.hls.recoverMediaError();\n          }\n          break;\n      }\n      if (data.fatal) {\n        this.hls.stopLoad();\n        return;\n      }\n    };\n    _proto.sendAlternateToPenaltyBox = function sendAlternateToPenaltyBox(data) {\n      var hls = this.hls;\n      var errorAction = data.errorAction;\n      if (!errorAction) {\n        return;\n      }\n      var flags = errorAction.flags;\n      var nextAutoLevel = errorAction.nextAutoLevel;\n      switch (flags) {\n        case ErrorActionFlags.None:\n          this.switchLevel(data, nextAutoLevel);\n          break;\n        case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n          {\n            var levelIndex = this.getVariantLevelIndex(data.frag);\n            var level = hls.levels[levelIndex];\n            var restrictedHdcpLevel = level == null ? void 0 : level.attrs['HDCP-LEVEL'];\n            errorAction.hdcpLevel = restrictedHdcpLevel;\n            if (restrictedHdcpLevel === 'NONE') {\n              this.warn(\"HDCP policy resticted output with HDCP-LEVEL=NONE\");\n            } else if (restrictedHdcpLevel) {\n              hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(restrictedHdcpLevel) - 1];\n              errorAction.resolved = true;\n              this.warn(\"Restricting playback to HDCP-LEVEL of \\\"\" + hls.maxHdcpLevel + \"\\\" or lower\");\n              break;\n            }\n            // Fallthrough when no HDCP-LEVEL attribute is found\n          }\n        // eslint-disable-next-line no-fallthrough\n        case ErrorActionFlags.MoveAllAlternatesMatchingKey:\n          {\n            var levelKey = data.decryptdata;\n            if (levelKey) {\n              // Penalize all levels with key\n              var levels = this.hls.levels;\n              var levelCountWithError = levels.length;\n              for (var i = levelCountWithError; i--;) {\n                if (this.variantHasKey(levels[i], levelKey)) {\n                  var _levels$i$audioGroups, _data$frag3;\n                  this.log(\"Banned key found in level \" + i + \" (\" + levels[i].bitrate + \"bps) or audio group \\\"\" + ((_levels$i$audioGroups = levels[i].audioGroups) == null ? void 0 : _levels$i$audioGroups.join(',')) + \"\\\" (\" + ((_data$frag3 = data.frag) == null ? void 0 : _data$frag3.type) + \" fragment) \" + arrayToHex(levelKey.keyId || []));\n                  levels[i].fragmentError++;\n                  levels[i].loadError++;\n                  this.log(\"Removing level \" + i + \" with key error (\" + data.error + \")\");\n                  this.hls.removeLevel(i);\n                }\n              }\n              var frag = data.frag;\n              if (this.hls.levels.length < levelCountWithError) {\n                errorAction.resolved = true;\n              } else if (frag && frag.type !== PlaylistLevelType.MAIN) {\n                // Ignore key error for audio track with unmatched key (main session error)\n                var fragLevelKey = frag.decryptdata;\n                if (fragLevelKey && !levelKey.matches(fragLevelKey)) {\n                  errorAction.resolved = true;\n                }\n              }\n            }\n            break;\n          }\n      }\n      // If not resolved by previous actions try to switch to next level\n      if (!errorAction.resolved) {\n        this.switchLevel(data, nextAutoLevel);\n      }\n    };\n    _proto.switchLevel = function switchLevel(data, levelIndex) {\n      if (levelIndex !== undefined && data.errorAction) {\n        this.warn(\"switching to level \" + levelIndex + \" after \" + data.details);\n        this.hls.nextAutoLevel = levelIndex;\n        data.errorAction.resolved = true;\n        // Stream controller is responsible for this but won't switch on false start\n        this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n        if (data.details === ErrorDetails.BUFFER_ADD_CODEC_ERROR && data.mimeType && data.sourceBufferName !== 'audiovideo') {\n          var codec = getCodecsForMimeType(data.mimeType);\n          var levels = this.hls.levels;\n          for (var i = levels.length; i--;) {\n            if (levels[i][data.sourceBufferName + \"Codec\"] === codec) {\n              this.log(\"Removing level \" + i + \" for \" + data.details + \" (\\\"\" + codec + \"\\\" not supported)\");\n              this.hls.removeLevel(i);\n            }\n          }\n        }\n      }\n    };\n    return ErrorController;\n  }(Logger);\n  function createDoNothingErrorAction(resolved) {\n    var errorAction = {\n      action: NetworkErrorAction.DoNothing,\n      flags: ErrorActionFlags.None\n    };\n    if (resolved) {\n      errorAction.resolved = true;\n    }\n    return errorAction;\n  }\n\n  var FragmentState = {\n    NOT_LOADED: \"NOT_LOADED\",\n    APPENDING: \"APPENDING\",\n    PARTIAL: \"PARTIAL\",\n    OK: \"OK\"\n  };\n  var FragmentTracker = /*#__PURE__*/function () {\n    function FragmentTracker(hls) {\n      this.activePartLists = Object.create(null);\n      this.endListFragments = Object.create(null);\n      this.fragments = Object.create(null);\n      this.timeRanges = Object.create(null);\n      this.bufferPadding = 0.2;\n      this.hls = void 0;\n      this.hasGaps = false;\n      this.hls = hls;\n      this._registerListeners();\n    }\n    var _proto = FragmentTracker.prototype;\n    _proto._registerListeners = function _registerListeners() {\n      var hls = this.hls;\n      if (hls) {\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n      }\n    };\n    _proto._unregisterListeners = function _unregisterListeners() {\n      var hls = this.hls;\n      if (hls) {\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n      }\n    };\n    _proto.destroy = function destroy() {\n      this._unregisterListeners();\n      // @ts-ignore\n      this.hls =\n      // @ts-ignore\n      this.fragments =\n      // @ts-ignore\n      this.activePartLists =\n      // @ts-ignore\n      this.endListFragments = this.timeRanges = null;\n    }\n\n    /**\n     * Return a Fragment or Part with an appended range that matches the position and levelType\n     * Otherwise, return null\n     */;\n    _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {\n      var activeParts = this.activePartLists[levelType];\n      if (activeParts) {\n        for (var i = activeParts.length; i--;) {\n          var activePart = activeParts[i];\n          if (!activePart) {\n            break;\n          }\n          if (activePart.start <= position && position <= activePart.end && activePart.loaded) {\n            return activePart;\n          }\n        }\n      }\n      return this.getBufferedFrag(position, levelType);\n    }\n\n    /**\n     * Return a buffered Fragment that matches the position and levelType.\n     * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n     * If not found any Fragment, return null\n     */;\n    _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {\n      return this.getFragAtPos(position, levelType, true);\n    };\n    _proto.getFragAtPos = function getFragAtPos(position, levelType, buffered) {\n      var fragments = this.fragments;\n      var keys = Object.keys(fragments);\n      for (var i = keys.length; i--;) {\n        var fragmentEntity = fragments[keys[i]];\n        if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && (!buffered || fragmentEntity.buffered)) {\n          var frag = fragmentEntity.body;\n          if (frag.start <= position && position <= frag.end) {\n            return frag;\n          }\n        }\n      }\n      return null;\n    }\n\n    /**\n     * Partial fragments effected by coded frame eviction will be removed\n     * The browser will unload parts of the buffer to free up memory for new buffer data\n     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n     */;\n    _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart, removeAppending) {\n      var _this = this;\n      if (this.timeRanges) {\n        this.timeRanges[elementaryStream] = timeRange;\n      }\n      // Check if any flagged fragments have been unloaded\n      // excluding anything newer than appendedPartSn\n      var appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n      Object.keys(this.fragments).forEach(function (key) {\n        var fragmentEntity = _this.fragments[key];\n        if (!fragmentEntity) {\n          return;\n        }\n        if (appendedPartSn >= fragmentEntity.body.sn) {\n          return;\n        }\n        if (!fragmentEntity.buffered && (!fragmentEntity.loaded || removeAppending)) {\n          if (fragmentEntity.body.type === playlistType) {\n            _this.removeFragment(fragmentEntity.body);\n          }\n          return;\n        }\n        var esData = fragmentEntity.range[elementaryStream];\n        if (!esData) {\n          return;\n        }\n        if (esData.time.length === 0) {\n          _this.removeFragment(fragmentEntity.body);\n          return;\n        }\n        esData.time.some(function (time) {\n          var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n          if (isNotBuffered) {\n            // Unregister partial fragment as it needs to load again to be reused\n            _this.removeFragment(fragmentEntity.body);\n          }\n          return isNotBuffered;\n        });\n      });\n    }\n\n    /**\n     * Checks if the fragment passed in is loaded in the buffer properly\n     * Partially loaded fragments will be registered as a partial fragment\n     */;\n    _proto.detectPartialFragments = function detectPartialFragments(data) {\n      var _this2 = this;\n      var timeRanges = this.timeRanges;\n      if (!timeRanges || data.frag.sn === 'initSegment') {\n        return;\n      }\n      var frag = data.frag;\n      var fragKey = getFragmentKey(frag);\n      var fragmentEntity = this.fragments[fragKey];\n      if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n        return;\n      }\n      var isFragHint = !frag.relurl;\n      Object.keys(timeRanges).forEach(function (elementaryStream) {\n        var streamInfo = frag.elementaryStreams[elementaryStream];\n        if (!streamInfo) {\n          return;\n        }\n        var timeRange = timeRanges[elementaryStream];\n        var partial = isFragHint || streamInfo.partial === true;\n        fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, data.part, partial, timeRange);\n      });\n      fragmentEntity.loaded = null;\n      if (Object.keys(fragmentEntity.range).length) {\n        this.bufferedEnd(fragmentEntity, frag);\n        if (!isPartial(fragmentEntity)) {\n          // Remove older fragment parts from lookup after frag is tracked as buffered\n          this.removeParts(frag.sn - 1, frag.type);\n        }\n      } else {\n        // remove fragment if nothing was appended\n        this.removeFragment(fragmentEntity.body);\n      }\n    };\n    _proto.bufferedEnd = function bufferedEnd(fragmentEntity, frag) {\n      fragmentEntity.buffered = true;\n      var endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;\n      if (endList) {\n        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n      }\n    };\n    _proto.removeParts = function removeParts(snToKeep, levelType) {\n      var activeParts = this.activePartLists[levelType];\n      if (!activeParts) {\n        return;\n      }\n      this.activePartLists[levelType] = filterParts(activeParts, function (part) {\n        return part.fragment.sn >= snToKeep;\n      });\n    };\n    _proto.fragBuffered = function fragBuffered(frag, force) {\n      var fragKey = getFragmentKey(frag);\n      var fragmentEntity = this.fragments[fragKey];\n      if (!fragmentEntity && force) {\n        fragmentEntity = this.fragments[fragKey] = {\n          body: frag,\n          appendedPTS: null,\n          loaded: null,\n          buffered: false,\n          range: Object.create(null)\n        };\n        if (frag.gap) {\n          this.hasGaps = true;\n        }\n      }\n      if (fragmentEntity) {\n        fragmentEntity.loaded = null;\n        this.bufferedEnd(fragmentEntity, frag);\n      }\n    };\n    _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {\n      var buffered = {\n        time: [],\n        partial: partial\n      };\n      var startPTS = fragment.start;\n      var endPTS = fragment.end;\n      var minEndPTS = fragment.minEndPTS || endPTS;\n      var maxStartPTS = fragment.maxStartPTS || startPTS;\n      for (var i = 0; i < timeRange.length; i++) {\n        var startTime = timeRange.start(i) - this.bufferPadding;\n        var endTime = timeRange.end(i) + this.bufferPadding;\n        if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n          // Fragment is entirely contained in buffer\n          // No need to check the other timeRange times since it's completely playable\n          buffered.time.push({\n            startPTS: Math.max(startPTS, timeRange.start(i)),\n            endPTS: Math.min(endPTS, timeRange.end(i))\n          });\n          break;\n        } else if (startPTS < endTime && endPTS > startTime) {\n          var start = Math.max(startPTS, timeRange.start(i));\n          var end = Math.min(endPTS, timeRange.end(i));\n          if (end > start) {\n            buffered.partial = true;\n            // Check for intersection with buffer\n            // Get playable sections of the fragment\n            buffered.time.push({\n              startPTS: start,\n              endPTS: end\n            });\n          }\n        } else if (endPTS <= startTime) {\n          // No need to check the rest of the timeRange as it is in order\n          break;\n        }\n      }\n      return buffered;\n    }\n\n    /**\n     * Gets the partial fragment for a certain time\n     */;\n    _proto.getPartialFragment = function getPartialFragment(time) {\n      var bestFragment = null;\n      var timePadding;\n      var startTime;\n      var endTime;\n      var bestOverlap = 0;\n      var bufferPadding = this.bufferPadding,\n        fragments = this.fragments;\n      Object.keys(fragments).forEach(function (key) {\n        var fragmentEntity = fragments[key];\n        if (!fragmentEntity) {\n          return;\n        }\n        if (isPartial(fragmentEntity)) {\n          startTime = fragmentEntity.body.start - bufferPadding;\n          endTime = fragmentEntity.body.end + bufferPadding;\n          if (time >= startTime && time <= endTime) {\n            // Use the fragment that has the most padding from start and end time\n            timePadding = Math.min(time - startTime, endTime - time);\n            if (bestOverlap <= timePadding) {\n              bestFragment = fragmentEntity.body;\n              bestOverlap = timePadding;\n            }\n          }\n        }\n      });\n      return bestFragment;\n    };\n    _proto.isEndListAppended = function isEndListAppended(type) {\n      var lastFragmentEntity = this.endListFragments[type];\n      return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n    };\n    _proto.getState = function getState(fragment) {\n      var fragKey = getFragmentKey(fragment);\n      var fragmentEntity = this.fragments[fragKey];\n      if (fragmentEntity) {\n        if (!fragmentEntity.buffered) {\n          return FragmentState.APPENDING;\n        } else if (isPartial(fragmentEntity)) {\n          return FragmentState.PARTIAL;\n        } else {\n          return FragmentState.OK;\n        }\n      }\n      return FragmentState.NOT_LOADED;\n    };\n    _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {\n      var startTime;\n      var endTime;\n      for (var i = 0; i < timeRange.length; i++) {\n        startTime = timeRange.start(i) - this.bufferPadding;\n        endTime = timeRange.end(i) + this.bufferPadding;\n        if (startPTS >= startTime && endPTS <= endTime) {\n          return true;\n        }\n        if (endPTS <= startTime) {\n          // No need to check the rest of the timeRange as it is in order\n          return false;\n        }\n      }\n      return false;\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.removeAllFragments();\n    };\n    _proto.onFragLoaded = function onFragLoaded(event, data) {\n      // don't track initsegment (for which sn is not a number)\n      // don't track frags used for bitrateTest, they're irrelevant.\n      if (data.frag.sn === 'initSegment' || data.frag.bitrateTest) {\n        return;\n      }\n      var frag = data.frag;\n      // Fragment entity `loaded` FragLoadedData is null when loading parts\n      var loaded = data.part ? null : data;\n      var fragKey = getFragmentKey(frag);\n      this.fragments[fragKey] = {\n        body: frag,\n        appendedPTS: null,\n        loaded: loaded,\n        buffered: false,\n        range: Object.create(null)\n      };\n    };\n    _proto.onBufferAppended = function onBufferAppended(event, data) {\n      var frag = data.frag,\n        part = data.part,\n        timeRanges = data.timeRanges,\n        type = data.type;\n      if (frag.sn === 'initSegment') {\n        return;\n      }\n      var playlistType = frag.type;\n      if (part) {\n        var activeParts = this.activePartLists[playlistType];\n        if (!activeParts) {\n          this.activePartLists[playlistType] = activeParts = [];\n        }\n        activeParts.push(part);\n      }\n      // Store the latest timeRanges loaded in the buffer\n      this.timeRanges = timeRanges;\n      var timeRange = timeRanges[type];\n      this.detectEvictedFragments(type, timeRange, playlistType, part);\n    };\n    _proto.onFragBuffered = function onFragBuffered(event, data) {\n      this.detectPartialFragments(data);\n    };\n    _proto.hasFragment = function hasFragment(fragment) {\n      var fragKey = getFragmentKey(fragment);\n      return !!this.fragments[fragKey];\n    };\n    _proto.hasFragments = function hasFragments(type) {\n      var fragments = this.fragments;\n      var keys = Object.keys(fragments);\n      if (!type) {\n        return keys.length > 0;\n      }\n      for (var i = keys.length; i--;) {\n        var fragmentEntity = fragments[keys[i]];\n        if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === type) {\n          return true;\n        }\n      }\n      return false;\n    };\n    _proto.hasParts = function hasParts(type) {\n      var _this$activePartLists;\n      return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n    };\n    _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n      var _this3 = this;\n      if (withGapOnly && !this.hasGaps) {\n        return;\n      }\n      Object.keys(this.fragments).forEach(function (key) {\n        var fragmentEntity = _this3.fragments[key];\n        if (!fragmentEntity) {\n          return;\n        }\n        var frag = fragmentEntity.body;\n        if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n          return;\n        }\n        if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n          _this3.removeFragment(frag);\n        }\n      });\n    };\n    _proto.removeFragment = function removeFragment(fragment) {\n      var fragKey = getFragmentKey(fragment);\n      fragment.clearElementaryStreamInfo();\n      var activeParts = this.activePartLists[fragment.type];\n      if (activeParts) {\n        var snToRemove = fragment.sn;\n        this.activePartLists[fragment.type] = filterParts(activeParts, function (part) {\n          return part.fragment.sn !== snToRemove;\n        });\n      }\n      delete this.fragments[fragKey];\n      if (fragment.endList) {\n        delete this.endListFragments[fragment.type];\n      }\n    };\n    _proto.removeAllFragments = function removeAllFragments() {\n      var _this$hls;\n      this.fragments = Object.create(null);\n      this.endListFragments = Object.create(null);\n      this.activePartLists = Object.create(null);\n      this.hasGaps = false;\n      var partlist = (_this$hls = this.hls) == null || (_this$hls = _this$hls.latestLevelDetails) == null ? void 0 : _this$hls.partList;\n      if (partlist) {\n        partlist.forEach(function (part) {\n          return part.clearElementaryStreamInfo();\n        });\n      }\n    };\n    return FragmentTracker;\n  }();\n  function isPartial(fragmentEntity) {\n    var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n    return fragmentEntity.buffered && !!(fragmentEntity.body.gap || (_fragmentEntity$range = fragmentEntity.range.video) != null && _fragmentEntity$range.partial || (_fragmentEntity$range2 = fragmentEntity.range.audio) != null && _fragmentEntity$range2.partial || (_fragmentEntity$range3 = fragmentEntity.range.audiovideo) != null && _fragmentEntity$range3.partial);\n  }\n  function getFragmentKey(fragment) {\n    return fragment.type + \"_\" + fragment.level + \"_\" + fragment.sn;\n  }\n  function filterParts(partList, predicate) {\n    return partList.filter(function (part) {\n      var keep = predicate(part);\n      if (!keep) {\n        part.clearElementaryStreamInfo();\n      }\n      return keep;\n    });\n  }\n\n  var DecrypterAesMode = {\n    cbc: 0,\n    ctr: 1\n  };\n\n  var AESCrypto = /*#__PURE__*/function () {\n    function AESCrypto(subtle, iv, aesMode) {\n      this.subtle = void 0;\n      this.aesIV = void 0;\n      this.aesMode = void 0;\n      this.subtle = subtle;\n      this.aesIV = iv;\n      this.aesMode = aesMode;\n    }\n    var _proto = AESCrypto.prototype;\n    _proto.decrypt = function decrypt(data, key) {\n      switch (this.aesMode) {\n        case DecrypterAesMode.cbc:\n          return this.subtle.decrypt({\n            name: 'AES-CBC',\n            iv: this.aesIV\n          }, key, data);\n        case DecrypterAesMode.ctr:\n          return this.subtle.decrypt({\n            name: 'AES-CTR',\n            counter: this.aesIV,\n            length: 64\n          },\n          //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block\n          key, data);\n        default:\n          throw new Error(\"[AESCrypto] invalid aes mode \" + this.aesMode);\n      }\n    };\n    return AESCrypto;\n  }();\n\n  // PKCS7\n  function removePadding(array) {\n    var outputBytes = array.byteLength;\n    var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n    if (paddingBytes) {\n      return array.slice(0, outputBytes - paddingBytes);\n    }\n    return array;\n  }\n  var AESDecryptor = /*#__PURE__*/function () {\n    function AESDecryptor() {\n      this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n      this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n      this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n      this.sBox = new Uint32Array(256);\n      this.invSBox = new Uint32Array(256);\n      this.key = new Uint32Array(0);\n      this.ksRows = 0;\n      this.keySize = 0;\n      this.keySchedule = void 0;\n      this.invKeySchedule = void 0;\n      this.initTable();\n    }\n\n    // Using view.getUint32() also swaps the byte order.\n    var _proto = AESDecryptor.prototype;\n    _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {\n      var view = new DataView(arrayBuffer);\n      var newArray = new Uint32Array(4);\n      for (var i = 0; i < 4; i++) {\n        newArray[i] = view.getUint32(i * 4);\n      }\n      return newArray;\n    };\n    _proto.initTable = function initTable() {\n      var sBox = this.sBox;\n      var invSBox = this.invSBox;\n      var subMix = this.subMix;\n      var subMix0 = subMix[0];\n      var subMix1 = subMix[1];\n      var subMix2 = subMix[2];\n      var subMix3 = subMix[3];\n      var invSubMix = this.invSubMix;\n      var invSubMix0 = invSubMix[0];\n      var invSubMix1 = invSubMix[1];\n      var invSubMix2 = invSubMix[2];\n      var invSubMix3 = invSubMix[3];\n      var d = new Uint32Array(256);\n      var x = 0;\n      var xi = 0;\n      var i = 0;\n      for (i = 0; i < 256; i++) {\n        if (i < 128) {\n          d[i] = i << 1;\n        } else {\n          d[i] = i << 1 ^ 0x11b;\n        }\n      }\n      for (i = 0; i < 256; i++) {\n        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n        sBox[x] = sx;\n        invSBox[sx] = x;\n\n        // Compute multiplication\n        var x2 = d[x];\n        var x4 = d[x2];\n        var x8 = d[x4];\n\n        // Compute sub/invSub bytes, mix columns tables\n        var t = d[sx] * 0x101 ^ sx * 0x1010100;\n        subMix0[x] = t << 24 | t >>> 8;\n        subMix1[x] = t << 16 | t >>> 16;\n        subMix2[x] = t << 8 | t >>> 24;\n        subMix3[x] = t;\n\n        // Compute inv sub bytes, inv mix columns tables\n        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n        invSubMix0[sx] = t << 24 | t >>> 8;\n        invSubMix1[sx] = t << 16 | t >>> 16;\n        invSubMix2[sx] = t << 8 | t >>> 24;\n        invSubMix3[sx] = t;\n\n        // Compute next counter\n        if (!x) {\n          x = xi = 1;\n        } else {\n          x = x2 ^ d[d[d[x8 ^ x2]]];\n          xi ^= d[d[xi]];\n        }\n      }\n    };\n    _proto.expandKey = function expandKey(keyBuffer) {\n      // convert keyBuffer to Uint32Array\n      var key = this.uint8ArrayToUint32Array_(keyBuffer);\n      var sameKey = true;\n      var offset = 0;\n      while (offset < key.length && sameKey) {\n        sameKey = key[offset] === this.key[offset];\n        offset++;\n      }\n      if (sameKey) {\n        return;\n      }\n      this.key = key;\n      var keySize = this.keySize = key.length;\n      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n        throw new Error('Invalid aes key size=' + keySize);\n      }\n      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n      var ksRow;\n      var invKsRow;\n      var keySchedule = this.keySchedule = new Uint32Array(ksRows);\n      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n      var sbox = this.sBox;\n      var rcon = this.rcon;\n      var invSubMix = this.invSubMix;\n      var invSubMix0 = invSubMix[0];\n      var invSubMix1 = invSubMix[1];\n      var invSubMix2 = invSubMix[2];\n      var invSubMix3 = invSubMix[3];\n      var prev;\n      var t;\n      for (ksRow = 0; ksRow < ksRows; ksRow++) {\n        if (ksRow < keySize) {\n          prev = keySchedule[ksRow] = key[ksRow];\n          continue;\n        }\n        t = prev;\n        if (ksRow % keySize === 0) {\n          // Rot word\n          t = t << 8 | t >>> 24;\n\n          // Sub word\n          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n          // Mix Rcon\n          t ^= rcon[ksRow / keySize | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n        }\n        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n      }\n      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n        ksRow = ksRows - invKsRow;\n        if (invKsRow & 3) {\n          t = keySchedule[ksRow];\n        } else {\n          t = keySchedule[ksRow - 4];\n        }\n        if (invKsRow < 4 || ksRow <= 4) {\n          invKeySchedule[invKsRow] = t;\n        } else {\n          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n        }\n        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n      }\n    }\n\n    // Adding this as a method greatly improves performance.\n    ;\n    _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {\n      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n    };\n    _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {\n      var nRounds = this.keySize + 6;\n      var invKeySchedule = this.invKeySchedule;\n      var invSBOX = this.invSBox;\n      var invSubMix = this.invSubMix;\n      var invSubMix0 = invSubMix[0];\n      var invSubMix1 = invSubMix[1];\n      var invSubMix2 = invSubMix[2];\n      var invSubMix3 = invSubMix[3];\n      var initVector = this.uint8ArrayToUint32Array_(aesIV);\n      var initVector0 = initVector[0];\n      var initVector1 = initVector[1];\n      var initVector2 = initVector[2];\n      var initVector3 = initVector[3];\n      var inputInt32 = new Int32Array(inputArrayBuffer);\n      var outputInt32 = new Int32Array(inputInt32.length);\n      var t0, t1, t2, t3;\n      var s0, s1, s2, s3;\n      var inputWords0, inputWords1, inputWords2, inputWords3;\n      var ksRow, i;\n      var swapWord = this.networkToHostOrderSwap;\n      while (offset < inputInt32.length) {\n        inputWords0 = swapWord(inputInt32[offset]);\n        inputWords1 = swapWord(inputInt32[offset + 1]);\n        inputWords2 = swapWord(inputInt32[offset + 2]);\n        inputWords3 = swapWord(inputInt32[offset + 3]);\n        s0 = inputWords0 ^ invKeySchedule[0];\n        s1 = inputWords3 ^ invKeySchedule[1];\n        s2 = inputWords2 ^ invKeySchedule[2];\n        s3 = inputWords1 ^ invKeySchedule[3];\n        ksRow = 4;\n\n        // Iterate through the rounds of decryption\n        for (i = 1; i < nRounds; i++) {\n          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n          // Update state\n          s0 = t0;\n          s1 = t1;\n          s2 = t2;\n          s3 = t3;\n          ksRow = ksRow + 4;\n        }\n\n        // Shift rows, sub bytes, add round key\n        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n        // Write\n        outputInt32[offset] = swapWord(t0 ^ initVector0);\n        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n        // reset initVector to last 4 unsigned int\n        initVector0 = inputWords0;\n        initVector1 = inputWords1;\n        initVector2 = inputWords2;\n        initVector3 = inputWords3;\n        offset = offset + 4;\n      }\n      return outputInt32.buffer;\n    };\n    return AESDecryptor;\n  }();\n\n  var FastAESKey = /*#__PURE__*/function () {\n    function FastAESKey(subtle, key, aesMode) {\n      this.subtle = void 0;\n      this.key = void 0;\n      this.aesMode = void 0;\n      this.subtle = subtle;\n      this.key = key;\n      this.aesMode = aesMode;\n    }\n    var _proto = FastAESKey.prototype;\n    _proto.expandKey = function expandKey() {\n      var subtleAlgoName = getSubtleAlgoName(this.aesMode);\n      return this.subtle.importKey('raw', this.key, {\n        name: subtleAlgoName\n      }, false, ['encrypt', 'decrypt']);\n    };\n    return FastAESKey;\n  }();\n  function getSubtleAlgoName(aesMode) {\n    switch (aesMode) {\n      case DecrypterAesMode.cbc:\n        return 'AES-CBC';\n      case DecrypterAesMode.ctr:\n        return 'AES-CTR';\n      default:\n        throw new Error(\"[FastAESKey] invalid aes mode \" + aesMode);\n    }\n  }\n\n  var CHUNK_SIZE = 16; // 16 bytes, 128 bits\n  var Decrypter = /*#__PURE__*/function () {\n    function Decrypter(config, _temp) {\n      var _ref = _temp === void 0 ? {} : _temp,\n        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,\n        removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;\n      this.logEnabled = true;\n      this.removePKCS7Padding = void 0;\n      this.subtle = null;\n      this.softwareDecrypter = null;\n      this.key = null;\n      this.fastAesKey = null;\n      this.remainderData = null;\n      this.currentIV = null;\n      this.currentResult = null;\n      this.useSoftware = void 0;\n      this.enableSoftwareAES = void 0;\n      this.enableSoftwareAES = config.enableSoftwareAES;\n      this.removePKCS7Padding = removePKCS7Padding;\n      // built in decryptor expects PKCS7 padding\n      if (removePKCS7Padding) {\n        try {\n          var browserCrypto = self.crypto;\n          if (browserCrypto) {\n            this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n          }\n        } catch (e) {\n          /* no-op */\n        }\n      }\n      this.useSoftware = !this.subtle;\n    }\n    var _proto = Decrypter.prototype;\n    _proto.destroy = function destroy() {\n      this.subtle = null;\n      this.softwareDecrypter = null;\n      this.key = null;\n      this.fastAesKey = null;\n      this.remainderData = null;\n      this.currentIV = null;\n      this.currentResult = null;\n    };\n    _proto.isSync = function isSync() {\n      return this.useSoftware;\n    };\n    _proto.flush = function flush() {\n      var currentResult = this.currentResult,\n        remainderData = this.remainderData;\n      if (!currentResult || remainderData) {\n        this.reset();\n        return null;\n      }\n      var data = new Uint8Array(currentResult);\n      this.reset();\n      if (this.removePKCS7Padding) {\n        return removePadding(data);\n      }\n      return data;\n    };\n    _proto.reset = function reset() {\n      this.currentResult = null;\n      this.currentIV = null;\n      this.remainderData = null;\n      if (this.softwareDecrypter) {\n        this.softwareDecrypter = null;\n      }\n    };\n    _proto.decrypt = function decrypt(data, key, iv, aesMode) {\n      var _this = this;\n      if (this.useSoftware) {\n        return new Promise(function (resolve, reject) {\n          var dataView = ArrayBuffer.isView(data) ? data : new Uint8Array(data);\n          _this.softwareDecrypt(dataView, key, iv, aesMode);\n          var decryptResult = _this.flush();\n          if (decryptResult) {\n            resolve(decryptResult.buffer);\n          } else {\n            reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n          }\n        });\n      }\n      return this.webCryptoDecrypt(new Uint8Array(data), key, iv, aesMode);\n    }\n\n    // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n    // data is handled in the flush() call\n    ;\n    _proto.softwareDecrypt = function softwareDecrypt(data, key, iv, aesMode) {\n      var currentIV = this.currentIV,\n        currentResult = this.currentResult,\n        remainderData = this.remainderData;\n      if (aesMode !== DecrypterAesMode.cbc || key.byteLength !== 16) {\n        logger.warn('SoftwareDecrypt: can only handle AES-128-CBC');\n        return null;\n      }\n      this.logOnce('JS AES decrypt');\n      // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n      // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n      // the end on flush(), but by that time we have already received all bytes for the segment.\n      // Progressive decryption does not work with WebCrypto\n\n      if (remainderData) {\n        data = appendUint8Array(remainderData, data);\n        this.remainderData = null;\n      }\n\n      // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n      var currentChunk = this.getValidChunk(data);\n      if (!currentChunk.length) {\n        return null;\n      }\n      if (currentIV) {\n        iv = currentIV;\n      }\n      var softwareDecrypter = this.softwareDecrypter;\n      if (!softwareDecrypter) {\n        softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n      }\n      softwareDecrypter.expandKey(key);\n      var result = currentResult;\n      this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n      this.currentIV = currentChunk.slice(-16).buffer;\n      if (!result) {\n        return null;\n      }\n      return result;\n    };\n    _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv, aesMode) {\n      var _this2 = this;\n      if (this.key !== key || !this.fastAesKey) {\n        if (!this.subtle) {\n          return Promise.resolve(this.onWebCryptoError(data, key, iv, aesMode));\n        }\n        this.key = key;\n        this.fastAesKey = new FastAESKey(this.subtle, key, aesMode);\n      }\n      return this.fastAesKey.expandKey().then(function (aesKey) {\n        // decrypt using web crypto\n        if (!_this2.subtle) {\n          return Promise.reject(new Error('web crypto not initialized'));\n        }\n        _this2.logOnce('WebCrypto AES decrypt');\n        var crypto = new AESCrypto(_this2.subtle, new Uint8Array(iv), aesMode);\n        return crypto.decrypt(data.buffer, aesKey);\n      }).catch(function (err) {\n        logger.warn(\"[decrypter]: WebCrypto Error, disable WebCrypto API, \" + err.name + \": \" + err.message);\n        return _this2.onWebCryptoError(data, key, iv, aesMode);\n      });\n    };\n    _proto.onWebCryptoError = function onWebCryptoError(data, key, iv, aesMode) {\n      var enableSoftwareAES = this.enableSoftwareAES;\n      if (enableSoftwareAES) {\n        this.useSoftware = true;\n        this.logEnabled = true;\n        this.softwareDecrypt(data, key, iv, aesMode);\n        var decryptResult = this.flush();\n        if (decryptResult) {\n          return decryptResult.buffer;\n        }\n      }\n      throw new Error('WebCrypto' + (enableSoftwareAES ? ' and softwareDecrypt' : '') + ': failed to decrypt data');\n    };\n    _proto.getValidChunk = function getValidChunk(data) {\n      var currentChunk = data;\n      var splitPoint = data.length - data.length % CHUNK_SIZE;\n      if (splitPoint !== data.length) {\n        currentChunk = data.slice(0, splitPoint);\n        this.remainderData = data.slice(splitPoint);\n      }\n      return currentChunk;\n    };\n    _proto.logOnce = function logOnce(msg) {\n      if (!this.logEnabled) {\n        return;\n      }\n      logger.log(\"[decrypter]: \" + msg);\n      this.logEnabled = false;\n    };\n    return Decrypter;\n  }();\n\n  var MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n  var FragmentLoader = /*#__PURE__*/function () {\n    function FragmentLoader(config) {\n      this.config = void 0;\n      this.loader = null;\n      this.partLoadTimeout = -1;\n      this.config = config;\n    }\n    var _proto = FragmentLoader.prototype;\n    _proto.destroy = function destroy() {\n      if (this.loader) {\n        this.loader.destroy();\n        this.loader = null;\n      }\n    };\n    _proto.abort = function abort() {\n      if (this.loader) {\n        // Abort the loader for current fragment. Only one may load at any given time\n        this.loader.abort();\n      }\n    };\n    _proto.load = function load(frag, onProgress) {\n      var _this = this;\n      var url = frag.url;\n      if (!url) {\n        return Promise.reject(new LoadError({\n          type: ErrorTypes.NETWORK_ERROR,\n          details: ErrorDetails.FRAG_LOAD_ERROR,\n          fatal: false,\n          frag: frag,\n          error: new Error(\"Fragment does not have a \" + (url ? 'part list' : 'url')),\n          networkDetails: null\n        }));\n      }\n      this.abort();\n      var config = this.config;\n      var FragmentILoader = config.fLoader;\n      var DefaultILoader = config.loader;\n      return new Promise(function (resolve, reject) {\n        if (_this.loader) {\n          _this.loader.destroy();\n        }\n        if (frag.gap) {\n          if (frag.tagList.some(function (tags) {\n            return tags[0] === 'GAP';\n          })) {\n            reject(createGapLoadError(frag));\n            return;\n          } else {\n            // Reset temporary treatment as GAP tag\n            frag.gap = false;\n          }\n        }\n        var loader = _this.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n        var loaderContext = createLoaderContext(frag);\n        frag.loader = loader;\n        var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: 0,\n          retryDelay: 0,\n          maxRetryDelay: 0,\n          highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n        };\n        // Assign frag stats to the loader's stats reference\n        frag.stats = loader.stats;\n        var callbacks = {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            _this.resetLoader(frag, loader);\n            var payload = response.data;\n            if (context.resetIV && frag.decryptdata) {\n              frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n              payload = payload.slice(16);\n            }\n            resolve({\n              frag: frag,\n              part: null,\n              payload: payload,\n              networkDetails: networkDetails\n            });\n          },\n          onError: function onError(response, context, networkDetails, stats) {\n            _this.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.FRAG_LOAD_ERROR,\n              fatal: false,\n              frag: frag,\n              response: _objectSpread2({\n                url: url,\n                data: undefined\n              }, response),\n              error: new Error(\"HTTP Error \" + response.code + \" \" + response.text),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          },\n          onAbort: function onAbort(stats, context, networkDetails) {\n            _this.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.INTERNAL_ABORTED,\n              fatal: false,\n              frag: frag,\n              error: new Error('Aborted'),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            _this.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n              fatal: false,\n              frag: frag,\n              error: new Error(\"Timeout after \" + loaderConfig.timeout + \"ms\"),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          }\n        };\n        if (onProgress) {\n          callbacks.onProgress = function (stats, context, data, networkDetails) {\n            return onProgress({\n              frag: frag,\n              part: null,\n              payload: data,\n              networkDetails: networkDetails\n            });\n          };\n        }\n        loader.load(loaderContext, loaderConfig, callbacks);\n      });\n    };\n    _proto.loadPart = function loadPart(frag, part, onProgress) {\n      var _this2 = this;\n      this.abort();\n      var config = this.config;\n      var FragmentILoader = config.fLoader;\n      var DefaultILoader = config.loader;\n      return new Promise(function (resolve, reject) {\n        if (_this2.loader) {\n          _this2.loader.destroy();\n        }\n        if (frag.gap || part.gap) {\n          reject(createGapLoadError(frag, part));\n          return;\n        }\n        var loader = _this2.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n        var loaderContext = createLoaderContext(frag, part);\n        frag.loader = loader;\n        // Should we define another load policy for parts?\n        var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: 0,\n          retryDelay: 0,\n          maxRetryDelay: 0,\n          highWaterMark: MIN_CHUNK_SIZE\n        };\n        // Assign part stats to the loader's stats reference\n        part.stats = loader.stats;\n        loader.load(loaderContext, loaderConfig, {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            _this2.resetLoader(frag, loader);\n            _this2.updateStatsFromPart(frag, part);\n            var partLoadedData = {\n              frag: frag,\n              part: part,\n              payload: response.data,\n              networkDetails: networkDetails\n            };\n            onProgress(partLoadedData);\n            resolve(partLoadedData);\n          },\n          onError: function onError(response, context, networkDetails, stats) {\n            _this2.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.FRAG_LOAD_ERROR,\n              fatal: false,\n              frag: frag,\n              part: part,\n              response: _objectSpread2({\n                url: loaderContext.url,\n                data: undefined\n              }, response),\n              error: new Error(\"HTTP Error \" + response.code + \" \" + response.text),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          },\n          onAbort: function onAbort(stats, context, networkDetails) {\n            frag.stats.aborted = part.stats.aborted;\n            _this2.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.INTERNAL_ABORTED,\n              fatal: false,\n              frag: frag,\n              part: part,\n              error: new Error('Aborted'),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            _this2.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n              fatal: false,\n              frag: frag,\n              part: part,\n              error: new Error(\"Timeout after \" + loaderConfig.timeout + \"ms\"),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          }\n        });\n      });\n    };\n    _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {\n      var fragStats = frag.stats;\n      var partStats = part.stats;\n      var partTotal = partStats.total;\n      fragStats.loaded += partStats.loaded;\n      if (partTotal) {\n        var estTotalParts = Math.round(frag.duration / part.duration);\n        var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n        var estRemainingParts = estTotalParts - estLoadedParts;\n        var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n        fragStats.total = fragStats.loaded + estRemainingBytes;\n      } else {\n        fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n      }\n      var fragLoading = fragStats.loading;\n      var partLoading = partStats.loading;\n      if (fragLoading.start) {\n        // add to fragment loader latency\n        fragLoading.first += partLoading.first - partLoading.start;\n      } else {\n        fragLoading.start = partLoading.start;\n        fragLoading.first = partLoading.first;\n      }\n      fragLoading.end = partLoading.end;\n    };\n    _proto.resetLoader = function resetLoader(frag, loader) {\n      frag.loader = null;\n      if (this.loader === loader) {\n        self.clearTimeout(this.partLoadTimeout);\n        this.loader = null;\n      }\n      loader.destroy();\n    };\n    return FragmentLoader;\n  }();\n  function createLoaderContext(frag, part) {\n    if (part === void 0) {\n      part = null;\n    }\n    var segment = part || frag;\n    var loaderContext = {\n      frag: frag,\n      part: part,\n      responseType: 'arraybuffer',\n      url: segment.url,\n      headers: {},\n      rangeStart: 0,\n      rangeEnd: 0\n    };\n    var start = segment.byteRangeStartOffset;\n    var end = segment.byteRangeEndOffset;\n    if (isFiniteNumber(start) && isFiniteNumber(end)) {\n      var _frag$decryptdata;\n      var byteRangeStart = start;\n      var byteRangeEnd = end;\n      if (frag.sn === 'initSegment' && isMethodFullSegmentAesCbc((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method)) {\n        // MAP segment encrypted with method 'AES-128' or 'AES-256' (cbc), when served with HTTP Range,\n        // has the unencrypted size specified in the range.\n        // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n        var fragmentLen = end - start;\n        if (fragmentLen % 16) {\n          byteRangeEnd = end + (16 - fragmentLen % 16);\n        }\n        if (start !== 0) {\n          loaderContext.resetIV = true;\n          byteRangeStart = start - 16;\n        }\n      }\n      loaderContext.rangeStart = byteRangeStart;\n      loaderContext.rangeEnd = byteRangeEnd;\n    }\n    return loaderContext;\n  }\n  function createGapLoadError(frag, part) {\n    var error = new Error(\"GAP \" + (frag.gap ? 'tag' : 'attribute') + \" found\");\n    var errorData = {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_GAP,\n      fatal: false,\n      frag: frag,\n      error: error,\n      networkDetails: null\n    };\n    if (part) {\n      errorData.part = part;\n    }\n    (part ? part : frag).stats.aborted = true;\n    return new LoadError(errorData);\n  }\n  function isMethodFullSegmentAesCbc(method) {\n    return method === 'AES-128' || method === 'AES-256';\n  }\n  var LoadError = /*#__PURE__*/function (_Error) {\n    function LoadError(data) {\n      var _this3;\n      _this3 = _Error.call(this, data.error.message) || this;\n      _this3.data = void 0;\n      _this3.data = data;\n      return _this3;\n    }\n    _inheritsLoose(LoadError, _Error);\n    return LoadError;\n  }(/*#__PURE__*/_wrapNativeSuper(Error));\n\n  /**\n   * @ignore\n   * Sub-class specialization of EventHandler base class.\n   *\n   * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n   * scheduled asynchroneously, avoiding recursive calls in the same tick.\n   *\n   * The task itself is implemented in `doTick`. It can be requested and called for single execution\n   * using the `tick` method.\n   *\n   * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n   * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n   *\n   * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n   * and cancelled with `clearNextTick`.\n   *\n   * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n   *\n   * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n   *\n   * Further explanations:\n   *\n   * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n   * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n   *\n   * When the task execution (`tick` method) is called in re-entrant way this is detected and\n   * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n   * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n   */\n  var TaskLoop = /*#__PURE__*/function (_Logger) {\n    function TaskLoop(label, logger) {\n      var _this;\n      _this = _Logger.call(this, label, logger) || this;\n      _this._boundTick = void 0;\n      _this._tickTimer = null;\n      _this._tickInterval = null;\n      _this._tickCallCount = 0;\n      _this._boundTick = _this.tick.bind(_this);\n      return _this;\n    }\n    _inheritsLoose(TaskLoop, _Logger);\n    var _proto = TaskLoop.prototype;\n    _proto.destroy = function destroy() {\n      this.onHandlerDestroying();\n      this.onHandlerDestroyed();\n    };\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      // clear all timers before unregistering from event bus\n      this.clearNextTick();\n      this.clearInterval();\n    };\n    _proto.onHandlerDestroyed = function onHandlerDestroyed() {};\n    _proto.hasInterval = function hasInterval() {\n      return !!this._tickInterval;\n    };\n    _proto.hasNextTick = function hasNextTick() {\n      return !!this._tickTimer;\n    }\n\n    /**\n     * @param millis - Interval time (ms)\n     * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n     */;\n    _proto.setInterval = function setInterval(millis) {\n      if (!this._tickInterval) {\n        this._tickCallCount = 0;\n        this._tickInterval = self.setInterval(this._boundTick, millis);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @returns True when interval was cleared, false when none was set (no effect)\n     */;\n    _proto.clearInterval = function clearInterval() {\n      if (this._tickInterval) {\n        self.clearInterval(this._tickInterval);\n        this._tickInterval = null;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @returns True when timeout was cleared, false when none was set (no effect)\n     */;\n    _proto.clearNextTick = function clearNextTick() {\n      if (this._tickTimer) {\n        self.clearTimeout(this._tickTimer);\n        this._tickTimer = null;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Will call the subclass doTick implementation in this main loop tick\n     * or in the next one (via setTimeout(,0)) in case it has already been called\n     * in this tick (in case this is a re-entrant call).\n     */;\n    _proto.tick = function tick() {\n      this._tickCallCount++;\n      if (this._tickCallCount === 1) {\n        this.doTick();\n        // re-entrant call to tick from previous doTick call stack\n        // -> schedule a call on the next main loop iteration to process this task processing request\n        if (this._tickCallCount > 1) {\n          // make sure only one timer exists at any time at max\n          this.tickImmediate();\n        }\n        this._tickCallCount = 0;\n      }\n    };\n    _proto.tickImmediate = function tickImmediate() {\n      this.clearNextTick();\n      this._tickTimer = self.setTimeout(this._boundTick, 0);\n    }\n\n    /**\n     * For subclass to implement task logic\n     * @abstract\n     */;\n    _proto.doTick = function doTick() {};\n    return TaskLoop;\n  }(Logger);\n\n  var ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {\n    if (size === void 0) {\n      size = 0;\n    }\n    if (part === void 0) {\n      part = -1;\n    }\n    if (partial === void 0) {\n      partial = false;\n    }\n    this.level = void 0;\n    this.sn = void 0;\n    this.part = void 0;\n    this.id = void 0;\n    this.size = void 0;\n    this.partial = void 0;\n    this.transmuxing = getNewPerformanceTiming();\n    this.buffering = {\n      audio: getNewPerformanceTiming(),\n      video: getNewPerformanceTiming(),\n      audiovideo: getNewPerformanceTiming()\n    };\n    this.level = level;\n    this.sn = sn;\n    this.id = id;\n    this.size = size;\n    this.part = part;\n    this.partial = partial;\n  };\n  function getNewPerformanceTiming() {\n    return {\n      start: 0,\n      executeStart: 0,\n      executeEnd: 0,\n      end: 0\n    };\n  }\n\n  /**\n   * Provides methods dealing with buffer length retrieval for example.\n   *\n   * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n   *\n   * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n   */\n\n  var noopBuffered = {\n    length: 0,\n    start: function start() {\n      return 0;\n    },\n    end: function end() {\n      return 0;\n    }\n  };\n  var BufferHelper = /*#__PURE__*/function () {\n    function BufferHelper() {}\n    /**\n     * Return true if `media`'s buffered include `position`\n     */\n    BufferHelper.isBuffered = function isBuffered(media, position) {\n      if (media) {\n        var buffered = BufferHelper.getBuffered(media);\n        for (var i = buffered.length; i--;) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    BufferHelper.bufferedRanges = function bufferedRanges(media) {\n      if (media) {\n        var timeRanges = BufferHelper.getBuffered(media);\n        return BufferHelper.timeRangesToArray(timeRanges);\n      }\n      return [];\n    };\n    BufferHelper.timeRangesToArray = function timeRangesToArray(timeRanges) {\n      var buffered = [];\n      for (var i = 0; i < timeRanges.length; i++) {\n        buffered.push({\n          start: timeRanges.start(i),\n          end: timeRanges.end(i)\n        });\n      }\n      return buffered;\n    };\n    BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {\n      if (media) {\n        var buffered = BufferHelper.bufferedRanges(media);\n        if (buffered.length) {\n          return BufferHelper.bufferedInfo(buffered, pos, maxHoleDuration);\n        }\n      }\n      return {\n        len: 0,\n        start: pos,\n        end: pos,\n        bufferedIndex: -1\n      };\n    };\n    BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {\n      pos = Math.max(0, pos);\n      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n      if (buffered.length > 1) {\n        buffered.sort(function (a, b) {\n          return a.start - b.start || b.end - a.end;\n        });\n      }\n      var bufferedIndex = -1;\n      var buffered2 = [];\n      if (maxHoleDuration) {\n        // there might be some small holes between buffer time range\n        // consider that holes smaller than maxHoleDuration are irrelevant and build another\n        // buffer time range representations that discards those holes\n        for (var i = 0; i < buffered.length; i++) {\n          if (pos >= buffered[i].start && pos <= buffered[i].end) {\n            bufferedIndex = i;\n          }\n          var buf2len = buffered2.length;\n          if (buf2len) {\n            var buf2end = buffered2[buf2len - 1].end;\n            // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n            if (buffered[i].start - buf2end < maxHoleDuration) {\n              // merge overlapping time ranges\n              // update lastRange.end only if smaller than item.end\n              // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n              // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n              if (buffered[i].end > buf2end) {\n                buffered2[buf2len - 1].end = buffered[i].end;\n              }\n            } else {\n              // big hole\n              buffered2.push(buffered[i]);\n            }\n          } else {\n            // first value\n            buffered2.push(buffered[i]);\n          }\n        }\n      } else {\n        buffered2 = buffered;\n      }\n      var bufferLen = 0;\n      var nextStart;\n\n      // bufferStart and bufferEnd are buffer boundaries around current playback position (pos)\n      var bufferStart = pos;\n      var bufferEnd = pos;\n      for (var _i = 0; _i < buffered2.length; _i++) {\n        var start = buffered2[_i].start;\n        var end = buffered2[_i].end;\n        // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n        if (bufferedIndex === -1 && pos >= start && pos <= end) {\n          bufferedIndex = _i;\n        }\n        if (pos + maxHoleDuration >= start && pos < end) {\n          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n          bufferStart = start;\n          bufferEnd = end;\n          bufferLen = bufferEnd - pos;\n        } else if (pos + maxHoleDuration < start) {\n          nextStart = start;\n          break;\n        }\n      }\n      return {\n        len: bufferLen,\n        start: bufferStart || 0,\n        end: bufferEnd || 0,\n        nextStart: nextStart,\n        buffered: buffered,\n        bufferedIndex: bufferedIndex\n      };\n    }\n\n    /**\n     * Safe method to get buffered property.\n     * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n     */;\n    BufferHelper.getBuffered = function getBuffered(media) {\n      try {\n        return media.buffered || noopBuffered;\n      } catch (e) {\n        logger.log('failed to get media.buffered', e);\n        return noopBuffered;\n      }\n    };\n    return BufferHelper;\n  }();\n\n  var VARIABLE_REPLACEMENT_REGEX = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\n  function hasVariableReferences(str) {\n    return VARIABLE_REPLACEMENT_REGEX.test(str);\n  }\n  function substituteVariables(parsed, value) {\n    if (parsed.variableList !== null || parsed.hasVariableRefs) {\n      var variableList = parsed.variableList;\n      return value.replace(VARIABLE_REPLACEMENT_REGEX, function (variableReference) {\n        var variableName = variableReference.substring(2, variableReference.length - 1);\n        var variableValue = variableList == null ? void 0 : variableList[variableName];\n        if (variableValue === undefined) {\n          parsed.playlistParsingError || (parsed.playlistParsingError = new Error(\"Missing preceding EXT-X-DEFINE tag for Variable Reference: \\\"\" + variableName + \"\\\"\"));\n          return variableReference;\n        }\n        return variableValue;\n      });\n    }\n    return value;\n  }\n  function addVariableDefinition(parsed, attr, parentUrl) {\n    var variableList = parsed.variableList;\n    if (!variableList) {\n      parsed.variableList = variableList = {};\n    }\n    var NAME;\n    var VALUE;\n    if ('QUERYPARAM' in attr) {\n      NAME = attr.QUERYPARAM;\n      try {\n        var searchParams = new self.URL(parentUrl).searchParams;\n        if (searchParams.has(NAME)) {\n          VALUE = searchParams.get(NAME);\n        } else {\n          throw new Error(\"\\\"\" + NAME + \"\\\" does not match any query parameter in URI: \\\"\" + parentUrl + \"\\\"\");\n        }\n      } catch (error) {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(\"EXT-X-DEFINE QUERYPARAM: \" + error.message));\n      }\n    } else {\n      NAME = attr.NAME;\n      VALUE = attr.VALUE;\n    }\n    if (NAME in variableList) {\n      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(\"EXT-X-DEFINE duplicate Variable Name declarations: \\\"\" + NAME + \"\\\"\"));\n    } else {\n      variableList[NAME] = VALUE || '';\n    }\n  }\n  function importVariableDefinition(parsed, attr, sourceVariableList) {\n    var IMPORT = attr.IMPORT;\n    if (sourceVariableList && IMPORT in sourceVariableList) {\n      var variableList = parsed.variableList;\n      if (!variableList) {\n        parsed.variableList = variableList = {};\n      }\n      variableList[IMPORT] = sourceVariableList[IMPORT];\n    } else {\n      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(\"EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \\\"\" + IMPORT + \"\\\"\"));\n    }\n  }\n\n  var DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\n  var ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n  // adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\n  var AttrList = /*#__PURE__*/function () {\n    function AttrList(attrs, parsed) {\n      if (typeof attrs === 'string') {\n        attrs = AttrList.parseAttrList(attrs, parsed);\n      }\n      _extends(this, attrs);\n    }\n    var _proto = AttrList.prototype;\n    _proto.decimalInteger = function decimalInteger(attrName) {\n      var intValue = parseInt(this[attrName], 10);\n      if (intValue > Number.MAX_SAFE_INTEGER) {\n        return Infinity;\n      }\n      return intValue;\n    };\n    _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {\n      if (this[attrName]) {\n        var stringValue = (this[attrName] || '0x').slice(2);\n        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n        var value = new Uint8Array(stringValue.length / 2);\n        for (var i = 0; i < stringValue.length / 2; i++) {\n          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n        }\n        return value;\n      }\n      return null;\n    };\n    _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {\n      var intValue = parseInt(this[attrName], 16);\n      if (intValue > Number.MAX_SAFE_INTEGER) {\n        return Infinity;\n      }\n      return intValue;\n    };\n    _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {\n      return parseFloat(this[attrName]);\n    };\n    _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {\n      var value = this[attrName];\n      return value ? parseFloat(value) : defaultValue;\n    };\n    _proto.enumeratedString = function enumeratedString(attrName) {\n      return this[attrName];\n    };\n    _proto.enumeratedStringList = function enumeratedStringList(attrName, dict) {\n      var attrValue = this[attrName];\n      return (attrValue ? attrValue.split(/[ ,]+/) : []).reduce(function (result, identifier) {\n        result[identifier.toLowerCase()] = true;\n        return result;\n      }, dict);\n    };\n    _proto.bool = function bool(attrName) {\n      return this[attrName] === 'YES';\n    };\n    _proto.decimalResolution = function decimalResolution(attrName) {\n      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n      if (res === null) {\n        return undefined;\n      }\n      return {\n        width: parseInt(res[1], 10),\n        height: parseInt(res[2], 10)\n      };\n    };\n    AttrList.parseAttrList = function parseAttrList(input, parsed) {\n      var match;\n      var attrs = {};\n      var quote = '\"';\n      ATTR_LIST_REGEX.lastIndex = 0;\n      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n        var name = match[1].trim();\n        var value = match[2];\n        var quotedString = value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1;\n        var hexadecimalSequence = false;\n        if (quotedString) {\n          value = value.slice(1, -1);\n        } else {\n          switch (name) {\n            case 'IV':\n            case 'SCTE35-CMD':\n            case 'SCTE35-IN':\n            case 'SCTE35-OUT':\n              hexadecimalSequence = true;\n          }\n        }\n        if (parsed && (quotedString || hexadecimalSequence)) {\n          {\n            value = substituteVariables(parsed, value);\n          }\n        } else if (!hexadecimalSequence && !quotedString) {\n          switch (name) {\n            case 'CLOSED-CAPTIONS':\n              if (value === 'NONE') {\n                break;\n              }\n            // falls through\n            case 'ALLOWED-CPC':\n            case 'CLASS':\n            case 'ASSOC-LANGUAGE':\n            case 'AUDIO':\n            case 'BYTERANGE':\n            case 'CHANNELS':\n            case 'CHARACTERISTICS':\n            case 'CODECS':\n            case 'DATA-ID':\n            case 'END-DATE':\n            case 'GROUP-ID':\n            case 'ID':\n            case 'IMPORT':\n            case 'INSTREAM-ID':\n            case 'KEYFORMAT':\n            case 'KEYFORMATVERSIONS':\n            case 'LANGUAGE':\n            case 'NAME':\n            case 'PATHWAY-ID':\n            case 'QUERYPARAM':\n            case 'RECENTLY-REMOVED-DATERANGES':\n            case 'SERVER-URI':\n            case 'STABLE-RENDITION-ID':\n            case 'STABLE-VARIANT-ID':\n            case 'START-DATE':\n            case 'SUBTITLES':\n            case 'SUPPLEMENTAL-CODECS':\n            case 'URI':\n            case 'VALUE':\n            case 'VIDEO':\n            case 'X-ASSET-LIST':\n            case 'X-ASSET-URI':\n              // Since we are not checking tag:attribute combination, just warn rather than ignoring attribute\n              logger.warn(input + \": attribute \" + name + \" is missing quotes\");\n            // continue;\n          }\n        }\n        attrs[name] = value;\n      }\n      return attrs;\n    };\n    return _createClass(AttrList, [{\n      key: \"clientAttrs\",\n      get: function get() {\n        return Object.keys(this).filter(function (attr) {\n          return attr.substring(0, 2) === 'X-';\n        });\n      }\n    }]);\n  }();\n\n  // Avoid exporting const enum so that these values can be inlined\n\n  var CLASS_INTERSTITIAL = 'com.apple.hls.interstitial';\n  function isDateRangeCueAttribute(attrName) {\n    return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"CUE\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n  }\n  function isSCTE35Attribute(attrName) {\n    return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\" || attrName === \"SCTE35-CMD\";\n  }\n  var DateRange = /*#__PURE__*/function () {\n    function DateRange(dateRangeAttr, dateRangeWithSameId, tagCount) {\n      var _dateRangeWithSameId$;\n      if (tagCount === void 0) {\n        tagCount = 0;\n      }\n      this.attr = void 0;\n      this.tagAnchor = void 0;\n      this.tagOrder = void 0;\n      this._startDate = void 0;\n      this._endDate = void 0;\n      this._dateAtEnd = void 0;\n      this._cue = void 0;\n      this._badValueForSameId = void 0;\n      this.tagAnchor = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagAnchor) || null;\n      this.tagOrder = (_dateRangeWithSameId$ = dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.tagOrder) != null ? _dateRangeWithSameId$ : tagCount;\n      if (dateRangeWithSameId) {\n        var previousAttr = dateRangeWithSameId.attr;\n        for (var key in previousAttr) {\n          if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n            logger.warn(\"DATERANGE tag attribute: \\\"\" + key + \"\\\" does not match for tags with ID: \\\"\" + dateRangeAttr.ID + \"\\\"\");\n            this._badValueForSameId = key;\n            break;\n          }\n        }\n        // Merge DateRange tags with the same ID\n        dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n      }\n      this.attr = dateRangeAttr;\n      if (dateRangeWithSameId) {\n        this._startDate = dateRangeWithSameId._startDate;\n        this._cue = dateRangeWithSameId._cue;\n        this._endDate = dateRangeWithSameId._endDate;\n        this._dateAtEnd = dateRangeWithSameId._dateAtEnd;\n      } else {\n        this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n      }\n      if (\"END-DATE\" in this.attr) {\n        var endDate = (dateRangeWithSameId == null ? void 0 : dateRangeWithSameId.endDate) || new Date(this.attr[\"END-DATE\"]);\n        if (isFiniteNumber(endDate.getTime())) {\n          this._endDate = endDate;\n        }\n      }\n    }\n    return _createClass(DateRange, [{\n      key: \"id\",\n      get: function get() {\n        return this.attr.ID;\n      }\n    }, {\n      key: \"class\",\n      get: function get() {\n        return this.attr.CLASS;\n      }\n    }, {\n      key: \"cue\",\n      get: function get() {\n        var _cue = this._cue;\n        if (_cue === undefined) {\n          return this._cue = this.attr.enumeratedStringList(this.attr.CUE ? 'CUE' : 'X-CUE', {\n            pre: false,\n            post: false,\n            once: false\n          });\n        }\n        return _cue;\n      }\n    }, {\n      key: \"startTime\",\n      get: function get() {\n        var tagAnchor = this.tagAnchor;\n        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n        if (tagAnchor === null || tagAnchor.programDateTime === null) {\n          logger.warn(\"Expected tagAnchor Fragment with PDT set for DateRange \\\"\" + this.id + \"\\\": \" + tagAnchor);\n          return NaN;\n        }\n        return tagAnchor.start + (this.startDate.getTime() - tagAnchor.programDateTime) / 1000;\n      }\n    }, {\n      key: \"startDate\",\n      get: function get() {\n        return this._startDate;\n      }\n    }, {\n      key: \"endDate\",\n      get: function get() {\n        var dateAtEnd = this._endDate || this._dateAtEnd;\n        if (dateAtEnd) {\n          return dateAtEnd;\n        }\n        var duration = this.duration;\n        if (duration !== null) {\n          return this._dateAtEnd = new Date(this._startDate.getTime() + duration * 1000);\n        }\n        return null;\n      }\n    }, {\n      key: \"duration\",\n      get: function get() {\n        if (\"DURATION\" in this.attr) {\n          var duration = this.attr.decimalFloatingPoint(\"DURATION\");\n          if (isFiniteNumber(duration)) {\n            return duration;\n          }\n        } else if (this._endDate) {\n          return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n        }\n        return null;\n      }\n    }, {\n      key: \"plannedDuration\",\n      get: function get() {\n        if (\"PLANNED-DURATION\" in this.attr) {\n          return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n        }\n        return null;\n      }\n    }, {\n      key: \"endOnNext\",\n      get: function get() {\n        return this.attr.bool(\"END-ON-NEXT\");\n      }\n    }, {\n      key: \"isInterstitial\",\n      get: function get() {\n        return this.class === CLASS_INTERSTITIAL;\n      }\n    }, {\n      key: \"isValid\",\n      get: function get() {\n        return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || 'X-ASSET-URI' in this.attr || 'X-ASSET-LIST' in this.attr);\n      }\n    }]);\n  }();\n\n  var DEFAULT_TARGET_DURATION = 10;\n\n  /**\n   * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n   */\n  var LevelDetails = /*#__PURE__*/function () {\n    function LevelDetails(baseUrl) {\n      this.PTSKnown = false;\n      this.alignedSliding = false;\n      this.averagetargetduration = void 0;\n      this.endCC = 0;\n      this.endSN = 0;\n      this.fragments = void 0;\n      this.fragmentHint = void 0;\n      this.partList = null;\n      this.dateRanges = void 0;\n      this.dateRangeTagCount = 0;\n      this.live = true;\n      this.requestScheduled = -1;\n      this.ageHeader = 0;\n      this.advancedDateTime = void 0;\n      this.updated = true;\n      this.advanced = true;\n      this.misses = 0;\n      this.startCC = 0;\n      this.startSN = 0;\n      this.startTimeOffset = null;\n      this.targetduration = 0;\n      this.totalduration = 0;\n      this.type = null;\n      this.url = void 0;\n      this.m3u8 = '';\n      this.version = null;\n      this.canBlockReload = false;\n      this.canSkipUntil = 0;\n      this.canSkipDateRanges = false;\n      this.skippedSegments = 0;\n      this.recentlyRemovedDateranges = void 0;\n      this.partHoldBack = 0;\n      this.holdBack = 0;\n      this.partTarget = 0;\n      this.preloadHint = void 0;\n      this.renditionReports = void 0;\n      this.tuneInGoal = 0;\n      this.deltaUpdateFailed = void 0;\n      this.driftStartTime = 0;\n      this.driftEndTime = 0;\n      this.driftStart = 0;\n      this.driftEnd = 0;\n      this.encryptedFragments = void 0;\n      this.playlistParsingError = null;\n      this.variableList = null;\n      this.hasVariableRefs = false;\n      this.appliedTimelineOffset = void 0;\n      this.fragments = [];\n      this.encryptedFragments = [];\n      this.dateRanges = {};\n      this.url = baseUrl;\n    }\n    var _proto = LevelDetails.prototype;\n    _proto.reloaded = function reloaded(previous) {\n      if (!previous) {\n        this.advanced = true;\n        this.updated = true;\n        return;\n      }\n      var partSnDiff = this.lastPartSn - previous.lastPartSn;\n      var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n      this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;\n      this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n      if (this.updated || this.advanced) {\n        this.misses = Math.floor(previous.misses * 0.6);\n      } else {\n        this.misses = previous.misses + 1;\n      }\n    };\n    _proto.hasKey = function hasKey(levelKey) {\n      return this.encryptedFragments.some(function (frag) {\n        var decryptdata = frag.decryptdata;\n        if (!decryptdata) {\n          frag.setKeyFormat(levelKey.keyFormat);\n          decryptdata = frag.decryptdata;\n        }\n        return !!decryptdata && levelKey.matches(decryptdata);\n      });\n    };\n    return _createClass(LevelDetails, [{\n      key: \"hasProgramDateTime\",\n      get: function get() {\n        if (this.fragments.length) {\n          return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n        }\n        return false;\n      }\n    }, {\n      key: \"levelTargetDuration\",\n      get: function get() {\n        return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n      }\n    }, {\n      key: \"drift\",\n      get: function get() {\n        var runTime = this.driftEndTime - this.driftStartTime;\n        if (runTime > 0) {\n          var runDuration = this.driftEnd - this.driftStart;\n          return runDuration * 1000 / runTime;\n        }\n        return 1;\n      }\n    }, {\n      key: \"edge\",\n      get: function get() {\n        return this.partEnd || this.fragmentEnd;\n      }\n    }, {\n      key: \"partEnd\",\n      get: function get() {\n        var _this$partList;\n        if ((_this$partList = this.partList) != null && _this$partList.length) {\n          return this.partList[this.partList.length - 1].end;\n        }\n        return this.fragmentEnd;\n      }\n    }, {\n      key: \"fragmentEnd\",\n      get: function get() {\n        if (this.fragments.length) {\n          return this.fragments[this.fragments.length - 1].end;\n        }\n        return 0;\n      }\n    }, {\n      key: \"fragmentStart\",\n      get: function get() {\n        if (this.fragments.length) {\n          return this.fragments[0].start;\n        }\n        return 0;\n      }\n    }, {\n      key: \"age\",\n      get: function get() {\n        if (this.advancedDateTime) {\n          return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n        }\n        return 0;\n      }\n    }, {\n      key: \"lastPartIndex\",\n      get: function get() {\n        var _this$partList2;\n        if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n          return this.partList[this.partList.length - 1].index;\n        }\n        return -1;\n      }\n    }, {\n      key: \"maxPartIndex\",\n      get: function get() {\n        var partList = this.partList;\n        if (partList) {\n          var lastIndex = this.lastPartIndex;\n          if (lastIndex !== -1) {\n            for (var i = partList.length; i--;) {\n              if (partList[i].index > lastIndex) {\n                return partList[i].index;\n              }\n            }\n            return lastIndex;\n          }\n        }\n        return 0;\n      }\n    }, {\n      key: \"lastPartSn\",\n      get: function get() {\n        var _this$partList3;\n        if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n          return this.partList[this.partList.length - 1].fragment.sn;\n        }\n        return this.endSN;\n      }\n    }, {\n      key: \"expired\",\n      get: function get() {\n        if (this.live && this.age && this.misses < 3) {\n          var playlistWindowDuration = this.partEnd - this.fragmentStart;\n          return this.age > Math.max(playlistWindowDuration, this.totalduration) + this.levelTargetDuration;\n        }\n        return false;\n      }\n    }]);\n  }();\n\n  function arrayValuesMatch(a, b) {\n    if (a.length === b.length) {\n      return !a.some(function (value, i) {\n        return value !== b[i];\n      });\n    }\n    return false;\n  }\n  function optionalArrayValuesMatch(a, b) {\n    if (!a && !b) {\n      return true;\n    }\n    if (!a || !b) {\n      return false;\n    }\n    return arrayValuesMatch(a, b);\n  }\n\n  function isFullSegmentEncryption(method) {\n    return method === 'AES-128' || method === 'AES-256' || method === 'AES-256-CTR';\n  }\n  function getAesModeFromFullSegmentMethod(method) {\n    switch (method) {\n      case 'AES-128':\n      case 'AES-256':\n        return DecrypterAesMode.cbc;\n      case 'AES-256-CTR':\n        return DecrypterAesMode.ctr;\n      default:\n        throw new Error(\"invalid full segment method \" + method);\n    }\n  }\n\n  function base64Decode(base64encodedStr) {\n    return Uint8Array.from(atob(base64encodedStr), function (c) {\n      return c.charCodeAt(0);\n    });\n  }\n\n  // breaking up those two types in order to clarify what is happening in the decoding path.\n\n  // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n  // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n  /* utf.js - UTF-8 <=> UTF-16 convertion\n   *\n   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n   * Version: 1.0\n   * LastModified: Dec 25 1999\n   * This library is free.  You can redistribute it and/or modify it.\n   */\n\n  function strToUtf8array(str) {\n    return Uint8Array.from(unescape(encodeURIComponent(str)), function (c) {\n      return c.charCodeAt(0);\n    });\n  }\n\n  function getKeyIdBytes(str) {\n    var keyIdbytes = strToUtf8array(str).subarray(0, 16);\n    var paddedkeyIdbytes = new Uint8Array(16);\n    paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n    return paddedkeyIdbytes;\n  }\n  function changeEndianness(keyId) {\n    var swap = function swap(array, from, to) {\n      var cur = array[from];\n      array[from] = array[to];\n      array[to] = cur;\n    };\n    swap(keyId, 0, 3);\n    swap(keyId, 1, 2);\n    swap(keyId, 4, 5);\n    swap(keyId, 6, 7);\n  }\n  function convertDataUriToArrayBytes(uri) {\n    // data:[<media type][;attribute=value][;base64],<data>\n    var colonsplit = uri.split(':');\n    var keydata = null;\n    if (colonsplit[0] === 'data' && colonsplit.length === 2) {\n      var semicolonsplit = colonsplit[1].split(';');\n      var commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');\n      if (commasplit.length === 2) {\n        var isbase64 = commasplit[0] === 'base64';\n        var data = commasplit[1];\n        if (isbase64) {\n          semicolonsplit.splice(-1, 1); // remove from processing\n          keydata = base64Decode(data);\n        } else {\n          keydata = getKeyIdBytes(data);\n        }\n      }\n    }\n    return keydata;\n  }\n\n  /** returns `undefined` is `self` is missing, e.g. in node */\n  var optionalSelf = typeof self !== 'undefined' ? self : undefined;\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n   */\n  var KeySystems = {\n    CLEARKEY: \"org.w3.clearkey\",\n    FAIRPLAY: \"com.apple.fps\",\n    PLAYREADY: \"com.microsoft.playready\",\n    WIDEVINE: \"com.widevine.alpha\"\n  };\n\n  // Playlist #EXT-X-KEY KEYFORMAT values\n  var KeySystemFormats = {\n    CLEARKEY: \"org.w3.clearkey\",\n    FAIRPLAY: \"com.apple.streamingkeydelivery\",\n    PLAYREADY: \"com.microsoft.playready\",\n    WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n  };\n  function keySystemFormatToKeySystemDomain(format) {\n    switch (format) {\n      case KeySystemFormats.FAIRPLAY:\n        return KeySystems.FAIRPLAY;\n      case KeySystemFormats.PLAYREADY:\n        return KeySystems.PLAYREADY;\n      case KeySystemFormats.WIDEVINE:\n        return KeySystems.WIDEVINE;\n      case KeySystemFormats.CLEARKEY:\n        return KeySystems.CLEARKEY;\n    }\n  }\n  function keySystemDomainToKeySystemFormat(keySystem) {\n    switch (keySystem) {\n      case KeySystems.FAIRPLAY:\n        return KeySystemFormats.FAIRPLAY;\n      case KeySystems.PLAYREADY:\n        return KeySystemFormats.PLAYREADY;\n      case KeySystems.WIDEVINE:\n        return KeySystemFormats.WIDEVINE;\n      case KeySystems.CLEARKEY:\n        return KeySystemFormats.CLEARKEY;\n    }\n  }\n  function getKeySystemsForConfig(config) {\n    var drmSystems = config.drmSystems,\n      widevineLicenseUrl = config.widevineLicenseUrl;\n    var keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(function (keySystem) {\n      return !!drmSystems[keySystem];\n    }) : [];\n    if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n      keySystemsToAttempt.push(KeySystems.WIDEVINE);\n    }\n    return keySystemsToAttempt;\n  }\n  var requestMediaKeySystemAccess = function (_optionalSelf$navigat) {\n    if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {\n      return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n    } else {\n      return null;\n    }\n  }();\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n   */\n  function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n    var initDataTypes;\n    switch (keySystem) {\n      case KeySystems.FAIRPLAY:\n        initDataTypes = ['cenc', 'sinf'];\n        break;\n      case KeySystems.WIDEVINE:\n      case KeySystems.PLAYREADY:\n        initDataTypes = ['cenc'];\n        break;\n      case KeySystems.CLEARKEY:\n        initDataTypes = ['cenc', 'keyids'];\n        break;\n      default:\n        throw new Error(\"Unknown key-system: \" + keySystem);\n    }\n    return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n  }\n  function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n    var baseConfig = {\n      initDataTypes: initDataTypes,\n      persistentState: drmSystemOptions.persistentState || 'optional',\n      distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'optional',\n      sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],\n      audioCapabilities: audioCodecs.map(function (codec) {\n        return {\n          contentType: \"audio/mp4; codecs=\" + codec,\n          robustness: drmSystemOptions.audioRobustness || '',\n          encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n        };\n      }),\n      videoCapabilities: videoCodecs.map(function (codec) {\n        return {\n          contentType: \"video/mp4; codecs=\" + codec,\n          robustness: drmSystemOptions.videoRobustness || '',\n          encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n        };\n      })\n    };\n    return [baseConfig];\n  }\n  function isPersistentSessionType(drmSystemOptions) {\n    var _drmSystemOptions$ses;\n    return !!drmSystemOptions && (drmSystemOptions.sessionType === 'persistent-license' || !!((_drmSystemOptions$ses = drmSystemOptions.sessionTypes) != null && _drmSystemOptions$ses.some(function (type) {\n      return type === 'persistent-license';\n    })));\n  }\n  function parsePlayReadyWRM(keyBytes) {\n    var keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n    var keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n\n    // Parse Playready WRMHeader XML\n    var xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);\n    var parser = new DOMParser();\n    var xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');\n    var keyData = xmlDoc.getElementsByTagName('KID')[0];\n    if (keyData) {\n      var keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');\n      if (keyId) {\n        var keyIdArray = base64Decode(keyId).subarray(0, 16);\n        // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n        // KID value in tenc is a big endian UUID GUID interpretation of UUID\n        changeEndianness(keyIdArray);\n        return keyIdArray;\n      }\n    }\n    return null;\n  }\n\n  var keyUriToKeyIdMap = {};\n  var LevelKey = /*#__PURE__*/function () {\n    function LevelKey(method, uri, format, formatversions, iv, keyId) {\n      if (formatversions === void 0) {\n        formatversions = [1];\n      }\n      if (iv === void 0) {\n        iv = null;\n      }\n      this.uri = void 0;\n      this.method = void 0;\n      this.keyFormat = void 0;\n      this.keyFormatVersions = void 0;\n      this.encrypted = void 0;\n      this.isCommonEncryption = void 0;\n      this.iv = null;\n      this.key = null;\n      this.keyId = null;\n      this.pssh = null;\n      this.method = method;\n      this.uri = uri;\n      this.keyFormat = format;\n      this.keyFormatVersions = formatversions;\n      this.iv = iv;\n      this.encrypted = method ? method !== 'NONE' : false;\n      this.isCommonEncryption = this.encrypted && !isFullSegmentEncryption(method);\n      if (keyId != null && keyId.startsWith('0x')) {\n        this.keyId = new Uint8Array(hexToArrayBuffer(keyId));\n      }\n    }\n    LevelKey.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {\n      keyUriToKeyIdMap = {};\n    };\n    LevelKey.setKeyIdForUri = function setKeyIdForUri(uri, keyId) {\n      keyUriToKeyIdMap[uri] = keyId;\n    };\n    LevelKey.addKeyIdForUri = function addKeyIdForUri(uri) {\n      var val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n      var keyId = new Uint8Array(16);\n      var dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes\n      dv.setUint32(0, val);\n      keyUriToKeyIdMap[uri] = keyId;\n      return keyId;\n    };\n    var _proto = LevelKey.prototype;\n    _proto.matches = function matches(key) {\n      return key.uri === this.uri && key.method === this.method && key.encrypted === this.encrypted && key.keyFormat === this.keyFormat && arrayValuesMatch(key.keyFormatVersions, this.keyFormatVersions) && optionalArrayValuesMatch(key.iv, this.iv) && optionalArrayValuesMatch(key.keyId, this.keyId);\n    };\n    _proto.isSupported = function isSupported() {\n      // If it's Segment encryption or No encryption, just select that key system\n      if (this.method) {\n        if (isFullSegmentEncryption(this.method) || this.method === 'NONE') {\n          return true;\n        }\n        if (this.keyFormat === 'identity') {\n          // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n          return this.method === 'SAMPLE-AES';\n        } else {\n          switch (this.keyFormat) {\n            case KeySystemFormats.FAIRPLAY:\n            case KeySystemFormats.WIDEVINE:\n            case KeySystemFormats.PLAYREADY:\n            case KeySystemFormats.CLEARKEY:\n              return ['SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;\n          }\n        }\n      }\n      return false;\n    };\n    _proto.getDecryptData = function getDecryptData(sn, levelKeys) {\n      if (!this.encrypted || !this.uri) {\n        return null;\n      }\n      if (isFullSegmentEncryption(this.method)) {\n        var iv = this.iv;\n        if (!iv) {\n          if (typeof sn !== 'number') {\n            // We are fetching decryption data for a initialization segment\n            // If the segment was encrypted with AES-128/256\n            // It must have an IV defined. We cannot substitute the Segment Number in.\n            logger.warn(\"missing IV for initialization segment with method=\\\"\" + this.method + \"\\\" - compliance issue\");\n\n            // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n            sn = 0;\n          }\n          iv = createInitializationVector(sn);\n        }\n        var decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n        return decryptdata;\n      }\n      if (this.keyId) {\n        // Handle case where key id is changed in KEY_LOADING event handler #7542#issuecomment-3305203929\n        var assignedKeyId = keyUriToKeyIdMap[this.uri];\n        if (assignedKeyId && !arrayValuesMatch(this.keyId, assignedKeyId)) {\n          LevelKey.setKeyIdForUri(this.uri, this.keyId);\n        }\n        if (this.pssh) {\n          return this;\n        }\n      }\n\n      // Key bytes are signalled the KEYID attribute, typically only found on WideVine KEY tags\n      // Initialize keyId if possible\n      var keyBytes = convertDataUriToArrayBytes(this.uri);\n      if (keyBytes) {\n        switch (this.keyFormat) {\n          case KeySystemFormats.WIDEVINE:\n            // Setting `pssh` on this LevelKey/DecryptData allows HLS.js to generate a session using\n            // the playlist-key before the \"encrypted\" event. (Comment out to only use \"encrypted\" path.)\n            this.pssh = keyBytes;\n            // In case of Widevine, if KEYID is not in the playlist, assume only two fields in the pssh KEY tag URI.\n            if (!this.keyId) {\n              var results = parseMultiPssh(keyBytes.buffer);\n              if (results.length) {\n                var _psshData$kids;\n                var psshData = results[0];\n                this.keyId = (_psshData$kids = psshData.kids) != null && _psshData$kids.length ? psshData.kids[0] : null;\n              }\n            }\n            if (!this.keyId) {\n              this.keyId = getKeyIdFromPlayReadyKey(levelKeys);\n            }\n            break;\n          case KeySystemFormats.PLAYREADY:\n            {\n              var PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);\n\n              // Setting `pssh` on this LevelKey/DecryptData allows HLS.js to generate a session using\n              // the playlist-key before the \"encrypted\" event. (Comment out to only use \"encrypted\" path.)\n              this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);\n              this.keyId = parsePlayReadyWRM(keyBytes);\n              break;\n            }\n          default:\n            {\n              var keydata = keyBytes.subarray(0, 16);\n              if (keydata.length !== 16) {\n                var padded = new Uint8Array(16);\n                padded.set(keydata, 16 - keydata.length);\n                keydata = padded;\n              }\n              this.keyId = keydata;\n              break;\n            }\n        }\n      }\n\n      // Default behavior: get keyId from other KEY tag or URI lookup\n      if (!this.keyId || this.keyId.byteLength !== 16) {\n        var keyId;\n        keyId = getKeyIdFromWidevineKey(levelKeys);\n        if (!keyId) {\n          keyId = getKeyIdFromPlayReadyKey(levelKeys);\n          if (!keyId) {\n            keyId = keyUriToKeyIdMap[this.uri];\n          }\n        }\n        if (keyId) {\n          this.keyId = keyId;\n          LevelKey.setKeyIdForUri(this.uri, keyId);\n        }\n      }\n      return this;\n    };\n    return LevelKey;\n  }();\n  function getKeyIdFromWidevineKey(levelKeys) {\n    var widevineKey = levelKeys == null ? void 0 : levelKeys[KeySystemFormats.WIDEVINE];\n    if (widevineKey) {\n      return widevineKey.keyId;\n    }\n    return null;\n  }\n  function getKeyIdFromPlayReadyKey(levelKeys) {\n    var playReadyKey = levelKeys == null ? void 0 : levelKeys[KeySystemFormats.PLAYREADY];\n    if (playReadyKey) {\n      var playReadyKeyBytes = convertDataUriToArrayBytes(playReadyKey.uri);\n      if (playReadyKeyBytes) {\n        return parsePlayReadyWRM(playReadyKeyBytes);\n      }\n    }\n    return null;\n  }\n  function createInitializationVector(segmentNumber) {\n    var uint8View = new Uint8Array(16);\n    for (var i = 12; i < 16; i++) {\n      uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n    }\n    return uint8View;\n  }\n\n  var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\n  var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\n  var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\n  var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n  /(?!#) *(\\S[^\\r\\n]*)/.source,\n  // segment URI, group 3 => the URI (note newline is not eaten)\n  /#.*/.source // All other non-segment oriented tags will match with all groups empty\n  ].join('|'), 'g');\n  var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\n  var M3U8Parser = /*#__PURE__*/function () {\n    function M3U8Parser() {}\n    M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {\n      for (var i = 0; i < groups.length; i++) {\n        var group = groups[i];\n        if (group.id === mediaGroupId) {\n          return group;\n        }\n      }\n    };\n    M3U8Parser.resolve = function resolve(url, baseUrl) {\n      return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n        alwaysNormalize: true\n      });\n    };\n    M3U8Parser.isMediaPlaylist = function isMediaPlaylist(str) {\n      return IS_MEDIA_PLAYLIST.test(str);\n    };\n    M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {\n      var hasVariableRefs = hasVariableReferences(string) ;\n      var parsed = {\n        contentSteering: null,\n        levels: [],\n        playlistParsingError: null,\n        sessionData: null,\n        sessionKeys: null,\n        startTimeOffset: null,\n        variableList: null,\n        hasVariableRefs: hasVariableRefs\n      };\n      var levelsWithKnownCodecs = [];\n      MASTER_PLAYLIST_REGEX.lastIndex = 0;\n      if (!string.startsWith('#EXTM3U')) {\n        parsed.playlistParsingError = new Error('no EXTM3U delimiter');\n        return parsed;\n      }\n      var result;\n      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n        if (result[1]) {\n          var _level$unknownCodecs;\n          // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n          var attrs = new AttrList(result[1], parsed);\n          var uri = substituteVariables(parsed, result[2]) ;\n          var level = {\n            attrs: attrs,\n            bitrate: attrs.decimalInteger('BANDWIDTH') || attrs.decimalInteger('AVERAGE-BANDWIDTH'),\n            name: attrs.NAME,\n            url: M3U8Parser.resolve(uri, baseurl)\n          };\n          var resolution = attrs.decimalResolution('RESOLUTION');\n          if (resolution) {\n            level.width = resolution.width;\n            level.height = resolution.height;\n          }\n          setCodecs(attrs.CODECS, level);\n          var supplementalCodecs = attrs['SUPPLEMENTAL-CODECS'];\n          if (supplementalCodecs) {\n            level.supplemental = {};\n            setCodecs(supplementalCodecs, level.supplemental);\n          }\n          if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n            levelsWithKnownCodecs.push(level);\n          }\n          parsed.levels.push(level);\n        } else if (result[3]) {\n          var tag = result[3];\n          var attributes = result[4];\n          switch (tag) {\n            case 'SESSION-DATA':\n              {\n                // #EXT-X-SESSION-DATA\n                var sessionAttrs = new AttrList(attributes, parsed);\n                var dataId = sessionAttrs['DATA-ID'];\n                if (dataId) {\n                  if (parsed.sessionData === null) {\n                    parsed.sessionData = {};\n                  }\n                  parsed.sessionData[dataId] = sessionAttrs;\n                }\n                break;\n              }\n            case 'SESSION-KEY':\n              {\n                // #EXT-X-SESSION-KEY\n                var sessionKey = parseKey(attributes, baseurl, parsed);\n                if (sessionKey.encrypted && sessionKey.isSupported()) {\n                  if (parsed.sessionKeys === null) {\n                    parsed.sessionKeys = [];\n                  }\n                  parsed.sessionKeys.push(sessionKey);\n                } else {\n                  logger.warn(\"[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \\\"\" + attributes + \"\\\"\");\n                }\n                break;\n              }\n            case 'DEFINE':\n              {\n                // #EXT-X-DEFINE\n                {\n                  var variableAttributes = new AttrList(attributes, parsed);\n                  addVariableDefinition(parsed, variableAttributes, baseurl);\n                }\n                break;\n              }\n            case 'CONTENT-STEERING':\n              {\n                // #EXT-X-CONTENT-STEERING\n                var contentSteeringAttributes = new AttrList(attributes, parsed);\n                parsed.contentSteering = {\n                  uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                  pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n                };\n                break;\n              }\n            case 'START':\n              {\n                // #EXT-X-START\n                parsed.startTimeOffset = parseStartTimeOffset(attributes);\n                break;\n              }\n          }\n        }\n      }\n      // Filter out levels with unknown codecs if it does not remove all levels\n      var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n      parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n      if (parsed.levels.length === 0) {\n        parsed.playlistParsingError = new Error('no levels found in manifest');\n      }\n      return parsed;\n    };\n    M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, parsed) {\n      var result;\n      var results = {};\n      var levels = parsed.levels;\n      var groupsByType = {\n        AUDIO: levels.map(function (level) {\n          return {\n            id: level.attrs.AUDIO,\n            audioCodec: level.audioCodec\n          };\n        }),\n        SUBTITLES: levels.map(function (level) {\n          return {\n            id: level.attrs.SUBTITLES,\n            textCodec: level.textCodec\n          };\n        }),\n        'CLOSED-CAPTIONS': []\n      };\n      var id = 0;\n      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n        var attrs = new AttrList(result[1], parsed);\n        var type = attrs.TYPE;\n        if (type) {\n          var groups = groupsByType[type];\n          var medias = results[type] || [];\n          results[type] = medias;\n          var lang = attrs.LANGUAGE;\n          var assocLang = attrs['ASSOC-LANGUAGE'];\n          var channels = attrs.CHANNELS;\n          var characteristics = attrs.CHARACTERISTICS;\n          var instreamId = attrs['INSTREAM-ID'];\n          var media = {\n            attrs: attrs,\n            bitrate: 0,\n            id: id++,\n            groupId: attrs['GROUP-ID'] || '',\n            name: attrs.NAME || lang || '',\n            type: type,\n            default: attrs.bool('DEFAULT'),\n            autoselect: attrs.bool('AUTOSELECT'),\n            forced: attrs.bool('FORCED'),\n            lang: lang,\n            url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n          };\n          if (assocLang) {\n            media.assocLang = assocLang;\n          }\n          if (channels) {\n            media.channels = channels;\n          }\n          if (characteristics) {\n            media.characteristics = characteristics;\n          }\n          if (instreamId) {\n            media.instreamId = instreamId;\n          }\n          if (groups != null && groups.length) {\n            // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n            // If we don't find the track signalled, lets use the first audio groups codec we have\n            // Acting as a best guess\n            var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n            assignCodec(media, groupCodec, 'audioCodec');\n            assignCodec(media, groupCodec, 'textCodec');\n          }\n          medias.push(media);\n        }\n      }\n      return results;\n    };\n    M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n      var _LEVEL_PLAYLIST_REGEX;\n      var base = {\n        url: baseurl\n      };\n      var level = new LevelDetails(baseurl);\n      var fragments = level.fragments;\n      var programDateTimes = [];\n      // The most recent init segment seen (applies to all subsequent segments)\n      var currentInitSegment = null;\n      var currentSN = 0;\n      var currentPart = 0;\n      var totalduration = 0;\n      var discontinuityCounter = 0;\n      var currentBitrate = 0;\n      var prevFrag = null;\n      var frag = new Fragment(type, base);\n      var result;\n      var i;\n      var levelkeys;\n      var firstPdtIndex = -1;\n      var createNextFrag = false;\n      var nextByteRange = null;\n      var serverControlAttrs;\n      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n      level.m3u8 = string;\n      level.hasVariableRefs = hasVariableReferences(string) ;\n      if (((_LEVEL_PLAYLIST_REGEX = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) == null ? void 0 : _LEVEL_PLAYLIST_REGEX[0]) !== '#EXTM3U') {\n        level.playlistParsingError = new Error('Missing format identifier #EXTM3U');\n        return level;\n      }\n      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n        if (createNextFrag) {\n          createNextFrag = false;\n          frag = new Fragment(type, base);\n          // setup the next fragment for part loading\n          frag.playlistOffset = totalduration;\n          frag.setStart(totalduration);\n          frag.sn = currentSN;\n          frag.cc = discontinuityCounter;\n          if (currentBitrate) {\n            frag.bitrate = currentBitrate;\n          }\n          frag.level = id;\n          if (currentInitSegment) {\n            frag.initSegment = currentInitSegment;\n            if (currentInitSegment.rawProgramDateTime) {\n              frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n              currentInitSegment.rawProgramDateTime = null;\n            }\n            if (nextByteRange) {\n              frag.setByteRange(nextByteRange);\n              nextByteRange = null;\n            }\n          }\n        }\n        var duration = result[1];\n        if (duration) {\n          // INF\n          frag.duration = parseFloat(duration);\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          var title = (' ' + result[2]).slice(1);\n          frag.title = title || null;\n          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n        } else if (result[3]) {\n          // url\n          if (isFiniteNumber(frag.duration)) {\n            frag.playlistOffset = totalduration;\n            frag.setStart(totalduration);\n            if (levelkeys) {\n              setFragLevelKeys(frag, levelkeys, level);\n            }\n            frag.sn = currentSN;\n            frag.level = id;\n            frag.cc = discontinuityCounter;\n            fragments.push(frag);\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            var uri = (' ' + result[3]).slice(1);\n            frag.relurl = substituteVariables(level, uri) ;\n            assignProgramDateTime(frag, prevFrag, programDateTimes);\n            prevFrag = frag;\n            totalduration += frag.duration;\n            currentSN++;\n            currentPart = 0;\n            createNextFrag = true;\n          }\n        } else {\n          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n          if (!result) {\n            logger.warn('No matches on slow regex match for level playlist!');\n            continue;\n          }\n          for (i = 1; i < result.length; i++) {\n            if (result[i] !== undefined) {\n              break;\n            }\n          }\n\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          var tag = (' ' + result[i]).slice(1);\n          var value1 = (' ' + result[i + 1]).slice(1);\n          var value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : null;\n          switch (tag) {\n            case 'BYTERANGE':\n              if (prevFrag) {\n                frag.setByteRange(value1, prevFrag);\n              } else {\n                frag.setByteRange(value1);\n              }\n              break;\n            case 'PROGRAM-DATE-TIME':\n              // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n              frag.rawProgramDateTime = value1;\n              frag.tagList.push(['PROGRAM-DATE-TIME', value1]);\n              if (firstPdtIndex === -1) {\n                firstPdtIndex = fragments.length;\n              }\n              break;\n            case 'PLAYLIST-TYPE':\n              if (level.type) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              level.type = value1.toUpperCase();\n              break;\n            case 'MEDIA-SEQUENCE':\n              if (level.startSN !== 0) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              } else if (fragments.length > 0) {\n                assignMustAppearBeforeSegmentsError(level, tag, result);\n              }\n              currentSN = level.startSN = parseInt(value1);\n              break;\n            case 'SKIP':\n              {\n                if (level.skippedSegments) {\n                  assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n                }\n                var skipAttrs = new AttrList(value1, level);\n                var skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n                if (isFiniteNumber(skippedSegments)) {\n                  level.skippedSegments += skippedSegments;\n                  // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                  for (var _i = skippedSegments; _i--;) {\n                    fragments.push(null);\n                  }\n                  currentSN += skippedSegments;\n                }\n                var recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n                if (recentlyRemovedDateranges) {\n                  level.recentlyRemovedDateranges = (level.recentlyRemovedDateranges || []).concat(recentlyRemovedDateranges.split('\\t'));\n                }\n                break;\n              }\n            case 'TARGETDURATION':\n              if (level.targetduration !== 0) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              level.targetduration = Math.max(parseInt(value1), 1);\n              break;\n            case 'VERSION':\n              if (level.version !== null) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              level.version = parseInt(value1);\n              break;\n            case 'INDEPENDENT-SEGMENTS':\n              break;\n            case 'ENDLIST':\n              if (!level.live) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              }\n              level.live = false;\n              break;\n            case '#':\n              if (value1 || value2) {\n                frag.tagList.push(value2 ? [value1, value2] : [value1]);\n              }\n              break;\n            case 'DISCONTINUITY':\n              discontinuityCounter++;\n              frag.tagList.push(['DIS']);\n              break;\n            case 'GAP':\n              frag.gap = true;\n              frag.tagList.push([tag]);\n              break;\n            case 'BITRATE':\n              frag.tagList.push([tag, value1]);\n              currentBitrate = parseInt(value1) * 1000;\n              if (isFiniteNumber(currentBitrate)) {\n                frag.bitrate = currentBitrate;\n              } else {\n                currentBitrate = 0;\n              }\n              break;\n            case 'DATERANGE':\n              {\n                var dateRangeAttr = new AttrList(value1, level);\n                var dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID], level.dateRangeTagCount);\n                level.dateRangeTagCount++;\n                if (dateRange.isValid || level.skippedSegments) {\n                  level.dateRanges[dateRange.id] = dateRange;\n                } else {\n                  logger.warn(\"Ignoring invalid DATERANGE tag: \\\"\" + value1 + \"\\\"\");\n                }\n                // Add to fragment tag list for backwards compatibility (< v1.2.0)\n                frag.tagList.push(['EXT-X-DATERANGE', value1]);\n                break;\n              }\n            case 'DEFINE':\n              {\n                {\n                  var variableAttributes = new AttrList(value1, level);\n                  if ('IMPORT' in variableAttributes) {\n                    importVariableDefinition(level, variableAttributes, multivariantVariableList);\n                  } else {\n                    addVariableDefinition(level, variableAttributes, baseurl);\n                  }\n                }\n                break;\n              }\n            case 'DISCONTINUITY-SEQUENCE':\n              if (level.startCC !== 0) {\n                assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n              } else if (fragments.length > 0) {\n                assignMustAppearBeforeSegmentsError(level, tag, result);\n              }\n              level.startCC = discontinuityCounter = parseInt(value1);\n              break;\n            case 'KEY':\n              {\n                var levelKey = parseKey(value1, baseurl, level);\n                if (levelKey.isSupported()) {\n                  if (levelKey.method === 'NONE') {\n                    levelkeys = undefined;\n                    break;\n                  }\n                  if (!levelkeys) {\n                    levelkeys = {};\n                  }\n                  var currentKey = levelkeys[levelKey.keyFormat];\n                  // Ignore duplicate playlist KEY tags\n                  if (!(currentKey != null && currentKey.matches(levelKey))) {\n                    if (currentKey) {\n                      levelkeys = _extends({}, levelkeys);\n                    }\n                    levelkeys[levelKey.keyFormat] = levelKey;\n                  }\n                } else {\n                  logger.warn(\"[Keys] Ignoring unsupported EXT-X-KEY tag: \\\"\" + value1 + \"\\\"\" + ('' ));\n                }\n                break;\n              }\n            case 'START':\n              level.startTimeOffset = parseStartTimeOffset(value1);\n              break;\n            case 'MAP':\n              {\n                var mapAttrs = new AttrList(value1, level);\n                if (frag.duration) {\n                  // Initial segment tag is after segment duration tag.\n                  //   #EXTINF: 6.0\n                  //   #EXT-X-MAP:URI=\"init.mp4\n                  var init = new Fragment(type, base);\n                  setInitSegment(init, mapAttrs, id, levelkeys);\n                  currentInitSegment = init;\n                  frag.initSegment = currentInitSegment;\n                  if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                  }\n                } else {\n                  // Initial segment tag is before segment duration tag\n                  // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE\n                  var end = frag.byteRangeEndOffset;\n                  if (end) {\n                    var start = frag.byteRangeStartOffset;\n                    nextByteRange = end - start + \"@\" + start;\n                  } else {\n                    nextByteRange = null;\n                  }\n                  setInitSegment(frag, mapAttrs, id, levelkeys);\n                  currentInitSegment = frag;\n                  createNextFrag = true;\n                }\n                currentInitSegment.cc = discontinuityCounter;\n                break;\n              }\n            case 'SERVER-CONTROL':\n              {\n                if (serverControlAttrs) {\n                  assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n                }\n                serverControlAttrs = new AttrList(value1);\n                level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n                level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n                level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n                level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n                level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n                break;\n              }\n            case 'PART-INF':\n              {\n                if (level.partTarget) {\n                  assignMultipleMediaPlaylistTagOccuranceError(level, tag, result);\n                }\n                var partInfAttrs = new AttrList(value1);\n                level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n                break;\n              }\n            case 'PART':\n              {\n                var partList = level.partList;\n                if (!partList) {\n                  partList = level.partList = [];\n                }\n                var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n                var index = currentPart++;\n                var partAttrs = new AttrList(value1, level);\n                var part = new Part(partAttrs, frag, base, index, previousFragmentPart);\n                partList.push(part);\n                frag.duration += part.duration;\n                break;\n              }\n            case 'PRELOAD-HINT':\n              {\n                var preloadHintAttrs = new AttrList(value1, level);\n                level.preloadHint = preloadHintAttrs;\n                break;\n              }\n            case 'RENDITION-REPORT':\n              {\n                var renditionReportAttrs = new AttrList(value1, level);\n                level.renditionReports = level.renditionReports || [];\n                level.renditionReports.push(renditionReportAttrs);\n                break;\n              }\n            default:\n              logger.warn(\"line parsed but not handled: \" + result);\n              break;\n          }\n        }\n      }\n      if (prevFrag && !prevFrag.relurl) {\n        fragments.pop();\n        totalduration -= prevFrag.duration;\n        if (level.partList) {\n          level.fragmentHint = prevFrag;\n        }\n      } else if (level.partList) {\n        assignProgramDateTime(frag, prevFrag, programDateTimes);\n        frag.cc = discontinuityCounter;\n        level.fragmentHint = frag;\n        if (levelkeys) {\n          setFragLevelKeys(frag, levelkeys, level);\n        }\n      }\n      if (!level.targetduration) {\n        level.playlistParsingError = new Error(\"Missing Target Duration\");\n      }\n      var fragmentLength = fragments.length;\n      var firstFragment = fragments[0];\n      var lastFragment = fragments[fragmentLength - 1];\n      totalduration += level.skippedSegments * level.targetduration;\n      if (totalduration > 0 && fragmentLength && lastFragment) {\n        level.averagetargetduration = totalduration / fragmentLength;\n        var lastSn = lastFragment.sn;\n        level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n        if (!level.live) {\n          lastFragment.endList = true;\n        }\n        /**\n         * Backfill any missing PDT values\n         * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n         * one or more Media Segment URIs, the client SHOULD extrapolate\n         * backward from that tag (using EXTINF durations and/or media\n         * timestamps) to associate dates with those segments.\"\n         * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n         * computed.\n         */\n        if (firstPdtIndex > 0) {\n          backfillProgramDateTimes(fragments, firstPdtIndex);\n          if (firstFragment) {\n            programDateTimes.unshift(firstFragment);\n          }\n        }\n      }\n      if (level.fragmentHint) {\n        totalduration += level.fragmentHint.duration;\n      }\n      level.totalduration = totalduration;\n      if (programDateTimes.length && level.dateRangeTagCount && firstFragment) {\n        mapDateRanges(programDateTimes, level);\n      }\n      level.endCC = discontinuityCounter;\n      return level;\n    };\n    return M3U8Parser;\n  }();\n  function mapDateRanges(programDateTimes, details) {\n    // Make sure DateRanges are mapped to a ProgramDateTime tag that applies a date to a segment that overlaps with its start date\n    var programDateTimeCount = programDateTimes.length;\n    if (!programDateTimeCount) {\n      if (details.hasProgramDateTime) {\n        var lastFragment = details.fragments[details.fragments.length - 1];\n        programDateTimes.push(lastFragment);\n        programDateTimeCount++;\n      } else {\n        // no segments with EXT-X-PROGRAM-DATE-TIME references in playlist history\n        return;\n      }\n    }\n    var lastProgramDateTime = programDateTimes[programDateTimeCount - 1];\n    var playlistEnd = details.live ? Infinity : details.totalduration;\n    var dateRangeIds = Object.keys(details.dateRanges);\n    for (var i = dateRangeIds.length; i--;) {\n      var dateRange = details.dateRanges[dateRangeIds[i]];\n      var startDateTime = dateRange.startDate.getTime();\n      dateRange.tagAnchor = lastProgramDateTime.ref;\n      for (var j = programDateTimeCount; j--;) {\n        var _programDateTimes$j;\n        if (((_programDateTimes$j = programDateTimes[j]) == null ? void 0 : _programDateTimes$j.sn) < details.startSN) {\n          break;\n        }\n        var fragIndex = findFragmentWithStartDate(details, startDateTime, programDateTimes, j, playlistEnd);\n        if (fragIndex !== -1) {\n          dateRange.tagAnchor = details.fragments[fragIndex].ref;\n          break;\n        }\n      }\n    }\n  }\n  function findFragmentWithStartDate(details, startDateTime, programDateTimes, index, endTime) {\n    var pdtFragment = programDateTimes[index];\n    if (pdtFragment) {\n      // find matching range between PDT tags\n      var pdtStart = pdtFragment.programDateTime;\n      if (startDateTime >= pdtStart || index === 0) {\n        var _programDateTimes;\n        var durationBetweenPdt = (((_programDateTimes = programDateTimes[index + 1]) == null ? void 0 : _programDateTimes.start) || endTime) - pdtFragment.start;\n        if (startDateTime <= pdtStart + durationBetweenPdt * 1000) {\n          // map to fragment with date-time range\n          var startIndex = programDateTimes[index].sn - details.startSN;\n          if (startIndex < 0) {\n            return -1;\n          }\n          var fragments = details.fragments;\n          if (fragments.length > programDateTimes.length) {\n            var endSegment = programDateTimes[index + 1] || fragments[fragments.length - 1];\n            var endIndex = endSegment.sn - details.startSN;\n            for (var i = endIndex; i > startIndex; i--) {\n              var fragStartDateTime = fragments[i].programDateTime;\n              if (startDateTime >= fragStartDateTime && startDateTime < fragStartDateTime + fragments[i].duration * 1000) {\n                return i;\n              }\n            }\n          }\n          return startIndex;\n        }\n      }\n    }\n    return -1;\n  }\n  function parseKey(keyTagAttributes, baseurl, parsed) {\n    var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n    // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n    var keyAttrs = new AttrList(keyTagAttributes, parsed);\n    var decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n    var decrypturi = keyAttrs.URI;\n    var decryptiv = keyAttrs.hexadecimalInteger('IV');\n    var decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n    // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n    var decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n    if (decrypturi && keyAttrs.IV && !decryptiv) {\n      logger.error(\"Invalid IV: \" + keyAttrs.IV);\n    }\n    // If decrypturi is a URI with a scheme, then baseurl will be ignored\n    // No uri is allowed when METHOD is NONE\n    var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n    var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n    return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv, keyAttrs.KEYID);\n  }\n  function parseStartTimeOffset(startAttributes) {\n    var startAttrs = new AttrList(startAttributes);\n    var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n    if (isFiniteNumber(startTimeOffset)) {\n      return startTimeOffset;\n    }\n    return null;\n  }\n  function setCodecs(codecsAttributeValue, level) {\n    var codecs = (codecsAttributeValue || '').split(/[ ,]+/).filter(function (c) {\n      return c;\n    });\n    ['video', 'audio', 'text'].forEach(function (type) {\n      var filtered = codecs.filter(function (codec) {\n        return isCodecType(codec, type);\n      });\n      if (filtered.length) {\n        // Comma separated list of all codecs for type\n        level[type + \"Codec\"] = filtered.map(function (c) {\n          return c.split('/')[0];\n        }).join(',');\n        // Remove known codecs so that only unknownCodecs are left after iterating through each type\n        codecs = codecs.filter(function (codec) {\n          return filtered.indexOf(codec) === -1;\n        });\n      }\n    });\n    level.unknownCodecs = codecs;\n  }\n  function assignCodec(media, groupItem, codecProperty) {\n    var codecValue = groupItem[codecProperty];\n    if (codecValue) {\n      media[codecProperty] = codecValue;\n    }\n  }\n  function backfillProgramDateTimes(fragments, firstPdtIndex) {\n    var fragPrev = fragments[firstPdtIndex];\n    for (var i = firstPdtIndex; i--;) {\n      var frag = fragments[i];\n      // Exit on delta-playlist skipped segments\n      if (!frag) {\n        return;\n      }\n      frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n      fragPrev = frag;\n    }\n  }\n  function assignProgramDateTime(frag, prevFrag, programDateTimes) {\n    if (frag.rawProgramDateTime) {\n      programDateTimes.push(frag);\n    } else if (prevFrag != null && prevFrag.programDateTime) {\n      frag.programDateTime = prevFrag.endProgramDateTime;\n    }\n  }\n  function setInitSegment(frag, mapAttrs, id, levelkeys) {\n    frag.relurl = mapAttrs.URI;\n    if (mapAttrs.BYTERANGE) {\n      frag.setByteRange(mapAttrs.BYTERANGE);\n    }\n    frag.level = id;\n    frag.sn = 'initSegment';\n    if (levelkeys) {\n      frag.levelkeys = levelkeys;\n    }\n    frag.initSegment = null;\n  }\n  function setFragLevelKeys(frag, levelkeys, level) {\n    frag.levelkeys = levelkeys;\n    var encryptedFragments = level.encryptedFragments;\n    if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function (format) {\n      return levelkeys[format].isCommonEncryption;\n    })) {\n      encryptedFragments.push(frag);\n    }\n  }\n  function assignMultipleMediaPlaylistTagOccuranceError(level, tag, result) {\n    level.playlistParsingError = new Error(\"#EXT-X-\" + tag + \" must not appear more than once (\" + result[0] + \")\");\n  }\n  function assignMustAppearBeforeSegmentsError(level, tag, result) {\n    level.playlistParsingError = new Error(\"#EXT-X-\" + tag + \" must appear before the first Media Segment (\" + result[0] + \")\");\n  }\n\n  function updateFromToPTS(fragFrom, fragTo) {\n    var fragToPTS = fragTo.startPTS;\n    // if we know startPTS[toIdx]\n    if (isFiniteNumber(fragToPTS)) {\n      // update fragment duration.\n      // it helps to fix drifts between playlist reported duration and fragment real duration\n      var duration = 0;\n      var frag;\n      if (fragTo.sn > fragFrom.sn) {\n        duration = fragToPTS - fragFrom.start;\n        frag = fragFrom;\n      } else {\n        duration = fragFrom.start - fragToPTS;\n        frag = fragTo;\n      }\n      if (frag.duration !== duration) {\n        frag.setDuration(duration);\n      }\n      // we dont know startPTS[toIdx]\n    } else if (fragTo.sn > fragFrom.sn) {\n      var contiguous = fragFrom.cc === fragTo.cc;\n      // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n      if (contiguous && fragFrom.minEndPTS) {\n        fragTo.setStart(fragFrom.start + (fragFrom.minEndPTS - fragFrom.start));\n      } else {\n        fragTo.setStart(fragFrom.start + fragFrom.duration);\n      }\n    } else {\n      fragTo.setStart(Math.max(fragFrom.start - fragTo.duration, 0));\n    }\n  }\n  function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS, logger) {\n    var parsedMediaDuration = endPTS - startPTS;\n    if (parsedMediaDuration <= 0) {\n      logger.warn('Fragment should have a positive duration', frag);\n      endPTS = startPTS + frag.duration;\n      endDTS = startDTS + frag.duration;\n    }\n    var maxStartPTS = startPTS;\n    var minEndPTS = endPTS;\n    var fragStartPts = frag.startPTS;\n    var fragEndPts = frag.endPTS;\n    if (isFiniteNumber(fragStartPts)) {\n      // delta PTS between audio and video\n      var deltaPTS = Math.abs(fragStartPts - startPTS);\n      if (details && deltaPTS > details.totalduration) {\n        logger.warn(\"media timestamps and playlist times differ by \" + deltaPTS + \"s for level \" + frag.level + \" \" + details.url);\n      } else if (!isFiniteNumber(frag.deltaPTS)) {\n        frag.deltaPTS = deltaPTS;\n      } else {\n        frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n      }\n      maxStartPTS = Math.max(startPTS, fragStartPts);\n      startPTS = Math.min(startPTS, fragStartPts);\n      startDTS = frag.startDTS !== undefined ? Math.min(startDTS, frag.startDTS) : startDTS;\n      minEndPTS = Math.min(endPTS, fragEndPts);\n      endPTS = Math.max(endPTS, fragEndPts);\n      endDTS = frag.endDTS !== undefined ? Math.max(endDTS, frag.endDTS) : endDTS;\n    }\n    var drift = startPTS - frag.start;\n    if (frag.start !== 0) {\n      frag.setStart(startPTS);\n    }\n    frag.setDuration(endPTS - frag.start);\n    frag.startPTS = startPTS;\n    frag.maxStartPTS = maxStartPTS;\n    frag.startDTS = startDTS;\n    frag.endPTS = endPTS;\n    frag.minEndPTS = minEndPTS;\n    frag.endDTS = endDTS;\n    var sn = frag.sn;\n    // exit if sn out of range\n    if (!details || sn < details.startSN || sn > details.endSN) {\n      return 0;\n    }\n    var i;\n    var fragIdx = sn - details.startSN;\n    var fragments = details.fragments;\n    // update frag reference in fragments array\n    // rationale is that fragments array might not contain this frag object.\n    // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n    // if we don't update frag, we won't be able to propagate PTS info on the playlist\n    // resulting in invalid sliding computation\n    fragments[fragIdx] = frag;\n    // adjust fragment PTS/duration from seqnum-1 to frag 0\n    for (i = fragIdx; i > 0; i--) {\n      updateFromToPTS(fragments[i], fragments[i - 1]);\n    }\n\n    // adjust fragment PTS/duration from seqnum to last frag\n    for (i = fragIdx; i < fragments.length - 1; i++) {\n      updateFromToPTS(fragments[i], fragments[i + 1]);\n    }\n    if (details.fragmentHint) {\n      updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n    }\n    details.PTSKnown = details.alignedSliding = true;\n    return drift;\n  }\n  function mergeDetails(oldDetails, newDetails, logger) {\n    if (oldDetails === newDetails) {\n      return;\n    }\n    // Track the last initSegment processed. Initialize it to the last one on the timeline.\n    var currentInitSegment = null;\n    var oldFragments = oldDetails.fragments;\n    for (var i = oldFragments.length - 1; i >= 0; i--) {\n      var oldInit = oldFragments[i].initSegment;\n      if (oldInit) {\n        currentInitSegment = oldInit;\n        break;\n      }\n    }\n    if (oldDetails.fragmentHint) {\n      // prevent PTS and duration from being adjusted on the next hint\n      delete oldDetails.fragmentHint.endPTS;\n    }\n    // check if old/new playlists have fragments in common\n    // loop through overlapping SN and update startPTS, cc, and duration if any found\n    var PTSFrag;\n    mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag, newFragIndex, newFragments) {\n      if ((!newDetails.startCC || newDetails.skippedSegments) && newFrag.cc !== oldFrag.cc) {\n        var ccOffset = oldFrag.cc - newFrag.cc;\n        for (var _i = newFragIndex; _i < newFragments.length; _i++) {\n          newFragments[_i].cc += ccOffset;\n        }\n        newDetails.endCC = newFragments[newFragments.length - 1].cc;\n      }\n      if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n        newFrag.setStart(newFrag.startPTS = oldFrag.startPTS);\n        newFrag.startDTS = oldFrag.startDTS;\n        newFrag.maxStartPTS = oldFrag.maxStartPTS;\n        newFrag.endPTS = oldFrag.endPTS;\n        newFrag.endDTS = oldFrag.endDTS;\n        newFrag.minEndPTS = oldFrag.minEndPTS;\n        newFrag.setDuration(oldFrag.endPTS - oldFrag.startPTS);\n        if (newFrag.duration) {\n          PTSFrag = newFrag;\n        }\n\n        // PTS is known when any segment has startPTS and endPTS\n        newDetails.PTSKnown = newDetails.alignedSliding = true;\n      }\n      if (oldFrag.hasStreams) {\n        newFrag.elementaryStreams = oldFrag.elementaryStreams;\n      }\n      newFrag.loader = oldFrag.loader;\n      if (oldFrag.hasStats) {\n        newFrag.stats = oldFrag.stats;\n      }\n      if (oldFrag.initSegment) {\n        newFrag.initSegment = oldFrag.initSegment;\n        currentInitSegment = oldFrag.initSegment;\n      }\n    });\n    var newFragments = newDetails.fragments;\n    var fragmentsToCheck = newDetails.fragmentHint ? newFragments.concat(newDetails.fragmentHint) : newFragments;\n    if (currentInitSegment) {\n      fragmentsToCheck.forEach(function (frag) {\n        var _currentInitSegment;\n        if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {\n          frag.initSegment = currentInitSegment;\n        }\n      });\n    }\n    if (newDetails.skippedSegments) {\n      newDetails.deltaUpdateFailed = newFragments.some(function (frag) {\n        return !frag;\n      });\n      if (newDetails.deltaUpdateFailed) {\n        logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n        for (var _i2 = newDetails.skippedSegments; _i2--;) {\n          newFragments.shift();\n        }\n        newDetails.startSN = newFragments[0].sn;\n      } else {\n        if (newDetails.canSkipDateRanges) {\n          newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails, logger);\n        }\n        var programDateTimes = oldDetails.fragments.filter(function (frag) {\n          return frag.rawProgramDateTime;\n        });\n        if (oldDetails.hasProgramDateTime && !newDetails.hasProgramDateTime) {\n          for (var _i3 = 1; _i3 < fragmentsToCheck.length; _i3++) {\n            if (fragmentsToCheck[_i3].programDateTime === null) {\n              assignProgramDateTime(fragmentsToCheck[_i3], fragmentsToCheck[_i3 - 1], programDateTimes);\n            }\n          }\n        }\n        mapDateRanges(programDateTimes, newDetails);\n      }\n      newDetails.endCC = newFragments[newFragments.length - 1].cc;\n    }\n    if (!newDetails.startCC) {\n      var _fragPriorToNewStart$;\n      var fragPriorToNewStart = getFragmentWithSN(oldDetails, newDetails.startSN - 1);\n      newDetails.startCC = (_fragPriorToNewStart$ = fragPriorToNewStart == null ? void 0 : fragPriorToNewStart.cc) != null ? _fragPriorToNewStart$ : newFragments[0].cc;\n    }\n\n    // Merge parts\n    mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {\n      newPart.elementaryStreams = oldPart.elementaryStreams;\n      newPart.stats = oldPart.stats;\n    });\n\n    // if at least one fragment contains PTS info, recompute PTS information for all fragments\n    if (PTSFrag) {\n      updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS, logger);\n    } else {\n      // ensure that delta is within oldFragments range\n      // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n      // in that case we also need to adjust start offset of all fragments\n      adjustSliding(oldDetails, newDetails);\n    }\n    if (newFragments.length) {\n      newDetails.totalduration = newDetails.edge - newFragments[0].start;\n    }\n    newDetails.driftStartTime = oldDetails.driftStartTime;\n    newDetails.driftStart = oldDetails.driftStart;\n    var advancedDateTime = newDetails.advancedDateTime;\n    if (newDetails.advanced && advancedDateTime) {\n      var edge = newDetails.edge;\n      if (!newDetails.driftStart) {\n        newDetails.driftStartTime = advancedDateTime;\n        newDetails.driftStart = edge;\n      }\n      newDetails.driftEndTime = advancedDateTime;\n      newDetails.driftEnd = edge;\n    } else {\n      newDetails.driftEndTime = oldDetails.driftEndTime;\n      newDetails.driftEnd = oldDetails.driftEnd;\n      newDetails.advancedDateTime = oldDetails.advancedDateTime;\n    }\n    if (newDetails.requestScheduled === -1) {\n      newDetails.requestScheduled = oldDetails.requestScheduled;\n    }\n  }\n  function mergeDateRanges(oldDateRanges, newDetails, logger) {\n    var deltaDateRanges = newDetails.dateRanges,\n      recentlyRemovedDateranges = newDetails.recentlyRemovedDateranges;\n    var dateRanges = _extends({}, oldDateRanges);\n    if (recentlyRemovedDateranges) {\n      recentlyRemovedDateranges.forEach(function (id) {\n        delete dateRanges[id];\n      });\n    }\n    var mergeIds = Object.keys(dateRanges);\n    var mergeCount = mergeIds.length;\n    if (!mergeCount) {\n      return deltaDateRanges;\n    }\n    Object.keys(deltaDateRanges).forEach(function (id) {\n      var mergedDateRange = dateRanges[id];\n      var dateRange = new DateRange(deltaDateRanges[id].attr, mergedDateRange);\n      if (dateRange.isValid) {\n        dateRanges[id] = dateRange;\n        if (!mergedDateRange) {\n          dateRange.tagOrder += mergeCount;\n        }\n      } else {\n        logger.warn(\"Ignoring invalid Playlist Delta Update DATERANGE tag: \\\"\" + stringify(deltaDateRanges[id].attr) + \"\\\"\");\n      }\n    });\n    return dateRanges;\n  }\n  function mapPartIntersection(oldParts, newParts, intersectionFn) {\n    if (oldParts && newParts) {\n      var delta = 0;\n      for (var i = 0, len = oldParts.length; i <= len; i++) {\n        var _oldPart = oldParts[i];\n        var _newPart = newParts[i + delta];\n        if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {\n          intersectionFn(_oldPart, _newPart);\n        } else {\n          delta--;\n        }\n      }\n    }\n  }\n  function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n    var skippedSegments = newDetails.skippedSegments;\n    var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n    var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n    var delta = newDetails.startSN - oldDetails.startSN;\n    var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n    for (var i = start; i <= end; i++) {\n      var _oldFrag = oldFrags[delta + i];\n      var _newFrag = newFrags[i];\n      if (skippedSegments && !_newFrag && _oldFrag) {\n        // Fill in skipped segments in delta playlist\n        _newFrag = newDetails.fragments[i] = _oldFrag;\n      }\n      if (_oldFrag && _newFrag) {\n        intersectionFn(_oldFrag, _newFrag, i, newFrags);\n        var uriBefore = _oldFrag.relurl;\n        var uriAfter = _newFrag.relurl;\n        if (uriBefore && notEqualAfterStrippingQueries(uriBefore, uriAfter)) {\n          newDetails.playlistParsingError = getSequenceError(\"media sequence mismatch \" + _newFrag.sn + \":\", oldDetails, newDetails, _oldFrag, _newFrag);\n          return;\n        } else if (_oldFrag.cc !== _newFrag.cc) {\n          newDetails.playlistParsingError = getSequenceError(\"discontinuity sequence mismatch (\" + _oldFrag.cc + \"!=\" + _newFrag.cc + \")\", oldDetails, newDetails, _oldFrag, _newFrag);\n          return;\n        }\n      }\n    }\n  }\n  function getSequenceError(message, oldDetails, newDetails, oldFrag, newFrag) {\n    return new Error(message + \" \" + newFrag.url + \"\\nPlaylist starting @\" + oldDetails.startSN + \"\\n\" + oldDetails.m3u8 + \"\\n\\nPlaylist starting @\" + newDetails.startSN + \"\\n\" + newDetails.m3u8);\n  }\n  function adjustSliding(oldDetails, newDetails, matchingStableVariantOrRendition) {\n    if (matchingStableVariantOrRendition === void 0) {\n      matchingStableVariantOrRendition = true;\n    }\n    var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n    var oldFragments = oldDetails.fragments;\n    var advancedOrStable = delta >= 0;\n    var sliding = 0;\n    if (advancedOrStable && delta < oldFragments.length) {\n      sliding = oldFragments[delta].start;\n    } else if (advancedOrStable && newDetails.startSN === oldDetails.endSN + 1) {\n      sliding = oldDetails.fragmentEnd;\n    } else if (advancedOrStable && matchingStableVariantOrRendition) {\n      // align with expected position (updated playlist start sequence is past end sequence of last update)\n      sliding = oldDetails.fragmentStart + delta * newDetails.levelTargetDuration;\n    } else if (!newDetails.skippedSegments && newDetails.fragmentStart === 0) {\n      // align new start with old (playlist switch has a sequence with no overlap and should not be used for alignment)\n      sliding = oldDetails.fragmentStart;\n    } else {\n      // new details already has a sliding offset or has skipped segments\n      return;\n    }\n    addSliding(newDetails, sliding);\n  }\n  function addSliding(details, sliding) {\n    if (sliding) {\n      var fragments = details.fragments;\n      for (var i = details.skippedSegments; i < fragments.length; i++) {\n        fragments[i].addStart(sliding);\n      }\n      if (details.fragmentHint) {\n        details.fragmentHint.addStart(sliding);\n      }\n    }\n  }\n  function computeReloadInterval(newDetails, distanceToLiveEdgeMs) {\n    if (distanceToLiveEdgeMs === void 0) {\n      distanceToLiveEdgeMs = Infinity;\n    }\n    var reloadInterval = 1000 * newDetails.targetduration;\n    if (newDetails.updated) {\n      // Use last segment duration when shorter than target duration and near live edge\n      var fragments = newDetails.fragments;\n      var liveEdgeMaxTargetDurations = 4;\n      if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n        var lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n        if (lastSegmentDuration < reloadInterval) {\n          reloadInterval = lastSegmentDuration;\n        }\n      }\n    } else {\n      // estimate = 'miss half average';\n      // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n      // changed then it MUST wait for a period of one-half the target\n      // duration before retrying.\n      reloadInterval /= 2;\n    }\n    return Math.round(reloadInterval);\n  }\n  function getFragmentWithSN(details, sn, fragCurrent) {\n    if (!details) {\n      return null;\n    }\n    var fragment = details.fragments[sn - details.startSN];\n    if (fragment) {\n      return fragment;\n    }\n    fragment = details.fragmentHint;\n    if (fragment && fragment.sn === sn) {\n      return fragment;\n    }\n    if (sn < details.startSN && fragCurrent && fragCurrent.sn === sn) {\n      return fragCurrent;\n    }\n    return null;\n  }\n  function getPartWith(details, sn, partIndex) {\n    if (!details) {\n      return null;\n    }\n    return findPart(details.partList, sn, partIndex);\n  }\n  function findPart(partList, sn, partIndex) {\n    if (partList) {\n      for (var i = partList.length; i--;) {\n        var part = partList[i];\n        if (part.index === partIndex && part.fragment.sn === sn) {\n          return part;\n        }\n      }\n    }\n    return null;\n  }\n  function reassignFragmentLevelIndexes(levels) {\n    levels.forEach(function (level, index) {\n      var _level$details;\n      (_level$details = level.details) == null || _level$details.fragments.forEach(function (fragment) {\n        fragment.level = index;\n        if (fragment.initSegment) {\n          fragment.initSegment.level = index;\n        }\n      });\n    });\n  }\n  function notEqualAfterStrippingQueries(uriBefore, uriAfter) {\n    if (uriBefore !== uriAfter && uriAfter) {\n      return stripQuery(uriBefore) !== stripQuery(uriAfter);\n    }\n    return false;\n  }\n  function stripQuery(uri) {\n    return uri.replace(/\\?[^?]*$/, '');\n  }\n\n  function findFirstFragWithCC(fragments, cc) {\n    for (var i = 0, len = fragments.length; i < len; i++) {\n      var _fragments$i;\n      if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {\n        return fragments[i];\n      }\n    }\n    return null;\n  }\n  function shouldAlignOnDiscontinuities(refDetails, details) {\n    if (refDetails) {\n      if (details.startCC < refDetails.endCC && details.endCC > refDetails.startCC) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function adjustFragmentStart(frag, sliding) {\n    var start = frag.start + sliding;\n    frag.startPTS = start;\n    frag.setStart(start);\n    frag.endPTS = start + frag.duration;\n  }\n  function adjustSlidingStart(sliding, details) {\n    // Update segments\n    var fragments = details.fragments;\n    for (var i = 0, len = fragments.length; i < len; i++) {\n      adjustFragmentStart(fragments[i], sliding);\n    }\n    // Update LL-HLS parts at the end of the playlist\n    if (details.fragmentHint) {\n      adjustFragmentStart(details.fragmentHint, sliding);\n    }\n    details.alignedSliding = true;\n  }\n\n  /**\n   * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n   * contiguous stream with the last fragments.\n   * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n   * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n   * and an extra download.\n   * @param lastLevel\n   * @param details\n   */\n  function alignStream(switchDetails, details) {\n    if (!switchDetails) {\n      return;\n    }\n    alignDiscontinuities(details, switchDetails);\n    if (!details.alignedSliding) {\n      // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n      // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n      // discontinuity sequence.\n      alignMediaPlaylistByPDT(details, switchDetails);\n    }\n    if (!details.alignedSliding && !details.skippedSegments) {\n      // Try to align on sn so that we pick a better start fragment.\n      // Do not perform this on playlists with delta updates as this is only to align levels on switch\n      // and adjustSliding only adjusts fragments after skippedSegments.\n      adjustSliding(switchDetails, details, false);\n    }\n  }\n\n  /**\n   * Ajust the start of fragments in `details` by the difference in time between fragments of the latest\n   * shared discontinuity sequence change.\n   * @param lastLevel - The details of the last loaded level\n   * @param details - The details of the new level\n   */\n  function alignDiscontinuities(details, refDetails) {\n    if (!shouldAlignOnDiscontinuities(refDetails, details)) {\n      return;\n    }\n    var targetCC = Math.min(refDetails.endCC, details.endCC);\n    var refFrag = findFirstFragWithCC(refDetails.fragments, targetCC);\n    var frag = findFirstFragWithCC(details.fragments, targetCC);\n    if (!refFrag || !frag) {\n      return;\n    }\n    logger.log(\"Aligning playlist at start of dicontinuity sequence \" + targetCC);\n    var delta = refFrag.start - frag.start;\n    adjustSlidingStart(delta, details);\n  }\n\n  /**\n   * Ensures appropriate time-alignment between renditions based on PDT.\n   * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs\n   * for the last discontinuity sequence number shared by both playlists when present,\n   * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n   * times/timelines of `details` accordingly.\n   * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n   * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n   * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n   * be consistent across playlists, per the HLS spec.\n   * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n   * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n   */\n  function alignMediaPlaylistByPDT(details, refDetails) {\n    if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n      return;\n    }\n    var fragments = details.fragments;\n    var refFragments = refDetails.fragments;\n    if (!fragments.length || !refFragments.length) {\n      return;\n    }\n\n    // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n    // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n    // If a fragment of the same discontinuity was not found use the middle fragment of both.\n    var refFrag;\n    var frag;\n    var targetCC = Math.min(refDetails.endCC, details.endCC);\n    if (refDetails.startCC < targetCC && details.startCC < targetCC) {\n      refFrag = findFirstFragWithCC(refFragments, targetCC);\n      frag = findFirstFragWithCC(fragments, targetCC);\n    }\n    if (!refFrag || !frag) {\n      refFrag = refFragments[Math.floor(refFragments.length / 2)];\n      frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];\n    }\n    var refPDT = refFrag.programDateTime;\n    var targetPDT = frag.programDateTime;\n    if (!refPDT || !targetPDT) {\n      return;\n    }\n    var delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n    adjustSlidingStart(delta, details);\n  }\n\n  function addEventListener(el, type, listener) {\n    removeEventListener(el, type, listener);\n    el.addEventListener(type, listener);\n  }\n  function removeEventListener(el, type, listener) {\n    el.removeEventListener(type, listener);\n  }\n\n  /**\n   *  TimeRanges to string helper\n   */\n\n  var TimeRanges = {\n    toString: function toString(r) {\n      var log = '';\n      var len = r.length;\n      for (var i = 0; i < len; i++) {\n        log += \"[\" + r.start(i).toFixed(3) + \"-\" + r.end(i).toFixed(3) + \"]\";\n      }\n      return log;\n    }\n  };\n\n  var State = {\n    STOPPED: 'STOPPED',\n    IDLE: 'IDLE',\n    KEY_LOADING: 'KEY_LOADING',\n    FRAG_LOADING: 'FRAG_LOADING',\n    FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n    WAITING_TRACK: 'WAITING_TRACK',\n    PARSING: 'PARSING',\n    PARSED: 'PARSED',\n    ENDED: 'ENDED',\n    ERROR: 'ERROR',\n    WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n    WAITING_LEVEL: 'WAITING_LEVEL'\n  };\n  var BaseStreamController = /*#__PURE__*/function (_TaskLoop) {\n    function BaseStreamController(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n      var _this;\n      _this = _TaskLoop.call(this, logPrefix, hls.logger) || this;\n      _this.hls = void 0;\n      _this.fragPrevious = null;\n      _this.fragCurrent = null;\n      _this.fragmentTracker = void 0;\n      _this.transmuxer = null;\n      _this._state = State.STOPPED;\n      _this.playlistType = void 0;\n      _this.media = null;\n      _this.mediaBuffer = null;\n      _this.config = void 0;\n      _this.bitrateTest = false;\n      _this.lastCurrentTime = 0;\n      _this.nextLoadPosition = 0;\n      _this.startPosition = 0;\n      _this.startTimeOffset = null;\n      _this.retryDate = 0;\n      _this.levels = null;\n      _this.fragmentLoader = void 0;\n      _this.keyLoader = void 0;\n      _this.levelLastLoaded = null;\n      _this.startFragRequested = false;\n      _this.decrypter = void 0;\n      _this.initPTS = [];\n      _this.buffering = true;\n      _this.loadingParts = false;\n      _this.loopSn = void 0;\n      _this.onMediaSeeking = function () {\n        var _this2 = _this,\n          config = _this2.config,\n          fragCurrent = _this2.fragCurrent,\n          media = _this2.media,\n          mediaBuffer = _this2.mediaBuffer,\n          state = _this2.state;\n        var currentTime = media ? media.currentTime : 0;\n        var bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n        var noFowardBuffer = !bufferInfo.len;\n        _this.log(\"Media seeking to \" + (isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime) + \", state: \" + state + \", \" + (noFowardBuffer ? 'out of' : 'in') + \" buffer\");\n        if (_this.state === State.ENDED) {\n          _this.resetLoadingState();\n        } else if (fragCurrent) {\n          // Seeking while frag load is in progress\n          var tolerance = config.maxFragLookUpTolerance;\n          var fragStartOffset = fragCurrent.start - tolerance;\n          var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n          // if seeking out of buffered range or into new one\n          if (noFowardBuffer || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n            var pastFragment = currentTime > fragEndOffset;\n            // if the seek position is outside the current fragment range\n            if (currentTime < fragStartOffset || pastFragment) {\n              if (pastFragment && fragCurrent.loader) {\n                _this.log(\"Cancelling fragment load for seek (sn: \" + fragCurrent.sn + \")\");\n                fragCurrent.abortRequests();\n                _this.resetLoadingState();\n              }\n              _this.fragPrevious = null;\n            }\n          }\n        }\n        if (media) {\n          // Remove gap fragments\n          _this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, _this.playlistType, true);\n\n          // Don't set lastCurrentTime with backward seeks (allows for frag selection with strict tolerances)\n          var lastCurrentTime = _this.lastCurrentTime;\n          if (currentTime > lastCurrentTime) {\n            _this.lastCurrentTime = currentTime;\n          }\n          if (!_this.loadingParts) {\n            var bufferEnd = Math.max(bufferInfo.end, currentTime);\n            var shouldLoadParts = _this.shouldLoadParts(_this.getLevelDetails(), bufferEnd);\n            if (shouldLoadParts) {\n              _this.log(\"LL-Part loading ON after seeking to \" + currentTime.toFixed(2) + \" with buffer @\" + bufferEnd.toFixed(2));\n              _this.loadingParts = shouldLoadParts;\n            }\n          }\n        }\n\n        // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n        if (!_this.hls.hasEnoughToStart) {\n          _this.log(\"Setting \" + (noFowardBuffer ? 'startPosition' : 'nextLoadPosition') + \" to \" + currentTime + \" for seek without enough to start\");\n          _this.nextLoadPosition = currentTime;\n          if (noFowardBuffer) {\n            _this.startPosition = currentTime;\n          }\n        }\n        if (noFowardBuffer && _this.state === State.IDLE) {\n          // Async tick to speed up processing\n          _this.tickImmediate();\n        }\n      };\n      _this.onMediaEnded = function () {\n        // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n        _this.log(\"setting startPosition to 0 because media ended\");\n        _this.startPosition = _this.lastCurrentTime = 0;\n      };\n      _this.playlistType = playlistType;\n      _this.hls = hls;\n      _this.fragmentLoader = new FragmentLoader(hls.config);\n      _this.keyLoader = keyLoader;\n      _this.fragmentTracker = fragmentTracker;\n      _this.config = hls.config;\n      _this.decrypter = new Decrypter(hls.config);\n      return _this;\n    }\n    _inheritsLoose(BaseStreamController, _TaskLoop);\n    var _proto = BaseStreamController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.doTick = function doTick() {\n      this.onTickEnd();\n    };\n    _proto.onTickEnd = function onTickEnd() {};\n    _proto.startLoad = function startLoad(startPosition) {};\n    _proto.stopLoad = function stopLoad() {\n      if (this.state === State.STOPPED) {\n        return;\n      }\n      this.fragmentLoader.abort();\n      this.keyLoader.abort(this.playlistType);\n      var frag = this.fragCurrent;\n      if (frag != null && frag.loader) {\n        frag.abortRequests();\n        this.fragmentTracker.removeFragment(frag);\n      }\n      this.resetTransmuxer();\n      this.fragCurrent = null;\n      this.fragPrevious = null;\n      this.clearInterval();\n      this.clearNextTick();\n      this.state = State.STOPPED;\n    };\n    _proto.pauseBuffering = function pauseBuffering() {\n      this.buffering = false;\n    };\n    _proto.resumeBuffering = function resumeBuffering() {\n      this.buffering = true;\n    };\n    _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {\n      // Stream is never \"ended\" when playlist is live or media is detached\n      if (levelDetails.live || !this.media) {\n        return false;\n      }\n      // Stream is not \"ended\" when nothing is buffered past the start\n      var bufferEnd = bufferInfo.end || 0;\n      var timelineStart = this.config.timelineOffset || 0;\n      if (bufferEnd <= timelineStart) {\n        return false;\n      }\n      // Stream is not \"ended\" when there is a second buffered range starting before the end of the playlist\n      var bufferedRanges = bufferInfo.buffered;\n      if (this.config.maxBufferHole && bufferedRanges && bufferedRanges.length > 1) {\n        // make sure bufferInfo accounts for any gaps\n        bufferInfo = BufferHelper.bufferedInfo(bufferedRanges, bufferInfo.start, 0);\n      }\n      var nextStart = bufferInfo.nextStart;\n      var hasSecondBufferedRange = nextStart && nextStart > timelineStart && nextStart < levelDetails.edge;\n      if (hasSecondBufferedRange) {\n        return false;\n      }\n      // Playhead is in unbuffered region. Marking EoS now could result in Safari failing to dispatch \"ended\" event following seek on start.\n      if (this.media.currentTime < bufferInfo.start) {\n        return false;\n      }\n      var partList = levelDetails.partList;\n      // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n      // check instead if the last part is buffered.\n      if (partList != null && partList.length) {\n        var lastPart = partList[partList.length - 1];\n\n        // Checking the midpoint of the part for potential margin of error and related issues.\n        // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n        // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n        // part mismatches for independent audio and video playlists/segments.\n        var lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n        return lastPartBuffered;\n      }\n      var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n      return this.fragmentTracker.isEndListAppended(playlistType);\n    };\n    _proto.getLevelDetails = function getLevelDetails() {\n      if (this.levels && this.levelLastLoaded !== null) {\n        return this.levelLastLoaded.details;\n      }\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      var media = this.media = this.mediaBuffer = data.media;\n      addEventListener(media, 'seeking', this.onMediaSeeking);\n      addEventListener(media, 'ended', this.onMediaEnded);\n      var config = this.config;\n      if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n        this.startLoad(config.startPosition);\n      }\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      var transferringMedia = !!data.transferMedia;\n      var media = this.media;\n      if (media === null) {\n        return;\n      }\n      if (media.ended) {\n        this.log('MSE detaching and video ended, reset startPosition');\n        this.startPosition = this.lastCurrentTime = 0;\n      }\n\n      // remove video listeners\n      removeEventListener(media, 'seeking', this.onMediaSeeking);\n      removeEventListener(media, 'ended', this.onMediaEnded);\n      if (this.keyLoader && !transferringMedia) {\n        this.keyLoader.detach();\n      }\n      this.media = this.mediaBuffer = null;\n      this.loopSn = undefined;\n      if (transferringMedia) {\n        this.resetLoadingState();\n        this.resetTransmuxer();\n        return;\n      }\n      this.loadingParts = false;\n      this.fragmentTracker.removeAllFragments();\n      this.stopLoad();\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.initPTS = [];\n      this.levels = this.levelLastLoaded = this.fragCurrent = null;\n      this.lastCurrentTime = this.startPosition = 0;\n      this.startFragRequested = false;\n    };\n    _proto.onError = function onError(event, data) {};\n    _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n      this.startTimeOffset = data.startTimeOffset;\n    };\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      this.stopLoad();\n      if (this.transmuxer) {\n        this.transmuxer.destroy();\n        this.transmuxer = null;\n      }\n      _TaskLoop.prototype.onHandlerDestroying.call(this);\n      // @ts-ignore\n      this.hls = this.onMediaSeeking = this.onMediaEnded = null;\n    };\n    _proto.onHandlerDestroyed = function onHandlerDestroyed() {\n      this.state = State.STOPPED;\n      if (this.fragmentLoader) {\n        this.fragmentLoader.destroy();\n      }\n      if (this.keyLoader) {\n        this.keyLoader.destroy();\n      }\n      if (this.decrypter) {\n        this.decrypter.destroy();\n      }\n      this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n      _TaskLoop.prototype.onHandlerDestroyed.call(this);\n    };\n    _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n      this.startFragRequested = true;\n      this._loadFragForPlayback(frag, level, targetBufferTime);\n    };\n    _proto._loadFragForPlayback = function _loadFragForPlayback(fragment, level, targetBufferTime) {\n      var _this3 = this;\n      var progressCallback = function progressCallback(data) {\n        var frag = data.frag;\n        if (_this3.fragContextChanged(frag)) {\n          _this3.warn(frag.type + \" sn: \" + frag.sn + (data.part ? ' part: ' + data.part.index : '') + \" of \" + _this3.fragInfo(frag, false, data.part) + \") was dropped during download.\");\n          _this3.fragmentTracker.removeFragment(frag);\n          return;\n        }\n        frag.stats.chunkCount++;\n        _this3._handleFragmentLoadProgress(data);\n      };\n      this._doFragLoad(fragment, level, targetBufferTime, progressCallback).then(function (data) {\n        if (!data) {\n          // if we're here we probably needed to backtrack or are waiting for more parts\n          return;\n        }\n        var state = _this3.state;\n        var frag = data.frag;\n        if (_this3.fragContextChanged(frag)) {\n          if (state === State.FRAG_LOADING || !_this3.fragCurrent && state === State.PARSING) {\n            _this3.fragmentTracker.removeFragment(frag);\n            _this3.state = State.IDLE;\n          }\n          return;\n        }\n        if ('payload' in data) {\n          _this3.log(\"Loaded \" + frag.type + \" sn: \" + frag.sn + \" of \" + _this3.playlistLabel() + \" \" + frag.level);\n          _this3.hls.trigger(Events.FRAG_LOADED, data);\n        }\n\n        // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n        _this3._handleFragmentLoadComplete(data);\n      }).catch(function (reason) {\n        if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {\n          return;\n        }\n        _this3.warn(\"Frag error: \" + ((reason == null ? void 0 : reason.message) || reason));\n        _this3.resetFragmentLoading(fragment);\n      });\n    };\n    _proto.clearTrackerIfNeeded = function clearTrackerIfNeeded(frag) {\n      var _this$mediaBuffer;\n      var fragmentTracker = this.fragmentTracker;\n      var fragState = fragmentTracker.getState(frag);\n      if (fragState === FragmentState.APPENDING) {\n        // Lower the max buffer length and try again\n        var playlistType = frag.type;\n        var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n        var minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n        // If backtracking, always remove from the tracker without reducing max buffer length\n        var backtrackFragment = this.backtrackFragment;\n        var backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;\n        if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {\n          fragmentTracker.removeFragment(frag);\n        }\n      } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n        // Stop gap for bad tracker / buffer flush behavior\n        fragmentTracker.removeAllFragments();\n      } else if (fragmentTracker.hasParts(frag.type)) {\n        // In low latency mode, remove fragments for which only some parts were buffered\n        fragmentTracker.detectPartialFragments({\n          frag: frag,\n          part: null,\n          stats: frag.stats,\n          id: frag.type\n        });\n        if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n          fragmentTracker.removeFragment(frag);\n        }\n      }\n    };\n    _proto.checkLiveUpdate = function checkLiveUpdate(details) {\n      if (details.updated && !details.live) {\n        // Live stream ended, update fragment tracker\n        var lastFragment = details.fragments[details.fragments.length - 1];\n        this.fragmentTracker.detectPartialFragments({\n          frag: lastFragment,\n          part: null,\n          stats: lastFragment.stats,\n          id: lastFragment.type\n        });\n      }\n      if (!details.fragments[0]) {\n        details.deltaUpdateFailed = true;\n      }\n    };\n    _proto.waitForLive = function waitForLive(levelInfo) {\n      var details = levelInfo.details;\n      return (details == null ? void 0 : details.live) && details.type !== 'EVENT' && (this.levelLastLoaded !== levelInfo || details.expired);\n    };\n    _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {\n      if (type === void 0) {\n        type = null;\n      }\n      if (!(startOffset - endOffset)) {\n        return;\n      }\n      // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n      // passing a null type flushes both buffers\n      var flushScope = {\n        startOffset: startOffset,\n        endOffset: endOffset,\n        type: type\n      };\n      this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n    };\n    _proto._loadInitSegment = function _loadInitSegment(fragment, level) {\n      var _this4 = this;\n      this._doFragLoad(fragment, level).then(function (data) {\n        var frag = data == null ? void 0 : data.frag;\n        if (!frag || _this4.fragContextChanged(frag) || !_this4.levels) {\n          throw new Error('init load aborted');\n        }\n        return data;\n      }).then(function (data) {\n        var hls = _this4.hls;\n        var frag = data.frag,\n          payload = data.payload;\n        var decryptData = frag.decryptdata;\n\n        // check to see if the payload needs to be decrypted\n        if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && isFullSegmentEncryption(decryptData.method)) {\n          var startTime = self.performance.now();\n          // decrypt init segment data\n          return _this4.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer, getAesModeFromFullSegmentMethod(decryptData.method)).catch(function (err) {\n            hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.FRAG_DECRYPT_ERROR,\n              fatal: false,\n              error: err,\n              reason: err.message,\n              frag: frag\n            });\n            throw err;\n          }).then(function (decryptedData) {\n            var endTime = self.performance.now();\n            hls.trigger(Events.FRAG_DECRYPTED, {\n              frag: frag,\n              payload: decryptedData,\n              stats: {\n                tstart: startTime,\n                tdecrypt: endTime\n              }\n            });\n            data.payload = decryptedData;\n            return _this4.completeInitSegmentLoad(data);\n          });\n        }\n        return _this4.completeInitSegmentLoad(data);\n      }).catch(function (reason) {\n        if (_this4.state === State.STOPPED || _this4.state === State.ERROR) {\n          return;\n        }\n        _this4.warn(reason);\n        _this4.resetFragmentLoading(fragment);\n      });\n    };\n    _proto.completeInitSegmentLoad = function completeInitSegmentLoad(data) {\n      var levels = this.levels;\n      if (!levels) {\n        throw new Error('init load aborted, missing levels');\n      }\n      var stats = data.frag.stats;\n      if (this.state !== State.STOPPED) {\n        this.state = State.IDLE;\n      }\n      data.frag.data = new Uint8Array(data.payload);\n      stats.parsing.start = stats.buffering.start = self.performance.now();\n      stats.parsing.end = stats.buffering.end = self.performance.now();\n      this.tick();\n    };\n    _proto.unhandledEncryptionError = function unhandledEncryptionError(initSegment, frag) {\n      var _tracks$audio, _tracks$video;\n      var tracks = initSegment.tracks;\n      if (tracks && !frag.encrypted && ((_tracks$audio = tracks.audio) != null && _tracks$audio.encrypted || (_tracks$video = tracks.video) != null && _tracks$video.encrypted) && (!this.config.emeEnabled || !this.keyLoader.emeController)) {\n        var media = this.media;\n        var error = new Error(\"Encrypted track with no key in \" + this.fragInfo(frag) + \" (media \" + (media ? 'attached mediaKeys: ' + media.mediaKeys : 'detached') + \")\" );\n        this.warn(error.message);\n        // Ignore if media is detached or mediaKeys are set\n        if (!media || media.mediaKeys) {\n          return false;\n        }\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n          fatal: false,\n          error: error,\n          frag: frag\n        });\n        this.resetTransmuxer();\n        return true;\n      }\n      return false;\n    };\n    _proto.fragContextChanged = function fragContextChanged(frag) {\n      var fragCurrent = this.fragCurrent;\n      return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;\n    };\n    _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {\n      var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n      this.log(\"Buffered \" + frag.type + \" sn: \" + frag.sn + (part ? ' part: ' + part.index : '') + \" of \" + this.fragInfo(frag, false, part) + \" > buffer:\" + (media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)') + \")\");\n      if (isMediaFragment(frag)) {\n        var _this$levels;\n        if (frag.type !== PlaylistLevelType.SUBTITLE) {\n          var el = frag.elementaryStreams;\n          if (!Object.keys(el).some(function (type) {\n            return !!el[type];\n          })) {\n            // empty segment\n            this.state = State.IDLE;\n            return;\n          }\n        }\n        var level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];\n        if (level != null && level.fragmentError) {\n          this.log(\"Resetting level fragment error count of \" + level.fragmentError + \" on frag buffered\");\n          level.fragmentError = 0;\n        }\n      }\n      this.state = State.IDLE;\n    };\n    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {\n      var transmuxer = this.transmuxer;\n      if (!transmuxer) {\n        return;\n      }\n      var frag = fragLoadedEndData.frag,\n        part = fragLoadedEndData.part,\n        partsLoaded = fragLoadedEndData.partsLoaded;\n      // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n      var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function (fragLoaded) {\n        return !fragLoaded;\n      });\n      var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n      transmuxer.flush(chunkMeta);\n    };\n    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};\n    _proto._doFragLoad = function _doFragLoad(frag, level, targetBufferTime, progressCallback) {\n      var _frag$decryptdata,\n        _this5 = this;\n      if (targetBufferTime === void 0) {\n        targetBufferTime = null;\n      }\n      this.fragCurrent = frag;\n      var details = level.details;\n      if (!this.levels || !details) {\n        throw new Error(\"frag load aborted, missing level\" + (details ? '' : ' detail') + \"s\");\n      }\n      var keyLoadingPromise = null;\n      if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n        this.log(\"Loading key for \" + frag.sn + \" of [\" + details.startSN + \"-\" + details.endSN + \"], \" + this.playlistLabel() + \" \" + frag.level);\n        this.state = State.KEY_LOADING;\n        this.fragCurrent = frag;\n        keyLoadingPromise = this.keyLoader.load(frag).then(function (keyLoadedData) {\n          if (!_this5.fragContextChanged(keyLoadedData.frag)) {\n            _this5.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n            if (_this5.state === State.KEY_LOADING) {\n              _this5.state = State.IDLE;\n            }\n            return keyLoadedData;\n          }\n        });\n        this.hls.trigger(Events.KEY_LOADING, {\n          frag: frag\n        });\n        if (this.fragCurrent === null) {\n          this.log(\"context changed in KEY_LOADING\");\n          return Promise.resolve(null);\n        }\n      } else if (!frag.encrypted) {\n        keyLoadingPromise = this.keyLoader.loadClear(frag, details.encryptedFragments, this.startFragRequested);\n        if (keyLoadingPromise) {\n          this.log(\"[eme] blocking frag load until media-keys acquired\");\n        }\n      }\n      var fragPrevious = this.fragPrevious;\n      if (isMediaFragment(frag) && (!fragPrevious || frag.sn !== fragPrevious.sn)) {\n        var shouldLoadParts = this.shouldLoadParts(level.details, frag.end);\n        if (shouldLoadParts !== this.loadingParts) {\n          this.log(\"LL-Part loading \" + (shouldLoadParts ? 'ON' : 'OFF') + \" loading sn \" + (fragPrevious == null ? void 0 : fragPrevious.sn) + \"->\" + frag.sn);\n          this.loadingParts = shouldLoadParts;\n        }\n      }\n      targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n      if (this.loadingParts && isMediaFragment(frag)) {\n        var partList = details.partList;\n        if (partList && progressCallback) {\n          if (targetBufferTime > details.fragmentEnd && details.fragmentHint) {\n            frag = details.fragmentHint;\n          }\n          var partIndex = this.getNextPart(partList, frag, targetBufferTime);\n          if (partIndex > -1) {\n            var part = partList[partIndex];\n            frag = this.fragCurrent = part.fragment;\n            this.log(\"Loading \" + frag.type + \" sn: \" + frag.sn + \" part: \" + part.index + \" (\" + partIndex + \"/\" + (partList.length - 1) + \") of \" + this.fragInfo(frag, false, part) + \") cc: \" + frag.cc + \" [\" + details.startSN + \"-\" + details.endSN + \"], target: \" + parseFloat(targetBufferTime.toFixed(3)));\n            this.nextLoadPosition = part.start + part.duration;\n            this.state = State.FRAG_LOADING;\n            var _result;\n            if (keyLoadingPromise) {\n              _result = keyLoadingPromise.then(function (keyLoadedData) {\n                if (!keyLoadedData || _this5.fragContextChanged(keyLoadedData.frag)) {\n                  return null;\n                }\n                return _this5.doFragPartsLoad(frag, part, level, progressCallback);\n              }).catch(function (error) {\n                return _this5.handleFragLoadError(error);\n              });\n            } else {\n              _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(function (error) {\n                return _this5.handleFragLoadError(error);\n              });\n            }\n            this.hls.trigger(Events.FRAG_LOADING, {\n              frag: frag,\n              part: part,\n              targetBufferTime: targetBufferTime\n            });\n            if (this.fragCurrent === null) {\n              return Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING parts\"));\n            }\n            return _result;\n          } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n            // Fragment hint has no parts\n            return Promise.resolve(null);\n          }\n        }\n      }\n      if (isMediaFragment(frag) && this.loadingParts) {\n        var _details$partList;\n        this.log(\"LL-Part loading OFF after next part miss @\" + targetBufferTime.toFixed(2) + \" Check buffer at sn: \" + frag.sn + \" loaded parts: \" + ((_details$partList = details.partList) == null ? void 0 : _details$partList.filter(function (p) {\n          return p.loaded;\n        }).map(function (p) {\n          return \"[\" + p.start + \"-\" + p.end + \"]\";\n        })));\n        this.loadingParts = false;\n      } else if (!frag.url) {\n        // Selected fragment hint for part but not loading parts\n        return Promise.resolve(null);\n      }\n      this.log(\"Loading \" + frag.type + \" sn: \" + frag.sn + \" of \" + this.fragInfo(frag, false) + \") cc: \" + frag.cc + \" \" + ('[' + details.startSN + '-' + details.endSN + ']') + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n      // Don't update nextLoadPosition for fragments which are not buffered\n      if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n        this.nextLoadPosition = frag.start + frag.duration;\n      }\n      this.state = State.FRAG_LOADING;\n\n      // Load key before streaming fragment data\n      var dataOnProgress = this.config.progressive && frag.type !== PlaylistLevelType.SUBTITLE;\n      var result;\n      if (dataOnProgress && keyLoadingPromise) {\n        result = keyLoadingPromise.then(function (keyLoadedData) {\n          if (!keyLoadedData || _this5.fragContextChanged(keyLoadedData.frag)) {\n            return null;\n          }\n          return _this5.fragmentLoader.load(frag, progressCallback);\n        }).catch(function (error) {\n          return _this5.handleFragLoadError(error);\n        });\n      } else {\n        // load unencrypted fragment data with progress event,\n        // or handle fragment result after key and fragment are finished loading\n        result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(function (_ref) {\n          var fragLoadedData = _ref[0];\n          if (!dataOnProgress && progressCallback) {\n            progressCallback(fragLoadedData);\n          }\n          return fragLoadedData;\n        }).catch(function (error) {\n          return _this5.handleFragLoadError(error);\n        });\n      }\n      this.hls.trigger(Events.FRAG_LOADING, {\n        frag: frag,\n        targetBufferTime: targetBufferTime\n      });\n      if (this.fragCurrent === null) {\n        return Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING\"));\n      }\n      return result;\n    };\n    _proto.doFragPartsLoad = function doFragPartsLoad(frag, fromPart, level, progressCallback) {\n      var _this6 = this;\n      return new Promise(function (resolve, reject) {\n        var _level$details;\n        var partsLoaded = [];\n        var initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n        var _loadPart = function loadPart(part) {\n          _this6.fragmentLoader.loadPart(frag, part, progressCallback).then(function (partLoadedData) {\n            partsLoaded[part.index] = partLoadedData;\n            var loadedPart = partLoadedData.part;\n            _this6.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n            var nextPart = getPartWith(level.details, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n            if (nextPart) {\n              _loadPart(nextPart);\n            } else {\n              return resolve({\n                frag: frag,\n                part: loadedPart,\n                partsLoaded: partsLoaded\n              });\n            }\n          }).catch(reject);\n        };\n        _loadPart(fromPart);\n      });\n    };\n    _proto.handleFragLoadError = function handleFragLoadError(error) {\n      if ('data' in error) {\n        var data = error.data;\n        if (data.frag && data.details === ErrorDetails.INTERNAL_ABORTED) {\n          this.handleFragLoadAborted(data.frag, data.part);\n        } else if (data.frag && data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n          data.frag.abortRequests();\n          this.resetStartWhenNotLoaded();\n          this.resetFragmentLoading(data.frag);\n        } else {\n          this.hls.trigger(Events.ERROR, data);\n        }\n      } else {\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERNAL_EXCEPTION,\n          err: error,\n          error: error,\n          fatal: true\n        });\n      }\n      return null;\n    };\n    _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {\n      var context = this.getCurrentContext(chunkMeta);\n      if (!context || this.state !== State.PARSING) {\n        if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      var frag = context.frag,\n        part = context.part,\n        level = context.level;\n      var now = self.performance.now();\n      frag.stats.parsing.end = now;\n      if (part) {\n        part.stats.parsing.end = now;\n      }\n      // See if part loading should be disabled/enabled based on buffer and playback position.\n      var levelDetails = this.getLevelDetails();\n      var loadingPartsAtEdge = levelDetails && frag.sn > levelDetails.endSN;\n      var shouldLoadParts = loadingPartsAtEdge || this.shouldLoadParts(levelDetails, frag.end);\n      if (shouldLoadParts !== this.loadingParts) {\n        this.log(\"LL-Part loading \" + (shouldLoadParts ? 'ON' : 'OFF') + \" after parsing segment ending @\" + frag.end.toFixed(2));\n        this.loadingParts = shouldLoadParts;\n      }\n      this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n    };\n    _proto.shouldLoadParts = function shouldLoadParts(details, bufferEnd) {\n      if (this.config.lowLatencyMode) {\n        if (!details) {\n          return this.loadingParts;\n        }\n        if (details.partList) {\n          var _details$fragmentHint;\n          // Buffer must be ahead of first part + duration of parts after last segment\n          // and playback must be at or past segment adjacent to part list\n          var firstPart = details.partList[0];\n          // Loading of VTT subtitle parts is not implemented in subtitle-stream-controller (#7460)\n          if (firstPart.fragment.type === PlaylistLevelType.SUBTITLE) {\n            return false;\n          }\n          var safePartStart = firstPart.end + (((_details$fragmentHint = details.fragmentHint) == null ? void 0 : _details$fragmentHint.duration) || 0);\n          if (bufferEnd >= safePartStart) {\n            var _this$media;\n            var playhead = this.hls.hasEnoughToStart ? ((_this$media = this.media) == null ? void 0 : _this$media.currentTime) || this.lastCurrentTime : this.getLoadPosition();\n            if (playhead > firstPart.start - firstPart.fragment.duration) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n    _proto.getCurrentContext = function getCurrentContext(chunkMeta) {\n      var levels = this.levels,\n        fragCurrent = this.fragCurrent;\n      var levelIndex = chunkMeta.level,\n        sn = chunkMeta.sn,\n        partIndex = chunkMeta.part;\n      if (!(levels != null && levels[levelIndex])) {\n        this.warn(\"Levels object was unset while buffering fragment \" + sn + \" of \" + this.playlistLabel() + \" \" + levelIndex + \". The current chunk will not be buffered.\");\n        return null;\n      }\n      var level = levels[levelIndex];\n      var levelDetails = level.details;\n      var part = partIndex > -1 ? getPartWith(levelDetails, sn, partIndex) : null;\n      var frag = part ? part.fragment : getFragmentWithSN(levelDetails, sn, fragCurrent);\n      if (!frag) {\n        return null;\n      }\n      if (fragCurrent && fragCurrent !== frag) {\n        frag.stats = fragCurrent.stats;\n      }\n      return {\n        frag: frag,\n        part: part,\n        level: level\n      };\n    };\n    _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n      if (this.state !== State.PARSING) {\n        return;\n      }\n      var data1 = data.data1,\n        data2 = data.data2;\n      var buffer = data1;\n      if (data2) {\n        // Combine the moof + mdat so that we buffer with a single append\n        buffer = appendUint8Array(data1, data2);\n      }\n      if (!buffer.length) {\n        return;\n      }\n      var offsetTimestamp = this.initPTS[frag.cc];\n      var offset = offsetTimestamp ? -offsetTimestamp.baseTime / offsetTimestamp.timescale : undefined;\n      var segment = {\n        type: data.type,\n        frag: frag,\n        part: part,\n        chunkMeta: chunkMeta,\n        offset: offset,\n        parent: frag.type,\n        data: buffer\n      };\n      this.hls.trigger(Events.BUFFER_APPENDING, segment);\n      if (data.dropped && data.independent && !part) {\n        if (noBacktracking) {\n          return;\n        }\n        // Clear buffer so that we reload previous segments sequentially if required\n        this.flushBufferGap(frag);\n      }\n    };\n    _proto.flushBufferGap = function flushBufferGap(frag) {\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n      if (!BufferHelper.isBuffered(media, media.currentTime)) {\n        this.flushMainBuffer(0, frag.start);\n        return;\n      }\n      // Remove back-buffer without interrupting playback to allow back tracking\n      var currentTime = media.currentTime;\n      var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n      var fragDuration = frag.duration;\n      var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n      var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n      if (frag.start - start > segmentFraction) {\n        this.flushMainBuffer(start, frag.start);\n      }\n    };\n    _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {\n      var _this$media2;\n      var pos = this.getLoadPosition();\n      if (!isFiniteNumber(pos)) {\n        return null;\n      }\n      var backwardSeek = this.lastCurrentTime > pos;\n      var maxBufferHole = backwardSeek || (_this$media2 = this.media) != null && _this$media2.paused ? 0 : this.config.maxBufferHole;\n      return this.getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole);\n    };\n    _proto.getFwdBufferInfoAtPos = function getFwdBufferInfoAtPos(bufferable, pos, type, maxBufferHole) {\n      var bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n      // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n      if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n        var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n        if (bufferedFragAtPos && (bufferInfo.nextStart <= bufferedFragAtPos.end || bufferedFragAtPos.gap)) {\n          var gapDuration = Math.max(Math.min(bufferInfo.nextStart, bufferedFragAtPos.end) - pos, maxBufferHole);\n          return BufferHelper.bufferInfo(bufferable, pos, gapDuration);\n        }\n      }\n      return bufferInfo;\n    };\n    _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {\n      var config = this.config;\n      var maxBufLen;\n      if (levelBitrate) {\n        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n      } else {\n        maxBufLen = config.maxBufferLength;\n      }\n      return Math.min(maxBufLen, config.maxMaxBufferLength);\n    };\n    _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold, fragDuration) {\n      var config = this.config;\n      var minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);\n      var reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);\n      if (reducedLength >= minLength) {\n        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n        config.maxMaxBufferLength = reducedLength;\n        this.warn(\"Reduce max buffer length to \" + reducedLength + \"s\");\n        return true;\n      }\n      return false;\n    };\n    _proto.getAppendedFrag = function getAppendedFrag(position, playlistType) {\n      if (playlistType === void 0) {\n        playlistType = PlaylistLevelType.MAIN;\n      }\n      var fragOrPart = this.fragmentTracker ? this.fragmentTracker.getAppendedFrag(position, playlistType) : null;\n      if (fragOrPart && 'fragment' in fragOrPart) {\n        return fragOrPart.fragment;\n      }\n      return fragOrPart;\n    };\n    _proto.getNextFragment = function getNextFragment(pos, levelDetails) {\n      var fragments = levelDetails.fragments;\n      var fragLen = fragments.length;\n      if (!fragLen) {\n        return null;\n      }\n\n      // find fragment index, contiguous with end of buffer position\n      var config = this.config;\n      var start = fragments[0].start;\n      var canLoadParts = config.lowLatencyMode && !!levelDetails.partList;\n      var frag = null;\n      if (levelDetails.live) {\n        var initialLiveManifestSize = config.initialLiveManifestSize;\n        if (fragLen < initialLiveManifestSize) {\n          this.warn(\"Not enough fragments to start playback (have: \" + fragLen + \", need: \" + initialLiveManifestSize + \")\");\n          return null;\n        }\n        // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n        // In order to discover the range, we load the best matching fragment for that level and demux it.\n        // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n        // we get the fragment matching that start time\n        if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {\n          var _frag;\n          if (canLoadParts && !this.loadingParts) {\n            this.log(\"LL-Part loading ON for initial live fragment\");\n            this.loadingParts = true;\n          }\n          frag = this.getInitialLiveFragment(levelDetails);\n          var mainStart = this.hls.startPosition;\n          var liveSyncPosition = this.hls.liveSyncPosition;\n          var startPosition = frag ? (mainStart !== -1 && mainStart >= start ? mainStart : liveSyncPosition) || frag.start : pos;\n          this.log(\"Setting startPosition to \" + startPosition + \" to match start frag at live edge. mainStart: \" + mainStart + \" liveSyncPosition: \" + liveSyncPosition + \" frag.start: \" + ((_frag = frag) == null ? void 0 : _frag.start));\n          this.startPosition = this.nextLoadPosition = startPosition;\n        }\n      } else if (pos <= start) {\n        // VoD playlist: if loadPosition before start of playlist, load first fragment\n        frag = fragments[0];\n      }\n\n      // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n      if (!frag) {\n        var end = this.loadingParts ? levelDetails.partEnd : levelDetails.fragmentEnd;\n        frag = this.getFragmentAtPosition(pos, end, levelDetails);\n      }\n      var programFrag = this.filterReplacedPrimary(frag, levelDetails);\n      if (!programFrag && frag) {\n        var curSNIdx = frag.sn - levelDetails.startSN;\n        programFrag = this.filterReplacedPrimary(fragments[curSNIdx + 1] || null, levelDetails);\n      }\n      return this.mapToInitFragWhenRequired(programFrag);\n    };\n    _proto.isLoopLoading = function isLoopLoading(frag, targetBufferTime) {\n      var trackerState = this.fragmentTracker.getState(frag);\n      return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n    };\n    _proto.getNextFragmentLoopLoading = function getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n      var nextFragment = null;\n      if (frag.gap) {\n        nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n        if (nextFragment && !nextFragment.gap && bufferInfo.nextStart) {\n          // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n          var nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType, 0);\n          if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n            // Returning here might result in not finding an audio and video candiate to skip to\n            var sn = nextFragment.sn;\n            if (this.loopSn !== sn) {\n              this.log(\"buffer full after gaps in \\\"\" + playlistType + \"\\\" playlist starting at sn: \" + sn);\n              this.loopSn = sn;\n            }\n            return null;\n          }\n        }\n      }\n      this.loopSn = undefined;\n      return nextFragment;\n    };\n    _proto.filterReplacedPrimary = function filterReplacedPrimary(frag, details) {\n      if (!frag) {\n        return frag;\n      }\n      if (interstitialsEnabled(this.config) && frag.type !== PlaylistLevelType.SUBTITLE) {\n        // Do not load fragments outside the buffering schedule segment\n        var interstitials = this.hls.interstitialsManager;\n        var bufferingItem = interstitials == null ? void 0 : interstitials.bufferingItem;\n        if (bufferingItem) {\n          var bufferingInterstitial = bufferingItem.event;\n          if (bufferingInterstitial) {\n            // Do not stream fragments while buffering Interstitial Events (except for overlap at the start)\n            if (bufferingInterstitial.appendInPlace || Math.abs(frag.start - bufferingItem.start) > 1 || bufferingItem.start === 0) {\n              return null;\n            }\n          } else {\n            // Limit fragment loading to media in schedule item\n            if (frag.end <= bufferingItem.start && (details == null ? void 0 : details.live) === false) {\n              // fragment ends by schedule item start\n              // this.fragmentTracker.fragBuffered(frag, true);\n              return null;\n            }\n            if (frag.start > bufferingItem.end && bufferingItem.nextEvent) {\n              // fragment is past schedule item end\n              // allow some overflow when not appending in place to prevent stalls\n              if (bufferingItem.nextEvent.appendInPlace || frag.start - bufferingItem.end > 1) {\n                return null;\n              }\n            }\n          }\n        }\n        // Skip loading of fragments that overlap completely with appendInPlace interstitials\n        var playerQueue = interstitials == null ? void 0 : interstitials.playerQueue;\n        if (playerQueue) {\n          for (var i = playerQueue.length; i--;) {\n            var interstitial = playerQueue[i].interstitial;\n            if (interstitial.appendInPlace && frag.start >= interstitial.startTime && frag.end <= interstitial.resumeTime) {\n              return null;\n            }\n          }\n        }\n      }\n      return frag;\n    };\n    _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {\n      // If an initSegment is present, it must be buffered first\n      if (frag != null && frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n        return frag.initSegment;\n      }\n      return frag;\n    };\n    _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {\n      var nextPart = -1;\n      var contiguous = false;\n      var independentAttrOmitted = true;\n      for (var i = 0, len = partList.length; i < len; i++) {\n        var part = partList[i];\n        independentAttrOmitted = independentAttrOmitted && !part.independent;\n        if (nextPart > -1 && targetBufferTime < part.start) {\n          break;\n        }\n        var loaded = part.loaded;\n        if (loaded) {\n          nextPart = -1;\n        } else if (contiguous || (part.independent || independentAttrOmitted) && part.fragment === frag) {\n          if (part.fragment !== frag) {\n            this.warn(\"Need buffer at \" + targetBufferTime + \" but next unloaded part starts at \" + part.start);\n          }\n          nextPart = i;\n        }\n        contiguous = loaded;\n      }\n      return nextPart;\n    };\n    _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {\n      var part;\n      for (var i = partList.length; i--;) {\n        part = partList[i];\n        if (!part.loaded) {\n          return false;\n        }\n        if (targetBufferTime > part.start) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /*\n     This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n     \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n     start and end times for each fragment in the playlist (after which this method will not need to be called).\n    */;\n    _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails) {\n      var fragments = levelDetails.fragments;\n      var fragPrevious = this.fragPrevious;\n      var frag = null;\n      if (fragPrevious) {\n        if (levelDetails.hasProgramDateTime) {\n          // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n          this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + fragPrevious.programDateTime);\n          frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n        }\n        if (!frag) {\n          // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n          var targetSN = fragPrevious.sn + 1;\n          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n            var fragNext = fragments[targetSN - levelDetails.startSN];\n            // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n            if (fragPrevious.cc === fragNext.cc) {\n              frag = fragNext;\n              this.log(\"Live playlist, switching playlist, load frag with next SN: \" + frag.sn);\n            }\n          }\n          // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n          // will have the wrong start times\n          if (!frag) {\n            frag = findNearestWithCC(levelDetails, fragPrevious.cc, fragPrevious.end);\n            if (frag) {\n              this.log(\"Live playlist, switching playlist, load frag with same CC: \" + frag.sn);\n            }\n          }\n        }\n      } else {\n        // Find a new start fragment when fragPrevious is null\n        var liveStart = this.hls.liveSyncPosition;\n        if (liveStart !== null) {\n          frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n        }\n      }\n      return frag;\n    }\n\n    /*\n    This method finds the best matching fragment given the provided position.\n     */;\n    _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {\n      var config = this.config;\n      var fragPrevious = this.fragPrevious;\n      var fragments = levelDetails.fragments,\n        endSN = levelDetails.endSN;\n      var fragmentHint = levelDetails.fragmentHint;\n      var maxFragLookUpTolerance = config.maxFragLookUpTolerance;\n      var partList = levelDetails.partList;\n      var loadingParts = !!(this.loadingParts && partList != null && partList.length && fragmentHint);\n      if (loadingParts && !this.bitrateTest && partList[partList.length - 1].fragment.sn === fragmentHint.sn) {\n        // Include incomplete fragment with parts at end\n        fragments = fragments.concat(fragmentHint);\n        endSN = fragmentHint.sn;\n      }\n      var frag;\n      if (bufferEnd < end) {\n        var _this$media3;\n        var backwardSeek = bufferEnd < this.lastCurrentTime;\n        var lookupTolerance = backwardSeek || bufferEnd > end - maxFragLookUpTolerance || (_this$media3 = this.media) != null && _this$media3.paused || !this.startFragRequested ? 0 : maxFragLookUpTolerance;\n        // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n        // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n        frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n      } else {\n        // reach end of playlist\n        frag = fragments[fragments.length - 1];\n      }\n      if (frag) {\n        var curSNIdx = frag.sn - levelDetails.startSN;\n        // Move fragPrevious forward to support forcing the next fragment to load\n        // when the buffer catches up to a previously buffered range.\n        var fragState = this.fragmentTracker.getState(frag);\n        if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n          fragPrevious = frag;\n        }\n        if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn || !levelDetails.live)) {\n          // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n          // non-uniform fragment durations\n          var sameLevel = frag.level === fragPrevious.level;\n          if (sameLevel) {\n            var nextFrag = fragments[curSNIdx + 1];\n            if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n              frag = nextFrag;\n            } else {\n              frag = null;\n            }\n          }\n        }\n      }\n      return frag;\n    };\n    _proto.alignPlaylists = function alignPlaylists(details, previousDetails, switchDetails) {\n      // TODO: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n      //  this could all go in level-helper mergeDetails()\n      var length = details.fragments.length;\n      if (!length) {\n        this.warn(\"No fragments in live playlist\");\n        return 0;\n      }\n      var slidingStart = details.fragmentStart;\n      var firstLevelLoad = !previousDetails;\n      var aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n      if (firstLevelLoad || !aligned && !slidingStart) {\n        alignStream(switchDetails, details);\n        var alignedSlidingStart = details.fragmentStart;\n        this.log(\"Live playlist sliding: \" + alignedSlidingStart.toFixed(2) + \" start-sn: \" + (previousDetails ? previousDetails.startSN : 'na') + \"->\" + details.startSN + \" fragments: \" + length);\n        return alignedSlidingStart;\n      }\n      return slidingStart;\n    };\n    _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {\n      // Wait for Low-Latency CDN Tune-in to get an updated playlist\n      var advancePartLimit = 3;\n      return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n    };\n    _proto.setStartPosition = function setStartPosition(details, sliding) {\n      // compute start position if set to -1. use it straight away if value is defined\n      var startPosition = this.startPosition;\n      if (startPosition < sliding) {\n        startPosition = -1;\n      }\n      var timelineOffset = this.timelineOffset;\n      if (startPosition === -1) {\n        // Use Playlist EXT-X-START:TIME-OFFSET when set\n        // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n        var offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n        var startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n        if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n          startPosition = sliding + startTimeOffset;\n          if (startTimeOffset < 0) {\n            startPosition += details.edge;\n          }\n          startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n          this.log(\"Setting startPosition to \" + startPosition + \" for start time offset \" + startTimeOffset + \" found in \" + (offsetInMultivariantPlaylist ? 'multivariant' : 'media') + \" playlist\");\n          this.startPosition = startPosition;\n        } else if (details.live) {\n          // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n          // not been specified via the config or an as an argument to startLoad (#3736).\n          startPosition = this.hls.liveSyncPosition || sliding;\n          this.log(\"Setting startPosition to -1 to start at live edge \" + startPosition);\n          this.startPosition = -1;\n        } else {\n          this.log(\"setting startPosition to 0 by default\");\n          this.startPosition = startPosition = 0;\n        }\n        this.lastCurrentTime = startPosition + timelineOffset;\n      }\n      this.nextLoadPosition = startPosition + timelineOffset;\n    };\n    _proto.getLoadPosition = function getLoadPosition() {\n      var _this$hls;\n      var media = this.media;\n      // if we have not yet loaded any fragment, start loading from start position\n      var pos = 0;\n      if ((_this$hls = this.hls) != null && _this$hls.hasEnoughToStart && media) {\n        pos = media.currentTime;\n      } else if (this.nextLoadPosition >= 0) {\n        pos = this.nextLoadPosition;\n      }\n      return pos;\n    };\n    _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {\n      if (this.transmuxer && frag.type === this.playlistType && isMediaFragment(frag) && frag.stats.aborted) {\n        this.log(\"Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of \" + this.playlistLabel() + \" \" + frag.level + \" was aborted\");\n        this.resetFragmentLoading(frag);\n      }\n    };\n    _proto.resetFragmentLoading = function resetFragmentLoading(frag) {\n      if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n        this.state = State.IDLE;\n      }\n    };\n    _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {\n      var _this$hls$latestLevel;\n      if (data.chunkMeta && !data.frag) {\n        var context = this.getCurrentContext(data.chunkMeta);\n        if (context) {\n          data.frag = context.frag;\n        }\n      }\n      var frag = data.frag;\n      // Handle frag error related to caller's filterType\n      if (!frag || frag.type !== filterType || !this.levels) {\n        return;\n      }\n      if (this.fragContextChanged(frag)) {\n        var _this$fragCurrent;\n        this.warn(\"Frag load error must match current frag to retry \" + frag.url + \" > \" + ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.url));\n        return;\n      }\n      var gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n      if (gapTagEncountered) {\n        this.fragmentTracker.fragBuffered(frag, true);\n      }\n      // keep retrying until the limit will be reached\n      var errorAction = data.errorAction;\n      if (!errorAction) {\n        this.state = State.ERROR;\n        return;\n      }\n      var action = errorAction.action,\n        flags = errorAction.flags,\n        _errorAction$retryCou = errorAction.retryCount,\n        retryCount = _errorAction$retryCou === void 0 ? 0 : _errorAction$retryCou,\n        retryConfig = errorAction.retryConfig;\n      var couldRetry = !!retryConfig;\n      var retry = couldRetry && action === NetworkErrorAction.RetryRequest;\n      var noAlternate = couldRetry && !errorAction.resolved && flags === ErrorActionFlags.MoveAllAlternatesMatchingHost;\n      var live = (_this$hls$latestLevel = this.hls.latestLevelDetails) == null ? void 0 : _this$hls$latestLevel.live;\n      if (!retry && noAlternate && isMediaFragment(frag) && !frag.endList && live && !isUnusableKeyError(data)) {\n        this.resetFragmentErrors(filterType);\n        this.treatAsGap(frag);\n        errorAction.resolved = true;\n      } else if ((retry || noAlternate) && retryCount < retryConfig.maxNumRetry) {\n        var _data$response;\n        var offlineStatus = offlineHttpStatus((_data$response = data.response) == null ? void 0 : _data$response.code);\n        var delay = getRetryDelay(retryConfig, retryCount);\n        this.resetStartWhenNotLoaded();\n        this.retryDate = self.performance.now() + delay;\n        this.state = State.FRAG_LOADING_WAITING_RETRY;\n        errorAction.resolved = true;\n        if (offlineStatus) {\n          this.log(\"Waiting for connection (offline)\");\n          this.retryDate = Infinity;\n          data.reason = 'offline';\n          return;\n        }\n        this.warn(\"Fragment \" + frag.sn + \" of \" + filterType + \" \" + frag.level + \" errored with \" + data.details + \", retrying loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" in \" + delay + \"ms\");\n      } else if (retryConfig) {\n        this.resetFragmentErrors(filterType);\n        if (retryCount < retryConfig.maxNumRetry) {\n          // Network retry is skipped when level switch is preferred\n          if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {\n            errorAction.resolved = true;\n          }\n        } else {\n          this.warn(data.details + \" reached or exceeded max retry (\" + retryCount + \")\");\n          return;\n        }\n      } else if (action === NetworkErrorAction.SendAlternateToPenaltyBox) {\n        this.state = State.WAITING_LEVEL;\n      } else {\n        this.state = State.ERROR;\n      }\n      // Perform next async tick sooner to speed up error action resolution\n      this.tickImmediate();\n    };\n    _proto.checkRetryDate = function checkRetryDate() {\n      var now = self.performance.now();\n      var retryDate = this.retryDate;\n      // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n      var waitingForConnection = retryDate === Infinity;\n      if (!retryDate || now >= retryDate || waitingForConnection && !offlineHttpStatus(0)) {\n        if (waitingForConnection) {\n          this.log(\"Connection restored (online)\");\n        }\n        this.resetStartWhenNotLoaded();\n        this.state = State.IDLE;\n      }\n    };\n    _proto.reduceLengthAndFlushBuffer = function reduceLengthAndFlushBuffer(data) {\n      // if in appending state\n      if (this.state === State.PARSING || this.state === State.PARSED) {\n        var frag = data.frag;\n        var playlistType = data.parent;\n        var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n        // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n        // reduce max buf len if current position is buffered\n        var buffered = bufferedInfo && bufferedInfo.len > 0.5;\n        if (buffered) {\n          this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? void 0 : frag.duration) || 10);\n        }\n        var flushBuffer = !buffered;\n        if (flushBuffer) {\n          // current position is not buffered, but browser is still complaining about buffer full error\n          // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n          // in that case flush the whole audio buffer to recover\n          this.warn(\"Buffer full error while media.currentTime (\" + this.getLoadPosition() + \") is not buffered, flush \" + playlistType + \" buffer\");\n        }\n        if (frag) {\n          this.fragmentTracker.removeFragment(frag);\n          this.nextLoadPosition = frag.start;\n        }\n        this.resetLoadingState();\n        return flushBuffer;\n      }\n      return false;\n    };\n    _proto.resetFragmentErrors = function resetFragmentErrors(filterType) {\n      if (filterType === PlaylistLevelType.AUDIO) {\n        // Reset current fragment since audio track audio is essential and may not have a fail-over track\n        this.fragCurrent = null;\n      }\n      // Fragment errors that result in a level switch or redundant fail-over\n      // should reset the stream controller state to idle\n      if (!this.hls.hasEnoughToStart) {\n        this.startFragRequested = false;\n      }\n      if (this.state !== State.STOPPED) {\n        this.state = State.IDLE;\n      }\n    };\n    _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {\n      if (!media) {\n        return;\n      }\n      // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n      // (so that we will check against video.buffered ranges in case of alt audio track)\n      var bufferedTimeRanges = BufferHelper.getBuffered(media);\n      this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n      if (this.state === State.ENDED) {\n        this.resetLoadingState();\n      }\n    };\n    _proto.resetLoadingState = function resetLoadingState() {\n      this.log('Reset loading state');\n      this.fragCurrent = null;\n      this.fragPrevious = null;\n      if (this.state !== State.STOPPED) {\n        this.state = State.IDLE;\n      }\n    };\n    _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded() {\n      // if loadedmetadata is not set, it means that first frag request failed\n      // in that case, reset startFragRequested flag\n      if (!this.hls.hasEnoughToStart) {\n        this.startFragRequested = false;\n        var level = this.levelLastLoaded;\n        var details = level ? level.details : null;\n        if (details != null && details.live) {\n          // Update the start position and return to IDLE to recover live start\n          this.log(\"resetting startPosition for live start\");\n          this.startPosition = -1;\n          this.setStartPosition(details, details.fragmentStart);\n          this.resetLoadingState();\n        } else {\n          this.nextLoadPosition = this.startPosition;\n        }\n      }\n    };\n    _proto.resetWhenMissingContext = function resetWhenMissingContext(chunkMeta) {\n      this.log(\"Loading context changed while buffering sn \" + chunkMeta.sn + \" of \" + this.playlistLabel() + \" \" + (chunkMeta.level === -1 ? '<removed>' : chunkMeta.level) + \". This chunk will not be buffered.\");\n      this.removeUnbufferedFrags();\n      this.resetStartWhenNotLoaded();\n      this.resetLoadingState();\n    };\n    _proto.removeUnbufferedFrags = function removeUnbufferedFrags(start) {\n      if (start === void 0) {\n        start = 0;\n      }\n      this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n    };\n    _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {\n      var _this7 = this;\n      var details = level.details;\n      if (!details) {\n        this.warn('level.details undefined');\n        return;\n      }\n      var parsed = Object.keys(frag.elementaryStreams).reduce(function (result, type) {\n        var info = frag.elementaryStreams[type];\n        if (info) {\n          var parsedDuration = info.endPTS - info.startPTS;\n          if (parsedDuration <= 0) {\n            // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n            // The new transmuxer will be configured with a time offset matching the next fragment start,\n            // preventing the timeline from shifting.\n            _this7.warn(\"Could not parse fragment \" + frag.sn + \" \" + type + \" duration reliably (\" + parsedDuration + \")\");\n            return result || false;\n          }\n          var drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS, _this7);\n          _this7.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n            details: details,\n            level: level,\n            drift: drift,\n            type: type,\n            frag: frag,\n            start: info.startPTS,\n            end: info.endPTS\n          });\n          return true;\n        }\n        return result;\n      }, false);\n      if (!parsed) {\n        var _this$transmuxer;\n        var mediaNotFound = ((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null;\n        if (level.fragmentError === 0 || mediaNotFound && (level.fragmentError < 2 || frag.endList)) {\n          // Mark and track the odd (or last) empty segment as a gap to avoid reloading\n          this.treatAsGap(frag, level);\n        }\n        if (mediaNotFound) {\n          var error = new Error(\"Found no media in fragment \" + frag.sn + \" of \" + this.playlistLabel() + \" \" + frag.level + \" resetting transmuxer to fallback to playlist timing\");\n          this.warn(error.message);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: false,\n            error: error,\n            frag: frag,\n            reason: \"Found no media in msn \" + frag.sn + \" of \" + this.playlistLabel() + \" \\\"\" + level.url + \"\\\"\"\n          });\n          if (!this.hls) {\n            return;\n          }\n          this.resetTransmuxer();\n        }\n        // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n      }\n      this.state = State.PARSED;\n      this.log(\"Parsed \" + frag.type + \" sn: \" + frag.sn + (part ? ' part: ' + part.index : '') + \" of \" + this.fragInfo(frag, false, part) + \")\");\n      this.hls.trigger(Events.FRAG_PARSED, {\n        frag: frag,\n        part: part\n      });\n    };\n    _proto.playlistLabel = function playlistLabel() {\n      return this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track';\n    };\n    _proto.fragInfo = function fragInfo(frag, pts, part) {\n      var _ref2, _ref3;\n      if (pts === void 0) {\n        pts = true;\n      }\n      return this.playlistLabel() + \" \" + frag.level + \" (\" + (part ? 'part' : 'frag') + \":[\" + ((_ref2 = pts && !part ? frag.startPTS : (part || frag).start) != null ? _ref2 : NaN).toFixed(3) + \"-\" + ((_ref3 = pts && !part ? frag.endPTS : (part || frag).end) != null ? _ref3 : NaN).toFixed(3) + \"]\" + (part && frag.type === 'main' ? 'INDEPENDENT=' + (part.independent ? 'YES' : 'NO') : '');\n    };\n    _proto.treatAsGap = function treatAsGap(frag, level) {\n      if (level) {\n        level.fragmentError++;\n      }\n      frag.gap = true;\n      this.fragmentTracker.removeFragment(frag);\n      this.fragmentTracker.fragBuffered(frag, true);\n    };\n    _proto.resetTransmuxer = function resetTransmuxer() {\n      var _this$transmuxer2;\n      (_this$transmuxer2 = this.transmuxer) == null || _this$transmuxer2.reset();\n    };\n    _proto.recoverWorkerError = function recoverWorkerError(data) {\n      if (data.event === 'demuxerWorker') {\n        this.fragmentTracker.removeAllFragments();\n        if (this.transmuxer) {\n          this.transmuxer.destroy();\n          this.transmuxer = null;\n        }\n        this.resetStartWhenNotLoaded();\n        this.resetLoadingState();\n      }\n    };\n    return _createClass(BaseStreamController, [{\n      key: \"startPositionValue\",\n      get: function get() {\n        var nextLoadPosition = this.nextLoadPosition,\n          startPosition = this.startPosition;\n        if (startPosition === -1 && nextLoadPosition) {\n          return nextLoadPosition;\n        }\n        return startPosition;\n      }\n    }, {\n      key: \"bufferingEnabled\",\n      get: function get() {\n        return this.buffering;\n      }\n    }, {\n      key: \"inFlightFrag\",\n      get: function get() {\n        return {\n          frag: this.fragCurrent,\n          state: this.state\n        };\n      }\n    }, {\n      key: \"timelineOffset\",\n      get: function get() {\n        var configuredTimelineOffset = this.config.timelineOffset;\n        if (configuredTimelineOffset) {\n          var _this$getLevelDetails;\n          return ((_this$getLevelDetails = this.getLevelDetails()) == null ? void 0 : _this$getLevelDetails.appliedTimelineOffset) || configuredTimelineOffset;\n        }\n        return 0;\n      }\n    }, {\n      key: \"primaryPrefetch\",\n      get: function get() {\n        if (interstitialsEnabled(this.config)) {\n          var _this$hls$interstitia;\n          var playingInterstitial = (_this$hls$interstitia = this.hls.interstitialsManager) == null || (_this$hls$interstitia = _this$hls$interstitia.playingItem) == null ? void 0 : _this$hls$interstitia.event;\n          if (playingInterstitial) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }, {\n      key: \"state\",\n      get: function get() {\n        return this._state;\n      },\n      set: function set(nextState) {\n        var previousState = this._state;\n        if (previousState !== nextState) {\n          this._state = nextState;\n          this.log(previousState + \"->\" + nextState);\n        }\n      }\n    }]);\n  }(TaskLoop);\n  function interstitialsEnabled(config) {\n    return !!config.interstitialsController && config.enableInterstitialPlayback !== false;\n  }\n\n  var ChunkCache = /*#__PURE__*/function () {\n    function ChunkCache() {\n      this.chunks = [];\n      this.dataLength = 0;\n    }\n    var _proto = ChunkCache.prototype;\n    _proto.push = function push(chunk) {\n      this.chunks.push(chunk);\n      this.dataLength += chunk.length;\n    };\n    _proto.flush = function flush() {\n      var chunks = this.chunks,\n        dataLength = this.dataLength;\n      var result;\n      if (!chunks.length) {\n        return new Uint8Array(0);\n      } else if (chunks.length === 1) {\n        result = chunks[0];\n      } else {\n        result = concatUint8Arrays(chunks, dataLength);\n      }\n      this.reset();\n      return result;\n    };\n    _proto.reset = function reset() {\n      this.chunks.length = 0;\n      this.dataLength = 0;\n    };\n    return ChunkCache;\n  }();\n  function concatUint8Arrays(chunks, dataLength) {\n    var result = new Uint8Array(dataLength);\n    var offset = 0;\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n      result.set(chunk, offset);\n      offset += chunk.length;\n    }\n    return result;\n  }\n\n  /**\n   * Returns true if an ID3 footer can be found at offset in data\n   *\n   * @param data - The data to search in\n   * @param offset - The offset at which to start searching\n   *\n   * @returns `true` if an ID3 footer is found\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function isId3Footer(data, offset) {\n    /*\n     * The footer is a copy of the header, but with a different identifier\n     */\n    if (offset + 10 <= data.length) {\n      // look for '3DI' identifier\n      if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n        // check version is within range\n        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n          // check size is within range\n          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if an ID3 header can be found at offset in data\n   *\n   * @param data - The data to search in\n   * @param offset - The offset at which to start searching\n   *\n   * @returns `true` if an ID3 header is found\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function isId3Header(data, offset) {\n    /*\n     * http://id3.org/id3v2.3.0\n     * [0]     = 'I'\n     * [1]     = 'D'\n     * [2]     = '3'\n     * [3,4]   = {Version}\n     * [5]     = {Flags}\n     * [6-9]   = {ID3 Size}\n     *\n     * An ID3v2 tag can be detected with the following pattern:\n     *  $49 44 33 yy yy xx zz zz zz zz\n     * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n     */\n    if (offset + 10 <= data.length) {\n      // look for 'ID3' identifier\n      if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n        // check version is within range\n        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n          // check size is within range\n          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Read ID3 size\n   *\n   * @param data - The data to read from\n   * @param offset - The offset at which to start reading\n   *\n   * @returns The size\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function readId3Size(data, offset) {\n    var size = 0;\n    size = (data[offset] & 0x7f) << 21;\n    size |= (data[offset + 1] & 0x7f) << 14;\n    size |= (data[offset + 2] & 0x7f) << 7;\n    size |= data[offset + 3] & 0x7f;\n    return size;\n  }\n\n  /**\n   * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n   *\n   * @param data - The data to search in\n   * @param offset - The offset at which to start searching\n   *\n   * @returns The block of data containing any ID3 tags found\n   * or `undefined` if no header is found at the starting offset\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function getId3Data(data, offset) {\n    var front = offset;\n    var length = 0;\n    while (isId3Header(data, offset)) {\n      // ID3 header is 10 bytes\n      length += 10;\n      var size = readId3Size(data, offset + 6);\n      length += size;\n      if (isId3Footer(data, offset + 10)) {\n        // ID3 footer is 10 bytes\n        length += 10;\n      }\n      offset += length;\n    }\n    if (length > 0) {\n      return data.subarray(front, front + length);\n    }\n    return undefined;\n  }\n\n  function getAudioConfig(observer, data, offset, manifestCodec) {\n    var adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    var byte2 = data[offset + 2];\n    var adtsSamplingIndex = byte2 >> 2 & 0xf;\n    if (adtsSamplingIndex > 12) {\n      var error = new Error(\"invalid ADTS sampling index:\" + adtsSamplingIndex);\n      observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: true,\n        error: error,\n        reason: error.message\n      });\n      return;\n    }\n    // MPEG-4 Audio Object Type (profile_ObjectType+1)\n    var adtsObjectType = (byte2 >> 6 & 0x3) + 1;\n    var channelCount = data[offset + 3] >> 6 & 0x3 | (byte2 & 1) << 2;\n    var codec = 'mp4a.40.' + adtsObjectType;\n    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n        ISO/IEC 14496-3 - Table 1.13  Syntax of AudioSpecificConfig()\n      Audio Profile / Audio Object Type\n      0: Null\n      1: AAC Main\n      2: AAC LC (Low Complexity)\n      3: AAC SSR (Scalable Sample Rate)\n      4: AAC LTP (Long Term Prediction)\n      5: SBR (Spectral Band Replication)\n      6: AAC Scalable\n     sampling freq\n      0: 96000 Hz\n      1: 88200 Hz\n      2: 64000 Hz\n      3: 48000 Hz\n      4: 44100 Hz\n      5: 32000 Hz\n      6: 24000 Hz\n      7: 22050 Hz\n      8: 16000 Hz\n      9: 12000 Hz\n      10: 11025 Hz\n      11: 8000 Hz\n      12: 7350 Hz\n      13: Reserved\n      14: Reserved\n      15: frequency is written explictly\n      Channel Configurations\n      These are the channel configurations:\n      0: Defined in AOT Specifc Config\n      1: 1 channel: front-center\n      2: 2 channels: front-left, front-right\n    */\n    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n    var samplerate = adtsSamplingRates[adtsSamplingIndex];\n    var aacSampleIndex = adtsSamplingIndex;\n    if (adtsObjectType === 5 || adtsObjectType === 29) {\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table above, equivalent to substract 3)\n      aacSampleIndex -= 3;\n    }\n    var config = [adtsObjectType << 3 | (aacSampleIndex & 0x0e) >> 1, (aacSampleIndex & 0x01) << 7 | channelCount << 3];\n    logger.log(\"manifest codec:\" + manifestCodec + \", parsed codec:\" + codec + \", channels:\" + channelCount + \", rate:\" + samplerate + \" (ADTS object type:\" + adtsObjectType + \" sampling index:\" + adtsSamplingIndex + \")\");\n    return {\n      config: config,\n      samplerate: samplerate,\n      channelCount: channelCount,\n      codec: codec,\n      parsedCodec: codec,\n      manifestCodec: manifestCodec\n    };\n  }\n  function isHeaderPattern$1(data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n  }\n  function getHeaderLength(data, offset) {\n    return data[offset + 1] & 0x01 ? 7 : 9;\n  }\n  function getFullFrameLength(data, offset) {\n    return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n  }\n  function canGetFrameLength(data, offset) {\n    return offset + 5 < data.length;\n  }\n  function isHeader$1(data, offset) {\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n  }\n  function canParse$1(data, offset) {\n    return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n  }\n  function probe$1(data, offset) {\n    // same as isHeader but we also check that ADTS frame follows last ADTS frame\n    // or end of data is reached\n    if (isHeader$1(data, offset)) {\n      // ADTS header Length\n      var headerLength = getHeaderLength(data, offset);\n      if (offset + headerLength >= data.length) {\n        return false;\n      }\n      // ADTS frame Length\n      var frameLength = getFullFrameLength(data, offset);\n      if (frameLength <= headerLength) {\n        return false;\n      }\n      var newOffset = offset + frameLength;\n      return newOffset === data.length || isHeader$1(data, newOffset);\n    }\n    return false;\n  }\n  function initTrackConfig(track, observer, data, offset, audioCodec) {\n    if (!track.samplerate) {\n      var config = getAudioConfig(observer, data, offset, audioCodec);\n      if (!config) {\n        return;\n      }\n      _extends(track, config);\n    }\n  }\n  function getFrameDuration(samplerate) {\n    return 1024 * 90000 / samplerate;\n  }\n  function parseFrameHeader(data, offset) {\n    // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n    var headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength <= data.length) {\n      // retrieve frame size\n      var frameLength = getFullFrameLength(data, offset) - headerLength;\n      if (frameLength > 0) {\n        // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n        return {\n          headerLength: headerLength,\n          frameLength: frameLength\n        };\n      }\n    }\n  }\n  function appendFrame$1(track, data, offset, pts, frameIndex) {\n    var frameDuration = getFrameDuration(track.samplerate);\n    var stamp = pts + frameIndex * frameDuration;\n    var header = parseFrameHeader(data, offset);\n    var unit;\n    if (header) {\n      var frameLength = header.frameLength,\n        headerLength = header.headerLength;\n      var _length = headerLength + frameLength;\n      var missing = Math.max(0, offset + _length - data.length);\n      // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n      if (missing) {\n        unit = new Uint8Array(_length - headerLength);\n        unit.set(data.subarray(offset + headerLength, data.length), 0);\n      } else {\n        unit = data.subarray(offset + headerLength, offset + _length);\n      }\n      var _sample = {\n        unit: unit,\n        pts: stamp\n      };\n      if (!missing) {\n        track.samples.push(_sample);\n      }\n      return {\n        sample: _sample,\n        length: _length,\n        missing: missing\n      };\n    }\n    // overflow incomplete header\n    var length = data.length - offset;\n    unit = new Uint8Array(length);\n    unit.set(data.subarray(offset, data.length), 0);\n    var sample = {\n      unit: unit,\n      pts: stamp\n    };\n    return {\n      sample: sample,\n      length: length,\n      missing: -1\n    };\n  }\n\n  /**\n   * Checks if the given data contains an ID3 tag.\n   *\n   * @param data - The data to check\n   * @param offset - The offset at which to start checking\n   *\n   * @returns `true` if an ID3 tag is found\n   *\n   * @group ID3\n   *\n   * @beta\n   */\n  function canParseId3(data, offset) {\n    return isId3Header(data, offset) && readId3Size(data, offset + 6) + 10 <= data.length - offset;\n  }\n\n  function toArrayBuffer(view) {\n    if (view instanceof ArrayBuffer) {\n      return view;\n    } else {\n      if (view.byteOffset == 0 && view.byteLength == view.buffer.byteLength) {\n        // This is a TypedArray over the whole buffer.\n        return view.buffer;\n      }\n      // This is a 'view' on the buffer.  Create a new buffer that only contains\n      // the data.  Note that since this isn't an ArrayBuffer, the 'new' call\n      // will allocate a new buffer to hold the copy.\n      return new Uint8Array(view).buffer;\n    }\n  }\n\n  function toUint8(data, offset, length) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    if (length === void 0) {\n      length = Infinity;\n    }\n    return view(data, offset, length, Uint8Array);\n  }\n  function view(data, offset, length, Type) {\n    var buffer = unsafeGetArrayBuffer(data);\n    var bytesPerElement = 1;\n    if ('BYTES_PER_ELEMENT' in Type) {\n      bytesPerElement = Type.BYTES_PER_ELEMENT;\n    }\n    // Absolute end of the |data| view within |buffer|.\n    var dataOffset = isArrayBufferView(data) ? data.byteOffset : 0;\n    var dataEnd = (dataOffset + data.byteLength) / bytesPerElement;\n    // Absolute start of the result within |buffer|.\n    var rawStart = (dataOffset + offset) / bytesPerElement;\n    var start = Math.floor(Math.max(0, Math.min(rawStart, dataEnd)));\n    // Absolute end of the result within |buffer|.\n    var end = Math.floor(Math.min(start + Math.max(length, 0), dataEnd));\n    return new Type(buffer, start, end - start);\n  }\n  function unsafeGetArrayBuffer(view) {\n    if (view instanceof ArrayBuffer) {\n      return view;\n    } else {\n      return view.buffer;\n    }\n  }\n  function isArrayBufferView(obj) {\n    return obj && obj.buffer instanceof ArrayBuffer && obj.byteLength !== undefined && obj.byteOffset !== undefined;\n  }\n\n  function decodeId3ImageFrame(frame) {\n    var metadataFrame = {\n      key: frame.type,\n      description: '',\n      data: '',\n      mimeType: null,\n      pictureType: null\n    };\n    var utf8Encoding = 0x03;\n    if (frame.size < 2) {\n      return undefined;\n    }\n    if (frame.data[0] !== utf8Encoding) {\n      console.log('Ignore frame with unrecognized character ' + 'encoding');\n      return undefined;\n    }\n    var mimeTypeEndIndex = frame.data.subarray(1).indexOf(0);\n    if (mimeTypeEndIndex === -1) {\n      return undefined;\n    }\n    var mimeType = utf8ArrayToStr(toUint8(frame.data, 1, mimeTypeEndIndex));\n    var pictureType = frame.data[2 + mimeTypeEndIndex];\n    var descriptionEndIndex = frame.data.subarray(3 + mimeTypeEndIndex).indexOf(0);\n    if (descriptionEndIndex === -1) {\n      return undefined;\n    }\n    var description = utf8ArrayToStr(toUint8(frame.data, 3 + mimeTypeEndIndex, descriptionEndIndex));\n    var data;\n    if (mimeType === '-->') {\n      data = utf8ArrayToStr(toUint8(frame.data, 4 + mimeTypeEndIndex + descriptionEndIndex));\n    } else {\n      data = toArrayBuffer(frame.data.subarray(4 + mimeTypeEndIndex + descriptionEndIndex));\n    }\n    metadataFrame.mimeType = mimeType;\n    metadataFrame.pictureType = pictureType;\n    metadataFrame.description = description;\n    metadataFrame.data = data;\n    return metadataFrame;\n  }\n\n  /**\n   * Decode an ID3 PRIV frame.\n   *\n   * @param frame - the ID3 PRIV frame\n   *\n   * @returns The decoded ID3 PRIV frame\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function decodeId3PrivFrame(frame) {\n    /*\n    Format: <text string>\\0<binary data>\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n    var owner = utf8ArrayToStr(frame.data, true);\n    var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n    return {\n      key: frame.type,\n      info: owner,\n      data: privateData.buffer\n    };\n  }\n\n  /**\n   * Decodes an ID3 text frame\n   *\n   * @param frame - the ID3 text frame\n   *\n   * @returns The decoded ID3 text frame\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function decodeId3TextFrame(frame) {\n    if (frame.size < 2) {\n      return undefined;\n    }\n    if (frame.type === 'TXXX') {\n      /*\n      Format:\n      [0]   = {Text Encoding}\n      [1-?] = {Description}\\0{Value}\n      */\n      var index = 1;\n      var description = utf8ArrayToStr(frame.data.subarray(index), true);\n      index += description.length + 1;\n      var value = utf8ArrayToStr(frame.data.subarray(index));\n      return {\n        key: frame.type,\n        info: description,\n        data: value\n      };\n    }\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Value}\n    */\n    var text = utf8ArrayToStr(frame.data.subarray(1));\n    return {\n      key: frame.type,\n      info: '',\n      data: text\n    };\n  }\n\n  /**\n   * Decode a URL frame\n   *\n   * @param frame - the ID3 URL frame\n   *\n   * @returns The decoded ID3 URL frame\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function decodeId3UrlFrame(frame) {\n    if (frame.type === 'WXXX') {\n      /*\n      Format:\n      [0]   = {Text Encoding}\n      [1-?] = {Description}\\0{URL}\n      */\n      if (frame.size < 2) {\n        return undefined;\n      }\n      var index = 1;\n      var description = utf8ArrayToStr(frame.data.subarray(index), true);\n      index += description.length + 1;\n      var value = utf8ArrayToStr(frame.data.subarray(index));\n      return {\n        key: frame.type,\n        info: description,\n        data: value\n      };\n    }\n    /*\n    Format:\n    [0-?] = {URL}\n    */\n    var url = utf8ArrayToStr(frame.data);\n    return {\n      key: frame.type,\n      info: '',\n      data: url\n    };\n  }\n\n  /**\n   * Decode an ID3 frame.\n   *\n   * @param frame - the ID3 frame\n   *\n   * @returns The decoded ID3 frame\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function decodeId3Frame(frame) {\n    if (frame.type === 'PRIV') {\n      return decodeId3PrivFrame(frame);\n    } else if (frame.type[0] === 'W') {\n      return decodeId3UrlFrame(frame);\n    } else if (frame.type === 'APIC') {\n      return decodeId3ImageFrame(frame);\n    }\n    return decodeId3TextFrame(frame);\n  }\n\n  /**\n   * Returns the data of an ID3 frame.\n   *\n   * @param data - The data to read from\n   *\n   * @returns The data of the ID3 frame\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function getId3FrameData(data) {\n    /*\n    Frame ID       $xx xx xx xx (four characters)\n    Size           $xx xx xx xx\n    Flags          $xx xx\n    */\n    var type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n    var size = readId3Size(data, 4);\n    // skip frame id, size, and flags\n    var offset = 10;\n    return {\n      type: type,\n      size: size,\n      data: data.subarray(offset, offset + size)\n    };\n  }\n\n  var HEADER_FOOTER_SIZE = 10;\n  var FRAME_SIZE = 10;\n  /**\n   * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n   *\n   * @param id3Data - The ID3 data containing one or more ID3 tags\n   *\n   * @returns Array of ID3 frame objects\n   *\n   * @group ID3\n   *\n   * @beta\n   */\n  function getId3Frames(id3Data) {\n    var offset = 0;\n    var frames = [];\n    while (isId3Header(id3Data, offset)) {\n      var size = readId3Size(id3Data, offset + 6);\n      if (id3Data[offset + 5] >> 6 & 1) {\n        // skip extended header\n        offset += HEADER_FOOTER_SIZE;\n      }\n      // skip past ID3 header\n      offset += HEADER_FOOTER_SIZE;\n      var end = offset + size;\n      // loop through frames in the ID3 tag\n      while (offset + FRAME_SIZE < end) {\n        var frameData = getId3FrameData(id3Data.subarray(offset));\n        var frame = decodeId3Frame(frameData);\n        if (frame) {\n          frames.push(frame);\n        }\n        // skip frame header and frame data\n        offset += frameData.size + HEADER_FOOTER_SIZE;\n      }\n      if (isId3Footer(id3Data, offset)) {\n        offset += HEADER_FOOTER_SIZE;\n      }\n    }\n    return frames;\n  }\n\n  /**\n   * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n   *\n   * @param frame - the ID3 frame\n   *\n   * @returns `true` if the ID3 frame is an Elementary Stream timestamp frame\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function isId3TimestampFrame(frame) {\n    return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n  }\n\n  /**\n   * Read a 33 bit timestamp from an ID3 frame.\n   *\n   * @param timeStampFrame - the ID3 frame\n   *\n   * @returns The timestamp\n   *\n   * @internal\n   *\n   * @group ID3\n   */\n  function readId3Timestamp(timeStampFrame) {\n    if (timeStampFrame.data.byteLength === 8) {\n      var data = new Uint8Array(timeStampFrame.data);\n      // timestamp is 33 bit expressed as a big-endian eight-octet number,\n      // with the upper 31 bits set to zero.\n      var pts33Bit = data[3] & 0x1;\n      var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n      timestamp /= 45;\n      if (pts33Bit) {\n        timestamp += 47721858.84;\n      } // 2^32 / 90\n      return Math.round(timestamp);\n    }\n    return undefined;\n  }\n\n  /**\n   * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n   *\n   * @param data - Block of data containing one or more ID3 tags\n   *\n   * @returns The timestamp\n   *\n   * @group ID3\n   *\n   * @beta\n   */\n  function getId3Timestamp(data) {\n    var frames = getId3Frames(data);\n    for (var i = 0; i < frames.length; i++) {\n      var frame = frames[i];\n      if (isId3TimestampFrame(frame)) {\n        return readId3Timestamp(frame);\n      }\n    }\n    return undefined;\n  }\n\n  var MetadataSchema = /*#__PURE__*/function (MetadataSchema) {\n    MetadataSchema[\"audioId3\"] = \"org.id3\";\n    MetadataSchema[\"dateRange\"] = \"com.apple.quicktime.HLS\";\n    MetadataSchema[\"emsg\"] = \"https://aomedia.org/emsg/ID3\";\n    MetadataSchema[\"misbklv\"] = \"urn:misb:KLV:bin:1910.1\";\n    return MetadataSchema;\n  }({});\n\n  function dummyTrack(type, inputTimeScale) {\n    if (type === void 0) {\n      type = '';\n    }\n    if (inputTimeScale === void 0) {\n      inputTimeScale = 90000;\n    }\n    return {\n      type: type,\n      id: -1,\n      pid: -1,\n      inputTimeScale: inputTimeScale,\n      sequenceNumber: -1,\n      samples: [],\n      dropped: 0\n    };\n  }\n\n  var BaseAudioDemuxer = /*#__PURE__*/function () {\n    function BaseAudioDemuxer() {\n      this._audioTrack = void 0;\n      this._id3Track = void 0;\n      this.frameIndex = 0;\n      this.cachedData = null;\n      this.basePTS = null;\n      this.initPTS = null;\n      this.lastPTS = null;\n    }\n    var _proto = BaseAudioDemuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      this._id3Track = {\n        type: 'id3',\n        id: 3,\n        pid: -1,\n        inputTimeScale: 90000,\n        sequenceNumber: 0,\n        samples: [],\n        dropped: 0\n      };\n    };\n    _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {\n      this.initPTS = deaultTimestamp;\n      this.resetContiguity();\n    };\n    _proto.resetContiguity = function resetContiguity() {\n      this.basePTS = null;\n      this.lastPTS = null;\n      this.frameIndex = 0;\n    };\n    _proto.canParse = function canParse(data, offset) {\n      return false;\n    };\n    _proto.appendFrame = function appendFrame(track, data, offset) {}\n\n    // feed incoming data to the front of the parsing pipeline\n    ;\n    _proto.demux = function demux(data, timeOffset) {\n      if (this.cachedData) {\n        data = appendUint8Array(this.cachedData, data);\n        this.cachedData = null;\n      }\n      var id3Data = getId3Data(data, 0);\n      var offset = id3Data ? id3Data.length : 0;\n      var lastDataIndex;\n      var track = this._audioTrack;\n      var id3Track = this._id3Track;\n      var timestamp = id3Data ? getId3Timestamp(id3Data) : undefined;\n      var length = data.length;\n      if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n        this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n        this.lastPTS = this.basePTS;\n      }\n      if (this.lastPTS === null) {\n        this.lastPTS = this.basePTS;\n      }\n\n      // more expressive than alternative: id3Data?.length\n      if (id3Data && id3Data.length > 0) {\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n      }\n      while (offset < length) {\n        if (this.canParse(data, offset)) {\n          var frame = this.appendFrame(track, data, offset);\n          if (frame) {\n            this.frameIndex++;\n            this.lastPTS = frame.sample.pts;\n            offset += frame.length;\n            lastDataIndex = offset;\n          } else {\n            offset = length;\n          }\n        } else if (canParseId3(data, offset)) {\n          // after a canParse, a call to getId3Data *should* always returns some data\n          id3Data = getId3Data(data, offset);\n          id3Track.samples.push({\n            pts: this.lastPTS,\n            dts: this.lastPTS,\n            data: id3Data,\n            type: MetadataSchema.audioId3,\n            duration: Number.POSITIVE_INFINITY\n          });\n          offset += id3Data.length;\n          lastDataIndex = offset;\n        } else {\n          offset++;\n        }\n        if (offset === length && lastDataIndex !== length) {\n          var partialData = data.slice(lastDataIndex);\n          if (this.cachedData) {\n            this.cachedData = appendUint8Array(this.cachedData, partialData);\n          } else {\n            this.cachedData = partialData;\n          }\n        }\n      }\n      return {\n        audioTrack: track,\n        videoTrack: dummyTrack(),\n        id3Track: id3Track,\n        textTrack: dummyTrack()\n      };\n    };\n    _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n      return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n    };\n    _proto.flush = function flush(timeOffset) {\n      // Parse cache in case of remaining frames.\n      var cachedData = this.cachedData;\n      if (cachedData) {\n        this.cachedData = null;\n        this.demux(cachedData, 0);\n      }\n      return {\n        audioTrack: this._audioTrack,\n        videoTrack: dummyTrack(),\n        id3Track: this._id3Track,\n        textTrack: dummyTrack()\n      };\n    };\n    _proto.destroy = function destroy() {\n      this.cachedData = null;\n      // @ts-ignore\n      this._audioTrack = this._id3Track = undefined;\n    };\n    return BaseAudioDemuxer;\n  }();\n  /**\n   * Initialize PTS\n   * <p>\n   *    use timestamp unless it is undefined, NaN or Infinity\n   * </p>\n   */\n  var initPTSFn = function initPTSFn(timestamp, timeOffset, initPTS) {\n    if (isFiniteNumber(timestamp)) {\n      return timestamp * 90;\n    }\n    var init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n    return timeOffset * 90000 + init90kHz;\n  };\n\n  /**\n   *  MPEG parser helper\n   */\n\n  var chromeVersion$1 = null;\n  var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\n  var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\n  var SamplesCoefficients = [\n  // MPEG 2.5\n  [0,\n  // Reserved\n  72,\n  // Layer3\n  144,\n  // Layer2\n  12 // Layer1\n  ],\n  // Reserved\n  [0,\n  // Reserved\n  0,\n  // Layer3\n  0,\n  // Layer2\n  0 // Layer1\n  ],\n  // MPEG 2\n  [0,\n  // Reserved\n  72,\n  // Layer3\n  144,\n  // Layer2\n  12 // Layer1\n  ],\n  // MPEG 1\n  [0,\n  // Reserved\n  144,\n  // Layer3\n  144,\n  // Layer2\n  12 // Layer1\n  ]];\n  var BytesInSlot = [0,\n  // Reserved\n  1,\n  // Layer3\n  1,\n  // Layer2\n  4 // Layer1\n  ];\n  function appendFrame(track, data, offset, pts, frameIndex) {\n    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n    if (offset + 24 > data.length) {\n      return;\n    }\n    var header = parseHeader(data, offset);\n    if (header && offset + header.frameLength <= data.length) {\n      var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n      var stamp = pts + frameIndex * frameDuration;\n      var sample = {\n        unit: data.subarray(offset, offset + header.frameLength),\n        pts: stamp,\n        dts: stamp\n      };\n      track.config = [];\n      track.channelCount = header.channelCount;\n      track.samplerate = header.sampleRate;\n      track.samples.push(sample);\n      return {\n        sample: sample,\n        length: header.frameLength,\n        missing: 0\n      };\n    }\n  }\n  function parseHeader(data, offset) {\n    var mpegVersion = data[offset + 1] >> 3 & 3;\n    var mpegLayer = data[offset + 1] >> 1 & 3;\n    var bitRateIndex = data[offset + 2] >> 4 & 15;\n    var sampleRateIndex = data[offset + 2] >> 2 & 3;\n    if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n      var paddingBit = data[offset + 2] >> 1 & 1;\n      var channelMode = data[offset + 3] >> 6;\n      var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n      var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n      var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n      var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n      var channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n      var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n      var bytesInSlot = BytesInSlot[mpegLayer];\n      var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n      var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n      if (chromeVersion$1 === null) {\n        var userAgent = navigator.userAgent || '';\n        var result = userAgent.match(/Chrome\\/(\\d+)/i);\n        chromeVersion$1 = result ? parseInt(result[1]) : 0;\n      }\n      var needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n      if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n        // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n        data[offset + 3] = data[offset + 3] | 0x80;\n      }\n      return {\n        sampleRate: sampleRate,\n        channelCount: channelCount,\n        frameLength: frameLength,\n        samplesPerFrame: samplesPerFrame\n      };\n    }\n  }\n  function isHeaderPattern(data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n  }\n  function isHeader(data, offset) {\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    return offset + 1 < data.length && isHeaderPattern(data, offset);\n  }\n  function canParse(data, offset) {\n    var headerSize = 4;\n    return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n  }\n  function probe(data, offset) {\n    // same as isHeader but we also check that MPEG frame follows last MPEG frame\n    // or end of data is reached\n    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n      // MPEG header Length\n      var headerLength = 4;\n      // MPEG frame Length\n      var header = parseHeader(data, offset);\n      var frameLength = headerLength;\n      if (header != null && header.frameLength) {\n        frameLength = header.frameLength;\n      }\n      var newOffset = offset + frameLength;\n      return newOffset === data.length || isHeader(data, newOffset);\n    }\n    return false;\n  }\n\n  var AACDemuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n    function AACDemuxer(observer, config) {\n      var _this;\n      _this = _BaseAudioDemuxer.call(this) || this;\n      _this.observer = void 0;\n      _this.config = void 0;\n      _this.observer = observer;\n      _this.config = config;\n      return _this;\n    }\n    _inheritsLoose(AACDemuxer, _BaseAudioDemuxer);\n    var _proto = AACDemuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n      this._audioTrack = {\n        container: 'audio/adts',\n        type: 'audio',\n        id: 2,\n        pid: -1,\n        sequenceNumber: 0,\n        segmentCodec: 'aac',\n        samples: [],\n        manifestCodec: audioCodec,\n        duration: trackDuration,\n        inputTimeScale: 90000,\n        dropped: 0\n      };\n    }\n\n    // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n    ;\n    AACDemuxer.probe = function probe$2(data, logger) {\n      if (!data) {\n        return false;\n      }\n\n      // Check for the ADTS sync word\n      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n      // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n      // More info https://wiki.multimedia.cx/index.php?title=ADTS\n      var id3Data = getId3Data(data, 0);\n      var offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n      if (probe(data, offset)) {\n        return false;\n      }\n      for (var length = data.length; offset < length; offset++) {\n        if (probe$1(data, offset)) {\n          logger.log('ADTS sync word found !');\n          return true;\n        }\n      }\n      return false;\n    };\n    _proto.canParse = function canParse(data, offset) {\n      return canParse$1(data, offset);\n    };\n    _proto.appendFrame = function appendFrame(track, data, offset) {\n      initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n      var frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n      if (frame && frame.missing === 0) {\n        return frame;\n      }\n    };\n    return AACDemuxer;\n  }(BaseAudioDemuxer);\n\n  var getAudioBSID = function getAudioBSID(data, offset) {\n    // check the bsid to confirm ac-3 | ec-3\n    var bsid = 0;\n    var numBits = 5;\n    offset += numBits;\n    var temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\n    var mask = new Uint32Array(1); // unsigned 32 bit mask value\n    var _byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\n    while (numBits > 0) {\n      _byte[0] = data[offset];\n      // read remaining bits, upto 8 bits at a time\n      var bits = Math.min(numBits, 8);\n      var shift = 8 - bits;\n      mask[0] = 0xff000000 >>> 24 + shift << shift;\n      temp[0] = (_byte[0] & mask[0]) >> shift;\n      bsid = !bsid ? temp[0] : bsid << bits | temp[0];\n      offset += 1;\n      numBits -= bits;\n    }\n    return bsid;\n  };\n\n  var AC3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n    function AC3Demuxer(observer) {\n      var _this;\n      _this = _BaseAudioDemuxer.call(this) || this;\n      _this.observer = void 0;\n      _this.observer = observer;\n      return _this;\n    }\n    _inheritsLoose(AC3Demuxer, _BaseAudioDemuxer);\n    var _proto = AC3Demuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n      this._audioTrack = {\n        container: 'audio/ac-3',\n        type: 'audio',\n        id: 2,\n        pid: -1,\n        sequenceNumber: 0,\n        segmentCodec: 'ac3',\n        samples: [],\n        manifestCodec: audioCodec,\n        duration: trackDuration,\n        inputTimeScale: 90000,\n        dropped: 0\n      };\n    };\n    _proto.canParse = function canParse(data, offset) {\n      return offset + 64 < data.length;\n    };\n    _proto.appendFrame = function appendFrame(track, data, offset) {\n      var frameLength = _appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n      if (frameLength !== -1) {\n        var sample = track.samples[track.samples.length - 1];\n        return {\n          sample: sample,\n          length: frameLength,\n          missing: 0\n        };\n      }\n    };\n    AC3Demuxer.probe = function probe(data) {\n      if (!data) {\n        return false;\n      }\n      var id3Data = getId3Data(data, 0);\n      if (!id3Data) {\n        return false;\n      }\n\n      // look for the ac-3 sync bytes\n      var offset = id3Data.length;\n      if (data[offset] === 0x0b && data[offset + 1] === 0x77 && getId3Timestamp(id3Data) !== undefined &&\n      // check the bsid to confirm ac-3\n      getAudioBSID(data, offset) < 16) {\n        return true;\n      }\n      return false;\n    };\n    return AC3Demuxer;\n  }(BaseAudioDemuxer);\n  function _appendFrame(track, data, start, pts, frameIndex) {\n    if (start + 8 > data.length) {\n      return -1; // not enough bytes left\n    }\n    if (data[start] !== 0x0b || data[start + 1] !== 0x77) {\n      return -1; // invalid magic\n    }\n\n    // get sample rate\n    var samplingRateCode = data[start + 4] >> 6;\n    if (samplingRateCode >= 3) {\n      return -1; // invalid sampling rate\n    }\n    var samplingRateMap = [48000, 44100, 32000];\n    var sampleRate = samplingRateMap[samplingRateCode];\n\n    // get frame size\n    var frameSizeCode = data[start + 4] & 0x3f;\n    var frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];\n    var frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;\n    if (start + frameLength > data.length) {\n      return -1;\n    }\n\n    // get channel count\n    var channelMode = data[start + 6] >> 5;\n    var skipCount = 0;\n    if (channelMode === 2) {\n      skipCount += 2;\n    } else {\n      if (channelMode & 1 && channelMode !== 1) {\n        skipCount += 2;\n      }\n      if (channelMode & 4) {\n        skipCount += 2;\n      }\n    }\n    var lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;\n    var channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];\n    var channelCount = channelsMap[channelMode] + lfeon;\n\n    // build dac3 box\n    var bsid = data[start + 5] >> 3;\n    var bsmod = data[start + 5] & 7;\n    var config = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 0xe0]);\n    var frameDuration = 1536 / sampleRate * 90000;\n    var stamp = pts + frameIndex * frameDuration;\n    var unit = data.subarray(start, start + frameLength);\n    track.config = config;\n    track.channelCount = channelCount;\n    track.samplerate = sampleRate;\n    track.samples.push({\n      unit: unit,\n      pts: stamp\n    });\n    return frameLength;\n  }\n\n  var MP3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n    function MP3Demuxer() {\n      return _BaseAudioDemuxer.apply(this, arguments) || this;\n    }\n    _inheritsLoose(MP3Demuxer, _BaseAudioDemuxer);\n    var _proto = MP3Demuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n      this._audioTrack = {\n        container: 'audio/mpeg',\n        type: 'audio',\n        id: 2,\n        pid: -1,\n        sequenceNumber: 0,\n        segmentCodec: 'mp3',\n        samples: [],\n        manifestCodec: audioCodec,\n        duration: trackDuration,\n        inputTimeScale: 90000,\n        dropped: 0\n      };\n    };\n    MP3Demuxer.probe = function probe$1(data) {\n      if (!data) {\n        return false;\n      }\n\n      // check if data contains ID3 timestamp and MPEG sync word\n      // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n      // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n      // More info http://www.mp3-tech.org/programmer/frame_header.html\n      var id3Data = getId3Data(data, 0);\n      var offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n\n      // Check for ac-3|ec-3 sync bytes and return false if present\n      if (id3Data && data[offset] === 0x0b && data[offset + 1] === 0x77 && getId3Timestamp(id3Data) !== undefined &&\n      // check the bsid to confirm ac-3 or ec-3 (not mp3)\n      getAudioBSID(data, offset) <= 16) {\n        return false;\n      }\n      for (var length = data.length; offset < length; offset++) {\n        if (probe(data, offset)) {\n          logger.log('MPEG Audio sync word found !');\n          return true;\n        }\n      }\n      return false;\n    };\n    _proto.canParse = function canParse$1(data, offset) {\n      return canParse(data, offset);\n    };\n    _proto.appendFrame = function appendFrame$1(track, data, offset) {\n      if (this.basePTS === null) {\n        return;\n      }\n      return appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n    };\n    return MP3Demuxer;\n  }(BaseAudioDemuxer);\n\n  var emsgSchemePattern = /\\/emsg[-/]ID3/i;\n  var MP4Demuxer = /*#__PURE__*/function () {\n    function MP4Demuxer(observer, config) {\n      this.remainderData = null;\n      this.timeOffset = 0;\n      this.config = void 0;\n      this.videoTrack = void 0;\n      this.audioTrack = void 0;\n      this.id3Track = void 0;\n      this.txtTrack = void 0;\n      this.config = config;\n    }\n    var _proto = MP4Demuxer.prototype;\n    _proto.resetTimeStamp = function resetTimeStamp() {};\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      var videoTrack = this.videoTrack = dummyTrack('video', 1);\n      var audioTrack = this.audioTrack = dummyTrack('audio', 1);\n      var captionTrack = this.txtTrack = dummyTrack('text', 1);\n      this.id3Track = dummyTrack('id3', 1);\n      this.timeOffset = 0;\n      if (!(initSegment != null && initSegment.byteLength)) {\n        return;\n      }\n      var initData = parseInitSegment(initSegment);\n      if (initData.video) {\n        var _initData$video = initData.video,\n          id = _initData$video.id,\n          timescale = _initData$video.timescale,\n          codec = _initData$video.codec,\n          supplemental = _initData$video.supplemental;\n        videoTrack.id = id;\n        videoTrack.timescale = captionTrack.timescale = timescale;\n        videoTrack.codec = codec;\n        videoTrack.supplemental = supplemental;\n      }\n      if (initData.audio) {\n        var _initData$audio = initData.audio,\n          _id = _initData$audio.id,\n          _timescale = _initData$audio.timescale,\n          _codec = _initData$audio.codec;\n        audioTrack.id = _id;\n        audioTrack.timescale = _timescale;\n        audioTrack.codec = _codec;\n      }\n      captionTrack.id = RemuxerTrackIdConfig.text;\n      videoTrack.sampleDuration = 0;\n      videoTrack.duration = audioTrack.duration = trackDuration;\n    };\n    _proto.resetContiguity = function resetContiguity() {\n      this.remainderData = null;\n    };\n    MP4Demuxer.probe = function probe(data) {\n      return hasMoofData(data);\n    };\n    _proto.demux = function demux(data, timeOffset) {\n      this.timeOffset = timeOffset;\n      // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n      var videoSamples = data;\n      var videoTrack = this.videoTrack;\n      var textTrack = this.txtTrack;\n      if (this.config.progressive) {\n        // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n        // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n        // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n        if (this.remainderData) {\n          videoSamples = appendUint8Array(this.remainderData, data);\n        }\n        var segmentedData = segmentValidRange(videoSamples);\n        this.remainderData = segmentedData.remainder;\n        videoTrack.samples = segmentedData.valid || new Uint8Array();\n      } else {\n        videoTrack.samples = videoSamples;\n      }\n      var id3Track = this.extractID3Track(videoTrack, timeOffset);\n      textTrack.samples = parseSamples(timeOffset, videoTrack);\n      return {\n        videoTrack: videoTrack,\n        audioTrack: this.audioTrack,\n        id3Track: id3Track,\n        textTrack: this.txtTrack\n      };\n    };\n    _proto.flush = function flush() {\n      var timeOffset = this.timeOffset;\n      var videoTrack = this.videoTrack;\n      var textTrack = this.txtTrack;\n      videoTrack.samples = this.remainderData || new Uint8Array();\n      this.remainderData = null;\n      var id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n      textTrack.samples = parseSamples(timeOffset, videoTrack);\n      return {\n        videoTrack: videoTrack,\n        audioTrack: dummyTrack(),\n        id3Track: id3Track,\n        textTrack: dummyTrack()\n      };\n    };\n    _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {\n      var _this = this;\n      var id3Track = this.id3Track;\n      if (videoTrack.samples.length) {\n        var emsgs = findBox(videoTrack.samples, ['emsg']);\n        if (emsgs) {\n          emsgs.forEach(function (data) {\n            var emsgInfo = parseEmsg(data);\n            if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n              var pts = getEmsgStartTime(emsgInfo, timeOffset);\n              var duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n              // Safari takes anything <= 0.001 seconds and maps it to Infinity\n              if (duration <= 0.001) {\n                duration = Number.POSITIVE_INFINITY;\n              }\n              var payload = emsgInfo.payload;\n              id3Track.samples.push({\n                data: payload,\n                len: payload.byteLength,\n                dts: pts,\n                pts: pts,\n                type: MetadataSchema.emsg,\n                duration: duration\n              });\n            } else if (_this.config.enableEmsgKLVMetadata && emsgInfo.schemeIdUri.startsWith('urn:misb:KLV:bin:1910.1')) {\n              var _pts = getEmsgStartTime(emsgInfo, timeOffset);\n              id3Track.samples.push({\n                data: emsgInfo.payload,\n                len: emsgInfo.payload.byteLength,\n                dts: _pts,\n                pts: _pts,\n                type: MetadataSchema.misbklv,\n                duration: Number.POSITIVE_INFINITY\n              });\n            }\n          });\n        }\n      }\n      return id3Track;\n    };\n    _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n      return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n    };\n    _proto.destroy = function destroy() {\n      // @ts-ignore\n      this.config = null;\n      this.remainderData = null;\n      this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = undefined;\n    };\n    return MP4Demuxer;\n  }();\n  function getEmsgStartTime(emsgInfo, timeOffset) {\n    return isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n  }\n\n  /**\n   * SAMPLE-AES decrypter\n   */\n\n  var SampleAesDecrypter = /*#__PURE__*/function () {\n    function SampleAesDecrypter(observer, config, keyData) {\n      this.keyData = void 0;\n      this.decrypter = void 0;\n      this.keyData = keyData;\n      this.decrypter = new Decrypter(config, {\n        removePKCS7Padding: false\n      });\n    }\n    var _proto = SampleAesDecrypter.prototype;\n    _proto.decryptBuffer = function decryptBuffer(encryptedData) {\n      return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer, DecrypterAesMode.cbc);\n    }\n\n    // AAC - encrypt all full 16 bytes blocks starting from offset 16\n    ;\n    _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback) {\n      var _this = this;\n      var curUnit = samples[sampleIndex].unit;\n      if (curUnit.length <= 16) {\n        // No encrypted portion in this sample (first 16 bytes is not\n        // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n        return;\n      }\n      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n      this.decryptBuffer(encryptedBuffer).then(function (decryptedBuffer) {\n        var decryptedData = new Uint8Array(decryptedBuffer);\n        curUnit.set(decryptedData, 16);\n        if (!_this.decrypter.isSync()) {\n          _this.decryptAacSamples(samples, sampleIndex + 1, callback);\n        }\n      }).catch(callback);\n    };\n    _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {\n      for (;; sampleIndex++) {\n        if (sampleIndex >= samples.length) {\n          callback();\n          return;\n        }\n        if (samples[sampleIndex].unit.length < 32) {\n          continue;\n        }\n        this.decryptAacSample(samples, sampleIndex, callback);\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n\n    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n    ;\n    _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {\n      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n      var encryptedData = new Int8Array(encryptedDataLen);\n      var outputPos = 0;\n      for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n      }\n      return encryptedData;\n    };\n    _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {\n      var uint8DecryptedData = new Uint8Array(decryptedData);\n      var inputPos = 0;\n      for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n        decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n      }\n      return decodedData;\n    };\n    _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n      var _this2 = this;\n      var decodedData = discardEPB(curUnit.data);\n      var encryptedData = this.getAvcEncryptedData(decodedData);\n      this.decryptBuffer(encryptedData.buffer).then(function (decryptedBuffer) {\n        curUnit.data = _this2.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n        if (!_this2.decrypter.isSync()) {\n          _this2.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n        }\n      }).catch(callback);\n    };\n    _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n      if (samples instanceof Uint8Array) {\n        throw new Error('Cannot decrypt samples of type Uint8Array');\n      }\n      for (;; sampleIndex++, unitIndex = 0) {\n        if (sampleIndex >= samples.length) {\n          callback();\n          return;\n        }\n        var curUnits = samples[sampleIndex].units;\n        for (;; unitIndex++) {\n          if (unitIndex >= curUnits.length) {\n            break;\n          }\n          var curUnit = curUnits[unitIndex];\n          if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n            continue;\n          }\n          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n          if (!this.decrypter.isSync()) {\n            return;\n          }\n        }\n      }\n    };\n    return SampleAesDecrypter;\n  }();\n\n  var BaseVideoParser = /*#__PURE__*/function () {\n    function BaseVideoParser() {\n      this.VideoSample = null;\n    }\n    var _proto = BaseVideoParser.prototype;\n    _proto.createVideoSample = function createVideoSample(key, pts, dts) {\n      return {\n        key: key,\n        frame: false,\n        pts: pts,\n        dts: dts,\n        units: [],\n        length: 0\n      };\n    };\n    _proto.getLastNalUnit = function getLastNalUnit(samples) {\n      var _VideoSample;\n      var VideoSample = this.VideoSample;\n      var lastUnit;\n      // try to fallback to previous sample if current one is empty\n      if (!VideoSample || VideoSample.units.length === 0) {\n        VideoSample = samples[samples.length - 1];\n      }\n      if ((_VideoSample = VideoSample) != null && _VideoSample.units) {\n        var units = VideoSample.units;\n        lastUnit = units[units.length - 1];\n      }\n      return lastUnit;\n    };\n    _proto.pushAccessUnit = function pushAccessUnit(VideoSample, videoTrack) {\n      if (VideoSample.units.length && VideoSample.frame) {\n        // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n        if (VideoSample.pts === undefined) {\n          var samples = videoTrack.samples;\n          var nbSamples = samples.length;\n          if (nbSamples) {\n            var lastSample = samples[nbSamples - 1];\n            VideoSample.pts = lastSample.pts;\n            VideoSample.dts = lastSample.dts;\n          } else {\n            // dropping samples, no timestamp found\n            videoTrack.dropped++;\n            return;\n          }\n        }\n        videoTrack.samples.push(VideoSample);\n      }\n    };\n    _proto.parseNALu = function parseNALu(track, array, endOfSegment) {\n      var len = array.byteLength;\n      var state = track.naluState || 0;\n      var lastState = state;\n      var units = [];\n      var i = 0;\n      var value;\n      var overflow;\n      var unitType;\n      var lastUnitStart = -1;\n      var lastUnitType = 0;\n      // logger.log('PES:' + Hex.hexDump(array));\n\n      if (state === -1) {\n        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n        lastUnitStart = 0;\n        // NALu type is value read from offset 0\n        lastUnitType = this.getNALuType(array, 0);\n        state = 0;\n        i = 1;\n      }\n      while (i < len) {\n        value = array[i++];\n        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n        if (!state) {\n          state = value ? 0 : 1;\n          continue;\n        }\n        if (state === 1) {\n          state = value ? 0 : 2;\n          continue;\n        }\n        // here we have state either equal to 2 or 3\n        if (!value) {\n          state = 3;\n        } else if (value === 1) {\n          overflow = i - state - 1;\n          if (lastUnitStart >= 0) {\n            var unit = {\n              data: array.subarray(lastUnitStart, overflow),\n              type: lastUnitType\n            };\n            // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n            units.push(unit);\n          } else {\n            // lastUnitStart is undefined => this is the first start code found in this PES packet\n            // first check if start code delimiter is overlapping between 2 PES packets,\n            // ie it started in last packet (lastState not zero)\n            // and ended at the beginning of this PES packet (i <= 4 - lastState)\n            var lastUnit = this.getLastNalUnit(track.samples);\n            if (lastUnit) {\n              if (lastState && i <= 4 - lastState) {\n                // start delimiter overlapping between PES packets\n                // strip start delimiter bytes from the end of last NAL unit\n                // check if lastUnit had a state different from zero\n                if (lastUnit.state) {\n                  // strip last bytes\n                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n                }\n              }\n              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n\n              if (overflow > 0) {\n                // logger.log('first NALU found with overflow:' + overflow);\n                lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));\n                lastUnit.state = 0;\n              }\n            }\n          }\n          // check if we can read unit type\n          if (i < len) {\n            unitType = this.getNALuType(array, i);\n            // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n            lastUnitStart = i;\n            lastUnitType = unitType;\n            state = 0;\n          } else {\n            // not enough byte to read unit type. let's read it on next PES parsing\n            state = -1;\n          }\n        } else {\n          state = 0;\n        }\n      }\n      if (lastUnitStart >= 0 && state >= 0) {\n        var _unit = {\n          data: array.subarray(lastUnitStart, len),\n          type: lastUnitType,\n          state: state\n        };\n        units.push(_unit);\n        // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n      }\n      // no NALu found\n      if (units.length === 0) {\n        // append pes.data to previous NAL unit\n        var _lastUnit = this.getLastNalUnit(track.samples);\n        if (_lastUnit) {\n          _lastUnit.data = appendUint8Array(_lastUnit.data, array);\n        }\n      }\n      track.naluState = state;\n      return units;\n    };\n    return BaseVideoParser;\n  }();\n\n  /**\n   * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n   */\n\n  var ExpGolomb = /*#__PURE__*/function () {\n    function ExpGolomb(data) {\n      this.data = void 0;\n      this.bytesAvailable = void 0;\n      this.word = void 0;\n      this.bitsAvailable = void 0;\n      this.data = data;\n      // the number of bytes left to examine in this.data\n      this.bytesAvailable = data.byteLength;\n      // the current word being examined\n      this.word = 0; // :uint\n      // the number of bits left to examine in the current word\n      this.bitsAvailable = 0; // :uint\n    }\n\n    // ():void\n    var _proto = ExpGolomb.prototype;\n    _proto.loadWord = function loadWord() {\n      var data = this.data;\n      var bytesAvailable = this.bytesAvailable;\n      var position = data.byteLength - bytesAvailable;\n      var workingBytes = new Uint8Array(4);\n      var availableBytes = Math.min(4, bytesAvailable);\n      if (availableBytes === 0) {\n        throw new Error('no bytes available');\n      }\n      workingBytes.set(data.subarray(position, position + availableBytes));\n      this.word = new DataView(workingBytes.buffer).getUint32(0);\n      // track the amount of this.data that has been processed\n      this.bitsAvailable = availableBytes * 8;\n      this.bytesAvailable -= availableBytes;\n    }\n\n    // (count:int):void\n    ;\n    _proto.skipBits = function skipBits(count) {\n      var skipBytes; // :int\n      count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n      if (this.bitsAvailable > count) {\n        this.word <<= count;\n        this.bitsAvailable -= count;\n      } else {\n        count -= this.bitsAvailable;\n        skipBytes = count >> 3;\n        count -= skipBytes << 3;\n        this.bytesAvailable -= skipBytes;\n        this.loadWord();\n        this.word <<= count;\n        this.bitsAvailable -= count;\n      }\n    }\n\n    // (size:int):uint\n    ;\n    _proto.readBits = function readBits(size) {\n      var bits = Math.min(this.bitsAvailable, size); // :uint\n      var valu = this.word >>> 32 - bits; // :uint\n      if (size > 32) {\n        logger.error('Cannot read more than 32 bits at a time');\n      }\n      this.bitsAvailable -= bits;\n      if (this.bitsAvailable > 0) {\n        this.word <<= bits;\n      } else if (this.bytesAvailable > 0) {\n        this.loadWord();\n      } else {\n        throw new Error('no bits available');\n      }\n      bits = size - bits;\n      if (bits > 0 && this.bitsAvailable) {\n        return valu << bits | this.readBits(bits);\n      } else {\n        return valu;\n      }\n    }\n\n    // ():uint\n    ;\n    _proto.skipLZ = function skipLZ() {\n      var leadingZeroCount; // :uint\n      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n        if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n          // the first bit of working word is 1\n          this.word <<= leadingZeroCount;\n          this.bitsAvailable -= leadingZeroCount;\n          return leadingZeroCount;\n        }\n      }\n      // we exhausted word and still have not found a 1\n      this.loadWord();\n      return leadingZeroCount + this.skipLZ();\n    }\n\n    // ():void\n    ;\n    _proto.skipUEG = function skipUEG() {\n      this.skipBits(1 + this.skipLZ());\n    }\n\n    // ():void\n    ;\n    _proto.skipEG = function skipEG() {\n      this.skipBits(1 + this.skipLZ());\n    }\n\n    // ():uint\n    ;\n    _proto.readUEG = function readUEG() {\n      var clz = this.skipLZ(); // :uint\n      return this.readBits(clz + 1) - 1;\n    }\n\n    // ():int\n    ;\n    _proto.readEG = function readEG() {\n      var valu = this.readUEG(); // :int\n      if (0x01 & valu) {\n        // the number is odd if the low order bit is set\n        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n      } else {\n        return -1 * (valu >>> 1); // divide by two then make it negative\n      }\n    }\n\n    // Some convenience functions\n    // :Boolean\n    ;\n    _proto.readBoolean = function readBoolean() {\n      return this.readBits(1) === 1;\n    }\n\n    // ():int\n    ;\n    _proto.readUByte = function readUByte() {\n      return this.readBits(8);\n    }\n\n    // ():int\n    ;\n    _proto.readUShort = function readUShort() {\n      return this.readBits(16);\n    }\n\n    // ():int\n    ;\n    _proto.readUInt = function readUInt() {\n      return this.readBits(32);\n    };\n    return ExpGolomb;\n  }();\n\n  var AvcVideoParser = /*#__PURE__*/function (_BaseVideoParser) {\n    function AvcVideoParser() {\n      return _BaseVideoParser.apply(this, arguments) || this;\n    }\n    _inheritsLoose(AvcVideoParser, _BaseVideoParser);\n    var _proto = AvcVideoParser.prototype;\n    _proto.parsePES = function parsePES(track, textTrack, pes, endOfSegment) {\n      var _this = this;\n      var units = this.parseNALu(track, pes.data, endOfSegment);\n      var VideoSample = this.VideoSample;\n      var push;\n      var spsfound = false;\n      // free pes.data to save up some memory\n      pes.data = null;\n\n      // if new NAL units found and last sample still there, let's push ...\n      // this helps parsing streams with missing AUD (only do this if AUD never found)\n      if (VideoSample && units.length && !track.audFound) {\n        this.pushAccessUnit(VideoSample, track);\n        VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n      }\n      units.forEach(function (unit) {\n        var _VideoSample2, _VideoSample3;\n        switch (unit.type) {\n          // NDR\n          case 1:\n            {\n              var iskey = false;\n              push = true;\n              var data = unit.data;\n              // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n              if (spsfound && data.length > 4) {\n                // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n                var sliceType = _this.readSliceType(data);\n                // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n                // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n                // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n                // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n                // if (sliceType === 2 || sliceType === 7) {\n                if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                  iskey = true;\n                }\n              }\n              if (iskey) {\n                var _VideoSample;\n                // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n                if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n                  _this.pushAccessUnit(VideoSample, track);\n                  VideoSample = _this.VideoSample = null;\n                }\n              }\n              if (!VideoSample) {\n                VideoSample = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts);\n              }\n              VideoSample.frame = true;\n              VideoSample.key = iskey;\n              break;\n              // IDR\n            }\n          case 5:\n            push = true;\n            // handle PES not starting with AUD\n            // if we have frame data already, that cannot belong to the same frame, so force a push\n            if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n              _this.pushAccessUnit(VideoSample, track);\n              VideoSample = _this.VideoSample = null;\n            }\n            if (!VideoSample) {\n              VideoSample = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts);\n            }\n            VideoSample.key = true;\n            VideoSample.frame = true;\n            break;\n          // SEI\n          case 6:\n            {\n              push = true;\n              parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n              break;\n              // SPS\n            }\n          case 7:\n            {\n              var _track$pixelRatio, _track$pixelRatio2;\n              push = true;\n              spsfound = true;\n              var sps = unit.data;\n              var config = _this.readSPS(sps);\n              if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {\n                track.width = config.width;\n                track.height = config.height;\n                track.pixelRatio = config.pixelRatio;\n                track.sps = [sps];\n                var codecarray = sps.subarray(1, 4);\n                var codecstring = 'avc1.';\n                for (var i = 0; i < 3; i++) {\n                  var h = codecarray[i].toString(16);\n                  if (h.length < 2) {\n                    h = '0' + h;\n                  }\n                  codecstring += h;\n                }\n                track.codec = codecstring;\n              }\n              break;\n            }\n          // PPS\n          case 8:\n            push = true;\n            track.pps = [unit.data];\n            break;\n          // AUD\n          case 9:\n            push = true;\n            track.audFound = true;\n            if ((_VideoSample3 = VideoSample) != null && _VideoSample3.frame) {\n              _this.pushAccessUnit(VideoSample, track);\n              VideoSample = null;\n            }\n            if (!VideoSample) {\n              VideoSample = _this.VideoSample = _this.createVideoSample(false, pes.pts, pes.dts);\n            }\n            break;\n          // Filler Data\n          case 12:\n            push = true;\n            break;\n          default:\n            push = false;\n            break;\n        }\n        if (VideoSample && push) {\n          var _units = VideoSample.units;\n          _units.push(unit);\n        }\n      });\n      // if last PES packet, push samples\n      if (endOfSegment && VideoSample) {\n        this.pushAccessUnit(VideoSample, track);\n        this.VideoSample = null;\n      }\n    };\n    _proto.getNALuType = function getNALuType(data, offset) {\n      return data[offset] & 0x1f;\n    };\n    _proto.readSliceType = function readSliceType(data) {\n      var eg = new ExpGolomb(data);\n      // skip NALu type\n      eg.readUByte();\n      // discard first_mb_in_slice\n      eg.readUEG();\n      // return slice_type\n      return eg.readUEG();\n    }\n\n    /**\n     * The scaling list is optionally transmitted as part of a sequence parameter\n     * set and is not relevant to transmuxing.\n     * @param count the number of entries in this scaling list\n     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n     */;\n    _proto.skipScalingList = function skipScalingList(count, reader) {\n      var lastScale = 8;\n      var nextScale = 8;\n      var deltaScale;\n      for (var j = 0; j < count; j++) {\n        if (nextScale !== 0) {\n          deltaScale = reader.readEG();\n          nextScale = (lastScale + deltaScale + 256) % 256;\n        }\n        lastScale = nextScale === 0 ? lastScale : nextScale;\n      }\n    }\n\n    /**\n     * Read a sequence parameter set and return some interesting video\n     * properties. A sequence parameter set is the H264 metadata that\n     * describes the properties of upcoming video frames.\n     * @returns an object with configuration parsed from the\n     * sequence parameter set, including the dimensions of the\n     * associated video frames.\n     */;\n    _proto.readSPS = function readSPS(sps) {\n      var eg = new ExpGolomb(sps);\n      var frameCropLeftOffset = 0;\n      var frameCropRightOffset = 0;\n      var frameCropTopOffset = 0;\n      var frameCropBottomOffset = 0;\n      var numRefFramesInPicOrderCntCycle;\n      var scalingListCount;\n      var i;\n      var readUByte = eg.readUByte.bind(eg);\n      var readBits = eg.readBits.bind(eg);\n      var readUEG = eg.readUEG.bind(eg);\n      var readBoolean = eg.readBoolean.bind(eg);\n      var skipBits = eg.skipBits.bind(eg);\n      var skipEG = eg.skipEG.bind(eg);\n      var skipUEG = eg.skipUEG.bind(eg);\n      var skipScalingList = this.skipScalingList.bind(this);\n      readUByte();\n      var profileIdc = readUByte(); // profile_idc\n      readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n      skipBits(3); // reserved_zero_3bits u(3),\n      readUByte(); // level_idc u(8)\n      skipUEG(); // seq_parameter_set_id\n      // some profiles have more optional data we don't need\n      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n        var chromaFormatIdc = readUEG();\n        if (chromaFormatIdc === 3) {\n          skipBits(1);\n        } // separate_colour_plane_flag\n\n        skipUEG(); // bit_depth_luma_minus8\n        skipUEG(); // bit_depth_chroma_minus8\n        skipBits(1); // qpprime_y_zero_transform_bypass_flag\n        if (readBoolean()) {\n          // seq_scaling_matrix_present_flag\n          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n          for (i = 0; i < scalingListCount; i++) {\n            if (readBoolean()) {\n              // seq_scaling_list_present_flag[ i ]\n              if (i < 6) {\n                skipScalingList(16, eg);\n              } else {\n                skipScalingList(64, eg);\n              }\n            }\n          }\n        }\n      }\n      skipUEG(); // log2_max_frame_num_minus4\n      var picOrderCntType = readUEG();\n      if (picOrderCntType === 0) {\n        readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n      } else if (picOrderCntType === 1) {\n        skipBits(1); // delta_pic_order_always_zero_flag\n        skipEG(); // offset_for_non_ref_pic\n        skipEG(); // offset_for_top_to_bottom_field\n        numRefFramesInPicOrderCntCycle = readUEG();\n        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n          skipEG();\n        } // offset_for_ref_frame[ i ]\n      }\n      skipUEG(); // max_num_ref_frames\n      skipBits(1); // gaps_in_frame_num_value_allowed_flag\n      var picWidthInMbsMinus1 = readUEG();\n      var picHeightInMapUnitsMinus1 = readUEG();\n      var frameMbsOnlyFlag = readBits(1);\n      if (frameMbsOnlyFlag === 0) {\n        skipBits(1);\n      } // mb_adaptive_frame_field_flag\n\n      skipBits(1); // direct_8x8_inference_flag\n      if (readBoolean()) {\n        // frame_cropping_flag\n        frameCropLeftOffset = readUEG();\n        frameCropRightOffset = readUEG();\n        frameCropTopOffset = readUEG();\n        frameCropBottomOffset = readUEG();\n      }\n      var pixelRatio = [1, 1];\n      if (readBoolean()) {\n        // vui_parameters_present_flag\n        if (readBoolean()) {\n          // aspect_ratio_info_present_flag\n          var aspectRatioIdc = readUByte();\n          switch (aspectRatioIdc) {\n            case 1:\n              pixelRatio = [1, 1];\n              break;\n            case 2:\n              pixelRatio = [12, 11];\n              break;\n            case 3:\n              pixelRatio = [10, 11];\n              break;\n            case 4:\n              pixelRatio = [16, 11];\n              break;\n            case 5:\n              pixelRatio = [40, 33];\n              break;\n            case 6:\n              pixelRatio = [24, 11];\n              break;\n            case 7:\n              pixelRatio = [20, 11];\n              break;\n            case 8:\n              pixelRatio = [32, 11];\n              break;\n            case 9:\n              pixelRatio = [80, 33];\n              break;\n            case 10:\n              pixelRatio = [18, 11];\n              break;\n            case 11:\n              pixelRatio = [15, 11];\n              break;\n            case 12:\n              pixelRatio = [64, 33];\n              break;\n            case 13:\n              pixelRatio = [160, 99];\n              break;\n            case 14:\n              pixelRatio = [4, 3];\n              break;\n            case 15:\n              pixelRatio = [3, 2];\n              break;\n            case 16:\n              pixelRatio = [2, 1];\n              break;\n            case 255:\n              {\n                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n                break;\n              }\n          }\n        }\n      }\n      return {\n        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n        pixelRatio: pixelRatio\n      };\n    };\n    return AvcVideoParser;\n  }(BaseVideoParser);\n\n  var HevcVideoParser = /*#__PURE__*/function (_BaseVideoParser) {\n    function HevcVideoParser() {\n      var _this;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _BaseVideoParser.call.apply(_BaseVideoParser, [this].concat(args)) || this;\n      _this.initVPS = null;\n      return _this;\n    }\n    _inheritsLoose(HevcVideoParser, _BaseVideoParser);\n    var _proto = HevcVideoParser.prototype;\n    _proto.parsePES = function parsePES(track, textTrack, pes, endOfSegment) {\n      var _this2 = this;\n      var units = this.parseNALu(track, pes.data, endOfSegment);\n      var VideoSample = this.VideoSample;\n      var push;\n      var spsfound = false;\n      // free pes.data to save up some memory\n      pes.data = null;\n\n      // if new NAL units found and last sample still there, let's push ...\n      // this helps parsing streams with missing AUD (only do this if AUD never found)\n      if (VideoSample && units.length && !track.audFound) {\n        this.pushAccessUnit(VideoSample, track);\n        VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts);\n      }\n      units.forEach(function (unit) {\n        var _VideoSample2, _VideoSample3;\n        switch (unit.type) {\n          // NON-IDR, NON RANDOM ACCESS SLICE\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n            if (!VideoSample) {\n              VideoSample = _this2.VideoSample = _this2.createVideoSample(false, pes.pts, pes.dts);\n            }\n            VideoSample.frame = true;\n            push = true;\n            break;\n\n          // CRA, BLA (random access picture)\n          case 16:\n          case 17:\n          case 18:\n          case 21:\n            push = true;\n            if (spsfound) {\n              var _VideoSample;\n              // handle PES not starting with AUD\n              // if we have frame data already, that cannot belong to the same frame, so force a push\n              if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n                _this2.pushAccessUnit(VideoSample, track);\n                VideoSample = _this2.VideoSample = null;\n              }\n            }\n            if (!VideoSample) {\n              VideoSample = _this2.VideoSample = _this2.createVideoSample(true, pes.pts, pes.dts);\n            }\n            VideoSample.key = true;\n            VideoSample.frame = true;\n            break;\n\n          // IDR\n          case 19:\n          case 20:\n            push = true;\n            // handle PES not starting with AUD\n            // if we have frame data already, that cannot belong to the same frame, so force a push\n            if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n              _this2.pushAccessUnit(VideoSample, track);\n              VideoSample = _this2.VideoSample = null;\n            }\n            if (!VideoSample) {\n              VideoSample = _this2.VideoSample = _this2.createVideoSample(true, pes.pts, pes.dts);\n            }\n            VideoSample.key = true;\n            VideoSample.frame = true;\n            break;\n\n          // SEI\n          case 39:\n            push = true;\n            parseSEIMessageFromNALu(unit.data, 2,\n            // NALu header size\n            pes.pts, textTrack.samples);\n            break;\n\n          // VPS\n          case 32:\n            push = true;\n            if (!track.vps) {\n              if (typeof track.params !== 'object') {\n                track.params = {};\n              }\n              track.params = _extends(track.params, _this2.readVPS(unit.data));\n              _this2.initVPS = unit.data;\n            }\n            track.vps = [unit.data];\n            break;\n\n          // SPS\n          case 33:\n            push = true;\n            spsfound = true;\n            if (track.vps !== undefined && track.vps[0] !== _this2.initVPS && track.sps !== undefined && !_this2.matchSPS(track.sps[0], unit.data)) {\n              _this2.initVPS = track.vps[0];\n              track.sps = track.pps = undefined;\n            }\n            if (!track.sps) {\n              var config = _this2.readSPS(unit.data);\n              track.width = config.width;\n              track.height = config.height;\n              track.pixelRatio = config.pixelRatio;\n              track.codec = config.codecString;\n              track.sps = [];\n              if (typeof track.params !== 'object') {\n                track.params = {};\n              }\n              for (var prop in config.params) {\n                track.params[prop] = config.params[prop];\n              }\n            }\n            _this2.pushParameterSet(track.sps, unit.data, track.vps);\n            if (!VideoSample) {\n              VideoSample = _this2.VideoSample = _this2.createVideoSample(true, pes.pts, pes.dts);\n            }\n            VideoSample.key = true;\n            break;\n\n          // PPS\n          case 34:\n            push = true;\n            if (typeof track.params === 'object') {\n              if (!track.pps) {\n                track.pps = [];\n                var _config = _this2.readPPS(unit.data);\n                for (var _prop in _config) {\n                  track.params[_prop] = _config[_prop];\n                }\n              }\n              _this2.pushParameterSet(track.pps, unit.data, track.vps);\n            }\n            break;\n\n          // ACCESS UNIT DELIMITER\n          case 35:\n            push = true;\n            track.audFound = true;\n            if ((_VideoSample3 = VideoSample) != null && _VideoSample3.frame) {\n              _this2.pushAccessUnit(VideoSample, track);\n              VideoSample = null;\n            }\n            if (!VideoSample) {\n              VideoSample = _this2.VideoSample = _this2.createVideoSample(false, pes.pts, pes.dts);\n            }\n            break;\n          default:\n            push = false;\n            break;\n        }\n        if (VideoSample && push) {\n          var _units = VideoSample.units;\n          _units.push(unit);\n        }\n      });\n      // if last PES packet, push samples\n      if (endOfSegment && VideoSample) {\n        this.pushAccessUnit(VideoSample, track);\n        this.VideoSample = null;\n      }\n    };\n    _proto.pushParameterSet = function pushParameterSet(parameterSets, data, vps) {\n      if (vps && vps[0] === this.initVPS || !vps && !parameterSets.length) {\n        parameterSets.push(data);\n      }\n    };\n    _proto.getNALuType = function getNALuType(data, offset) {\n      return (data[offset] & 0x7e) >>> 1;\n    };\n    _proto.ebsp2rbsp = function ebsp2rbsp(arr) {\n      var dst = new Uint8Array(arr.byteLength);\n      var dstIdx = 0;\n      for (var i = 0; i < arr.byteLength; i++) {\n        if (i >= 2) {\n          // Unescape: Skip 0x03 after 00 00\n          if (arr[i] === 0x03 && arr[i - 1] === 0x00 && arr[i - 2] === 0x00) {\n            continue;\n          }\n        }\n        dst[dstIdx] = arr[i];\n        dstIdx++;\n      }\n      return new Uint8Array(dst.buffer, 0, dstIdx);\n    };\n    _proto.pushAccessUnit = function pushAccessUnit(VideoSample, videoTrack) {\n      _BaseVideoParser.prototype.pushAccessUnit.call(this, VideoSample, videoTrack);\n      if (this.initVPS) {\n        this.initVPS = null; // null initVPS to prevent possible track's sps/pps growth until next VPS\n      }\n    };\n    _proto.readVPS = function readVPS(vps) {\n      var eg = new ExpGolomb(vps);\n      // remove header\n      eg.readUByte();\n      eg.readUByte();\n      eg.readBits(4); // video_parameter_set_id\n      eg.skipBits(2);\n      eg.readBits(6); // max_layers_minus1\n      var max_sub_layers_minus1 = eg.readBits(3);\n      var temporal_id_nesting_flag = eg.readBoolean();\n      // ...vui fps can be here, but empty fps value is not critical for metadata\n\n      return {\n        numTemporalLayers: max_sub_layers_minus1 + 1,\n        temporalIdNested: temporal_id_nesting_flag\n      };\n    };\n    _proto.readSPS = function readSPS(sps) {\n      var eg = new ExpGolomb(this.ebsp2rbsp(sps));\n      eg.readUByte();\n      eg.readUByte();\n      eg.readBits(4); //video_parameter_set_id\n      var max_sub_layers_minus1 = eg.readBits(3);\n      eg.readBoolean(); // temporal_id_nesting_flag\n\n      // profile_tier_level\n      var general_profile_space = eg.readBits(2);\n      var general_tier_flag = eg.readBoolean();\n      var general_profile_idc = eg.readBits(5);\n      var general_profile_compatibility_flags_1 = eg.readUByte();\n      var general_profile_compatibility_flags_2 = eg.readUByte();\n      var general_profile_compatibility_flags_3 = eg.readUByte();\n      var general_profile_compatibility_flags_4 = eg.readUByte();\n      var general_constraint_indicator_flags_1 = eg.readUByte();\n      var general_constraint_indicator_flags_2 = eg.readUByte();\n      var general_constraint_indicator_flags_3 = eg.readUByte();\n      var general_constraint_indicator_flags_4 = eg.readUByte();\n      var general_constraint_indicator_flags_5 = eg.readUByte();\n      var general_constraint_indicator_flags_6 = eg.readUByte();\n      var general_level_idc = eg.readUByte();\n      var sub_layer_profile_present_flags = [];\n      var sub_layer_level_present_flags = [];\n      for (var i = 0; i < max_sub_layers_minus1; i++) {\n        sub_layer_profile_present_flags.push(eg.readBoolean());\n        sub_layer_level_present_flags.push(eg.readBoolean());\n      }\n      if (max_sub_layers_minus1 > 0) {\n        for (var _i = max_sub_layers_minus1; _i < 8; _i++) {\n          eg.readBits(2);\n        }\n      }\n      for (var _i2 = 0; _i2 < max_sub_layers_minus1; _i2++) {\n        if (sub_layer_profile_present_flags[_i2]) {\n          eg.readUByte(); // sub_layer_profile_space, sub_layer_tier_flag, sub_layer_profile_idc\n          eg.readUByte();\n          eg.readUByte();\n          eg.readUByte();\n          eg.readUByte(); // sub_layer_profile_compatibility_flag\n          eg.readUByte();\n          eg.readUByte();\n          eg.readUByte();\n          eg.readUByte();\n          eg.readUByte();\n          eg.readUByte();\n        }\n        if (sub_layer_level_present_flags[_i2]) {\n          eg.readUByte();\n        }\n      }\n      eg.readUEG(); // seq_parameter_set_id\n      var chroma_format_idc = eg.readUEG();\n      if (chroma_format_idc == 3) {\n        eg.skipBits(1); //separate_colour_plane_flag\n      }\n      var pic_width_in_luma_samples = eg.readUEG();\n      var pic_height_in_luma_samples = eg.readUEG();\n      var conformance_window_flag = eg.readBoolean();\n      var pic_left_offset = 0,\n        pic_right_offset = 0,\n        pic_top_offset = 0,\n        pic_bottom_offset = 0;\n      if (conformance_window_flag) {\n        pic_left_offset += eg.readUEG();\n        pic_right_offset += eg.readUEG();\n        pic_top_offset += eg.readUEG();\n        pic_bottom_offset += eg.readUEG();\n      }\n      var bit_depth_luma_minus8 = eg.readUEG();\n      var bit_depth_chroma_minus8 = eg.readUEG();\n      var log2_max_pic_order_cnt_lsb_minus4 = eg.readUEG();\n      var sub_layer_ordering_info_present_flag = eg.readBoolean();\n      for (var _i3 = sub_layer_ordering_info_present_flag ? 0 : max_sub_layers_minus1; _i3 <= max_sub_layers_minus1; _i3++) {\n        eg.skipUEG(); // max_dec_pic_buffering_minus1[i]\n        eg.skipUEG(); // max_num_reorder_pics[i]\n        eg.skipUEG(); // max_latency_increase_plus1[i]\n      }\n      eg.skipUEG(); // log2_min_luma_coding_block_size_minus3\n      eg.skipUEG(); // log2_diff_max_min_luma_coding_block_size\n      eg.skipUEG(); // log2_min_transform_block_size_minus2\n      eg.skipUEG(); // log2_diff_max_min_transform_block_size\n      eg.skipUEG(); // max_transform_hierarchy_depth_inter\n      eg.skipUEG(); // max_transform_hierarchy_depth_intra\n      var scaling_list_enabled_flag = eg.readBoolean();\n      if (scaling_list_enabled_flag) {\n        var sps_scaling_list_data_present_flag = eg.readBoolean();\n        if (sps_scaling_list_data_present_flag) {\n          for (var sizeId = 0; sizeId < 4; sizeId++) {\n            for (var matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {\n              var scaling_list_pred_mode_flag = eg.readBoolean();\n              if (!scaling_list_pred_mode_flag) {\n                eg.readUEG(); // scaling_list_pred_matrix_id_delta\n              } else {\n                var coefNum = Math.min(64, 1 << 4 + (sizeId << 1));\n                if (sizeId > 1) {\n                  eg.readEG();\n                }\n                for (var _i4 = 0; _i4 < coefNum; _i4++) {\n                  eg.readEG();\n                }\n              }\n            }\n          }\n        }\n      }\n      eg.readBoolean(); // amp_enabled_flag\n      eg.readBoolean(); // sample_adaptive_offset_enabled_flag\n      var pcm_enabled_flag = eg.readBoolean();\n      if (pcm_enabled_flag) {\n        eg.readUByte();\n        eg.skipUEG();\n        eg.skipUEG();\n        eg.readBoolean();\n      }\n      var num_short_term_ref_pic_sets = eg.readUEG();\n      var num_delta_pocs = 0;\n      for (var _i5 = 0; _i5 < num_short_term_ref_pic_sets; _i5++) {\n        var inter_ref_pic_set_prediction_flag = false;\n        if (_i5 !== 0) {\n          inter_ref_pic_set_prediction_flag = eg.readBoolean();\n        }\n        if (inter_ref_pic_set_prediction_flag) {\n          if (_i5 === num_short_term_ref_pic_sets) {\n            eg.readUEG();\n          }\n          eg.readBoolean();\n          eg.readUEG();\n          var next_num_delta_pocs = 0;\n          for (var j = 0; j <= num_delta_pocs; j++) {\n            var used_by_curr_pic_flag = eg.readBoolean();\n            var use_delta_flag = false;\n            if (!used_by_curr_pic_flag) {\n              use_delta_flag = eg.readBoolean();\n            }\n            if (used_by_curr_pic_flag || use_delta_flag) {\n              next_num_delta_pocs++;\n            }\n          }\n          num_delta_pocs = next_num_delta_pocs;\n        } else {\n          var num_negative_pics = eg.readUEG();\n          var num_positive_pics = eg.readUEG();\n          num_delta_pocs = num_negative_pics + num_positive_pics;\n          for (var _j = 0; _j < num_negative_pics; _j++) {\n            eg.readUEG();\n            eg.readBoolean();\n          }\n          for (var _j2 = 0; _j2 < num_positive_pics; _j2++) {\n            eg.readUEG();\n            eg.readBoolean();\n          }\n        }\n      }\n      var long_term_ref_pics_present_flag = eg.readBoolean();\n      if (long_term_ref_pics_present_flag) {\n        var num_long_term_ref_pics_sps = eg.readUEG();\n        for (var _i6 = 0; _i6 < num_long_term_ref_pics_sps; _i6++) {\n          for (var _j3 = 0; _j3 < log2_max_pic_order_cnt_lsb_minus4 + 4; _j3++) {\n            eg.readBits(1);\n          }\n          eg.readBits(1);\n        }\n      }\n      var min_spatial_segmentation_idc = 0;\n      var sar_width = 1,\n        sar_height = 1;\n      var fps_fixed = true,\n        fps_den = 1,\n        fps_num = 0;\n      eg.readBoolean(); // sps_temporal_mvp_enabled_flag\n      eg.readBoolean(); // strong_intra_smoothing_enabled_flag\n      var default_display_window_flag = false;\n      var vui_parameters_present_flag = eg.readBoolean();\n      if (vui_parameters_present_flag) {\n        var aspect_ratio_info_present_flag = eg.readBoolean();\n        if (aspect_ratio_info_present_flag) {\n          var aspect_ratio_idc = eg.readUByte();\n          var sar_width_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n          var sar_height_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n          if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n            sar_width = sar_width_table[aspect_ratio_idc - 1];\n            sar_height = sar_height_table[aspect_ratio_idc - 1];\n          } else if (aspect_ratio_idc === 255) {\n            sar_width = eg.readBits(16);\n            sar_height = eg.readBits(16);\n          }\n        }\n        var overscan_info_present_flag = eg.readBoolean();\n        if (overscan_info_present_flag) {\n          eg.readBoolean();\n        }\n        var video_signal_type_present_flag = eg.readBoolean();\n        if (video_signal_type_present_flag) {\n          eg.readBits(3);\n          eg.readBoolean();\n          var colour_description_present_flag = eg.readBoolean();\n          if (colour_description_present_flag) {\n            eg.readUByte();\n            eg.readUByte();\n            eg.readUByte();\n          }\n        }\n        var chroma_loc_info_present_flag = eg.readBoolean();\n        if (chroma_loc_info_present_flag) {\n          eg.readUEG();\n          eg.readUEG();\n        }\n        eg.readBoolean(); // neutral_chroma_indication_flag\n        eg.readBoolean(); // field_seq_flag\n        eg.readBoolean(); // frame_field_info_present_flag\n        default_display_window_flag = eg.readBoolean();\n        if (default_display_window_flag) {\n          eg.skipUEG();\n          eg.skipUEG();\n          eg.skipUEG();\n          eg.skipUEG();\n        }\n        var vui_timing_info_present_flag = eg.readBoolean();\n        if (vui_timing_info_present_flag) {\n          fps_den = eg.readBits(32);\n          fps_num = eg.readBits(32);\n          var vui_poc_proportional_to_timing_flag = eg.readBoolean();\n          if (vui_poc_proportional_to_timing_flag) {\n            eg.readUEG();\n          }\n          var vui_hrd_parameters_present_flag = eg.readBoolean();\n          if (vui_hrd_parameters_present_flag) {\n            //const commonInfPresentFlag = true;\n            //if (commonInfPresentFlag) {\n            var nal_hrd_parameters_present_flag = eg.readBoolean();\n            var vcl_hrd_parameters_present_flag = eg.readBoolean();\n            var sub_pic_hrd_params_present_flag = false;\n            if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n              sub_pic_hrd_params_present_flag = eg.readBoolean();\n              if (sub_pic_hrd_params_present_flag) {\n                eg.readUByte();\n                eg.readBits(5);\n                eg.readBoolean();\n                eg.readBits(5);\n              }\n              eg.readBits(4); // bit_rate_scale\n              eg.readBits(4); // cpb_size_scale\n              if (sub_pic_hrd_params_present_flag) {\n                eg.readBits(4);\n              }\n              eg.readBits(5);\n              eg.readBits(5);\n              eg.readBits(5);\n            }\n            //}\n            for (var _i7 = 0; _i7 <= max_sub_layers_minus1; _i7++) {\n              fps_fixed = eg.readBoolean(); // fixed_pic_rate_general_flag\n              var fixed_pic_rate_within_cvs_flag = fps_fixed || eg.readBoolean();\n              var low_delay_hrd_flag = false;\n              if (fixed_pic_rate_within_cvs_flag) {\n                eg.readEG();\n              } else {\n                low_delay_hrd_flag = eg.readBoolean();\n              }\n              var cpb_cnt = low_delay_hrd_flag ? 1 : eg.readUEG() + 1;\n              if (nal_hrd_parameters_present_flag) {\n                for (var _j4 = 0; _j4 < cpb_cnt; _j4++) {\n                  eg.readUEG();\n                  eg.readUEG();\n                  if (sub_pic_hrd_params_present_flag) {\n                    eg.readUEG();\n                    eg.readUEG();\n                  }\n                  eg.skipBits(1);\n                }\n              }\n              if (vcl_hrd_parameters_present_flag) {\n                for (var _j5 = 0; _j5 < cpb_cnt; _j5++) {\n                  eg.readUEG();\n                  eg.readUEG();\n                  if (sub_pic_hrd_params_present_flag) {\n                    eg.readUEG();\n                    eg.readUEG();\n                  }\n                  eg.skipBits(1);\n                }\n              }\n            }\n          }\n        }\n        var bitstream_restriction_flag = eg.readBoolean();\n        if (bitstream_restriction_flag) {\n          eg.readBoolean(); // tiles_fixed_structure_flag\n          eg.readBoolean(); // motion_vectors_over_pic_boundaries_flag\n          eg.readBoolean(); // restricted_ref_pic_lists_flag\n          min_spatial_segmentation_idc = eg.readUEG();\n        }\n      }\n      var width = pic_width_in_luma_samples,\n        height = pic_height_in_luma_samples;\n      if (conformance_window_flag) {\n        var chroma_scale_w = 1,\n          chroma_scale_h = 1;\n        if (chroma_format_idc === 1) {\n          // YUV 420\n          chroma_scale_w = chroma_scale_h = 2;\n        } else if (chroma_format_idc == 2) {\n          // YUV 422\n          chroma_scale_w = 2;\n        }\n        width = pic_width_in_luma_samples - chroma_scale_w * pic_right_offset - chroma_scale_w * pic_left_offset;\n        height = pic_height_in_luma_samples - chroma_scale_h * pic_bottom_offset - chroma_scale_h * pic_top_offset;\n      }\n      var profile_space_string = general_profile_space ? ['A', 'B', 'C'][general_profile_space] : '';\n      var profile_compatibility_buf = general_profile_compatibility_flags_1 << 24 | general_profile_compatibility_flags_2 << 16 | general_profile_compatibility_flags_3 << 8 | general_profile_compatibility_flags_4;\n      var profile_compatibility_rev = 0;\n      for (var _i8 = 0; _i8 < 32; _i8++) {\n        profile_compatibility_rev = (profile_compatibility_rev | (profile_compatibility_buf >> _i8 & 1) << 31 - _i8) >>> 0; // reverse bit position (and cast as UInt32)\n      }\n      var profile_compatibility_flags_string = profile_compatibility_rev.toString(16);\n      if (general_profile_idc === 1 && profile_compatibility_flags_string === '2') {\n        profile_compatibility_flags_string = '6';\n      }\n      var tier_flag_string = general_tier_flag ? 'H' : 'L';\n      return {\n        codecString: \"hvc1.\" + profile_space_string + general_profile_idc + \".\" + profile_compatibility_flags_string + \".\" + tier_flag_string + general_level_idc + \".B0\",\n        params: {\n          general_tier_flag: general_tier_flag,\n          general_profile_idc: general_profile_idc,\n          general_profile_space: general_profile_space,\n          general_profile_compatibility_flags: [general_profile_compatibility_flags_1, general_profile_compatibility_flags_2, general_profile_compatibility_flags_3, general_profile_compatibility_flags_4],\n          general_constraint_indicator_flags: [general_constraint_indicator_flags_1, general_constraint_indicator_flags_2, general_constraint_indicator_flags_3, general_constraint_indicator_flags_4, general_constraint_indicator_flags_5, general_constraint_indicator_flags_6],\n          general_level_idc: general_level_idc,\n          bit_depth: bit_depth_luma_minus8 + 8,\n          bit_depth_luma_minus8: bit_depth_luma_minus8,\n          bit_depth_chroma_minus8: bit_depth_chroma_minus8,\n          min_spatial_segmentation_idc: min_spatial_segmentation_idc,\n          chroma_format_idc: chroma_format_idc,\n          frame_rate: {\n            fixed: fps_fixed,\n            fps: fps_num / fps_den\n          }\n        },\n        width: width,\n        height: height,\n        pixelRatio: [sar_width, sar_height]\n      };\n    };\n    _proto.readPPS = function readPPS(pps) {\n      var eg = new ExpGolomb(this.ebsp2rbsp(pps));\n      eg.readUByte();\n      eg.readUByte();\n      eg.skipUEG(); // pic_parameter_set_id\n      eg.skipUEG(); // seq_parameter_set_id\n      eg.skipBits(2); // dependent_slice_segments_enabled_flag, output_flag_present_flag\n      eg.skipBits(3); // num_extra_slice_header_bits\n      eg.skipBits(2); // sign_data_hiding_enabled_flag, cabac_init_present_flag\n      eg.skipUEG();\n      eg.skipUEG();\n      eg.skipEG(); // init_qp_minus26\n      eg.skipBits(2); // constrained_intra_pred_flag, transform_skip_enabled_flag\n      var cu_qp_delta_enabled_flag = eg.readBoolean();\n      if (cu_qp_delta_enabled_flag) {\n        eg.skipUEG();\n      }\n      eg.skipEG(); // cb_qp_offset\n      eg.skipEG(); // cr_qp_offset\n      eg.skipBits(4); // pps_slice_chroma_qp_offsets_present_flag, weighted_pred_flag, weighted_bipred_flag, transquant_bypass_enabled_flag\n      var tiles_enabled_flag = eg.readBoolean();\n      var entropy_coding_sync_enabled_flag = eg.readBoolean();\n      var parallelismType = 1; // slice-based parallel decoding\n      if (entropy_coding_sync_enabled_flag && tiles_enabled_flag) {\n        parallelismType = 0; // mixed-type parallel decoding\n      } else if (entropy_coding_sync_enabled_flag) {\n        parallelismType = 3; // wavefront-based parallel decoding\n      } else if (tiles_enabled_flag) {\n        parallelismType = 2; // tile-based parallel decoding\n      }\n      return {\n        parallelismType: parallelismType\n      };\n    };\n    _proto.matchSPS = function matchSPS(sps1, sps2) {\n      // compare without headers and VPS related params\n      return String.fromCharCode.apply(null, sps1).substr(3) === String.fromCharCode.apply(null, sps2).substr(3);\n    };\n    return HevcVideoParser;\n  }(BaseVideoParser);\n\n  var PACKET_LENGTH = 188;\n  var TSDemuxer = /*#__PURE__*/function () {\n    function TSDemuxer(observer, config, typeSupported, logger) {\n      this.logger = void 0;\n      this.observer = void 0;\n      this.config = void 0;\n      this.typeSupported = void 0;\n      this.sampleAes = null;\n      this.pmtParsed = false;\n      this.audioCodec = void 0;\n      this.videoCodec = void 0;\n      this._pmtId = -1;\n      this._videoTrack = void 0;\n      this._audioTrack = void 0;\n      this._id3Track = void 0;\n      this._txtTrack = void 0;\n      this.aacOverFlow = null;\n      this.remainderData = null;\n      this.videoParser = void 0;\n      this.observer = observer;\n      this.config = config;\n      this.typeSupported = typeSupported;\n      this.logger = logger;\n      this.videoParser = null;\n    }\n    TSDemuxer.probe = function probe(data, logger) {\n      var syncOffset = TSDemuxer.syncOffset(data);\n      if (syncOffset > 0) {\n        logger.warn(\"MPEG2-TS detected but first sync word found @ offset \" + syncOffset);\n      }\n      return syncOffset !== -1;\n    };\n    TSDemuxer.syncOffset = function syncOffset(data) {\n      var length = data.length;\n      var scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;\n      var i = 0;\n      while (i < scanwindow) {\n        // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n        var foundPat = false;\n        var packetStart = -1;\n        var tsPackets = 0;\n        for (var j = i; j < length; j += PACKET_LENGTH) {\n          if (data[j] === 0x47 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)) {\n            tsPackets++;\n            if (packetStart === -1) {\n              packetStart = j;\n              // First sync word found at offset, increase scan length (#5251)\n              if (packetStart !== 0) {\n                scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n              }\n            }\n            if (!foundPat) {\n              foundPat = parsePID(data, j) === 0;\n            }\n            // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n            if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n              return packetStart;\n            }\n          } else if (tsPackets) {\n            // Exit if sync word found, but does not contain contiguous packets\n            return -1;\n          } else {\n            break;\n          }\n        }\n        i++;\n      }\n      return -1;\n    }\n\n    /**\n     * Creates a track model internal to demuxer used to drive remuxing input\n     */;\n    TSDemuxer.createTrack = function createTrack(type, duration) {\n      return {\n        container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n        type: type,\n        id: RemuxerTrackIdConfig[type],\n        pid: -1,\n        inputTimeScale: 90000,\n        sequenceNumber: 0,\n        samples: [],\n        dropped: 0,\n        duration: type === 'audio' ? duration : undefined\n      };\n    }\n\n    /**\n     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n     * Resets all internal track instances of the demuxer.\n     */;\n    var _proto = TSDemuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      this.pmtParsed = false;\n      this._pmtId = -1;\n      this._videoTrack = TSDemuxer.createTrack('video');\n      this._videoTrack.duration = trackDuration;\n      this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n      this._id3Track = TSDemuxer.createTrack('id3');\n      this._txtTrack = TSDemuxer.createTrack('text');\n      this._audioTrack.segmentCodec = 'aac';\n\n      // flush any partial content\n      this.videoParser = null;\n      this.aacOverFlow = null;\n      this.remainderData = null;\n      this.audioCodec = audioCodec;\n      this.videoCodec = videoCodec;\n    };\n    _proto.resetTimeStamp = function resetTimeStamp() {};\n    _proto.resetContiguity = function resetContiguity() {\n      var _audioTrack = this._audioTrack,\n        _videoTrack = this._videoTrack,\n        _id3Track = this._id3Track;\n      if (_audioTrack) {\n        _audioTrack.pesData = null;\n      }\n      if (_videoTrack) {\n        _videoTrack.pesData = null;\n      }\n      if (_id3Track) {\n        _id3Track.pesData = null;\n      }\n      this.aacOverFlow = null;\n      this.remainderData = null;\n    };\n    _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {\n      if (isSampleAes === void 0) {\n        isSampleAes = false;\n      }\n      if (flush === void 0) {\n        flush = false;\n      }\n      if (!isSampleAes) {\n        this.sampleAes = null;\n      }\n      var pes;\n      var videoTrack = this._videoTrack;\n      var audioTrack = this._audioTrack;\n      var id3Track = this._id3Track;\n      var textTrack = this._txtTrack;\n      var videoPid = videoTrack.pid;\n      var videoData = videoTrack.pesData;\n      var audioPid = audioTrack.pid;\n      var id3Pid = id3Track.pid;\n      var audioData = audioTrack.pesData;\n      var id3Data = id3Track.pesData;\n      var unknownPID = null;\n      var pmtParsed = this.pmtParsed;\n      var pmtId = this._pmtId;\n      var len = data.length;\n      if (this.remainderData) {\n        data = appendUint8Array(this.remainderData, data);\n        len = data.length;\n        this.remainderData = null;\n      }\n      if (len < PACKET_LENGTH && !flush) {\n        this.remainderData = data;\n        return {\n          audioTrack: audioTrack,\n          videoTrack: videoTrack,\n          id3Track: id3Track,\n          textTrack: textTrack\n        };\n      }\n      var syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n      len -= (len - syncOffset) % PACKET_LENGTH;\n      if (len < data.byteLength && !flush) {\n        this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n      }\n\n      // loop through TS packets\n      var tsPacketErrors = 0;\n      for (var start = syncOffset; start < len; start += PACKET_LENGTH) {\n        if (data[start] === 0x47) {\n          var stt = !!(data[start + 1] & 0x40);\n          var pid = parsePID(data, start);\n          var atf = (data[start + 3] & 0x30) >> 4;\n\n          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n          var offset = void 0;\n          if (atf > 1) {\n            offset = start + 5 + data[start + 4];\n            // continue if there is only adaptation field\n            if (offset === start + PACKET_LENGTH) {\n              continue;\n            }\n          } else {\n            offset = start + 4;\n          }\n          switch (pid) {\n            case videoPid:\n              if (stt) {\n                if (videoData && (pes = parsePES(videoData, this.logger))) {\n                  this.readyVideoParser(videoTrack.segmentCodec);\n                  if (this.videoParser !== null) {\n                    this.videoParser.parsePES(videoTrack, textTrack, pes, false);\n                  }\n                }\n                videoData = {\n                  data: [],\n                  size: 0\n                };\n              }\n              if (videoData) {\n                videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                videoData.size += start + PACKET_LENGTH - offset;\n              }\n              break;\n            case audioPid:\n              if (stt) {\n                if (audioData && (pes = parsePES(audioData, this.logger))) {\n                  switch (audioTrack.segmentCodec) {\n                    case 'aac':\n                      this.parseAACPES(audioTrack, pes);\n                      break;\n                    case 'mp3':\n                      this.parseMPEGPES(audioTrack, pes);\n                      break;\n                    case 'ac3':\n                      {\n                        this.parseAC3PES(audioTrack, pes);\n                      }\n                      break;\n                  }\n                }\n                audioData = {\n                  data: [],\n                  size: 0\n                };\n              }\n              if (audioData) {\n                audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                audioData.size += start + PACKET_LENGTH - offset;\n              }\n              break;\n            case id3Pid:\n              if (stt) {\n                if (id3Data && (pes = parsePES(id3Data, this.logger))) {\n                  this.parseID3PES(id3Track, pes);\n                }\n                id3Data = {\n                  data: [],\n                  size: 0\n                };\n              }\n              if (id3Data) {\n                id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                id3Data.size += start + PACKET_LENGTH - offset;\n              }\n              break;\n            case 0:\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              pmtId = this._pmtId = parsePAT(data, offset);\n              // this.logger.log('PMT PID:'  + this._pmtId);\n              break;\n            case pmtId:\n              {\n                if (stt) {\n                  offset += data[offset] + 1;\n                }\n                var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer, this.logger);\n\n                // only update track id if track PID found while parsing PMT\n                // this is to avoid resetting the PID to -1 in case\n                // track PID transiently disappears from the stream\n                // this could happen in case of transient missing audio samples for example\n                // NOTE this is only the PID of the track as found in TS,\n                // but we are not using this for MP4 track IDs.\n                videoPid = parsedPIDs.videoPid;\n                if (videoPid > 0) {\n                  videoTrack.pid = videoPid;\n                  videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\n                }\n                audioPid = parsedPIDs.audioPid;\n                if (audioPid > 0) {\n                  audioTrack.pid = audioPid;\n                  audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\n                }\n                id3Pid = parsedPIDs.id3Pid;\n                if (id3Pid > 0) {\n                  id3Track.pid = id3Pid;\n                }\n                if (unknownPID !== null && !pmtParsed) {\n                  this.logger.warn(\"MPEG-TS PMT found at \" + start + \" after unknown PID '\" + unknownPID + \"'. Backtracking to sync byte @\" + syncOffset + \" to parse all TS packets.\");\n                  unknownPID = null;\n                  // we set it to -188, the += 188 in the for loop will reset start to 0\n                  start = syncOffset - 188;\n                }\n                pmtParsed = this.pmtParsed = true;\n                break;\n              }\n            case 0x11:\n            case 0x1fff:\n              break;\n            default:\n              unknownPID = pid;\n              break;\n          }\n        } else {\n          tsPacketErrors++;\n        }\n      }\n      if (tsPacketErrors > 0) {\n        emitParsingError(this.observer, new Error(\"Found \" + tsPacketErrors + \" TS packet/s that do not start with 0x47\"), undefined, this.logger);\n      }\n      videoTrack.pesData = videoData;\n      audioTrack.pesData = audioData;\n      id3Track.pesData = id3Data;\n      var demuxResult = {\n        audioTrack: audioTrack,\n        videoTrack: videoTrack,\n        id3Track: id3Track,\n        textTrack: textTrack\n      };\n      if (flush) {\n        this.extractRemainingSamples(demuxResult);\n      }\n      return demuxResult;\n    };\n    _proto.flush = function flush() {\n      var remainderData = this.remainderData;\n      this.remainderData = null;\n      var result;\n      if (remainderData) {\n        result = this.demux(remainderData, -1, false, true);\n      } else {\n        result = {\n          videoTrack: this._videoTrack,\n          audioTrack: this._audioTrack,\n          id3Track: this._id3Track,\n          textTrack: this._txtTrack\n        };\n      }\n      this.extractRemainingSamples(result);\n      if (this.sampleAes) {\n        return this.decrypt(result, this.sampleAes);\n      }\n      return result;\n    };\n    _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {\n      var audioTrack = demuxResult.audioTrack,\n        videoTrack = demuxResult.videoTrack,\n        id3Track = demuxResult.id3Track,\n        textTrack = demuxResult.textTrack;\n      var videoData = videoTrack.pesData;\n      var audioData = audioTrack.pesData;\n      var id3Data = id3Track.pesData;\n      // try to parse last PES packets\n      var pes;\n      if (videoData && (pes = parsePES(videoData, this.logger))) {\n        this.readyVideoParser(videoTrack.segmentCodec);\n        if (this.videoParser !== null) {\n          this.videoParser.parsePES(videoTrack, textTrack, pes, true);\n          videoTrack.pesData = null;\n        }\n      } else {\n        // either avcData null or PES truncated, keep it for next frag parsing\n        videoTrack.pesData = videoData;\n      }\n      if (audioData && (pes = parsePES(audioData, this.logger))) {\n        switch (audioTrack.segmentCodec) {\n          case 'aac':\n            this.parseAACPES(audioTrack, pes);\n            break;\n          case 'mp3':\n            this.parseMPEGPES(audioTrack, pes);\n            break;\n          case 'ac3':\n            {\n              this.parseAC3PES(audioTrack, pes);\n            }\n            break;\n        }\n        audioTrack.pesData = null;\n      } else {\n        if (audioData != null && audioData.size) {\n          this.logger.log('last AAC PES packet truncated,might overlap between fragments');\n        }\n\n        // either audioData null or PES truncated, keep it for next frag parsing\n        audioTrack.pesData = audioData;\n      }\n      if (id3Data && (pes = parsePES(id3Data, this.logger))) {\n        this.parseID3PES(id3Track, pes);\n        id3Track.pesData = null;\n      } else {\n        // either id3Data null or PES truncated, keep it for next frag parsing\n        id3Track.pesData = id3Data;\n      }\n    };\n    _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n      var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n      var sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n      return this.decrypt(demuxResult, sampleAes);\n    };\n    _proto.readyVideoParser = function readyVideoParser(codec) {\n      if (this.videoParser === null) {\n        if (codec === 'avc') {\n          this.videoParser = new AvcVideoParser();\n        } else if (codec === 'hevc') {\n          this.videoParser = new HevcVideoParser();\n        }\n      }\n    };\n    _proto.decrypt = function decrypt(demuxResult, sampleAes) {\n      return new Promise(function (resolve) {\n        var audioTrack = demuxResult.audioTrack,\n          videoTrack = demuxResult.videoTrack;\n        if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n          sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n            if (videoTrack.samples) {\n              sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n                resolve(demuxResult);\n              });\n            } else {\n              resolve(demuxResult);\n            }\n          });\n        } else if (videoTrack.samples) {\n          sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n            resolve(demuxResult);\n          });\n        }\n      });\n    };\n    _proto.destroy = function destroy() {\n      if (this.observer) {\n        this.observer.removeAllListeners();\n      }\n      // @ts-ignore\n      this.config = this.logger = this.observer = null;\n      this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null;\n      this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = undefined;\n    };\n    _proto.parseAACPES = function parseAACPES(track, pes) {\n      var startOffset = 0;\n      var aacOverFlow = this.aacOverFlow;\n      var data = pes.data;\n      if (aacOverFlow) {\n        this.aacOverFlow = null;\n        var frameMissingBytes = aacOverFlow.missing;\n        var sampleLength = aacOverFlow.sample.unit.byteLength;\n        // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n        if (frameMissingBytes === -1) {\n          data = appendUint8Array(aacOverFlow.sample.unit, data);\n        } else {\n          var frameOverflowBytes = sampleLength - frameMissingBytes;\n          aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n          track.samples.push(aacOverFlow.sample);\n          startOffset = aacOverFlow.missing;\n        }\n      }\n      // look for ADTS header (0xFFFx)\n      var offset;\n      var len;\n      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n        if (isHeader$1(data, offset)) {\n          break;\n        }\n      }\n      // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n      if (offset !== startOffset) {\n        var reason;\n        var recoverable = offset < len - 1;\n        if (recoverable) {\n          reason = \"AAC PES did not start with ADTS header,offset:\" + offset;\n        } else {\n          reason = 'No ADTS header found in AAC PES';\n        }\n        emitParsingError(this.observer, new Error(reason), recoverable, this.logger);\n        if (!recoverable) {\n          return;\n        }\n      }\n      initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n      var pts;\n      if (pes.pts !== undefined) {\n        pts = pes.pts;\n      } else if (aacOverFlow) {\n        // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n        // first sample PTS should be equal to last sample PTS + frameDuration\n        var frameDuration = getFrameDuration(track.samplerate);\n        pts = aacOverFlow.sample.pts + frameDuration;\n      } else {\n        this.logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n        return;\n      }\n\n      // scan for aac samples\n      var frameIndex = 0;\n      var frame;\n      while (offset < len) {\n        frame = appendFrame$1(track, data, offset, pts, frameIndex);\n        offset += frame.length;\n        if (!frame.missing) {\n          frameIndex++;\n          for (; offset < len - 1; offset++) {\n            if (isHeader$1(data, offset)) {\n              break;\n            }\n          }\n        } else {\n          this.aacOverFlow = frame;\n          break;\n        }\n      }\n    };\n    _proto.parseMPEGPES = function parseMPEGPES(track, pes) {\n      var data = pes.data;\n      var length = data.length;\n      var frameIndex = 0;\n      var offset = 0;\n      var pts = pes.pts;\n      if (pts === undefined) {\n        this.logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n        return;\n      }\n      while (offset < length) {\n        if (isHeader(data, offset)) {\n          var frame = appendFrame(track, data, offset, pts, frameIndex);\n          if (frame) {\n            offset += frame.length;\n            frameIndex++;\n          } else {\n            // logger.log('Unable to parse Mpeg audio frame');\n            break;\n          }\n        } else {\n          // nothing found, keep looking\n          offset++;\n        }\n      }\n    };\n    _proto.parseAC3PES = function parseAC3PES(track, pes) {\n      {\n        var data = pes.data;\n        var pts = pes.pts;\n        if (pts === undefined) {\n          this.logger.warn('[tsdemuxer]: AC3 PES unknown PTS');\n          return;\n        }\n        var length = data.length;\n        var frameIndex = 0;\n        var offset = 0;\n        var parsed;\n        while (offset < length && (parsed = _appendFrame(track, data, offset, pts, frameIndex++)) > 0) {\n          offset += parsed;\n        }\n      }\n    };\n    _proto.parseID3PES = function parseID3PES(id3Track, pes) {\n      if (pes.pts === undefined) {\n        this.logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n        return;\n      }\n      var id3Sample = _extends({}, pes, {\n        type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      });\n      id3Track.samples.push(id3Sample);\n    };\n    return TSDemuxer;\n  }();\n  function parsePID(data, offset) {\n    // pid is a 13-bit field starting at the last bit of TS[1]\n    return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n  }\n  function parsePAT(data, offset) {\n    // skip the PSI header and parse the first PMT entry\n    return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n  }\n  function parsePMT(data, offset, typeSupported, isSampleAes, observer, logger) {\n    var result = {\n      audioPid: -1,\n      videoPid: -1,\n      id3Pid: -1,\n      segmentVideoCodec: 'avc',\n      segmentAudioCodec: 'aac'\n    };\n    var sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n    var tableEnd = offset + 3 + sectionLength - 4;\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    var programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n    // advance the offset to the first entry in the mapping table\n    offset += 12 + programInfoLength;\n    while (offset < tableEnd) {\n      var pid = parsePID(data, offset);\n      var esInfoLength = (data[offset + 3] & 0x0f) << 8 | data[offset + 4];\n      switch (data[offset]) {\n        case 0xcf:\n          // SAMPLE-AES AAC\n          if (!isSampleAes) {\n            logEncryptedSamplesFoundInUnencryptedStream('ADTS AAC', logger);\n            break;\n          }\n        /* falls through */\n        case 0x0f:\n          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n          // logger.log('AAC PID:'  + pid);\n          if (result.audioPid === -1) {\n            result.audioPid = pid;\n          }\n          break;\n\n        // Packetized metadata (ID3)\n        case 0x15:\n          // logger.log('ID3 PID:'  + pid);\n          if (result.id3Pid === -1) {\n            result.id3Pid = pid;\n          }\n          break;\n        case 0xdb:\n          // SAMPLE-AES AVC\n          if (!isSampleAes) {\n            logEncryptedSamplesFoundInUnencryptedStream('H.264', logger);\n            break;\n          }\n        /* falls through */\n        case 0x1b:\n          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n          // logger.log('AVC PID:'  + pid);\n          if (result.videoPid === -1) {\n            result.videoPid = pid;\n          }\n          break;\n\n        // ISO/IEC 11172-3 (MPEG-1 audio)\n        // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n        case 0x03:\n        case 0x04:\n          // logger.log('MPEG PID:'  + pid);\n          if (!typeSupported.mpeg && !typeSupported.mp3) {\n            logger.log('MPEG audio found, not supported in this browser');\n          } else if (result.audioPid === -1) {\n            result.audioPid = pid;\n            result.segmentAudioCodec = 'mp3';\n          }\n          break;\n        case 0xc1:\n          // SAMPLE-AES AC3\n          if (!isSampleAes) {\n            logEncryptedSamplesFoundInUnencryptedStream('AC-3', logger);\n            break;\n          }\n        /* falls through */\n        case 0x81:\n          {\n            if (!typeSupported.ac3) {\n              logger.log('AC-3 audio found, not supported in this browser');\n            } else if (result.audioPid === -1) {\n              result.audioPid = pid;\n              result.segmentAudioCodec = 'ac3';\n            }\n          }\n          break;\n        case 0x06:\n          // stream_type 6 can mean a lot of different things in case of DVB.\n          // We need to look at the descriptors. Right now, we're only interested\n          // in AC-3 audio, so we do the descriptor parsing only when we don't have\n          // an audio PID yet.\n          if (result.audioPid === -1 && esInfoLength > 0) {\n            var parsePos = offset + 5;\n            var remaining = esInfoLength;\n            while (remaining > 2) {\n              var descriptorId = data[parsePos];\n              switch (descriptorId) {\n                case 0x6a:\n                  // DVB Descriptor for AC-3\n                  {\n                    if (typeSupported.ac3 !== true) {\n                      logger.log('AC-3 audio found, not supported in this browser for now');\n                    } else {\n                      result.audioPid = pid;\n                      result.segmentAudioCodec = 'ac3';\n                    }\n                  }\n                  break;\n              }\n              var descriptorLen = data[parsePos + 1] + 2;\n              parsePos += descriptorLen;\n              remaining -= descriptorLen;\n            }\n          }\n          break;\n        case 0xc2: // SAMPLE-AES EC3\n        /* falls through */\n        case 0x87:\n          emitParsingError(observer, new Error('Unsupported EC-3 in M2TS found'), undefined, logger);\n          return result;\n        case 0x24:\n          // ITU-T Rec. H.265 and ISO/IEC 23008-2 (HEVC)\n          {\n            if (result.videoPid === -1) {\n              result.videoPid = pid;\n              result.segmentVideoCodec = 'hevc';\n              logger.log('HEVC in M2TS found');\n            }\n          }\n          break;\n      }\n      // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n      offset += esInfoLength + 5;\n    }\n    return result;\n  }\n  function emitParsingError(observer, error, levelRetry, logger) {\n    logger.warn(\"parsing error: \" + error.message);\n    observer.emit(Events.ERROR, Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: false,\n      levelRetry: levelRetry,\n      error: error,\n      reason: error.message\n    });\n  }\n  function logEncryptedSamplesFoundInUnencryptedStream(type, logger) {\n    logger.log(type + \" with AES-128-CBC encryption found in unencrypted stream\");\n  }\n  function parsePES(stream, logger) {\n    var i = 0;\n    var frag;\n    var pesLen;\n    var pesHdrLen;\n    var pesPts;\n    var pesDts;\n    var data = stream.data;\n    // safety check\n    if (!stream || stream.size === 0) {\n      return null;\n    }\n\n    // we might need up to 19 bytes to read PES header\n    // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n    // usually only one merge is needed (and this is rare ...)\n    while (data[0].length < 19 && data.length > 1) {\n      data[0] = appendUint8Array(data[0], data[1]);\n      data.splice(1, 1);\n    }\n    // retrieve PTS/DTS from first fragment\n    frag = data[0];\n    var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n    if (pesPrefix === 1) {\n      pesLen = (frag[4] << 8) + frag[5];\n      // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n      // minus 6 : PES header size\n      if (pesLen && pesLen > stream.size - 6) {\n        return null;\n      }\n      var pesFlags = frag[7];\n      if (pesFlags & 0xc0) {\n        /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n            as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n            as Bitwise operators treat their operands as a sequence of 32 bits */\n        pesPts = (frag[9] & 0x0e) * 536870912 +\n        // 1 << 29\n        (frag[10] & 0xff) * 4194304 +\n        // 1 << 22\n        (frag[11] & 0xfe) * 16384 +\n        // 1 << 14\n        (frag[12] & 0xff) * 128 +\n        // 1 << 7\n        (frag[13] & 0xfe) / 2;\n        if (pesFlags & 0x40) {\n          pesDts = (frag[14] & 0x0e) * 536870912 +\n          // 1 << 29\n          (frag[15] & 0xff) * 4194304 +\n          // 1 << 22\n          (frag[16] & 0xfe) * 16384 +\n          // 1 << 14\n          (frag[17] & 0xff) * 128 +\n          // 1 << 7\n          (frag[18] & 0xfe) / 2;\n          if (pesPts - pesDts > 60 * 90000) {\n            logger.warn(Math.round((pesPts - pesDts) / 90000) + \"s delta between PTS and DTS, align them\");\n            pesPts = pesDts;\n          }\n        } else {\n          pesDts = pesPts;\n        }\n      }\n      pesHdrLen = frag[8];\n      // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n      var payloadStartOffset = pesHdrLen + 9;\n      if (stream.size <= payloadStartOffset) {\n        return null;\n      }\n      stream.size -= payloadStartOffset;\n      // reassemble PES packet\n      var pesData = new Uint8Array(stream.size);\n      for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n        frag = data[j];\n        var len = frag.byteLength;\n        if (payloadStartOffset) {\n          if (payloadStartOffset > len) {\n            // trim full frag if PES header bigger than frag\n            payloadStartOffset -= len;\n            continue;\n          } else {\n            // trim partial frag if PES header smaller than frag\n            frag = frag.subarray(payloadStartOffset);\n            len -= payloadStartOffset;\n            payloadStartOffset = 0;\n          }\n        }\n        pesData.set(frag, i);\n        i += len;\n      }\n      if (pesLen) {\n        // payload size : remove PES header + PES extension\n        pesLen -= pesHdrLen + 3;\n      }\n      return {\n        data: pesData,\n        pts: pesPts,\n        dts: pesDts,\n        len: pesLen\n      };\n    }\n    return null;\n  }\n\n  /**\n   *  AAC helper\n   */\n  var AAC = /*#__PURE__*/function () {\n    function AAC() {}\n    AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {\n      switch (codec) {\n        case 'mp4a.40.2':\n          if (channelCount === 1) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n          } else if (channelCount === 2) {\n            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n          } else if (channelCount === 3) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n          } else if (channelCount === 4) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n          } else if (channelCount === 5) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n          } else if (channelCount === 6) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n          }\n          break;\n        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n        default:\n          if (channelCount === 1) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          } else if (channelCount === 2) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          } else if (channelCount === 3) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          }\n          break;\n      }\n      return undefined;\n    };\n    return AAC;\n  }();\n\n  /**\n   * Generate MP4 Box\n   */\n\n  var UINT32_MAX = Math.pow(2, 32) - 1;\n  var MP4 = /*#__PURE__*/function () {\n    function MP4() {}\n    MP4.init = function init() {\n      MP4.types = {\n        avc1: [],\n        // codingname\n        avcC: [],\n        hvc1: [],\n        hvcC: [],\n        btrt: [],\n        dinf: [],\n        dref: [],\n        esds: [],\n        ftyp: [],\n        hdlr: [],\n        mdat: [],\n        mdhd: [],\n        mdia: [],\n        mfhd: [],\n        minf: [],\n        moof: [],\n        moov: [],\n        mp4a: [],\n        '.mp3': [],\n        dac3: [],\n        'ac-3': [],\n        mvex: [],\n        mvhd: [],\n        pasp: [],\n        sdtp: [],\n        stbl: [],\n        stco: [],\n        stsc: [],\n        stsd: [],\n        stsz: [],\n        stts: [],\n        tfdt: [],\n        tfhd: [],\n        traf: [],\n        trak: [],\n        trun: [],\n        trex: [],\n        tkhd: [],\n        vmhd: [],\n        smhd: []\n      };\n      var i;\n      for (i in MP4.types) {\n        if (MP4.types.hasOwnProperty(i)) {\n          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n        }\n      }\n      var videoHdlr = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      0x76, 0x69, 0x64, 0x65,\n      // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n      ]);\n      var audioHdlr = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      0x73, 0x6f, 0x75, 0x6e,\n      // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n      ]);\n      MP4.HDLR_TYPES = {\n        video: videoHdlr,\n        audio: audioHdlr\n      };\n      var dref = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x01,\n      // entry_count\n      0x00, 0x00, 0x00, 0x0c,\n      // entry_size\n      0x75, 0x72, 0x6c, 0x20,\n      // 'url' type\n      0x00,\n      // version 0\n      0x00, 0x00, 0x01 // entry_flags\n      ]);\n      var stco = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n      MP4.STTS = MP4.STSC = MP4.STCO = stco;\n      MP4.STSZ = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // sample_size\n      0x00, 0x00, 0x00, 0x00 // sample_count\n      ]);\n      MP4.VMHD = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x01,\n      // flags\n      0x00, 0x00,\n      // graphicsmode\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n      ]);\n      MP4.SMHD = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00,\n      // balance\n      0x00, 0x00 // reserved\n      ]);\n      MP4.STSD = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x01]); // entry_count\n\n      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n      var minorVersion = new Uint8Array([0, 0, 0, 1]);\n      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n    };\n    MP4.box = function box(type) {\n      var size = 8;\n      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        payload[_key - 1] = arguments[_key];\n      }\n      var i = payload.length;\n      var len = i;\n      // calculate the total size we need to allocate\n      while (i--) {\n        size += payload[i].byteLength;\n      }\n      var result = new Uint8Array(size);\n      result[0] = size >> 24 & 0xff;\n      result[1] = size >> 16 & 0xff;\n      result[2] = size >> 8 & 0xff;\n      result[3] = size & 0xff;\n      result.set(type, 4);\n      // copy the payload into the result\n      for (i = 0, size = 8; i < len; i++) {\n        // copy payload[i] array @ offset size\n        result.set(payload[i], size);\n        size += payload[i].byteLength;\n      }\n      return result;\n    };\n    MP4.hdlr = function hdlr(type) {\n      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n    };\n    MP4.mdat = function mdat(data) {\n      return MP4.box(MP4.types.mdat, data);\n    };\n    MP4.mdhd = function mdhd(timescale, duration) {\n      duration *= timescale;\n      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n      // version 1\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n      // creation_time\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n      // modification_time\n      timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n      // timescale\n      upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n      // 'und' language (undetermined)\n      0x00, 0x00]));\n    };\n    MP4.mdia = function mdia(track) {\n      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale || 0, track.duration || 0), MP4.hdlr(track.type), MP4.minf(track));\n    };\n    MP4.mfhd = function mfhd(sequenceNumber) {\n      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n      // flags\n      sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n      ]));\n    };\n    MP4.minf = function minf(track) {\n      if (track.type === 'audio') {\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n      } else {\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n      }\n    };\n    MP4.moof = function moof(sn, baseMediaDecodeTime, track) {\n      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n    };\n    MP4.moov = function moov(tracks) {\n      var i = tracks.length;\n      var boxes = [];\n      while (i--) {\n        boxes[i] = MP4.trak(tracks[i]);\n      }\n      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale || 0, tracks[0].duration || 0)].concat(boxes).concat(MP4.mvex(tracks)));\n    };\n    MP4.mvex = function mvex(tracks) {\n      var i = tracks.length;\n      var boxes = [];\n      while (i--) {\n        boxes[i] = MP4.trex(tracks[i]);\n      }\n      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n    };\n    MP4.mvhd = function mvhd(timescale, duration) {\n      duration *= timescale;\n      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n      var bytes = new Uint8Array([0x01,\n      // version 1\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n      // creation_time\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n      // modification_time\n      timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n      // timescale\n      upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n      // 1.0 rate\n      0x01, 0x00,\n      // 1.0 volume\n      0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n      // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n      ]);\n      return MP4.box(MP4.types.mvhd, bytes);\n    };\n    MP4.sdtp = function sdtp(track) {\n      var samples = track.samples || [];\n      var bytes = new Uint8Array(4 + samples.length);\n      var i;\n      var flags;\n      // leave the full box header (4 bytes) all zero\n      // write the sample table\n      for (i = 0; i < samples.length; i++) {\n        flags = samples[i].flags;\n        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n      }\n      return MP4.box(MP4.types.sdtp, bytes);\n    };\n    MP4.stbl = function stbl(track) {\n      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n    };\n    MP4.avc1 = function avc1(track) {\n      var sps = [];\n      var pps = [];\n      var i;\n      var data;\n      var len;\n      // assemble the SPSs\n\n      for (i = 0; i < track.sps.length; i++) {\n        data = track.sps[i];\n        len = data.byteLength;\n        sps.push(len >>> 8 & 0xff);\n        sps.push(len & 0xff);\n\n        // SPS\n        sps = sps.concat(Array.prototype.slice.call(data));\n      }\n\n      // assemble the PPSs\n      for (i = 0; i < track.pps.length; i++) {\n        data = track.pps[i];\n        len = data.byteLength;\n        pps.push(len >>> 8 & 0xff);\n        pps.push(len & 0xff);\n        pps = pps.concat(Array.prototype.slice.call(data));\n      }\n      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n      // version\n      sps[3],\n      // profile\n      sps[4],\n      // profile compat\n      sps[5],\n      // level\n      0xfc | 3,\n      // lengthSizeMinusOne, hard-coded to 4 bytes\n      0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n      ]).concat(pps))); // \"PPS\"\n      var width = track.width;\n      var height = track.height;\n      var hSpacing = track.pixelRatio[0];\n      var vSpacing = track.pixelRatio[1];\n      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01,\n      // data_reference_index\n      0x00, 0x00,\n      // pre_defined\n      0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      width >> 8 & 0xff, width & 0xff,\n      // width\n      height >> 8 & 0xff, height & 0xff,\n      // height\n      0x00, 0x48, 0x00, 0x00,\n      // horizresolution\n      0x00, 0x48, 0x00, 0x00,\n      // vertresolution\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01,\n      // frame_count\n      0x12, 0x64, 0x61, 0x69, 0x6c,\n      // dailymotion/hls.js\n      0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // compressorname\n      0x00, 0x18,\n      // depth = 24\n      0x11, 0x11]),\n      // pre_defined = -1\n      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n      // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0,\n      // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0])),\n      // avgBitrate\n      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n      // hSpacing\n      hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n      // vSpacing\n      vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n    };\n    MP4.esds = function esds(track) {\n      var config = track.config;\n      return new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n\n      0x03,\n      // descriptor_type\n      0x19,\n      // length\n\n      0x00, 0x01,\n      // es_id\n\n      0x00,\n      // stream_priority\n\n      0x04,\n      // descriptor_type\n      0x11,\n      // length\n      0x40,\n      // codec : mpeg4_audio\n      0x15,\n      // stream_type\n      0x00, 0x00, 0x00,\n      // buffer_size\n      0x00, 0x00, 0x00, 0x00,\n      // maxBitrate\n      0x00, 0x00, 0x00, 0x00,\n      // avgBitrate\n\n      0x05,\n      // descriptor_type\n      0x02].concat(config, [0x06, 0x01, 0x02 // GASpecificConfig)); // length + audio config descriptor\n      ]));\n    };\n    MP4.audioStsd = function audioStsd(track) {\n      var samplerate = track.samplerate || 0;\n      return new Uint8Array([0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01,\n      // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, track.channelCount || 0,\n      // channelcount\n      0x00, 0x10,\n      // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00,\n      // reserved2\n      samplerate >> 8 & 0xff, samplerate & 0xff,\n      //\n      0x00, 0x00]);\n    };\n    MP4.mp4a = function mp4a(track) {\n      return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));\n    };\n    MP4.mp3 = function mp3(track) {\n      return MP4.box(MP4.types['.mp3'], MP4.audioStsd(track));\n    };\n    MP4.ac3 = function ac3(track) {\n      return MP4.box(MP4.types['ac-3'], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));\n    };\n    MP4.stsd = function stsd(track) {\n      var segmentCodec = track.segmentCodec;\n      if (track.type === 'audio') {\n        if (segmentCodec === 'aac') {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n        }\n        if (segmentCodec === 'ac3' && track.config) {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\n        }\n        if (segmentCodec === 'mp3' && track.codec === 'mp3') {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n        }\n      } else {\n        if (track.pps && track.sps) {\n          if (segmentCodec === 'avc') {\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n          }\n          if (segmentCodec === 'hevc' && track.vps) {\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.hvc1(track));\n          }\n        } else {\n          throw new Error(\"video track missing pps or sps\");\n        }\n      }\n      throw new Error(\"unsupported \" + track.type + \" segment codec (\" + segmentCodec + \"/\" + track.codec + \")\");\n    };\n    MP4.tkhd = function tkhd(track) {\n      var id = track.id;\n      var duration = (track.duration || 0) * (track.timescale || 0);\n      var width = track.width || 0;\n      var height = track.height || 0;\n      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n      // version 1\n      0x00, 0x00, 0x07,\n      // flags\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n      // creation_time\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n      // modification_time\n      id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n      // track_ID\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00,\n      // layer\n      0x00, 0x00,\n      // alternate_group\n      0x00, 0x00,\n      // non-audio track volume\n      0x00, 0x00,\n      // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n      // transformation: unity matrix\n      width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n      // width\n      height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n      ]));\n    };\n    MP4.traf = function traf(track, baseMediaDecodeTime) {\n      var sampleDependencyTable = MP4.sdtp(track);\n      var id = track.id;\n      var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n      var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n      ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n      // version 1\n      0x00, 0x00, 0x00,\n      // flags\n      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n      // tfhd\n      20 +\n      // tfdt\n      8 +\n      // traf header\n      16 +\n      // mfhd\n      8 +\n      // moof header\n      8),\n      // mdat header\n      sampleDependencyTable);\n    }\n\n    /**\n     * Generate a track box.\n     * @param track a track definition\n     */;\n    MP4.trak = function trak(track) {\n      track.duration = track.duration || 0xffffffff;\n      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n    };\n    MP4.trex = function trex(track) {\n      var id = track.id;\n      return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n      // track_ID\n      0x00, 0x00, 0x00, 0x01,\n      // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00,\n      // default_sample_duration\n      0x00, 0x00, 0x00, 0x00,\n      // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n      ]));\n    };\n    MP4.trun = function trun(track, offset) {\n      var samples = track.samples || [];\n      var len = samples.length;\n      var arraylen = 12 + 16 * len;\n      var array = new Uint8Array(arraylen);\n      var i;\n      var sample;\n      var duration;\n      var size;\n      var flags;\n      var cts;\n      offset += 8 + arraylen;\n      array.set([track.type === 'video' ? 0x01 : 0x00,\n      // version 1 for video with signed-int sample_composition_time_offset\n      0x00, 0x0f, 0x01,\n      // flags\n      len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n      // sample_count\n      offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n      ], 0);\n      for (i = 0; i < len; i++) {\n        sample = samples[i];\n        duration = sample.duration;\n        size = sample.size;\n        flags = sample.flags;\n        cts = sample.cts;\n        array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n        // sample_duration\n        size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n        // sample_size\n        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n        // sample_flags\n        cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n        ], 12 + 16 * i);\n      }\n      return MP4.box(MP4.types.trun, array);\n    };\n    MP4.initSegment = function initSegment(tracks) {\n      if (!MP4.types) {\n        MP4.init();\n      }\n      var movie = MP4.moov(tracks);\n      var result = appendUint8Array(MP4.FTYP, movie);\n      return result;\n    };\n    MP4.hvc1 = function hvc1(track) {\n      var ps = track.params;\n      var units = [track.vps, track.sps, track.pps];\n      var NALuLengthSize = 4;\n      var config = new Uint8Array([0x01, ps.general_profile_space << 6 | (ps.general_tier_flag ? 32 : 0) | ps.general_profile_idc, ps.general_profile_compatibility_flags[0], ps.general_profile_compatibility_flags[1], ps.general_profile_compatibility_flags[2], ps.general_profile_compatibility_flags[3], ps.general_constraint_indicator_flags[0], ps.general_constraint_indicator_flags[1], ps.general_constraint_indicator_flags[2], ps.general_constraint_indicator_flags[3], ps.general_constraint_indicator_flags[4], ps.general_constraint_indicator_flags[5], ps.general_level_idc, 240 | ps.min_spatial_segmentation_idc >> 8, 255 & ps.min_spatial_segmentation_idc, 252 | ps.parallelismType, 252 | ps.chroma_format_idc, 248 | ps.bit_depth_luma_minus8, 248 | ps.bit_depth_chroma_minus8, 0x00, parseInt(ps.frame_rate.fps), NALuLengthSize - 1 | ps.temporal_id_nested << 2 | ps.num_temporal_layers << 3 | (ps.frame_rate.fixed ? 64 : 0), units.length]);\n\n      // compute hvcC size in bytes\n      var length = config.length;\n      for (var i = 0; i < units.length; i += 1) {\n        length += 3;\n        for (var j = 0; j < units[i].length; j += 1) {\n          length += 2 + units[i][j].length;\n        }\n      }\n      var hvcC = new Uint8Array(length);\n      hvcC.set(config, 0);\n      length = config.length;\n      // append parameter set units: one vps, one or more sps and pps\n      var iMax = units.length - 1;\n      for (var _i = 0; _i < units.length; _i += 1) {\n        hvcC.set(new Uint8Array([32 + _i | (_i === iMax ? 128 : 0), 0x00, units[_i].length]), length);\n        length += 3;\n        for (var _j = 0; _j < units[_i].length; _j += 1) {\n          hvcC.set(new Uint8Array([units[_i][_j].length >> 8, units[_i][_j].length & 255]), length);\n          length += 2;\n          hvcC.set(units[_i][_j], length);\n          length += units[_i][_j].length;\n        }\n      }\n      var hvcc = MP4.box(MP4.types.hvcC, hvcC);\n      var width = track.width;\n      var height = track.height;\n      var hSpacing = track.pixelRatio[0];\n      var vSpacing = track.pixelRatio[1];\n      return MP4.box(MP4.types.hvc1, new Uint8Array([0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01,\n      // data_reference_index\n      0x00, 0x00,\n      // pre_defined\n      0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      width >> 8 & 0xff, width & 0xff,\n      // width\n      height >> 8 & 0xff, height & 0xff,\n      // height\n      0x00, 0x48, 0x00, 0x00,\n      // horizresolution\n      0x00, 0x48, 0x00, 0x00,\n      // vertresolution\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01,\n      // frame_count\n      0x12, 0x64, 0x61, 0x69, 0x6c,\n      // dailymotion/hls.js\n      0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // compressorname\n      0x00, 0x18,\n      // depth = 24\n      0x11, 0x11]),\n      // pre_defined = -1\n      hvcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n      // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0,\n      // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0])),\n      // avgBitrate\n      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n      // hSpacing\n      hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n      // vSpacing\n      vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n    };\n    return MP4;\n  }();\n  MP4.types = void 0;\n  MP4.HDLR_TYPES = void 0;\n  MP4.STTS = void 0;\n  MP4.STSC = void 0;\n  MP4.STCO = void 0;\n  MP4.STSZ = void 0;\n  MP4.VMHD = void 0;\n  MP4.SMHD = void 0;\n  MP4.STSD = void 0;\n  MP4.FTYP = void 0;\n  MP4.DINF = void 0;\n\n  var MPEG_TS_CLOCK_FREQ_HZ = 90000;\n  function toTimescaleFromBase(baseTime, destScale, srcBase, round) {\n    if (srcBase === void 0) {\n      srcBase = 1;\n    }\n    if (round === void 0) {\n      round = false;\n    }\n    var result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n    return round ? Math.round(result) : result;\n  }\n  function toTimescaleFromScale(baseTime, destScale, srcScale, round) {\n    if (srcScale === void 0) {\n      srcScale = 1;\n    }\n    if (round === void 0) {\n      round = false;\n    }\n    return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n  }\n  function toMsFromMpegTsClock(baseTime, round) {\n    return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n  }\n  function toMpegTsClockFromTimescale(baseTime, srcScale) {\n    if (srcScale === void 0) {\n      srcScale = 1;\n    }\n    return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n  }\n  function timestampToString(timestamp) {\n    var baseTime = timestamp.baseTime,\n      timescale = timestamp.timescale,\n      trackId = timestamp.trackId;\n    return baseTime / timescale + \" (\" + baseTime + \"/\" + timescale + \") trackId: \" + trackId;\n  }\n\n  var MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\n  var AAC_SAMPLES_PER_FRAME = 1024;\n  var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\n  var AC3_SAMPLES_PER_FRAME = 1536;\n  var chromeVersion = null;\n  var safariWebkitVersion = null;\n  function createMp4Sample(isKeyframe, duration, size, cts) {\n    return {\n      duration: duration,\n      size: size,\n      cts: cts,\n      flags: {\n        isLeading: 0,\n        isDependedOn: 0,\n        hasRedundancy: 0,\n        degradPrio: 0,\n        dependsOn: isKeyframe ? 2 : 1,\n        isNonSync: isKeyframe ? 0 : 1\n      }\n    };\n  }\n  var MP4Remuxer = /*#__PURE__*/function (_Logger) {\n    function MP4Remuxer(observer, config, typeSupported, logger) {\n      var _this;\n      _this = _Logger.call(this, 'mp4-remuxer', logger) || this;\n      _this.observer = void 0;\n      _this.config = void 0;\n      _this.typeSupported = void 0;\n      _this.ISGenerated = false;\n      _this._initPTS = null;\n      _this._initDTS = null;\n      _this.nextVideoTs = null;\n      _this.nextAudioTs = null;\n      _this.videoSampleDuration = null;\n      _this.isAudioContiguous = false;\n      _this.isVideoContiguous = false;\n      _this.videoTrackConfig = void 0;\n      _this.observer = observer;\n      _this.config = config;\n      _this.typeSupported = typeSupported;\n      _this.ISGenerated = false;\n      if (chromeVersion === null) {\n        var userAgent = navigator.userAgent || '';\n        var result = userAgent.match(/Chrome\\/(\\d+)/i);\n        chromeVersion = result ? parseInt(result[1]) : 0;\n      }\n      if (safariWebkitVersion === null) {\n        var _result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n        safariWebkitVersion = _result ? parseInt(_result[1]) : 0;\n      }\n      return _this;\n    }\n    _inheritsLoose(MP4Remuxer, _Logger);\n    var _proto = MP4Remuxer.prototype;\n    _proto.destroy = function destroy() {\n      // @ts-ignore\n      this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n    };\n    _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {\n      var initPTS = this._initPTS;\n      if (!initPTS || !defaultTimeStamp || defaultTimeStamp.trackId !== initPTS.trackId || defaultTimeStamp.baseTime !== initPTS.baseTime || defaultTimeStamp.timescale !== initPTS.timescale) {\n        this.log(\"Reset initPTS: \" + (initPTS ? timestampToString(initPTS) : initPTS) + \" > \" + (defaultTimeStamp ? timestampToString(defaultTimeStamp) : defaultTimeStamp));\n      }\n      this._initPTS = this._initDTS = defaultTimeStamp;\n    };\n    _proto.resetNextTimestamp = function resetNextTimestamp() {\n      this.log('reset next timestamp');\n      this.isVideoContiguous = false;\n      this.isAudioContiguous = false;\n    };\n    _proto.resetInitSegment = function resetInitSegment() {\n      this.log('ISGenerated flag reset');\n      this.ISGenerated = false;\n      this.videoTrackConfig = undefined;\n    };\n    _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {\n      // Get the minimum PTS value relative to the first sample's PTS, normalized for 33-bit wrapping\n      var rolloverDetected = false;\n      var firstPts = videoSamples[0].pts;\n      var startPTS = videoSamples.reduce(function (minPTS, sample) {\n        var pts = sample.pts;\n        var delta = pts - minPTS;\n        if (delta < -4294967296) {\n          // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n          rolloverDetected = true;\n          pts = normalizePts(pts, firstPts);\n          delta = pts - minPTS;\n        }\n        if (delta > 0) {\n          return minPTS;\n        }\n        return pts;\n      }, firstPts);\n      if (rolloverDetected) {\n        this.debug('PTS rollover detected');\n      }\n      return startPTS;\n    };\n    _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n      var video;\n      var audio;\n      var initSegment;\n      var text;\n      var id3;\n      var independent;\n      var audioTimeOffset = timeOffset;\n      var videoTimeOffset = timeOffset;\n\n      // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n      // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n      // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n      // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n      // then we can remux one track without waiting for the other.\n      var hasAudio = audioTrack.pid > -1;\n      var hasVideo = videoTrack.pid > -1;\n      var length = videoTrack.samples.length;\n      var enoughAudioSamples = audioTrack.samples.length > 0;\n      var enoughVideoSamples = flush && length > 0 || length > 1;\n      var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n      if (canRemuxAvc) {\n        if (this.ISGenerated) {\n          var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;\n          var config = this.videoTrackConfig;\n          if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1])) || !config && enoughVideoSamples || this.nextAudioTs === null && enoughAudioSamples) {\n            this.resetInitSegment();\n          }\n        }\n        if (!this.ISGenerated) {\n          initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n        }\n        var isVideoContiguous = this.isVideoContiguous;\n        var firstKeyFrameIndex = -1;\n        var firstKeyFramePTS;\n        if (enoughVideoSamples) {\n          firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n          if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n            independent = true;\n            if (firstKeyFrameIndex > 0) {\n              this.warn(\"Dropped \" + firstKeyFrameIndex + \" out of \" + length + \" video samples due to a missing keyframe\");\n              var startPTS = this.getVideoStartPts(videoTrack.samples);\n              videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n              videoTrack.dropped += firstKeyFrameIndex;\n              videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n              firstKeyFramePTS = videoTimeOffset;\n            } else if (firstKeyFrameIndex === -1) {\n              this.warn(\"No keyframe found out of \" + length + \" video samples\");\n              independent = false;\n            }\n          }\n        }\n        if (this.ISGenerated) {\n          if (enoughAudioSamples && enoughVideoSamples) {\n            // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n            // if first audio DTS is not aligned with first video DTS then we need to take that into account\n            // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n            // drift between audio and video streams\n            var _startPTS = this.getVideoStartPts(videoTrack.samples);\n            var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;\n            var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n            audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n            videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n          }\n\n          // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n          if (enoughAudioSamples) {\n            // if initSegment was generated without audio samples, regenerate it again\n            if (!audioTrack.samplerate) {\n              this.warn('regenerate InitSegment as audio detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n            if (enoughVideoSamples) {\n              var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n              // if initSegment was generated without video samples, regenerate it again\n              if (!videoTrack.inputTimeScale) {\n                this.warn('regenerate InitSegment as video detected');\n                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n              }\n              video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n            }\n          } else if (enoughVideoSamples) {\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n          }\n          if (video) {\n            video.firstKeyFrame = firstKeyFrameIndex;\n            video.independent = firstKeyFrameIndex !== -1;\n            video.firstKeyFramePTS = firstKeyFramePTS;\n          }\n        }\n      }\n\n      // Allow ID3 and text to remux, even if more audio/video samples are required\n      if (this.ISGenerated && this._initPTS && this._initDTS) {\n        if (id3Track.samples.length) {\n          id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n        }\n        if (textTrack.samples.length) {\n          text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n        }\n      }\n      return {\n        audio: audio,\n        video: video,\n        initSegment: initSegment,\n        independent: independent,\n        text: text,\n        id3: id3\n      };\n    };\n    _proto.computeInitPts = function computeInitPts(basetime, timescale, presentationTime, type) {\n      var offset = Math.round(presentationTime * timescale);\n      var timestamp = normalizePts(basetime, offset);\n      if (timestamp < offset + timescale) {\n        this.log(\"Adjusting PTS for rollover in timeline near \" + (offset - timestamp) / timescale + \" \" + type);\n        while (timestamp < offset + timescale) {\n          timestamp += 8589934592;\n        }\n      }\n      return timestamp - offset;\n    };\n    _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n      var audioSamples = audioTrack.samples;\n      var videoSamples = videoTrack.samples;\n      var typeSupported = this.typeSupported;\n      var tracks = {};\n      var _initPTS = this._initPTS;\n      var computePTSDTS = !_initPTS || accurateTimeOffset;\n      var container = 'audio/mp4';\n      var initPTS;\n      var initDTS;\n      var timescale;\n      var trackId = -1;\n      if (computePTSDTS) {\n        initPTS = initDTS = Infinity;\n      }\n      if (audioTrack.config && audioSamples.length) {\n        // let's use audio sampling rate as MP4 time scale.\n        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n        // using audio sampling rate here helps having an integer MP4 frame duration\n        // this avoids potential rounding issue and AV sync issue\n        audioTrack.timescale = audioTrack.samplerate;\n        switch (audioTrack.segmentCodec) {\n          case 'mp3':\n            if (typeSupported.mpeg) {\n              // Chrome and Safari\n              container = 'audio/mpeg';\n              audioTrack.codec = '';\n            } else if (typeSupported.mp3) {\n              // Firefox\n              audioTrack.codec = 'mp3';\n            }\n            break;\n          case 'ac3':\n            audioTrack.codec = 'ac-3';\n            break;\n        }\n        tracks.audio = {\n          id: 'audio',\n          container: container,\n          codec: audioTrack.codec,\n          initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n          metadata: {\n            channelCount: audioTrack.channelCount\n          }\n        };\n        if (computePTSDTS) {\n          trackId = audioTrack.id;\n          timescale = audioTrack.inputTimeScale;\n          if (!_initPTS || timescale !== _initPTS.timescale) {\n            // remember first PTS of this demuxing context. for audio, PTS = DTS\n            initPTS = initDTS = this.computeInitPts(audioSamples[0].pts, timescale, timeOffset, 'audio');\n          } else {\n            computePTSDTS = false;\n          }\n        }\n      }\n      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n        // let's use input time scale as MP4 video timescale\n        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n        videoTrack.timescale = videoTrack.inputTimeScale;\n        tracks.video = {\n          id: 'main',\n          container: 'video/mp4',\n          codec: videoTrack.codec,\n          initSegment: MP4.initSegment([videoTrack]),\n          metadata: {\n            width: videoTrack.width,\n            height: videoTrack.height\n          }\n        };\n        if (computePTSDTS) {\n          trackId = videoTrack.id;\n          timescale = videoTrack.inputTimeScale;\n          if (!_initPTS || timescale !== _initPTS.timescale) {\n            var basePTS = this.getVideoStartPts(videoSamples);\n            var baseDTS = normalizePts(videoSamples[0].dts, basePTS);\n            var videoInitDTS = this.computeInitPts(baseDTS, timescale, timeOffset, 'video');\n            var videoInitPTS = this.computeInitPts(basePTS, timescale, timeOffset, 'video');\n            initDTS = Math.min(initDTS, videoInitDTS);\n            initPTS = Math.min(initPTS, videoInitPTS);\n          } else {\n            computePTSDTS = false;\n          }\n        }\n        this.videoTrackConfig = {\n          width: videoTrack.width,\n          height: videoTrack.height,\n          pixelRatio: videoTrack.pixelRatio\n        };\n      }\n      if (Object.keys(tracks).length) {\n        this.ISGenerated = true;\n        if (computePTSDTS) {\n          if (_initPTS) {\n            this.warn(\"Timestamps at playlist time: \" + (accurateTimeOffset ? '' : '~') + timeOffset + \" \" + initPTS / timescale + \" != initPTS: \" + _initPTS.baseTime / _initPTS.timescale + \" (\" + _initPTS.baseTime + \"/\" + _initPTS.timescale + \") trackId: \" + _initPTS.trackId);\n          }\n          this.log(\"Found initPTS at playlist time: \" + timeOffset + \" offset: \" + initPTS / timescale + \" (\" + initPTS + \"/\" + timescale + \") trackId: \" + trackId);\n          this._initPTS = {\n            baseTime: initPTS,\n            timescale: timescale,\n            trackId: trackId\n          };\n          this._initDTS = {\n            baseTime: initDTS,\n            timescale: timescale,\n            trackId: trackId\n          };\n        } else {\n          initPTS = timescale = undefined;\n        }\n        return {\n          tracks: tracks,\n          initPTS: initPTS,\n          timescale: timescale,\n          trackId: trackId\n        };\n      }\n    };\n    _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n      var timeScale = track.inputTimeScale;\n      var inputSamples = track.samples;\n      var outputSamples = [];\n      var nbSamples = inputSamples.length;\n      var initPTS = this._initPTS;\n      var initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n      var nextVideoTs = this.nextVideoTs;\n      var offset = 8;\n      var mp4SampleDuration = this.videoSampleDuration;\n      var firstDTS;\n      var lastDTS;\n      var minPTS = Number.POSITIVE_INFINITY;\n      var maxPTS = Number.NEGATIVE_INFINITY;\n      var sortSamples = false;\n\n      // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n      if (!contiguous || nextVideoTs === null) {\n        var pts = initTime + timeOffset * timeScale;\n        var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n        if (chromeVersion && nextVideoTs !== null && Math.abs(pts - cts - (nextVideoTs + initTime)) < 15000) {\n          // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\n          contiguous = true;\n        } else {\n          // if not contiguous, let's use target timeOffset\n          nextVideoTs = pts - cts - initTime;\n        }\n      }\n\n      // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n      // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n      var nextVideoPts = nextVideoTs + initTime;\n      for (var i = 0; i < nbSamples; i++) {\n        var sample = inputSamples[i];\n        sample.pts = normalizePts(sample.pts, nextVideoPts);\n        sample.dts = normalizePts(sample.dts, nextVideoPts);\n        if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n          sortSamples = true;\n        }\n      }\n\n      // sort video samples by DTS then PTS then demux id order\n      if (sortSamples) {\n        inputSamples.sort(function (a, b) {\n          var deltadts = a.dts - b.dts;\n          var deltapts = a.pts - b.pts;\n          return deltadts || deltapts;\n        });\n      }\n\n      // Get first/last DTS\n      firstDTS = inputSamples[0].dts;\n      lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n      // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n      // set this constant duration as being the avg delta between consecutive DTS.\n      var inputDuration = lastDTS - firstDTS;\n      var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n      // if fragment are contiguous, detect hole/overlapping between fragments\n      if (contiguous) {\n        // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n        var delta = firstDTS - nextVideoPts;\n        var foundHole = delta > averageSampleDuration;\n        var foundOverlap = delta < -1;\n        if (foundHole || foundOverlap) {\n          if (foundHole) {\n            this.warn((track.segmentCodec || '').toUpperCase() + \": \" + toMsFromMpegTsClock(delta, true) + \" ms (\" + delta + \"dts) hole between fragments detected at \" + timeOffset.toFixed(3));\n          } else {\n            this.warn((track.segmentCodec || '').toUpperCase() + \": \" + toMsFromMpegTsClock(-delta, true) + \" ms (\" + delta + \"dts) overlapping between fragments detected at \" + timeOffset.toFixed(3));\n          }\n          if (!foundOverlap || nextVideoPts >= inputSamples[0].pts || chromeVersion) {\n            firstDTS = nextVideoPts;\n            var firstPTS = inputSamples[0].pts - delta;\n            if (foundHole) {\n              inputSamples[0].dts = firstDTS;\n              inputSamples[0].pts = firstPTS;\n            } else {\n              var isPTSOrderRetained = true;\n              for (var _i = 0; _i < inputSamples.length; _i++) {\n                if (inputSamples[_i].dts > firstPTS && isPTSOrderRetained) {\n                  break;\n                }\n                var prevPTS = inputSamples[_i].pts;\n                inputSamples[_i].dts -= delta;\n                inputSamples[_i].pts -= delta;\n\n                // check to see if this sample's PTS order has changed\n                // relative to the next one\n                if (_i < inputSamples.length - 1) {\n                  var nextSamplePTS = inputSamples[_i + 1].pts;\n                  var currentSamplePTS = inputSamples[_i].pts;\n                  var currentOrder = nextSamplePTS <= currentSamplePTS;\n                  var prevOrder = nextSamplePTS <= prevPTS;\n                  isPTSOrderRetained = currentOrder == prevOrder;\n                }\n              }\n            }\n            this.log(\"Video: Initial PTS/DTS adjusted: \" + toMsFromMpegTsClock(firstPTS, true) + \"/\" + toMsFromMpegTsClock(firstDTS, true) + \", delta: \" + toMsFromMpegTsClock(delta, true) + \" ms\");\n          }\n        }\n      }\n      firstDTS = Math.max(0, firstDTS);\n      var nbNalu = 0;\n      var naluLen = 0;\n      var dtsStep = firstDTS;\n      for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n        // compute total/avc sample length and nb of NAL units\n        var _sample = inputSamples[_i2];\n        var units = _sample.units;\n        var nbUnits = units.length;\n        var sampleLen = 0;\n        for (var j = 0; j < nbUnits; j++) {\n          sampleLen += units[j].data.length;\n        }\n        naluLen += sampleLen;\n        nbNalu += nbUnits;\n        _sample.length = sampleLen;\n\n        // ensure sample monotonic DTS\n        if (_sample.dts < dtsStep) {\n          _sample.dts = dtsStep;\n          dtsStep += averageSampleDuration / 4 | 0 || 1;\n        } else {\n          dtsStep = _sample.dts;\n        }\n        minPTS = Math.min(_sample.pts, minPTS);\n        maxPTS = Math.max(_sample.pts, maxPTS);\n      }\n      lastDTS = inputSamples[nbSamples - 1].dts;\n\n      /* concatenate the video data and construct the mdat in place\n        (need 8 more bytes to fill length and mpdat type) */\n      var mdatSize = naluLen + 4 * nbNalu + 8;\n      var mdat;\n      try {\n        mdat = new Uint8Array(mdatSize);\n      } catch (err) {\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MUX_ERROR,\n          details: ErrorDetails.REMUX_ALLOC_ERROR,\n          fatal: false,\n          error: err,\n          bytes: mdatSize,\n          reason: \"fail allocating video mdat \" + mdatSize\n        });\n        return;\n      }\n      var view = new DataView(mdat.buffer);\n      view.setUint32(0, mdatSize);\n      mdat.set(MP4.types.mdat, 4);\n      var stretchedLastFrame = false;\n      var minDtsDelta = Number.POSITIVE_INFINITY;\n      var minPtsDelta = Number.POSITIVE_INFINITY;\n      var maxDtsDelta = Number.NEGATIVE_INFINITY;\n      var maxPtsDelta = Number.NEGATIVE_INFINITY;\n      for (var _i3 = 0; _i3 < nbSamples; _i3++) {\n        var VideoSample = inputSamples[_i3];\n        var VideoSampleUnits = VideoSample.units;\n        var mp4SampleLength = 0;\n        // convert NALU bitstream to MP4 format (prepend NALU with size field)\n        for (var _j = 0, _nbUnits = VideoSampleUnits.length; _j < _nbUnits; _j++) {\n          var unit = VideoSampleUnits[_j];\n          var unitData = unit.data;\n          var unitDataLen = unit.data.byteLength;\n          view.setUint32(offset, unitDataLen);\n          offset += 4;\n          mdat.set(unitData, offset);\n          offset += unitDataLen;\n          mp4SampleLength += 4 + unitDataLen;\n        }\n\n        // expected sample duration is the Decoding Timestamp diff of consecutive samples\n        var ptsDelta = void 0;\n        if (_i3 < nbSamples - 1) {\n          mp4SampleDuration = inputSamples[_i3 + 1].dts - VideoSample.dts;\n          ptsDelta = inputSamples[_i3 + 1].pts - VideoSample.pts;\n        } else {\n          var config = this.config;\n          var lastFrameDuration = _i3 > 0 ? VideoSample.dts - inputSamples[_i3 - 1].dts : averageSampleDuration;\n          ptsDelta = _i3 > 0 ? VideoSample.pts - inputSamples[_i3 - 1].pts : averageSampleDuration;\n          if (config.stretchShortVideoTrack && this.nextAudioTs !== null) {\n            // In some cases, a segment's audio track duration may exceed the video track duration.\n            // Since we've already remuxed audio, and we know how long the audio track is, we look to\n            // see if the delta to the next segment is longer than maxBufferHole.\n            // If so, playback would potentially get stuck, so we artificially inflate\n            // the duration of the last frame to minimize any potential gap between segments.\n            var gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n            var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioTs + initTime) - VideoSample.pts;\n            if (deltaToFrameEnd > gapTolerance) {\n              // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n              // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n              mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n              if (mp4SampleDuration < 0) {\n                mp4SampleDuration = lastFrameDuration;\n              } else {\n                stretchedLastFrame = true;\n              }\n              this.log(\"It is approximately \" + deltaToFrameEnd / 90 + \" ms to the next segment; using duration \" + mp4SampleDuration / 90 + \" ms for the last video frame.\");\n            } else {\n              mp4SampleDuration = lastFrameDuration;\n            }\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        }\n        var compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);\n        minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n        maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n        minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n        maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n        outputSamples.push(createMp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n      }\n      if (outputSamples.length) {\n        if (chromeVersion) {\n          if (chromeVersion < 70) {\n            // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n            // https://code.google.com/p/chromium/issues/detail?id=229412\n            var flags = outputSamples[0].flags;\n            flags.dependsOn = 2;\n            flags.isNonSync = 0;\n          }\n        } else if (safariWebkitVersion) {\n          // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n          // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n          if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n            this.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n            var dts = firstDTS;\n            for (var _i4 = 0, len = outputSamples.length; _i4 < len; _i4++) {\n              var nextDts = dts + outputSamples[_i4].duration;\n              var _pts = dts + outputSamples[_i4].cts;\n              if (_i4 < len - 1) {\n                var nextPts = nextDts + outputSamples[_i4 + 1].cts;\n                outputSamples[_i4].duration = nextPts - _pts;\n              } else {\n                outputSamples[_i4].duration = _i4 ? outputSamples[_i4 - 1].duration : averageSampleDuration;\n              }\n              outputSamples[_i4].cts = 0;\n              dts = nextDts;\n            }\n          }\n        }\n      }\n      // next AVC/HEVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n      mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n      var endDTS = lastDTS + mp4SampleDuration;\n      this.nextVideoTs = nextVideoTs = endDTS - initTime;\n      this.videoSampleDuration = mp4SampleDuration;\n      this.isVideoContiguous = true;\n      var moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends(track, {\n        samples: outputSamples\n      }));\n      var type = 'video';\n      var data = {\n        data1: moof,\n        data2: mdat,\n        startPTS: (minPTS - initTime) / timeScale,\n        endPTS: (maxPTS + mp4SampleDuration - initTime) / timeScale,\n        startDTS: (firstDTS - initTime) / timeScale,\n        endDTS: nextVideoTs / timeScale,\n        type: type,\n        hasAudio: false,\n        hasVideo: true,\n        nb: outputSamples.length,\n        dropped: track.dropped\n      };\n      track.samples = [];\n      track.dropped = 0;\n      return data;\n    };\n    _proto.getSamplesPerFrame = function getSamplesPerFrame(track) {\n      switch (track.segmentCodec) {\n        case 'mp3':\n          return MPEG_AUDIO_SAMPLE_PER_FRAME;\n        case 'ac3':\n          return AC3_SAMPLES_PER_FRAME;\n        default:\n          return AAC_SAMPLES_PER_FRAME;\n      }\n    };\n    _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n      var inputTimeScale = track.inputTimeScale;\n      var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n      var scaleFactor = inputTimeScale / mp4timeScale;\n      var mp4SampleDuration = this.getSamplesPerFrame(track);\n      var inputSampleDuration = mp4SampleDuration * scaleFactor;\n      var initPTS = this._initPTS;\n      var rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n      var outputSamples = [];\n      var alignedWithVideo = videoTimeOffset !== undefined;\n      var inputSamples = track.samples;\n      var offset = rawMPEG ? 0 : 8;\n      var nextAudioTs = this.nextAudioTs || -1;\n\n      // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n      // for sake of clarity:\n      // consecutive fragments are frags with\n      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n      //  - less than 20 audio frames distance\n      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n      // this helps ensuring audio continuity\n      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n      var initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n      var timeOffsetMpegTS = initTime + timeOffset * inputTimeScale;\n      this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioTs > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - (nextAudioTs + initTime)) < 9000 || Math.abs(normalizePts(inputSamples[0].pts, timeOffsetMpegTS) - (nextAudioTs + initTime)) < 20 * inputSampleDuration);\n\n      // compute normalized PTS\n      inputSamples.forEach(function (sample) {\n        sample.pts = normalizePts(sample.pts, timeOffsetMpegTS);\n      });\n      if (!contiguous || nextAudioTs < 0) {\n        var sampleCount = inputSamples.length;\n        // filter out sample with negative PTS that are not playable anyway\n        // if we don't remove these negative samples, they will shift all audio samples forward.\n        // leading to audio overlap between current / next fragment\n        inputSamples = inputSamples.filter(function (sample) {\n          return sample.pts >= 0;\n        });\n        if (sampleCount !== inputSamples.length) {\n          this.warn(\"Removed \" + (inputSamples.length - sampleCount) + \" of \" + sampleCount + \" samples (initPTS \" + initTime + \" / \" + inputTimeScale + \")\");\n        }\n\n        // in case all samples have negative PTS, and have been filtered out, return now\n        if (!inputSamples.length) {\n          return;\n        }\n        if (videoTimeOffset === 0) {\n          // Set the start to match video so that start gaps larger than inputSampleDuration are filled with silence\n          nextAudioTs = 0;\n        } else if (accurateTimeOffset && !alignedWithVideo) {\n          // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n          nextAudioTs = Math.max(0, timeOffsetMpegTS - initTime);\n        } else {\n          // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n          nextAudioTs = inputSamples[0].pts - initTime;\n        }\n      }\n\n      // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n      // In an effort to prevent this from happening, we inject frames here where there are gaps.\n      // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n      // frame.\n\n      if (track.segmentCodec === 'aac') {\n        var maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n        for (var i = 0, nextPts = nextAudioTs + initTime; i < inputSamples.length; i++) {\n          // First, let's see how far off this frame is from where we expect it to be\n          var sample = inputSamples[i];\n          var pts = sample.pts;\n          var delta = pts - nextPts;\n          var duration = Math.abs(1000 * delta / inputTimeScale);\n\n          // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n          if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n            if (i === 0) {\n              this.warn(\"Audio frame @ \" + (pts / inputTimeScale).toFixed(3) + \"s overlaps marker by \" + Math.round(1000 * delta / inputTimeScale) + \" ms.\");\n              this.nextAudioTs = nextAudioTs = pts - initTime;\n              nextPts = pts;\n            }\n          } // eslint-disable-line brace-style\n\n          // Insert missing frames if:\n          // 1: We're more than maxAudioFramesDrift frame away\n          // 2: Not more than MAX_SILENT_FRAME_DURATION away\n          // 3: currentTime (aka nextPtsNorm) is not 0\n          // 4: remuxing with video (videoTimeOffset !== undefined)\n          else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n            var missing = Math.round(delta / inputSampleDuration);\n            // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n            // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n            nextPts = pts - missing * inputSampleDuration;\n            while (nextPts < 0 && missing && inputSampleDuration) {\n              missing--;\n              nextPts += inputSampleDuration;\n            }\n            if (i === 0) {\n              this.nextAudioTs = nextAudioTs = nextPts - initTime;\n            }\n            this.warn(\"Injecting \" + missing + \" audio frames @ \" + ((nextPts - initTime) / inputTimeScale).toFixed(3) + \"s due to \" + Math.round(1000 * delta / inputTimeScale) + \" ms gap.\");\n            for (var j = 0; j < missing; j++) {\n              var fillFrame = AAC.getSilentFrame(track.parsedCodec || track.manifestCodec || track.codec, track.channelCount);\n              if (!fillFrame) {\n                this.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');\n                fillFrame = sample.unit.subarray();\n              }\n              inputSamples.splice(i, 0, {\n                unit: fillFrame,\n                pts: nextPts\n              });\n              nextPts += inputSampleDuration;\n              i++;\n            }\n          }\n          sample.pts = nextPts;\n          nextPts += inputSampleDuration;\n        }\n      }\n      var firstPTS = null;\n      var lastPTS = null;\n      var mdat;\n      var mdatSize = 0;\n      var sampleLength = inputSamples.length;\n      while (sampleLength--) {\n        mdatSize += inputSamples[sampleLength].unit.byteLength;\n      }\n      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n        var audioSample = inputSamples[_j2];\n        var unit = audioSample.unit;\n        var _pts2 = audioSample.pts;\n        if (lastPTS !== null) {\n          // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n          // the previous sample\n          var prevSample = outputSamples[_j2 - 1];\n          prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);\n        } else {\n          if (contiguous && track.segmentCodec === 'aac') {\n            // set PTS/DTS to expected PTS/DTS\n            _pts2 = nextAudioTs + initTime;\n          }\n          // remember first PTS of our audioSamples\n          firstPTS = _pts2;\n          if (mdatSize > 0) {\n            /* concatenate the audio data and construct the mdat in place\n              (need 8 more bytes to fill length and mdat type) */\n            mdatSize += offset;\n            try {\n              mdat = new Uint8Array(mdatSize);\n            } catch (err) {\n              this.observer.emit(Events.ERROR, Events.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.REMUX_ALLOC_ERROR,\n                fatal: false,\n                error: err,\n                bytes: mdatSize,\n                reason: \"fail allocating audio mdat \" + mdatSize\n              });\n              return;\n            }\n            if (!rawMPEG) {\n              var view = new DataView(mdat.buffer);\n              view.setUint32(0, mdatSize);\n              mdat.set(MP4.types.mdat, 4);\n            }\n          } else {\n            // no audio samples\n            return;\n          }\n        }\n        mdat.set(unit, offset);\n        var unitLen = unit.byteLength;\n        offset += unitLen;\n        // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n        // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n        // becomes the PTS diff with the previous sample\n        outputSamples.push(createMp4Sample(true, mp4SampleDuration, unitLen, 0));\n        lastPTS = _pts2;\n      }\n\n      // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n      var nbSamples = outputSamples.length;\n      if (!nbSamples) {\n        return;\n      }\n\n      // The next audio sample PTS should be equal to last sample PTS + duration\n      var lastSample = outputSamples[outputSamples.length - 1];\n      nextAudioTs = lastPTS - initTime;\n      this.nextAudioTs = nextAudioTs + scaleFactor * lastSample.duration;\n\n      // Set the track samples from inputSamples to outputSamples before remuxing\n      var moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n        samples: outputSamples\n      }));\n\n      // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n      track.samples = [];\n      var start = (firstPTS - initTime) / inputTimeScale;\n      var end = this.nextAudioTs / inputTimeScale;\n      var type = 'audio';\n      var audioData = {\n        data1: moof,\n        data2: mdat,\n        startPTS: start,\n        endPTS: end,\n        startDTS: start,\n        endDTS: end,\n        type: type,\n        hasAudio: true,\n        hasVideo: false,\n        nb: nbSamples\n      };\n      this.isAudioContiguous = true;\n      return audioData;\n    };\n    return MP4Remuxer;\n  }(Logger);\n  function normalizePts(value, reference) {\n    var offset;\n    if (reference === null) {\n      return value;\n    }\n    if (reference < value) {\n      // - 2^33\n      offset = -8589934592;\n    } else {\n      // + 2^33\n      offset = 8589934592;\n    }\n    /* PTS is 33bit (from 0 to 2^33 -1)\n      if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n      PTS looping occured. fill the gap */\n    while (Math.abs(value - reference) > 4294967296) {\n      value += offset;\n    }\n    return value;\n  }\n  function findKeyframeIndex(samples) {\n    for (var i = 0; i < samples.length; i++) {\n      if (samples[i].key) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n    var length = track.samples.length;\n    if (!length) {\n      return;\n    }\n    var inputTimeScale = track.inputTimeScale;\n    for (var index = 0; index < length; index++) {\n      var sample = track.samples[index];\n      // setting id3 pts, dts to relative time\n      // using this._initPTS and this._initDTS to calculate relative time\n      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n      sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n    var samples = track.samples;\n    track.samples = [];\n    return {\n      samples: samples\n    };\n  }\n  function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n    var length = track.samples.length;\n    if (!length) {\n      return;\n    }\n    var inputTimeScale = track.inputTimeScale;\n    for (var index = 0; index < length; index++) {\n      var sample = track.samples[index];\n      // setting text pts, dts to relative time\n      // using this._initPTS and this._initDTS to calculate relative time\n      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n    track.samples.sort(function (a, b) {\n      return a.pts - b.pts;\n    });\n    var samples = track.samples;\n    track.samples = [];\n    return {\n      samples: samples\n    };\n  }\n\n  var PassThroughRemuxer = /*#__PURE__*/function (_Logger) {\n    function PassThroughRemuxer(observer, config, typeSupported, logger) {\n      var _this;\n      _this = _Logger.call(this, 'passthrough-remuxer', logger) || this;\n      _this.emitInitSegment = false;\n      _this.audioCodec = void 0;\n      _this.videoCodec = void 0;\n      _this.initData = void 0;\n      _this.initPTS = null;\n      _this.initTracks = void 0;\n      _this.lastEndTime = null;\n      _this.isVideoContiguous = false;\n      return _this;\n    }\n    _inheritsLoose(PassThroughRemuxer, _Logger);\n    var _proto = PassThroughRemuxer.prototype;\n    _proto.destroy = function destroy() {};\n    _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {\n      this.lastEndTime = null;\n      var initPTS = this.initPTS;\n      if (initPTS && defaultInitPTS) {\n        if (initPTS.baseTime === defaultInitPTS.baseTime && initPTS.timescale === defaultInitPTS.timescale) {\n          return;\n        }\n      }\n      this.initPTS = defaultInitPTS;\n    };\n    _proto.resetNextTimestamp = function resetNextTimestamp() {\n      this.isVideoContiguous = false;\n      this.lastEndTime = null;\n    };\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n      this.audioCodec = audioCodec;\n      this.videoCodec = videoCodec;\n      this.generateInitSegment(initSegment, decryptdata);\n      this.emitInitSegment = true;\n    };\n    _proto.generateInitSegment = function generateInitSegment(initSegment, decryptdata) {\n      var audioCodec = this.audioCodec,\n        videoCodec = this.videoCodec;\n      if (!(initSegment != null && initSegment.byteLength)) {\n        this.initTracks = undefined;\n        this.initData = undefined;\n        return;\n      }\n      var _this$initData = this.initData = parseInitSegment(initSegment),\n        audio = _this$initData.audio,\n        video = _this$initData.video;\n      if (decryptdata) {\n        patchEncyptionData(initSegment, decryptdata);\n      } else {\n        var eitherTrack = audio || video;\n        if (eitherTrack != null && eitherTrack.encrypted) {\n          this.warn(\"Init segment with encrypted track with has no key (\\\"\" + eitherTrack.codec + \"\\\")!\");\n        }\n      }\n\n      // Get codec from initSegment\n      if (audio) {\n        audioCodec = getParsedTrackCodec(audio, ElementaryStreamTypes.AUDIO, this);\n      }\n      if (video) {\n        videoCodec = getParsedTrackCodec(video, ElementaryStreamTypes.VIDEO, this);\n      }\n      var tracks = {};\n      if (audio && video) {\n        tracks.audiovideo = {\n          container: 'video/mp4',\n          codec: audioCodec + ',' + videoCodec,\n          supplemental: video.supplemental,\n          encrypted: video.encrypted,\n          initSegment: initSegment,\n          id: 'main'\n        };\n      } else if (audio) {\n        tracks.audio = {\n          container: 'audio/mp4',\n          codec: audioCodec,\n          encrypted: audio.encrypted,\n          initSegment: initSegment,\n          id: 'audio'\n        };\n      } else if (video) {\n        tracks.video = {\n          container: 'video/mp4',\n          codec: videoCodec,\n          supplemental: video.supplemental,\n          encrypted: video.encrypted,\n          initSegment: initSegment,\n          id: 'main'\n        };\n      } else {\n        this.warn('initSegment does not contain moov or trak boxes.');\n      }\n      this.initTracks = tracks;\n    };\n    _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n      var _initData, _initData2;\n      var initPTS = this.initPTS,\n        lastEndTime = this.lastEndTime;\n      var result = {\n        audio: undefined,\n        video: undefined,\n        text: textTrack,\n        id3: id3Track,\n        initSegment: undefined\n      };\n\n      // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n      // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n      // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n      if (!isFiniteNumber(lastEndTime)) {\n        lastEndTime = this.lastEndTime = timeOffset || 0;\n      }\n\n      // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n      // audio or video (or both); adding it to video was an arbitrary choice.\n      var data = videoTrack.samples;\n      if (!data.length) {\n        return result;\n      }\n      var initSegment = {\n        initPTS: undefined,\n        timescale: undefined,\n        trackId: undefined\n      };\n      var initData = this.initData;\n      if (!((_initData = initData) != null && _initData.length)) {\n        this.generateInitSegment(data);\n        initData = this.initData;\n      }\n      if (!((_initData2 = initData) != null && _initData2.length)) {\n        // We can't remux if the initSegment could not be generated\n        this.warn('Failed to generate initSegment.');\n        return result;\n      }\n      if (this.emitInitSegment) {\n        initSegment.tracks = this.initTracks;\n        this.emitInitSegment = false;\n      }\n      var trackSampleData = getSampleData(data, initData, this);\n      var audioSampleTimestamps = initData.audio ? trackSampleData[initData.audio.id] : null;\n      var videoSampleTimestamps = initData.video ? trackSampleData[initData.video.id] : null;\n      var videoStartTime = toStartEndOrDefault(videoSampleTimestamps, Infinity);\n      var audioStartTime = toStartEndOrDefault(audioSampleTimestamps, Infinity);\n      var videoEndTime = toStartEndOrDefault(videoSampleTimestamps, 0, true);\n      var audioEndTime = toStartEndOrDefault(audioSampleTimestamps, 0, true);\n      var decodeTime = timeOffset;\n      var duration = 0;\n      var syncOnAudio = audioSampleTimestamps && (!videoSampleTimestamps || !initPTS && audioStartTime < videoStartTime || initPTS && initPTS.trackId === initData.audio.id);\n      var baseOffsetSamples = syncOnAudio ? audioSampleTimestamps : videoSampleTimestamps;\n      if (baseOffsetSamples) {\n        var timescale = baseOffsetSamples.timescale;\n        var baseTime = baseOffsetSamples.start - timeOffset * timescale;\n        var trackId = syncOnAudio ? initData.audio.id : initData.video.id;\n        decodeTime = baseOffsetSamples.start / timescale;\n        duration = syncOnAudio ? audioEndTime - audioStartTime : videoEndTime - videoStartTime;\n        if ((accurateTimeOffset || !initPTS) && (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || timescale !== initPTS.timescale)) {\n          if (initPTS) {\n            this.warn(\"Timestamps at playlist time: \" + (accurateTimeOffset ? '' : '~') + timeOffset + \" \" + baseTime / timescale + \" != initPTS: \" + initPTS.baseTime / initPTS.timescale + \" (\" + initPTS.baseTime + \"/\" + initPTS.timescale + \") trackId: \" + initPTS.trackId);\n          }\n          this.log(\"Found initPTS at playlist time: \" + timeOffset + \" offset: \" + (decodeTime - timeOffset) + \" (\" + baseTime + \"/\" + timescale + \") trackId: \" + trackId);\n          initPTS = null;\n          initSegment.initPTS = baseTime;\n          initSegment.timescale = timescale;\n          initSegment.trackId = trackId;\n        }\n      } else {\n        this.warn(\"No audio or video samples found for initPTS at playlist time: \" + timeOffset);\n      }\n      if (!initPTS) {\n        if (!initSegment.timescale || initSegment.trackId === undefined || initSegment.initPTS === undefined) {\n          this.warn('Could not set initPTS');\n          initSegment.initPTS = decodeTime;\n          initSegment.timescale = 1;\n          initSegment.trackId = -1;\n        }\n        this.initPTS = initPTS = {\n          baseTime: initSegment.initPTS,\n          timescale: initSegment.timescale,\n          trackId: initSegment.trackId\n        };\n      } else {\n        initSegment.initPTS = initPTS.baseTime;\n        initSegment.timescale = initPTS.timescale;\n        initSegment.trackId = initPTS.trackId;\n      }\n      var startTime = decodeTime - initPTS.baseTime / initPTS.timescale;\n      var endTime = startTime + duration;\n      if (duration > 0) {\n        this.lastEndTime = endTime;\n      } else {\n        this.warn('Duration parsed from mp4 should be greater than zero');\n        this.resetNextTimestamp();\n      }\n      var hasAudio = !!initData.audio;\n      var hasVideo = !!initData.video;\n      var type = '';\n      if (hasAudio) {\n        type += 'audio';\n      }\n      if (hasVideo) {\n        type += 'video';\n      }\n      var encrypted = (initData.audio ? initData.audio.encrypted : false) || (initData.video ? initData.video.encrypted : false);\n      var track = {\n        data1: data,\n        startPTS: startTime,\n        startDTS: startTime,\n        endPTS: endTime,\n        endDTS: endTime,\n        type: type,\n        hasAudio: hasAudio,\n        hasVideo: hasVideo,\n        nb: 1,\n        dropped: 0,\n        encrypted: encrypted\n      };\n      result.audio = hasAudio && !hasVideo ? track : undefined;\n      result.video = hasVideo ? track : undefined;\n      var videoSampleCount = videoSampleTimestamps == null ? void 0 : videoSampleTimestamps.sampleCount;\n      if (videoSampleCount) {\n        var firstKeyFrame = videoSampleTimestamps.keyFrameIndex;\n        var independent = firstKeyFrame !== -1;\n        track.nb = videoSampleCount;\n        track.dropped = firstKeyFrame === 0 || this.isVideoContiguous ? 0 : independent ? firstKeyFrame : videoSampleCount;\n        track.independent = independent;\n        track.firstKeyFrame = firstKeyFrame;\n        if (independent && videoSampleTimestamps.keyFrameStart) {\n          track.firstKeyFramePTS = (videoSampleTimestamps.keyFrameStart - initPTS.baseTime) / initPTS.timescale;\n        }\n        if (!this.isVideoContiguous) {\n          result.independent = independent;\n        }\n        this.isVideoContiguous || (this.isVideoContiguous = independent);\n        if (track.dropped) {\n          this.warn(\"fmp4 does not start with IDR: firstIDR \" + firstKeyFrame + \"/\" + videoSampleCount + \" dropped: \" + track.dropped + \" start: \" + (track.firstKeyFramePTS || 'NA'));\n        }\n      }\n      result.initSegment = initSegment;\n      result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n      if (textTrack.samples.length) {\n        result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n      }\n      return result;\n    };\n    return PassThroughRemuxer;\n  }(Logger);\n  function toStartEndOrDefault(trackTimes, defaultValue, end) {\n    if (end === void 0) {\n      end = false;\n    }\n    return (trackTimes == null ? void 0 : trackTimes.start) !== undefined ? (trackTimes.start + (end ? trackTimes.duration : 0)) / trackTimes.timescale : defaultValue;\n  }\n  function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n    if (initPTS === null) {\n      return true;\n    }\n    // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n    var minDuration = Math.max(duration, 1);\n    var startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n    return Math.abs(startTime - timeOffset) > minDuration;\n  }\n  function getParsedTrackCodec(track, type, logger) {\n    var parsedCodec = track.codec;\n    if (parsedCodec && parsedCodec.length > 4) {\n      return parsedCodec;\n    }\n    if (type === ElementaryStreamTypes.AUDIO) {\n      if (parsedCodec === 'ec-3' || parsedCodec === 'ac-3' || parsedCodec === 'alac') {\n        return parsedCodec;\n      }\n      if (parsedCodec === 'fLaC' || parsedCodec === 'Opus') {\n        // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\n        var preferManagedMediaSource = false;\n        return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\n      }\n      logger.warn(\"Unhandled audio codec \\\"\" + parsedCodec + \"\\\" in mp4 MAP\");\n      return parsedCodec || 'mp4a';\n    }\n    // Provide defaults based on codec type\n    // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n    logger.warn(\"Unhandled video codec \\\"\" + parsedCodec + \"\\\" in mp4 MAP\");\n    return parsedCodec || 'avc1';\n  }\n\n  var now;\n  // performance.now() not available on WebWorker, at least on Safari Desktop\n  try {\n    now = self.performance.now.bind(self.performance);\n  } catch (err) {\n    now = Date.now;\n  }\n  var muxConfig = [{\n    demux: MP4Demuxer,\n    remux: PassThroughRemuxer\n  }, {\n    demux: TSDemuxer,\n    remux: MP4Remuxer\n  }, {\n    demux: AACDemuxer,\n    remux: MP4Remuxer\n  }, {\n    demux: MP3Demuxer,\n    remux: MP4Remuxer\n  }];\n  {\n    muxConfig.splice(2, 0, {\n      demux: AC3Demuxer,\n      remux: MP4Remuxer\n    });\n  }\n  var Transmuxer = /*#__PURE__*/function () {\n    function Transmuxer(observer, typeSupported, config, vendor, id, logger) {\n      this.asyncResult = false;\n      this.logger = void 0;\n      this.observer = void 0;\n      this.typeSupported = void 0;\n      this.config = void 0;\n      this.id = void 0;\n      this.demuxer = void 0;\n      this.remuxer = void 0;\n      this.decrypter = void 0;\n      this.probe = void 0;\n      this.decryptionPromise = null;\n      this.transmuxConfig = void 0;\n      this.currentTransmuxState = void 0;\n      this.observer = observer;\n      this.typeSupported = typeSupported;\n      this.config = config;\n      this.id = id;\n      this.logger = logger;\n    }\n    var _proto = Transmuxer.prototype;\n    _proto.configure = function configure(transmuxConfig) {\n      this.transmuxConfig = transmuxConfig;\n      if (this.decrypter) {\n        this.decrypter.reset();\n      }\n    };\n    _proto.push = function push(data, decryptdata, chunkMeta, state) {\n      var _this = this;\n      var stats = chunkMeta.transmuxing;\n      stats.executeStart = now();\n      var uintData = new Uint8Array(data);\n      var currentTransmuxState = this.currentTransmuxState,\n        transmuxConfig = this.transmuxConfig;\n      if (state) {\n        this.currentTransmuxState = state;\n      }\n      var _ref = state || currentTransmuxState,\n        contiguous = _ref.contiguous,\n        discontinuity = _ref.discontinuity,\n        trackSwitch = _ref.trackSwitch,\n        accurateTimeOffset = _ref.accurateTimeOffset,\n        timeOffset = _ref.timeOffset,\n        initSegmentChange = _ref.initSegmentChange;\n      var audioCodec = transmuxConfig.audioCodec,\n        videoCodec = transmuxConfig.videoCodec,\n        defaultInitPts = transmuxConfig.defaultInitPts,\n        duration = transmuxConfig.duration,\n        initSegmentData = transmuxConfig.initSegmentData;\n      var keyData = getEncryptionType(uintData, decryptdata);\n      if (keyData && isFullSegmentEncryption(keyData.method)) {\n        var decrypter = this.getDecrypter();\n        var aesMode = getAesModeFromFullSegmentMethod(keyData.method);\n\n        // Software decryption is synchronous; webCrypto is not\n        if (decrypter.isSync()) {\n          // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n          // data is handled in the flush() call\n          var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode);\n          // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n          var loadingParts = chunkMeta.part > -1;\n          if (loadingParts) {\n            var _data = decrypter.flush();\n            decryptedData = _data ? _data.buffer : _data;\n          }\n          if (!decryptedData) {\n            stats.executeEnd = now();\n            return emptyResult(chunkMeta);\n          }\n          uintData = new Uint8Array(decryptedData);\n        } else {\n          this.asyncResult = true;\n          this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer, aesMode).then(function (decryptedData) {\n            // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n            // the decrypted data has been transmuxed\n            var result = _this.push(decryptedData, null, chunkMeta);\n            _this.decryptionPromise = null;\n            return result;\n          });\n          return this.decryptionPromise;\n        }\n      }\n      var resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n      if (resetMuxers) {\n        var error = this.configureTransmuxer(uintData);\n        if (error) {\n          this.logger.warn(\"[transmuxer] \" + error.message);\n          this.observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: false,\n            error: error,\n            reason: error.message\n          });\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n      }\n      if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n        this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n      }\n      if (discontinuity || initSegmentChange || resetMuxers) {\n        this.resetInitialTimestamp(defaultInitPts);\n      }\n      if (!contiguous) {\n        this.resetContiguity();\n      }\n      var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n      this.asyncResult = isPromise(result);\n      var currentState = this.currentTransmuxState;\n      currentState.contiguous = true;\n      currentState.discontinuity = false;\n      currentState.trackSwitch = false;\n      stats.executeEnd = now();\n      return result;\n    }\n\n    // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n    ;\n    _proto.flush = function flush(chunkMeta) {\n      var _this2 = this;\n      var stats = chunkMeta.transmuxing;\n      stats.executeStart = now();\n      var decrypter = this.decrypter,\n        currentTransmuxState = this.currentTransmuxState,\n        decryptionPromise = this.decryptionPromise;\n      if (decryptionPromise) {\n        this.asyncResult = true;\n        // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n        // only flushing is required for async decryption\n        return decryptionPromise.then(function () {\n          return _this2.flush(chunkMeta);\n        });\n      }\n      var transmuxResults = [];\n      var timeOffset = currentTransmuxState.timeOffset;\n      if (decrypter) {\n        // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n        // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n        // or for progressive downloads with small segments)\n        var decryptedData = decrypter.flush();\n        if (decryptedData) {\n          // Push always returns a TransmuxerResult if decryptdata is null\n          transmuxResults.push(this.push(decryptedData.buffer, null, chunkMeta));\n        }\n      }\n      var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n      if (!demuxer || !remuxer) {\n        // If probing failed, then Hls.js has been given content its not able to handle\n        stats.executeEnd = now();\n        var emptyResults = [emptyResult(chunkMeta)];\n        if (this.asyncResult) {\n          return Promise.resolve(emptyResults);\n        }\n        return emptyResults;\n      }\n      var demuxResultOrPromise = demuxer.flush(timeOffset);\n      if (isPromise(demuxResultOrPromise)) {\n        this.asyncResult = true;\n        // Decrypt final SAMPLE-AES samples\n        return demuxResultOrPromise.then(function (demuxResult) {\n          _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);\n          return transmuxResults;\n        });\n      }\n      this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n      if (this.asyncResult) {\n        return Promise.resolve(transmuxResults);\n      }\n      return transmuxResults;\n    };\n    _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {\n      var audioTrack = demuxResult.audioTrack,\n        videoTrack = demuxResult.videoTrack,\n        id3Track = demuxResult.id3Track,\n        textTrack = demuxResult.textTrack;\n      var _this$currentTransmux = this.currentTransmuxState,\n        accurateTimeOffset = _this$currentTransmux.accurateTimeOffset,\n        timeOffset = _this$currentTransmux.timeOffset;\n      this.logger.log(\"[transmuxer.ts]: Flushed \" + this.id + \" sn: \" + chunkMeta.sn + (chunkMeta.part > -1 ? ' part: ' + chunkMeta.part : '') + \" of \" + (this.id === PlaylistLevelType.MAIN ? 'level' : 'track') + \" \" + chunkMeta.level);\n      var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n      transmuxResults.push({\n        remuxResult: remuxResult,\n        chunkMeta: chunkMeta\n      });\n      chunkMeta.transmuxing.executeEnd = now();\n    };\n    _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {\n      var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n      if (!demuxer || !remuxer) {\n        return;\n      }\n      demuxer.resetTimeStamp(defaultInitPts);\n      remuxer.resetTimeStamp(defaultInitPts);\n    };\n    _proto.resetContiguity = function resetContiguity() {\n      var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n      if (!demuxer || !remuxer) {\n        return;\n      }\n      demuxer.resetContiguity();\n      remuxer.resetNextTimestamp();\n    };\n    _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n      var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n      if (!demuxer || !remuxer) {\n        return;\n      }\n      demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n      remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n    };\n    _proto.destroy = function destroy() {\n      if (this.demuxer) {\n        this.demuxer.destroy();\n        this.demuxer = undefined;\n      }\n      if (this.remuxer) {\n        this.remuxer.destroy();\n        this.remuxer = undefined;\n      }\n    };\n    _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n      var result;\n      if (keyData && keyData.method === 'SAMPLE-AES') {\n        result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n      } else {\n        result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n      }\n      return result;\n    };\n    _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n      var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive),\n        audioTrack = _demux.audioTrack,\n        videoTrack = _demux.videoTrack,\n        id3Track = _demux.id3Track,\n        textTrack = _demux.textTrack;\n      var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n      return {\n        remuxResult: remuxResult,\n        chunkMeta: chunkMeta\n      };\n    };\n    _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n      var _this3 = this;\n      return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function (demuxResult) {\n        var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);\n        return {\n          remuxResult: remuxResult,\n          chunkMeta: chunkMeta\n        };\n      });\n    };\n    _proto.configureTransmuxer = function configureTransmuxer(data) {\n      var config = this.config,\n        observer = this.observer,\n        typeSupported = this.typeSupported;\n      // probe for content type\n      var mux;\n      for (var i = 0, len = muxConfig.length; i < len; i++) {\n        var _muxConfig$i$demux;\n        if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data, this.logger)) {\n          mux = muxConfig[i];\n          break;\n        }\n      }\n      if (!mux) {\n        return new Error('Failed to find demuxer by probing fragment data');\n      }\n      // so let's check that current remuxer and demuxer are still valid\n      var demuxer = this.demuxer;\n      var remuxer = this.remuxer;\n      var Remuxer = mux.remux;\n      var Demuxer = mux.demux;\n      if (!remuxer || !(remuxer instanceof Remuxer)) {\n        this.remuxer = new Remuxer(observer, config, typeSupported, this.logger);\n      }\n      if (!demuxer || !(demuxer instanceof Demuxer)) {\n        this.demuxer = new Demuxer(observer, config, typeSupported, this.logger);\n        this.probe = Demuxer.probe;\n      }\n    };\n    _proto.needsProbing = function needsProbing(discontinuity, trackSwitch) {\n      // in case of continuity change, or track switch\n      // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n      return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n    };\n    _proto.getDecrypter = function getDecrypter() {\n      var decrypter = this.decrypter;\n      if (!decrypter) {\n        decrypter = this.decrypter = new Decrypter(this.config);\n      }\n      return decrypter;\n    };\n    return Transmuxer;\n  }();\n  function getEncryptionType(data, decryptData) {\n    var encryptionType = null;\n    if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {\n      encryptionType = decryptData;\n    }\n    return encryptionType;\n  }\n  var emptyResult = function emptyResult(chunkMeta) {\n    return {\n      remuxResult: {},\n      chunkMeta: chunkMeta\n    };\n  };\n  function isPromise(p) {\n    return 'then' in p && p.then instanceof Function;\n  }\n  var TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initSegmentData = void 0;\n    this.duration = void 0;\n    this.defaultInitPts = void 0;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  };\n  var TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n    this.discontinuity = void 0;\n    this.contiguous = void 0;\n    this.accurateTimeOffset = void 0;\n    this.trackSwitch = void 0;\n    this.timeOffset = void 0;\n    this.initSegmentChange = void 0;\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  };\n\n  var transmuxers = [];\n  if (typeof __IN_WORKER__ !== 'undefined' && __IN_WORKER__) {\n    startWorker();\n  }\n  function startWorker() {\n    self.addEventListener('message', function (ev) {\n      var data = ev.data;\n      var instanceNo = data.instanceNo;\n      if (instanceNo === undefined) {\n        return;\n      }\n      var transmuxer = transmuxers[instanceNo];\n      if (data.cmd === 'reset') {\n        delete transmuxers[data.resetNo];\n        if (transmuxer) {\n          transmuxer.destroy();\n        }\n        data.cmd = 'init';\n      }\n      if (data.cmd === 'init') {\n        var config = JSON.parse(data.config);\n        var observer = new EventEmitter();\n        observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n        observer.on(Events.ERROR, forwardMessage);\n        var logger = enableLogs(config.debug, data.id);\n        forwardWorkerLogs(logger, instanceNo);\n        transmuxers[instanceNo] = new Transmuxer(observer, data.typeSupported, config, '', data.id, logger);\n        forwardMessage('init', null, instanceNo);\n        return;\n      }\n      if (!transmuxer) {\n        return;\n      }\n      switch (data.cmd) {\n        case 'configure':\n          {\n            transmuxer.configure(data.config);\n            break;\n          }\n        case 'demux':\n          {\n            var transmuxResult = transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);\n            if (isPromise(transmuxResult)) {\n              transmuxResult.then(function (data) {\n                emitTransmuxComplete(self, data, instanceNo);\n              }).catch(function (error) {\n                forwardMessage(Events.ERROR, {\n                  instanceNo: instanceNo,\n                  type: ErrorTypes.MEDIA_ERROR,\n                  details: ErrorDetails.FRAG_PARSING_ERROR,\n                  chunkMeta: data.chunkMeta,\n                  fatal: false,\n                  error: error,\n                  err: error,\n                  reason: \"transmuxer-worker push error\"\n                }, instanceNo);\n              });\n            } else {\n              emitTransmuxComplete(self, transmuxResult, instanceNo);\n            }\n            break;\n          }\n        case 'flush':\n          {\n            var chunkMeta = data.chunkMeta;\n            var _transmuxResult = transmuxer.flush(chunkMeta);\n            if (isPromise(_transmuxResult)) {\n              _transmuxResult.then(function (results) {\n                handleFlushResult(self, results, chunkMeta, instanceNo);\n              }).catch(function (error) {\n                forwardMessage(Events.ERROR, {\n                  type: ErrorTypes.MEDIA_ERROR,\n                  details: ErrorDetails.FRAG_PARSING_ERROR,\n                  chunkMeta: data.chunkMeta,\n                  fatal: false,\n                  error: error,\n                  err: error,\n                  reason: \"transmuxer-worker flush error\"\n                }, instanceNo);\n              });\n            } else {\n              handleFlushResult(self, _transmuxResult, chunkMeta, instanceNo);\n            }\n            break;\n          }\n      }\n    });\n  }\n  function emitTransmuxComplete(self, transmuxResult, instanceNo) {\n    if (isEmptyResult(transmuxResult.remuxResult)) {\n      return false;\n    }\n    var transferable = [];\n    var _transmuxResult$remux = transmuxResult.remuxResult,\n      audio = _transmuxResult$remux.audio,\n      video = _transmuxResult$remux.video;\n    if (audio) {\n      addToTransferable(transferable, audio);\n    }\n    if (video) {\n      addToTransferable(transferable, video);\n    }\n    self.postMessage({\n      event: 'transmuxComplete',\n      data: transmuxResult,\n      instanceNo: instanceNo\n    }, transferable);\n    return true;\n  }\n\n  // Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\n  // in order to minimize message passing overhead\n  function addToTransferable(transferable, track) {\n    if (track.data1) {\n      transferable.push(track.data1.buffer);\n    }\n    if (track.data2) {\n      transferable.push(track.data2.buffer);\n    }\n  }\n  function handleFlushResult(self, results, chunkMeta, instanceNo) {\n    var parsed = results.reduce(function (parsed, result) {\n      return emitTransmuxComplete(self, result, instanceNo) || parsed;\n    }, false);\n    if (!parsed) {\n      // Emit at least one \"transmuxComplete\" message even if media is not found to update stream-controller state to PARSING\n      self.postMessage({\n        event: 'transmuxComplete',\n        data: results[0],\n        instanceNo: instanceNo\n      });\n    }\n    self.postMessage({\n      event: 'flush',\n      data: chunkMeta,\n      instanceNo: instanceNo\n    });\n  }\n  function forwardMessage(event, data, instanceNo) {\n    self.postMessage({\n      event: event,\n      data: data,\n      instanceNo: instanceNo\n    });\n  }\n  function forwardWorkerLogs(logger, instanceNo) {\n    var _loop = function _loop(logFn) {\n      logger[logFn] = function () {\n        var message = Array.prototype.join.call(arguments, ' ');\n        forwardMessage('workerLog', {\n          logType: logFn,\n          message: message\n        }, instanceNo);\n      };\n    };\n    for (var logFn in logger) {\n      _loop(logFn);\n    }\n  }\n  function isEmptyResult(remuxResult) {\n    return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;\n  }\n\n  var version = \"1.6.15\";\n\n  // ensure the worker ends up in the bundle\n  // If the worker should not be included this gets aliased to empty.js\n  var workerStore = {};\n  function hasUMDWorker() {\n    return typeof __HLS_WORKER_BUNDLE__ === 'function';\n  }\n  function injectWorker() {\n    var workerContext = workerStore[version];\n    if (workerContext) {\n      workerContext.clientCount++;\n      return workerContext;\n    }\n    var blob = new self.Blob([\"var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(\" + __HLS_WORKER_BUNDLE__.toString() + \")(true);\"], {\n      type: 'text/javascript'\n    });\n    var objectURL = self.URL.createObjectURL(blob);\n    var worker = new self.Worker(objectURL);\n    var result = {\n      worker: worker,\n      objectURL: objectURL,\n      clientCount: 1\n    };\n    workerStore[version] = result;\n    return result;\n  }\n  function loadWorker(path) {\n    var workerContext = workerStore[path];\n    if (workerContext) {\n      workerContext.clientCount++;\n      return workerContext;\n    }\n    var scriptURL = new self.URL(path, self.location.href).href;\n    var worker = new self.Worker(scriptURL);\n    var result = {\n      worker: worker,\n      scriptURL: scriptURL,\n      clientCount: 1\n    };\n    workerStore[path] = result;\n    return result;\n  }\n  function removeWorkerFromStore(path) {\n    var workerContext = workerStore[path || version];\n    if (workerContext) {\n      var clientCount = workerContext.clientCount--;\n      if (clientCount === 1) {\n        var worker = workerContext.worker,\n          objectURL = workerContext.objectURL;\n        delete workerStore[path || version];\n        if (objectURL) {\n          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n          self.URL.revokeObjectURL(objectURL);\n        }\n        worker.terminate();\n      }\n    }\n  }\n\n  var transmuxerInstanceCount = 0;\n  var TransmuxerInterface = /*#__PURE__*/function () {\n    function TransmuxerInterface(_hls, id, onTransmuxComplete, onFlush) {\n      var _this = this;\n      this.error = null;\n      this.hls = void 0;\n      this.id = void 0;\n      this.instanceNo = transmuxerInstanceCount++;\n      this.observer = void 0;\n      this.frag = null;\n      this.part = null;\n      this.useWorker = void 0;\n      this.workerContext = null;\n      this.transmuxer = null;\n      this.onTransmuxComplete = void 0;\n      this.onFlush = void 0;\n      this.onWorkerMessage = function (event) {\n        var data = event.data;\n        var hls = _this.hls;\n        if (!hls || !(data != null && data.event) || data.instanceNo !== _this.instanceNo) {\n          return;\n        }\n        switch (data.event) {\n          case 'init':\n            {\n              var _this$workerContext;\n              var objectURL = (_this$workerContext = _this.workerContext) == null ? void 0 : _this$workerContext.objectURL;\n              if (objectURL) {\n                // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n                self.URL.revokeObjectURL(objectURL);\n              }\n              break;\n            }\n          case 'transmuxComplete':\n            {\n              _this.handleTransmuxComplete(data.data);\n              break;\n            }\n          case 'flush':\n            {\n              _this.onFlush(data.data);\n              break;\n            }\n\n          // pass logs from the worker thread to the main logger\n          case 'workerLog':\n            {\n              if (hls.logger[data.data.logType]) {\n                hls.logger[data.data.logType](data.data.message);\n              }\n              break;\n            }\n          default:\n            {\n              data.data = data.data || {};\n              data.data.frag = _this.frag;\n              data.data.part = _this.part;\n              data.data.id = _this.id;\n              hls.trigger(data.event, data.data);\n              break;\n            }\n        }\n      };\n      this.onWorkerError = function (event) {\n        if (!_this.hls) {\n          return;\n        }\n        var error = new Error(event.message + \"  (\" + event.filename + \":\" + event.lineno + \")\");\n        _this.hls.config.enableWorker = false;\n        _this.hls.logger.warn(\"Error in \\\"\" + _this.id + \"\\\" Web Worker, fallback to inline\");\n        _this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERNAL_EXCEPTION,\n          fatal: false,\n          event: 'demuxerWorker',\n          error: error\n        });\n      };\n      var config = _hls.config;\n      this.hls = _hls;\n      this.id = id;\n      this.useWorker = !!config.enableWorker;\n      this.onTransmuxComplete = onTransmuxComplete;\n      this.onFlush = onFlush;\n      var forwardMessage = function forwardMessage(ev, data) {\n        data = data || {};\n        data.frag = _this.frag || undefined;\n        if (ev === Events.ERROR) {\n          data = data;\n          data.parent = _this.id;\n          data.part = _this.part;\n          _this.error = data.error;\n        }\n        _this.hls.trigger(ev, data);\n      };\n\n      // forward events to main thread\n      this.observer = new EventEmitter();\n      this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n      this.observer.on(Events.ERROR, forwardMessage);\n      var m2tsTypeSupported = getM2TSSupportedAudioTypes(config.preferManagedMediaSource);\n      if (this.useWorker && typeof Worker !== 'undefined') {\n        var logger = this.hls.logger;\n        var canCreateWorker = config.workerPath || hasUMDWorker();\n        if (canCreateWorker) {\n          try {\n            if (config.workerPath) {\n              logger.log(\"loading Web Worker \" + config.workerPath + \" for \\\"\" + id + \"\\\"\");\n              this.workerContext = loadWorker(config.workerPath);\n            } else {\n              logger.log(\"injecting Web Worker for \\\"\" + id + \"\\\"\");\n              this.workerContext = injectWorker();\n            }\n            var worker = this.workerContext.worker;\n            worker.addEventListener('message', this.onWorkerMessage);\n            worker.addEventListener('error', this.onWorkerError);\n            worker.postMessage({\n              instanceNo: this.instanceNo,\n              cmd: 'init',\n              typeSupported: m2tsTypeSupported,\n              id: id,\n              config: stringify(config)\n            });\n          } catch (err) {\n            logger.warn(\"Error setting up \\\"\" + id + \"\\\" Web Worker, fallback to inline\", err);\n            this.terminateWorker();\n            this.error = null;\n            this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id, _hls.logger);\n          }\n          return;\n        }\n      }\n      this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id, _hls.logger);\n    }\n    var _proto = TransmuxerInterface.prototype;\n    _proto.reset = function reset() {\n      this.frag = null;\n      this.part = null;\n      if (this.workerContext) {\n        var instanceNo = this.instanceNo;\n        this.instanceNo = transmuxerInstanceCount++;\n        var config = this.hls.config;\n        var m2tsTypeSupported = getM2TSSupportedAudioTypes(config.preferManagedMediaSource);\n        this.workerContext.worker.postMessage({\n          instanceNo: this.instanceNo,\n          cmd: 'reset',\n          resetNo: instanceNo,\n          typeSupported: m2tsTypeSupported,\n          id: this.id,\n          config: stringify(config)\n        });\n      }\n    };\n    _proto.terminateWorker = function terminateWorker() {\n      if (this.workerContext) {\n        var worker = this.workerContext.worker;\n        this.workerContext = null;\n        worker.removeEventListener('message', this.onWorkerMessage);\n        worker.removeEventListener('error', this.onWorkerError);\n        removeWorkerFromStore(this.hls.config.workerPath);\n      }\n    };\n    _proto.destroy = function destroy() {\n      if (this.workerContext) {\n        this.terminateWorker();\n        // @ts-ignore\n        this.onWorkerMessage = this.onWorkerError = null;\n      } else {\n        var transmuxer = this.transmuxer;\n        if (transmuxer) {\n          transmuxer.destroy();\n          this.transmuxer = null;\n        }\n      }\n      var observer = this.observer;\n      if (observer) {\n        observer.removeAllListeners();\n      }\n      this.frag = null;\n      this.part = null;\n      // @ts-ignore\n      this.observer = null;\n      // @ts-ignore\n      this.hls = null;\n    };\n    _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n      var _frag$initSegment,\n        _lastFrag$initSegment,\n        _this2 = this;\n      chunkMeta.transmuxing.start = self.performance.now();\n      var instanceNo = this.instanceNo,\n        transmuxer = this.transmuxer;\n      var timeOffset = part ? part.start : frag.start;\n      // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n      var decryptdata = frag.decryptdata;\n      var lastFrag = this.frag;\n      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n      var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n      var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n      var partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n      var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n      var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n      var now = self.performance.now();\n      if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n        frag.stats.parsing.start = now;\n      }\n      if (part && (partDiff || !contiguous)) {\n        part.stats.parsing.start = now;\n      }\n      var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n      var state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n      if (!contiguous || discontinuity || initSegmentChange) {\n        this.hls.logger.log(\"[transmuxer-interface]: Starting new transmux session for \" + frag.type + \" sn: \" + chunkMeta.sn + (chunkMeta.part > -1 ? ' part: ' + chunkMeta.part : '') + \" \" + (this.id === PlaylistLevelType.MAIN ? 'level' : 'track') + \": \" + chunkMeta.level + \" id: \" + chunkMeta.id + \"\\n        discontinuity: \" + discontinuity + \"\\n        trackSwitch: \" + trackSwitch + \"\\n        contiguous: \" + contiguous + \"\\n        accurateTimeOffset: \" + accurateTimeOffset + \"\\n        timeOffset: \" + timeOffset + \"\\n        initSegmentChange: \" + initSegmentChange);\n        var config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n        this.configureTransmuxer(config);\n      }\n      this.frag = frag;\n      this.part = part;\n\n      // Frags with sn of 'initSegment' are not transmuxed\n      if (this.workerContext) {\n        // post fragment payload as transferable objects for ArrayBuffer (no copy)\n        this.workerContext.worker.postMessage({\n          instanceNo: instanceNo,\n          cmd: 'demux',\n          data: data,\n          decryptdata: decryptdata,\n          chunkMeta: chunkMeta,\n          state: state\n        }, data instanceof ArrayBuffer ? [data] : []);\n      } else if (transmuxer) {\n        var transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n        if (isPromise(transmuxResult)) {\n          transmuxResult.then(function (data) {\n            _this2.handleTransmuxComplete(data);\n          }).catch(function (error) {\n            _this2.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n          });\n        } else {\n          this.handleTransmuxComplete(transmuxResult);\n        }\n      }\n    };\n    _proto.flush = function flush(chunkMeta) {\n      var _this3 = this;\n      chunkMeta.transmuxing.start = self.performance.now();\n      var instanceNo = this.instanceNo,\n        transmuxer = this.transmuxer;\n      if (this.workerContext) {\n        this.workerContext.worker.postMessage({\n          instanceNo: instanceNo,\n          cmd: 'flush',\n          chunkMeta: chunkMeta\n        });\n      } else if (transmuxer) {\n        var transmuxResult = transmuxer.flush(chunkMeta);\n        if (isPromise(transmuxResult)) {\n          transmuxResult.then(function (data) {\n            _this3.handleFlushResult(data, chunkMeta);\n          }).catch(function (error) {\n            _this3.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n          });\n        } else {\n          this.handleFlushResult(transmuxResult, chunkMeta);\n        }\n      }\n    };\n    _proto.transmuxerError = function transmuxerError(error, chunkMeta, reason) {\n      if (!this.hls) {\n        return;\n      }\n      this.error = error;\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        chunkMeta: chunkMeta,\n        frag: this.frag || undefined,\n        part: this.part || undefined,\n        fatal: false,\n        error: error,\n        err: error,\n        reason: reason\n      });\n    };\n    _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {\n      var _this4 = this;\n      results.forEach(function (result) {\n        _this4.handleTransmuxComplete(result);\n      });\n      this.onFlush(chunkMeta);\n    };\n    _proto.configureTransmuxer = function configureTransmuxer(config) {\n      var instanceNo = this.instanceNo,\n        transmuxer = this.transmuxer;\n      if (this.workerContext) {\n        this.workerContext.worker.postMessage({\n          instanceNo: instanceNo,\n          cmd: 'configure',\n          config: config\n        });\n      } else if (transmuxer) {\n        transmuxer.configure(config);\n      }\n    };\n    _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {\n      result.chunkMeta.transmuxing.end = self.performance.now();\n      this.onTransmuxComplete(result);\n    };\n    return TransmuxerInterface;\n  }();\n\n  var TICK_INTERVAL$3 = 100; // how often to tick in ms\n  var AudioStreamController = /*#__PURE__*/function (_BaseStreamController) {\n    function AudioStreamController(hls, fragmentTracker, keyLoader) {\n      var _this;\n      _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, 'audio-stream-controller', PlaylistLevelType.AUDIO) || this;\n      _this.mainAnchor = null;\n      _this.mainFragLoading = null;\n      _this.audioOnly = false;\n      _this.bufferedTrack = null;\n      _this.switchingTrack = null;\n      _this.trackId = -1;\n      _this.waitingData = null;\n      _this.mainDetails = null;\n      _this.flushing = false;\n      _this.bufferFlushed = false;\n      _this.cachedTrackLoadedData = null;\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(AudioStreamController, _BaseStreamController);\n    var _proto = AudioStreamController.prototype;\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      this.unregisterListeners();\n      _BaseStreamController.prototype.onHandlerDestroying.call(this);\n      this.resetItem();\n    };\n    _proto.resetItem = function resetItem() {\n      this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      _BaseStreamController.prototype.registerListeners.call(this);\n      var hls = this.hls;\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n      hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n      hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n      hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n      hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      _BaseStreamController.prototype.unregisterListeners.call(this);\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n      hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n      hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n      hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n      hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n\n    // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n    ;\n    _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n      var frag = _ref.frag,\n        id = _ref.id,\n        initPTS = _ref.initPTS,\n        timescale = _ref.timescale,\n        trackId = _ref.trackId;\n      // Always update the new INIT PTS\n      // Can change due level switch\n      if (id === PlaylistLevelType.MAIN) {\n        var cc = frag.cc;\n        var inFlightFrag = this.fragCurrent;\n        this.initPTS[cc] = {\n          baseTime: initPTS,\n          timescale: timescale,\n          trackId: trackId\n        };\n        this.log(\"InitPTS for cc: \" + cc + \" found from main: \" + initPTS / timescale + \" (\" + initPTS + \"/\" + timescale + \") trackId: \" + trackId);\n        this.mainAnchor = frag;\n        // If we are waiting, tick immediately to unblock audio fragment transmuxing\n        if (this.state === State.WAITING_INIT_PTS) {\n          var waitingData = this.waitingData;\n          if (!waitingData && !this.loadingParts || waitingData && waitingData.frag.cc !== cc) {\n            this.syncWithAnchor(frag, waitingData == null ? void 0 : waitingData.frag);\n          }\n        } else if (!this.hls.hasEnoughToStart && inFlightFrag && inFlightFrag.cc !== cc) {\n          inFlightFrag.abortRequests();\n          this.syncWithAnchor(frag, inFlightFrag);\n        } else if (this.state === State.IDLE) {\n          this.tick();\n        }\n      }\n    };\n    _proto.getLoadPosition = function getLoadPosition() {\n      if (!this.startFragRequested && this.nextLoadPosition >= 0) {\n        return this.nextLoadPosition;\n      }\n      return _BaseStreamController.prototype.getLoadPosition.call(this);\n    };\n    _proto.syncWithAnchor = function syncWithAnchor(mainAnchor, waitingToAppend) {\n      var _this$mainFragLoading;\n      // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n      var mainFragLoading = ((_this$mainFragLoading = this.mainFragLoading) == null ? void 0 : _this$mainFragLoading.frag) || null;\n      if (waitingToAppend) {\n        if ((mainFragLoading == null ? void 0 : mainFragLoading.cc) === waitingToAppend.cc) {\n          // Wait for loading frag to complete and INIT_PTS_FOUND\n          return;\n        }\n      }\n      var targetDiscontinuity = (mainFragLoading || mainAnchor).cc;\n      var trackDetails = this.getLevelDetails();\n      var pos = this.getLoadPosition();\n      var syncFrag = findNearestWithCC(trackDetails, targetDiscontinuity, pos);\n      // Only stop waiting for audioFrag.cc if an audio segment of the same discontinuity domain (cc) is found\n      if (syncFrag) {\n        this.log(\"Syncing with main frag at \" + syncFrag.start + \" cc \" + syncFrag.cc);\n        this.startFragRequested = false;\n        this.nextLoadPosition = syncFrag.start;\n        this.resetLoadingState();\n        if (this.state === State.IDLE) {\n          this.doTickIdle();\n        }\n      }\n    };\n    _proto.startLoad = function startLoad(startPosition, skipSeekToStartPosition) {\n      if (!this.levels) {\n        this.startPosition = startPosition;\n        this.state = State.STOPPED;\n        return;\n      }\n      var lastCurrentTime = this.lastCurrentTime;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL$3);\n      if (lastCurrentTime > 0 && startPosition === -1) {\n        this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n        startPosition = lastCurrentTime;\n        this.state = State.IDLE;\n      } else {\n        this.state = State.WAITING_TRACK;\n      }\n      this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;\n      this.startPosition = skipSeekToStartPosition ? -1 : startPosition;\n      this.tick();\n    };\n    _proto.doTick = function doTick() {\n      switch (this.state) {\n        case State.IDLE:\n          this.doTickIdle();\n          break;\n        case State.WAITING_TRACK:\n          {\n            var levels = this.levels,\n              trackId = this.trackId;\n            var currenTrack = levels == null ? void 0 : levels[trackId];\n            var details = currenTrack == null ? void 0 : currenTrack.details;\n            if (details && !this.waitForLive(currenTrack)) {\n              if (this.waitForCdnTuneIn(details)) {\n                break;\n              }\n              this.state = State.WAITING_INIT_PTS;\n            }\n            break;\n          }\n        case State.FRAG_LOADING_WAITING_RETRY:\n          {\n            this.checkRetryDate();\n            break;\n          }\n        case State.WAITING_INIT_PTS:\n          {\n            // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n            var waitingData = this.waitingData;\n            if (waitingData) {\n              var frag = waitingData.frag,\n                part = waitingData.part,\n                cache = waitingData.cache,\n                complete = waitingData.complete;\n              var mainAnchor = this.mainAnchor;\n              if (this.initPTS[frag.cc] !== undefined) {\n                this.waitingData = null;\n                this.state = State.FRAG_LOADING;\n                var payload = cache.flush().buffer;\n                var data = {\n                  frag: frag,\n                  part: part,\n                  payload: payload,\n                  networkDetails: null\n                };\n                this._handleFragmentLoadProgress(data);\n                if (complete) {\n                  _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);\n                }\n              } else if (mainAnchor && mainAnchor.cc !== waitingData.frag.cc) {\n                this.syncWithAnchor(mainAnchor, waitingData.frag);\n              }\n            } else {\n              this.state = State.IDLE;\n            }\n          }\n      }\n      this.onTickEnd();\n    };\n    _proto.resetLoadingState = function resetLoadingState() {\n      var waitingData = this.waitingData;\n      if (waitingData) {\n        this.fragmentTracker.removeFragment(waitingData.frag);\n        this.waitingData = null;\n      }\n      _BaseStreamController.prototype.resetLoadingState.call(this);\n    };\n    _proto.onTickEnd = function onTickEnd() {\n      var media = this.media;\n      if (!(media != null && media.readyState)) {\n        // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n        return;\n      }\n      this.lastCurrentTime = media.currentTime;\n    };\n    _proto.doTickIdle = function doTickIdle() {\n      var _this$mainFragLoading2;\n      var hls = this.hls,\n        levels = this.levels,\n        media = this.media,\n        trackId = this.trackId;\n      var config = hls.config;\n\n      // 1. if buffering is suspended\n      // 2. if video not attached AND\n      //    start fragment already requested OR start frag prefetch not enabled\n      // 3. if tracks or track not loaded and selected\n      // then exit loop\n      // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n      if (!this.buffering || !media && !this.primaryPrefetch && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {\n        return;\n      }\n      var levelInfo = levels[trackId];\n      var trackDetails = levelInfo.details;\n      if (!trackDetails || this.waitForLive(levelInfo) || this.waitForCdnTuneIn(trackDetails)) {\n        this.state = State.WAITING_TRACK;\n        this.startFragRequested = false;\n        return;\n      }\n      var bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n      if (this.bufferFlushed && bufferable) {\n        this.bufferFlushed = false;\n        this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);\n      }\n      var bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);\n      if (bufferInfo === null) {\n        return;\n      }\n      if (!this.switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {\n        hls.trigger(Events.BUFFER_EOS, {\n          type: 'audio'\n        });\n        this.state = State.ENDED;\n        return;\n      }\n      var bufferLen = bufferInfo.len;\n      var maxBufLen = hls.maxBufferLength;\n      var fragments = trackDetails.fragments;\n      var start = fragments[0].start;\n      var loadPosition = this.getLoadPosition();\n      var targetBufferTime = this.flushing ? loadPosition : bufferInfo.end;\n      if (this.switchingTrack && media) {\n        var pos = loadPosition;\n        // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n        if (trackDetails.PTSKnown && pos < start) {\n          // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n          if (bufferInfo.end > start || bufferInfo.nextStart) {\n            this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n            media.currentTime = start + 0.05;\n          }\n        }\n      }\n\n      // if buffer length is less than maxBufLen, or near the end, find a fragment to load\n      if (bufferLen >= maxBufLen && !this.switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {\n        return;\n      }\n      var frag = this.getNextFragment(targetBufferTime, trackDetails);\n      // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n      if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n        frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n      }\n      if (!frag) {\n        this.bufferFlushed = true;\n        return;\n      }\n\n      // Request audio segments up to one fragment ahead of main stream-controller\n      var mainFragLoading = ((_this$mainFragLoading2 = this.mainFragLoading) == null ? void 0 : _this$mainFragLoading2.frag) || null;\n      if (!this.audioOnly && this.startFragRequested && mainFragLoading && isMediaFragment(frag) && !frag.endList && (!trackDetails.live || !this.loadingParts && targetBufferTime < this.hls.liveSyncPosition)) {\n        if (this.fragmentTracker.getState(mainFragLoading) === FragmentState.OK) {\n          this.mainFragLoading = mainFragLoading = null;\n        }\n        if (mainFragLoading && isMediaFragment(mainFragLoading)) {\n          if (frag.start > mainFragLoading.end) {\n            // Get buffered frag at target position from tracker (loaded out of sequence)\n            var mainFragAtPos = this.fragmentTracker.getFragAtPos(targetBufferTime, PlaylistLevelType.MAIN);\n            if (mainFragAtPos && mainFragAtPos.end > mainFragLoading.end) {\n              mainFragLoading = mainFragAtPos;\n              this.mainFragLoading = {\n                frag: mainFragAtPos,\n                targetBufferTime: null\n              };\n            }\n          }\n          var atBufferSyncLimit = frag.start > mainFragLoading.end;\n          if (atBufferSyncLimit) {\n            return;\n          }\n        }\n      }\n      this.loadFragment(frag, levelInfo, targetBufferTime);\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      this.bufferFlushed = this.flushing = false;\n      _BaseStreamController.prototype.onMediaDetaching.call(this, event, data);\n    };\n    _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {\n      var audioTracks = _ref2.audioTracks;\n      // Reset tranxmuxer is essential for large context switches (Content Steering)\n      this.resetTransmuxer();\n      this.levels = audioTracks.map(function (mediaPlaylist) {\n        return new Level(mediaPlaylist);\n      });\n    };\n    _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n      // if any URL found on new audio track, it is an alternate audio track\n      var altAudio = !!data.url;\n      this.trackId = data.id;\n      var fragCurrent = this.fragCurrent;\n      if (fragCurrent) {\n        fragCurrent.abortRequests();\n        this.removeUnbufferedFrags(fragCurrent.start);\n      }\n      this.resetLoadingState();\n\n      // should we switch tracks ?\n      if (altAudio) {\n        this.switchingTrack = data;\n        // main audio track are handled by stream-controller, just do something if switching to alt audio track\n        this.flushAudioIfNeeded(data);\n        if (this.state !== State.STOPPED) {\n          // switching to audio track, start timer if not already started\n          this.setInterval(TICK_INTERVAL$3);\n          this.state = State.IDLE;\n          this.tick();\n        }\n      } else {\n        // destroy useless transmuxer when switching audio to main\n        this.resetTransmuxer();\n        this.switchingTrack = null;\n        this.bufferedTrack = data;\n        this.clearInterval();\n      }\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      _BaseStreamController.prototype.onManifestLoading.call(this);\n      this.bufferFlushed = this.flushing = this.audioOnly = false;\n      this.resetItem();\n      this.trackId = -1;\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      this.mainDetails = data.details;\n      var cachedTrackLoadedData = this.cachedTrackLoadedData;\n      if (cachedTrackLoadedData) {\n        this.cachedTrackLoadedData = null;\n        this.onAudioTrackLoaded(Events.AUDIO_TRACK_LOADED, cachedTrackLoadedData);\n      }\n    };\n    _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n      var _trackLevel$details;\n      var levels = this.levels;\n      var newDetails = data.details,\n        trackId = data.id,\n        groupId = data.groupId,\n        track = data.track;\n      if (!levels) {\n        this.warn(\"Audio tracks reset while loading track \" + trackId + \" \\\"\" + track.name + \"\\\" of \\\"\" + groupId + \"\\\"\");\n        return;\n      }\n      var mainDetails = this.mainDetails;\n      if (!mainDetails || newDetails.endCC > mainDetails.endCC || mainDetails.expired) {\n        this.cachedTrackLoadedData = data;\n        if (this.state !== State.STOPPED) {\n          this.state = State.WAITING_TRACK;\n        }\n        return;\n      }\n      this.cachedTrackLoadedData = null;\n      this.log(\"Audio track \" + trackId + \" \\\"\" + track.name + \"\\\" of \\\"\" + groupId + \"\\\" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"]\" + (newDetails.lastPartSn ? \"[part-\" + newDetails.lastPartSn + \"-\" + newDetails.lastPartIndex + \"]\" : '') + \",duration:\" + newDetails.totalduration);\n      var trackLevel = levels[trackId];\n      var sliding = 0;\n      if (newDetails.live || (_trackLevel$details = trackLevel.details) != null && _trackLevel$details.live) {\n        this.checkLiveUpdate(newDetails);\n        if (newDetails.deltaUpdateFailed) {\n          return;\n        }\n        if (trackLevel.details) {\n          var _this$levelLastLoaded;\n          sliding = this.alignPlaylists(newDetails, trackLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n        }\n        if (!newDetails.alignedSliding) {\n          // Align audio rendition with the \"main\" playlist on discontinuity change\n          // or program-date-time (PDT)\n          alignDiscontinuities(newDetails, mainDetails);\n          if (!newDetails.alignedSliding) {\n            alignMediaPlaylistByPDT(newDetails, mainDetails);\n          }\n          sliding = newDetails.fragmentStart;\n        }\n      }\n      trackLevel.details = newDetails;\n      this.levelLastLoaded = trackLevel;\n\n      // compute start position if we are aligned with the main playlist\n      if (!this.startFragRequested) {\n        this.setStartPosition(mainDetails, sliding);\n      }\n      this.hls.trigger(Events.AUDIO_TRACK_UPDATED, {\n        details: newDetails,\n        id: trackId,\n        groupId: data.groupId\n      });\n\n      // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n      if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n        this.state = State.IDLE;\n      }\n\n      // trigger handler right now\n      this.tick();\n    };\n    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n      var _frag$initSegment;\n      var frag = data.frag;\n      var part = data.part,\n        payload = data.payload;\n      var config = this.config,\n        trackId = this.trackId,\n        levels = this.levels;\n      if (!levels) {\n        this.warn(\"Audio tracks were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n        return;\n      }\n      var track = levels[trackId];\n      if (!track) {\n        this.warn('Audio track is undefined on fragment load progress');\n        return;\n      }\n      var details = track.details;\n      if (!details) {\n        this.warn('Audio track details undefined on fragment load progress');\n        this.removeUnbufferedFrags(frag.start);\n        return;\n      }\n      var audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n      var transmuxer = this.transmuxer;\n      if (!transmuxer) {\n        transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n      }\n\n      // Check if we have video initPTS\n      // If not we need to wait for it\n      var initPTS = this.initPTS[frag.cc];\n      var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n      if (initPTS !== undefined) {\n        // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n        var accurateTimeOffset = false; // details.PTSKnown || !details.live;\n        var partIndex = part ? part.index : -1;\n        var partial = partIndex !== -1;\n        var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n        transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n      } else {\n        this.log(\"Unknown video PTS for cc \" + frag.cc + \", waiting for video PTS before demuxing audio frag \" + frag.sn + \" of [\" + details.startSN + \" ,\" + details.endSN + \"],track \" + trackId);\n        var _this$waitingData = this.waitingData = this.waitingData || {\n            frag: frag,\n            part: part,\n            cache: new ChunkCache(),\n            complete: false\n          },\n          cache = _this$waitingData.cache;\n        cache.push(new Uint8Array(payload));\n        if (this.state !== State.STOPPED) {\n          this.state = State.WAITING_INIT_PTS;\n        }\n      }\n    };\n    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n      if (this.waitingData) {\n        this.waitingData.complete = true;\n        return;\n      }\n      _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);\n    };\n    _proto.onBufferReset = function onBufferReset(/* event: Events.BUFFER_RESET */\n    ) {\n      // reset reference to sourcebuffers\n      this.mediaBuffer = null;\n    };\n    _proto.onBufferCreated = function onBufferCreated(event, data) {\n      this.bufferFlushed = this.flushing = false;\n      var audioTrack = data.tracks.audio;\n      if (audioTrack) {\n        this.mediaBuffer = audioTrack.buffer || null;\n      }\n    };\n    _proto.onFragLoading = function onFragLoading(event, data) {\n      if (!this.audioOnly && data.frag.type === PlaylistLevelType.MAIN && isMediaFragment(data.frag)) {\n        this.mainFragLoading = data;\n        if (this.state === State.IDLE) {\n          this.tick();\n        }\n      }\n    };\n    _proto.onFragBuffered = function onFragBuffered(event, data) {\n      var frag = data.frag,\n        part = data.part;\n      if (frag.type !== PlaylistLevelType.AUDIO) {\n        if (!this.audioOnly && frag.type === PlaylistLevelType.MAIN && !frag.elementaryStreams.video && !frag.elementaryStreams.audiovideo) {\n          this.audioOnly = true;\n          this.mainFragLoading = null;\n        }\n        return;\n      }\n      if (this.fragContextChanged(frag)) {\n        // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n        // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n        this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state + \", audioSwitch: \" + (this.switchingTrack ? this.switchingTrack.name : 'false'));\n        return;\n      }\n      if (isMediaFragment(frag)) {\n        this.fragPrevious = frag;\n        var track = this.switchingTrack;\n        if (track) {\n          this.bufferedTrack = track;\n          this.switchingTrack = null;\n          this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));\n        }\n      }\n      this.fragBufferedComplete(frag, part);\n      if (this.media) {\n        this.tick();\n      }\n    };\n    _proto.onError = function onError(event, data) {\n      var _data$context;\n      if (data.fatal) {\n        this.state = State.ERROR;\n        return;\n      }\n      switch (data.details) {\n        case ErrorDetails.FRAG_GAP:\n        case ErrorDetails.FRAG_PARSING_ERROR:\n        case ErrorDetails.FRAG_DECRYPT_ERROR:\n        case ErrorDetails.FRAG_LOAD_ERROR:\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_ERROR:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n          this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);\n          break;\n        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n        case ErrorDetails.LEVEL_PARSING_ERROR:\n          // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE\n          if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {\n            this.state = State.IDLE;\n          }\n          break;\n        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n        case ErrorDetails.BUFFER_APPEND_ERROR:\n          if (data.parent !== 'audio') {\n            return;\n          }\n          if (!this.reduceLengthAndFlushBuffer(data)) {\n            this.resetLoadingState();\n          }\n          break;\n        case ErrorDetails.BUFFER_FULL_ERROR:\n          if (data.parent !== 'audio') {\n            return;\n          }\n          if (this.reduceLengthAndFlushBuffer(data)) {\n            this.bufferedTrack = null;\n            _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n          }\n          break;\n        case ErrorDetails.INTERNAL_EXCEPTION:\n          this.recoverWorkerError(data);\n          break;\n      }\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, _ref3) {\n      var type = _ref3.type;\n      if (type !== ElementaryStreamTypes.VIDEO) {\n        this.flushing = true;\n      }\n    };\n    _proto.onBufferFlushed = function onBufferFlushed(event, _ref4) {\n      var type = _ref4.type;\n      if (type !== ElementaryStreamTypes.VIDEO) {\n        this.flushing = false;\n        this.bufferFlushed = true;\n        if (this.state === State.ENDED) {\n          this.state = State.IDLE;\n        }\n        var mediaBuffer = this.mediaBuffer || this.media;\n        if (mediaBuffer) {\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);\n          this.tick();\n        }\n      }\n    };\n    _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n      var _id3$samples;\n      var id = 'audio';\n      var hls = this.hls;\n      var remuxResult = transmuxResult.remuxResult,\n        chunkMeta = transmuxResult.chunkMeta;\n      var context = this.getCurrentContext(chunkMeta);\n      if (!context) {\n        this.resetWhenMissingContext(chunkMeta);\n        return;\n      }\n      var frag = context.frag,\n        part = context.part,\n        level = context.level;\n      var details = level.details;\n      var audio = remuxResult.audio,\n        text = remuxResult.text,\n        id3 = remuxResult.id3,\n        initSegment = remuxResult.initSegment;\n\n      // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n      // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n      if (this.fragContextChanged(frag) || !details) {\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      this.state = State.PARSING;\n      if (this.switchingTrack && audio) {\n        this.completeAudioSwitch(this.switchingTrack);\n      }\n      if (initSegment != null && initSegment.tracks) {\n        var mapFragment = frag.initSegment || frag;\n        if (this.unhandledEncryptionError(initSegment, frag)) {\n          return;\n        }\n        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n          frag: mapFragment,\n          id: id,\n          tracks: initSegment.tracks\n        });\n        // Only flush audio from old audio tracks when PTS is known on new audio track\n      }\n      if (audio) {\n        var startPTS = audio.startPTS,\n          endPTS = audio.endPTS,\n          startDTS = audio.startDTS,\n          endDTS = audio.endDTS;\n        if (part) {\n          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n            startPTS: startPTS,\n            endPTS: endPTS,\n            startDTS: startDTS,\n            endDTS: endDTS\n          };\n        }\n        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n        this.bufferFragmentData(audio, frag, part, chunkMeta);\n      }\n      if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n        var emittedID3 = _extends({\n          id: id,\n          frag: frag,\n          details: details\n        }, id3);\n        hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n      }\n      if (text) {\n        var emittedText = _extends({\n          id: id,\n          frag: frag,\n          details: details\n        }, text);\n        hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n      }\n    };\n    _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n      if (this.state !== State.PARSING) {\n        return;\n      }\n      // delete any video track found on audio transmuxer\n      if (tracks.video) {\n        delete tracks.video;\n      }\n      if (tracks.audiovideo) {\n        delete tracks.audiovideo;\n      }\n\n      // include levelCodec in audio and video tracks\n      if (!tracks.audio) {\n        return;\n      }\n      var track = tracks.audio;\n      track.id = PlaylistLevelType.AUDIO;\n      var variantAudioCodecs = currentLevel.audioCodec;\n      this.log(\"Init audio buffer, container:\" + track.container + \", codecs[level/parsed]=[\" + variantAudioCodecs + \"/\" + track.codec + \"]\");\n      // SourceBuffer will use track.levelCodec if defined\n      if (variantAudioCodecs && variantAudioCodecs.split(',').length === 1) {\n        track.levelCodec = variantAudioCodecs;\n      }\n      this.hls.trigger(Events.BUFFER_CODECS, tracks);\n      var initSegment = track.initSegment;\n      if (initSegment != null && initSegment.byteLength) {\n        var segment = {\n          type: 'audio',\n          frag: frag,\n          part: null,\n          chunkMeta: chunkMeta,\n          parent: frag.type,\n          data: initSegment\n        };\n        this.hls.trigger(Events.BUFFER_APPENDING, segment);\n      }\n      // trigger handler right now\n      this.tickImmediate();\n    };\n    _proto.loadFragment = function loadFragment(frag, track, targetBufferTime) {\n      // only load if fragment is not loaded or if in audio switch\n      var fragState = this.fragmentTracker.getState(frag);\n\n      // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n      if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n        var _track$details;\n        if (!isMediaFragment(frag)) {\n          this._loadInitSegment(frag, track);\n        } else if ((_track$details = track.details) != null && _track$details.live && !this.initPTS[frag.cc]) {\n          this.log(\"Waiting for video PTS in continuity counter \" + frag.cc + \" of live stream before loading audio fragment \" + frag.sn + \" of level \" + this.trackId);\n          this.state = State.WAITING_INIT_PTS;\n          var mainDetails = this.mainDetails;\n          if (mainDetails && mainDetails.fragmentStart !== track.details.fragmentStart) {\n            alignMediaPlaylistByPDT(track.details, mainDetails);\n          }\n        } else {\n          _BaseStreamController.prototype.loadFragment.call(this, frag, track, targetBufferTime);\n        }\n      } else {\n        this.clearTrackerIfNeeded(frag);\n      }\n    };\n    _proto.flushAudioIfNeeded = function flushAudioIfNeeded(switchingTrack) {\n      if (this.media && this.bufferedTrack) {\n        var _this$bufferedTrack = this.bufferedTrack,\n          name = _this$bufferedTrack.name,\n          lang = _this$bufferedTrack.lang,\n          assocLang = _this$bufferedTrack.assocLang,\n          characteristics = _this$bufferedTrack.characteristics,\n          audioCodec = _this$bufferedTrack.audioCodec,\n          channels = _this$bufferedTrack.channels;\n        if (!matchesOption({\n          name: name,\n          lang: lang,\n          assocLang: assocLang,\n          characteristics: characteristics,\n          audioCodec: audioCodec,\n          channels: channels\n        }, switchingTrack, audioMatchPredicate)) {\n          if (useAlternateAudio(switchingTrack.url, this.hls)) {\n            this.log('Switching audio track : flushing all audio');\n            _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n            this.bufferedTrack = null;\n          } else {\n            // Main is being buffered. Set bufferedTrack so that it is flushed when switching back to alt-audio\n            this.bufferedTrack = switchingTrack;\n          }\n        }\n      }\n    };\n    _proto.completeAudioSwitch = function completeAudioSwitch(switchingTrack) {\n      var hls = this.hls;\n      this.flushAudioIfNeeded(switchingTrack);\n      this.bufferedTrack = switchingTrack;\n      this.switchingTrack = null;\n      hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));\n    };\n    return AudioStreamController;\n  }(BaseStreamController);\n\n  var BasePlaylistController = /*#__PURE__*/function (_Logger) {\n    function BasePlaylistController(hls, logPrefix) {\n      var _this;\n      _this = _Logger.call(this, logPrefix, hls.logger) || this;\n      _this.hls = void 0;\n      _this.canLoad = false;\n      _this.timer = -1;\n      _this.hls = hls;\n      return _this;\n    }\n    _inheritsLoose(BasePlaylistController, _Logger);\n    var _proto = BasePlaylistController.prototype;\n    _proto.destroy = function destroy() {\n      this.clearTimer();\n      // @ts-ignore\n      this.hls = this.log = this.warn = null;\n    };\n    _proto.clearTimer = function clearTimer() {\n      if (this.timer !== -1) {\n        self.clearTimeout(this.timer);\n        this.timer = -1;\n      }\n    };\n    _proto.startLoad = function startLoad() {\n      this.canLoad = true;\n      this.loadPlaylist();\n    };\n    _proto.stopLoad = function stopLoad() {\n      this.canLoad = false;\n      this.clearTimer();\n    };\n    _proto.switchParams = function switchParams(playlistUri, previous, current) {\n      var renditionReports = previous == null ? void 0 : previous.renditionReports;\n      if (renditionReports) {\n        var foundIndex = -1;\n        for (var i = 0; i < renditionReports.length; i++) {\n          var attr = renditionReports[i];\n          var uri = void 0;\n          try {\n            uri = new self.URL(attr.URI, previous.url).href;\n          } catch (error) {\n            this.warn(\"Could not construct new URL for Rendition Report: \" + error);\n            uri = attr.URI || '';\n          }\n          // Use exact match. Otherwise, the last partial match, if any, will be used\n          // (Playlist URI includes a query string that the Rendition Report does not)\n          if (uri === playlistUri) {\n            foundIndex = i;\n            break;\n          } else if (uri === playlistUri.substring(0, uri.length)) {\n            foundIndex = i;\n          }\n        }\n        if (foundIndex !== -1) {\n          var _attr = renditionReports[foundIndex];\n          var msn = parseInt(_attr['LAST-MSN']) || previous.lastPartSn;\n          var part = parseInt(_attr['LAST-PART']) || previous.lastPartIndex;\n          if (this.hls.config.lowLatencyMode) {\n            var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n            if (part >= 0 && currentGoal > previous.partTarget) {\n              part += 1;\n            }\n          }\n          var skip = current && getSkipValue(current);\n          return new HlsUrlParameters(msn, part >= 0 ? part : undefined, skip);\n        }\n      }\n    };\n    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n      // Loading is handled by the subclasses\n      this.clearTimer();\n    };\n    _proto.loadingPlaylist = function loadingPlaylist(playlist, hlsUrlParameters) {\n      // Loading is handled by the subclasses\n      this.clearTimer();\n    };\n    _proto.shouldLoadPlaylist = function shouldLoadPlaylist(playlist) {\n      return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n    };\n    _proto.getUrlWithDirectives = function getUrlWithDirectives(uri, hlsUrlParameters) {\n      if (hlsUrlParameters) {\n        try {\n          return hlsUrlParameters.addDirectives(uri);\n        } catch (error) {\n          this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n        }\n      }\n      return uri;\n    };\n    _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {\n      var details = data.details,\n        stats = data.stats;\n\n      // Set last updated date-time\n      var now = self.performance.now();\n      var elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n      details.advancedDateTime = Date.now() - elapsed;\n\n      // shift fragment starts with timelineOffset\n      var timelineOffset = this.hls.config.timelineOffset;\n      if (timelineOffset !== details.appliedTimelineOffset) {\n        var offset = Math.max(timelineOffset || 0, 0);\n        details.appliedTimelineOffset = offset;\n        details.fragments.forEach(function (frag) {\n          frag.setStart(frag.playlistOffset + offset);\n        });\n      }\n\n      // if current playlist is a live playlist, arm a timer to reload it\n      if (details.live || previousDetails != null && previousDetails.live) {\n        var levelOrTrack = 'levelInfo' in data ? data.levelInfo : data.track;\n        details.reloaded(previousDetails);\n        // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n        if (previousDetails && details.fragments.length > 0) {\n          mergeDetails(previousDetails, details, this);\n          var error = details.playlistParsingError;\n          if (error) {\n            this.warn(error);\n            var hls = this.hls;\n            if (!hls.config.ignorePlaylistParsingErrors) {\n              var _details$fragments$;\n              var networkDetails = data.networkDetails;\n              hls.trigger(Events.ERROR, {\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.LEVEL_PARSING_ERROR,\n                fatal: false,\n                url: details.url,\n                error: error,\n                reason: error.message,\n                level: data.level || undefined,\n                parent: (_details$fragments$ = details.fragments[0]) == null ? void 0 : _details$fragments$.type,\n                networkDetails: networkDetails,\n                stats: stats\n              });\n              return;\n            }\n            details.playlistParsingError = null;\n          }\n        }\n        if (details.requestScheduled === -1) {\n          details.requestScheduled = stats.loading.start;\n        }\n        var bufferInfo = this.hls.mainForwardBufferInfo;\n        var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n        var distanceToLiveEdgeMs = (details.edge - position) * 1000;\n        var reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n        if (details.requestScheduled + reloadInterval < now) {\n          details.requestScheduled = now;\n        } else {\n          details.requestScheduled += reloadInterval;\n        }\n        this.log(\"live playlist \" + index + \" \" + (details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : details.updated ? 'UPDATED' : 'MISSED'));\n        if (!this.canLoad || !details.live) {\n          return;\n        }\n        var deliveryDirectives;\n        var msn = undefined;\n        var part = undefined;\n        if (details.canBlockReload && details.endSN && details.advanced) {\n          // Load level with LL-HLS delivery directives\n          var lowLatencyMode = this.hls.config.lowLatencyMode;\n          var lastPartSn = details.lastPartSn;\n          var endSn = details.endSN;\n          var lastPartIndex = details.lastPartIndex;\n          var hasParts = lastPartIndex !== -1;\n          var atLastPartOfSegment = lastPartSn === endSn;\n          if (hasParts) {\n            // When low latency mode is disabled, request the last part of the next segment\n            if (atLastPartOfSegment) {\n              msn = endSn + 1;\n              part = lowLatencyMode ? 0 : lastPartIndex;\n            } else {\n              msn = lastPartSn;\n              part = lowLatencyMode ? lastPartIndex + 1 : details.maxPartIndex;\n            }\n          } else {\n            msn = endSn + 1;\n          }\n          // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n          // Update directives to obtain the Playlist that has the estimated additional duration of media\n          var lastAdvanced = details.age;\n          var cdnAge = lastAdvanced + details.ageHeader;\n          var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n          if (currentGoal > 0) {\n            if (cdnAge > details.targetduration * 3) {\n              // Omit segment and part directives when the last response was more than 3 target durations ago,\n              this.log(\"Playlist last advanced \" + lastAdvanced.toFixed(2) + \"s ago. Omitting segment and part directives.\");\n              msn = undefined;\n              part = undefined;\n            } else if (previousDetails != null && previousDetails.tuneInGoal && cdnAge - details.partTarget > previousDetails.tuneInGoal) {\n              // If we attempted to get the next or latest playlist update, but currentGoal increased,\n              // then we either can't catchup, or the \"age\" header cannot be trusted.\n              this.warn(\"CDN Tune-in goal increased from: \" + previousDetails.tuneInGoal + \" to: \" + currentGoal + \" with playlist age: \" + details.age);\n              currentGoal = 0;\n            } else {\n              var segments = Math.floor(currentGoal / details.targetduration);\n              msn += segments;\n              if (part !== undefined) {\n                var parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n                part += parts;\n              }\n              this.log(\"CDN Tune-in age: \" + details.ageHeader + \"s last advanced \" + lastAdvanced.toFixed(2) + \"s goal: \" + currentGoal + \" skip sn \" + segments + \" to part \" + part);\n            }\n            details.tuneInGoal = currentGoal;\n          }\n          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n          if (lowLatencyMode || !atLastPartOfSegment) {\n            details.requestScheduled = now;\n            this.loadingPlaylist(levelOrTrack, deliveryDirectives);\n            return;\n          }\n        } else if (details.canBlockReload || details.canSkipUntil) {\n          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n        }\n        if (deliveryDirectives && msn !== undefined && details.canBlockReload) {\n          details.requestScheduled = stats.loading.first + Math.max(reloadInterval - elapsed * 2, reloadInterval / 2);\n        }\n        this.scheduleLoading(levelOrTrack, deliveryDirectives, details);\n      } else {\n        this.clearTimer();\n      }\n    };\n    _proto.scheduleLoading = function scheduleLoading(levelOrTrack, deliveryDirectives, updatedDetails) {\n      var _this2 = this;\n      var details = updatedDetails || levelOrTrack.details;\n      if (!details) {\n        this.loadingPlaylist(levelOrTrack, deliveryDirectives);\n        return;\n      }\n      var now = self.performance.now();\n      var requestScheduled = details.requestScheduled;\n      if (now >= requestScheduled) {\n        this.loadingPlaylist(levelOrTrack, deliveryDirectives);\n        return;\n      }\n      var estimatedTimeUntilUpdate = requestScheduled - now;\n      this.log(\"reload live playlist \" + (levelOrTrack.name || levelOrTrack.bitrate + 'bps') + \" in \" + Math.round(estimatedTimeUntilUpdate) + \" ms\");\n      this.clearTimer();\n      this.timer = self.setTimeout(function () {\n        return _this2.loadingPlaylist(levelOrTrack, deliveryDirectives);\n      }, estimatedTimeUntilUpdate);\n    };\n    _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n      var skip = getSkipValue(details);\n      if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n        msn = previousDeliveryDirectives.msn;\n        part = previousDeliveryDirectives.part;\n        skip = HlsSkip.No;\n      }\n      return new HlsUrlParameters(msn, part, skip);\n    };\n    _proto.checkRetry = function checkRetry(errorEvent) {\n      var _this3 = this;\n      var errorDetails = errorEvent.details;\n      var isTimeout = isTimeoutError(errorEvent);\n      var errorAction = errorEvent.errorAction;\n      var _ref = errorAction || {},\n        action = _ref.action,\n        _ref$retryCount = _ref.retryCount,\n        retryCount = _ref$retryCount === void 0 ? 0 : _ref$retryCount,\n        retryConfig = _ref.retryConfig;\n      var retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n      if (retry) {\n        var _errorEvent$context;\n        if (retryCount >= retryConfig.maxNumRetry) {\n          return false;\n        }\n        if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n          // The LL-HLS request already timed out so retry immediately\n          this.warn(\"Retrying playlist loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" after \\\"\" + errorDetails + \"\\\" without delivery-directives\");\n          this.loadPlaylist();\n        } else {\n          var delay = getRetryDelay(retryConfig, retryCount);\n          // Schedule level/track reload\n          this.clearTimer();\n          this.timer = self.setTimeout(function () {\n            return _this3.loadPlaylist();\n          }, delay);\n          this.warn(\"Retrying playlist loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" after \\\"\" + errorDetails + \"\\\" in \" + delay + \"ms\");\n        }\n        // `levelRetry = true` used to inform other controllers that a retry is happening\n        errorEvent.levelRetry = true;\n        errorAction.resolved = true;\n      }\n      return retry;\n    };\n    return BasePlaylistController;\n  }(Logger);\n\n  function subtitleOptionsIdentical(trackList1, trackList2) {\n    if (trackList1.length !== trackList2.length) {\n      return false;\n    }\n    for (var i = 0; i < trackList1.length; i++) {\n      if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function mediaAttributesIdentical(attrs1, attrs2, customAttributes) {\n    // Media options with the same rendition ID must be bit identical\n    var stableRenditionId = attrs1['STABLE-RENDITION-ID'];\n    if (stableRenditionId && !customAttributes) {\n      return stableRenditionId === attrs2['STABLE-RENDITION-ID'];\n    }\n    // When rendition ID is not present, compare attributes\n    return !(customAttributes || ['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED', 'ASSOC-LANGUAGE']).some(function (subtitleAttribute) {\n      return attrs1[subtitleAttribute] !== attrs2[subtitleAttribute];\n    });\n  }\n  function subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {\n    return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || '').toLowerCase());\n  }\n\n  var AudioTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n    function AudioTrackController(hls) {\n      var _this;\n      _this = _BasePlaylistControll.call(this, hls, 'audio-track-controller') || this;\n      _this.tracks = [];\n      _this.groupIds = null;\n      _this.tracksInGroup = [];\n      _this.trackId = -1;\n      _this.currentTrack = null;\n      _this.selectDefaultTrack = true;\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(AudioTrackController, _BasePlaylistControll);\n    var _proto = AudioTrackController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.tracks.length = 0;\n      this.tracksInGroup.length = 0;\n      this.currentTrack = null;\n      _BasePlaylistControll.prototype.destroy.call(this);\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.tracks = [];\n      this.tracksInGroup = [];\n      this.groupIds = null;\n      this.currentTrack = null;\n      this.trackId = -1;\n      this.selectDefaultTrack = true;\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      this.tracks = data.audioTracks || [];\n    };\n    _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n      var id = data.id,\n        groupId = data.groupId,\n        details = data.details;\n      var trackInActiveGroup = this.tracksInGroup[id];\n      if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n        this.warn(\"Audio track with id:\" + id + \" and group:\" + groupId + \" not found in active group \" + (trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId));\n        return;\n      }\n      var curDetails = trackInActiveGroup.details;\n      trackInActiveGroup.details = data.details;\n      this.log(\"Audio track \" + id + \" \\\"\" + trackInActiveGroup.name + \"\\\" lang:\" + trackInActiveGroup.lang + \" group:\" + groupId + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n      if (id === this.trackId) {\n        this.playlistLoaded(id, data, curDetails);\n      }\n    };\n    _proto.onLevelLoading = function onLevelLoading(event, data) {\n      this.switchLevel(data.level);\n    };\n    _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n      this.switchLevel(data.level);\n    };\n    _proto.switchLevel = function switchLevel(levelIndex) {\n      var levelInfo = this.hls.levels[levelIndex];\n      if (!levelInfo) {\n        return;\n      }\n      var audioGroups = levelInfo.audioGroups || null;\n      var currentGroups = this.groupIds;\n      var currentTrack = this.currentTrack;\n      if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some(function (groupId) {\n        return (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1;\n      })) {\n        this.groupIds = audioGroups;\n        this.trackId = -1;\n        this.currentTrack = null;\n        var audioTracks = this.tracks.filter(function (track) {\n          return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;\n        });\n        if (audioTracks.length) {\n          // Disable selectDefaultTrack if there are no default tracks\n          if (this.selectDefaultTrack && !audioTracks.some(function (track) {\n            return track.default;\n          })) {\n            this.selectDefaultTrack = false;\n          }\n          // track.id should match hls.audioTracks index\n          audioTracks.forEach(function (track, i) {\n            track.id = i;\n          });\n        } else if (!currentTrack && !this.tracksInGroup.length) {\n          // Do not dispatch AUDIO_TRACKS_UPDATED when there were and are no tracks\n          return;\n        }\n        this.tracksInGroup = audioTracks;\n\n        // Find preferred track\n        var audioPreference = this.hls.config.audioPreference;\n        if (!currentTrack && audioPreference) {\n          var groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);\n          if (groupIndex > -1) {\n            currentTrack = audioTracks[groupIndex];\n          } else {\n            var allIndex = findMatchingOption(audioPreference, this.tracks);\n            currentTrack = this.tracks[allIndex];\n          }\n        }\n\n        // Select initial track\n        var trackId = this.findTrackId(currentTrack);\n        if (trackId === -1 && currentTrack) {\n          trackId = this.findTrackId(null);\n        }\n\n        // Dispatch events and load track if needed\n        var audioTracksUpdated = {\n          audioTracks: audioTracks\n        };\n        this.log(\"Updating audio tracks, \" + audioTracks.length + \" track(s) found in group(s): \" + (audioGroups == null ? void 0 : audioGroups.join(',')));\n        this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n        var selectedTrackId = this.trackId;\n        if (trackId !== -1 && selectedTrackId === -1) {\n          this.setAudioTrack(trackId);\n        } else if (audioTracks.length && selectedTrackId === -1) {\n          var _this$groupIds;\n          var error = new Error(\"No audio track selected for current audio group-ID(s): \" + ((_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(',')) + \" track count: \" + audioTracks.length);\n          this.warn(error.message);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n            fatal: true,\n            error: error\n          });\n        }\n      }\n    };\n    _proto.onError = function onError(event, data) {\n      if (data.fatal || !data.context) {\n        return;\n      }\n      if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n        this.checkRetry(data);\n      }\n    };\n    _proto.setAudioOption = function setAudioOption(audioOption) {\n      var hls = this.hls;\n      hls.config.audioPreference = audioOption;\n      if (audioOption) {\n        var allAudioTracks = this.allAudioTracks;\n        this.selectDefaultTrack = false;\n        if (allAudioTracks.length) {\n          // First see if current option matches (no switch op)\n          var currentTrack = this.currentTrack;\n          if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {\n            return currentTrack;\n          }\n          // Find option in available tracks (tracksInGroup)\n          var groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);\n          if (groupIndex > -1) {\n            var track = this.tracksInGroup[groupIndex];\n            this.setAudioTrack(groupIndex);\n            return track;\n          } else if (currentTrack) {\n            // Find option in nearest level audio group\n            var searchIndex = hls.loadLevel;\n            if (searchIndex === -1) {\n              searchIndex = hls.firstAutoLevel;\n            }\n            var switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);\n            if (switchIndex === -1) {\n              // could not find matching variant\n              return null;\n            }\n            // and switch level to acheive the audio group switch\n            hls.nextLoadLevel = switchIndex;\n          }\n          if (audioOption.channels || audioOption.audioCodec) {\n            // Could not find a match with codec / channels predicate\n            // Find a match without channels or codec\n            var withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);\n            if (withoutCodecAndChannelsMatch > -1) {\n              return allAudioTracks[withoutCodecAndChannelsMatch];\n            }\n          }\n        }\n      }\n      return null;\n    };\n    _proto.setAudioTrack = function setAudioTrack(newId) {\n      var tracks = this.tracksInGroup;\n\n      // check if level idx is valid\n      if (newId < 0 || newId >= tracks.length) {\n        this.warn(\"Invalid audio track id: \" + newId);\n        return;\n      }\n      this.selectDefaultTrack = false;\n      var lastTrack = this.currentTrack;\n      var track = tracks[newId];\n      var trackLoaded = track.details && !track.details.live;\n      if (newId === this.trackId && track === lastTrack && trackLoaded) {\n        return;\n      }\n      this.log(\"Switching to audio-track \" + newId + \" \\\"\" + track.name + \"\\\" lang:\" + track.lang + \" group:\" + track.groupId + \" channels:\" + track.channels);\n      this.trackId = newId;\n      this.currentTrack = track;\n      this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));\n      // Do not reload track unless live\n      if (trackLoaded) {\n        return;\n      }\n      var hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n      this.loadPlaylist(hlsUrlParameters);\n    };\n    _proto.findTrackId = function findTrackId(currentTrack) {\n      var audioTracks = this.tracksInGroup;\n      for (var i = 0; i < audioTracks.length; i++) {\n        var track = audioTracks[i];\n        if (this.selectDefaultTrack && !track.default) {\n          continue;\n        }\n        if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {\n          return i;\n        }\n      }\n      if (currentTrack) {\n        var name = currentTrack.name,\n          lang = currentTrack.lang,\n          assocLang = currentTrack.assocLang,\n          characteristics = currentTrack.characteristics,\n          audioCodec = currentTrack.audioCodec,\n          channels = currentTrack.channels;\n        for (var _i = 0; _i < audioTracks.length; _i++) {\n          var _track = audioTracks[_i];\n          if (matchesOption({\n            name: name,\n            lang: lang,\n            assocLang: assocLang,\n            characteristics: characteristics,\n            audioCodec: audioCodec,\n            channels: channels\n          }, _track, audioMatchPredicate)) {\n            return _i;\n          }\n        }\n        for (var _i2 = 0; _i2 < audioTracks.length; _i2++) {\n          var _track2 = audioTracks[_i2];\n          if (mediaAttributesIdentical(currentTrack.attrs, _track2.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n            return _i2;\n          }\n        }\n        for (var _i3 = 0; _i3 < audioTracks.length; _i3++) {\n          var _track3 = audioTracks[_i3];\n          if (mediaAttributesIdentical(currentTrack.attrs, _track3.attrs, ['LANGUAGE'])) {\n            return _i3;\n          }\n        }\n      }\n      return -1;\n    };\n    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n      _BasePlaylistControll.prototype.loadPlaylist.call(this);\n      var audioTrack = this.currentTrack;\n      if (!this.shouldLoadPlaylist(audioTrack)) {\n        return;\n      }\n      // Do not load audio rendition with URI matching main variant URI\n      if (useAlternateAudio(audioTrack.url, this.hls)) {\n        this.scheduleLoading(audioTrack, hlsUrlParameters);\n      }\n    };\n    _proto.loadingPlaylist = function loadingPlaylist(audioTrack, hlsUrlParameters) {\n      _BasePlaylistControll.prototype.loadingPlaylist.call(this, audioTrack, hlsUrlParameters);\n      var id = audioTrack.id;\n      var groupId = audioTrack.groupId;\n      var url = this.getUrlWithDirectives(audioTrack.url, hlsUrlParameters);\n      var details = audioTrack.details;\n      var age = details == null ? void 0 : details.age;\n      this.log(\"Loading audio-track \" + id + \" \\\"\" + audioTrack.name + \"\\\" lang:\" + audioTrack.lang + \" group:\" + groupId + ((hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + (age && details.live ? ' age ' + age.toFixed(1) + (details.type ? ' ' + details.type || 0 : '') : '') + \" \" + url);\n      this.hls.trigger(Events.AUDIO_TRACK_LOADING, {\n        url: url,\n        id: id,\n        groupId: groupId,\n        deliveryDirectives: hlsUrlParameters || null,\n        track: audioTrack\n      });\n    };\n    return _createClass(AudioTrackController, [{\n      key: \"allAudioTracks\",\n      get: function get() {\n        return this.tracks;\n      }\n    }, {\n      key: \"audioTracks\",\n      get: function get() {\n        return this.tracksInGroup;\n      }\n    }, {\n      key: \"audioTrack\",\n      get: function get() {\n        return this.trackId;\n      },\n      set: function set(newId) {\n        // If audio track is selected from API then don't choose from the manifest default track\n        this.selectDefaultTrack = false;\n        this.setAudioTrack(newId);\n      }\n    }]);\n  }(BasePlaylistController);\n\n  var BufferOperationQueue = /*#__PURE__*/function () {\n    function BufferOperationQueue(sourceBufferReference) {\n      this.tracks = void 0;\n      this.queues = {\n        video: [],\n        audio: [],\n        audiovideo: []\n      };\n      this.tracks = sourceBufferReference;\n    }\n    var _proto = BufferOperationQueue.prototype;\n    _proto.destroy = function destroy() {\n      this.tracks = this.queues = null;\n    };\n    _proto.append = function append(operation, type, pending) {\n      if (this.queues === null || this.tracks === null) {\n        return;\n      }\n      var queue = this.queues[type];\n      queue.push(operation);\n      if (queue.length === 1 && !pending) {\n        this.executeNext(type);\n      }\n    };\n    _proto.appendBlocker = function appendBlocker(type) {\n      var _this = this;\n      return new Promise(function (resolve) {\n        var operation = {\n          label: 'async-blocker',\n          execute: resolve,\n          onStart: function onStart() {},\n          onComplete: function onComplete() {},\n          onError: function onError() {}\n        };\n        _this.append(operation, type);\n      });\n    };\n    _proto.prependBlocker = function prependBlocker(type) {\n      var _this2 = this;\n      return new Promise(function (resolve) {\n        if (_this2.queues) {\n          var operation = {\n            label: 'async-blocker-prepend',\n            execute: resolve,\n            onStart: function onStart() {},\n            onComplete: function onComplete() {},\n            onError: function onError() {}\n          };\n          _this2.queues[type].unshift(operation);\n        }\n      });\n    };\n    _proto.removeBlockers = function removeBlockers() {\n      if (this.queues === null) {\n        return;\n      }\n      [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach(function (queue) {\n        var _queue$;\n        var label = (_queue$ = queue[0]) == null ? void 0 : _queue$.label;\n        if (label === 'async-blocker' || label === 'async-blocker-prepend') {\n          queue[0].execute();\n          queue.splice(0, 1);\n        }\n      });\n    };\n    _proto.unblockAudio = function unblockAudio(op) {\n      if (this.queues === null) {\n        return;\n      }\n      var queue = this.queues.audio;\n      if (queue[0] === op) {\n        this.shiftAndExecuteNext('audio');\n      }\n    };\n    _proto.executeNext = function executeNext(type) {\n      if (this.queues === null || this.tracks === null) {\n        return;\n      }\n      var queue = this.queues[type];\n      if (queue.length) {\n        var operation = queue[0];\n        try {\n          // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n          // which do not end with this event must call _onSBUpdateEnd manually\n          operation.execute();\n        } catch (error) {\n          var _this$tracks$type;\n          operation.onError(error);\n          if (this.queues === null || this.tracks === null) {\n            return;\n          }\n\n          // Only shift the current operation off, otherwise the updateend handler will do this for us\n          var sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;\n          if (!(sb != null && sb.updating)) {\n            this.shiftAndExecuteNext(type);\n          }\n        }\n      }\n    };\n    _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {\n      if (this.queues === null) {\n        return;\n      }\n      this.queues[type].shift();\n      this.executeNext(type);\n    };\n    _proto.current = function current(type) {\n      var _this$queues;\n      return ((_this$queues = this.queues) == null ? void 0 : _this$queues[type][0]) || null;\n    };\n    _proto.toString = function toString() {\n      var queues = this.queues,\n        tracks = this.tracks;\n      if (queues === null || tracks === null) {\n        return \"<destroyed>\";\n      }\n      return \"\\n\" + this.list('video') + \"\\n\" + this.list('audio') + \"\\n\" + this.list('audiovideo') + \"}\";\n    };\n    _proto.list = function list(type) {\n      var _this$queues2, _this$tracks;\n      return (_this$queues2 = this.queues) != null && _this$queues2[type] || (_this$tracks = this.tracks) != null && _this$tracks[type] ? type + \": (\" + this.listSbInfo(type) + \") \" + this.listOps(type) : '';\n    };\n    _proto.listSbInfo = function listSbInfo(type) {\n      var _this$tracks2;\n      var track = (_this$tracks2 = this.tracks) == null ? void 0 : _this$tracks2[type];\n      var sb = track == null ? void 0 : track.buffer;\n      if (!sb) {\n        return 'none';\n      }\n      return \"SourceBuffer\" + (sb.updating ? ' updating' : '') + (track.ended ? ' ended' : '') + (track.ending ? ' ending' : '');\n    };\n    _proto.listOps = function listOps(type) {\n      var _this$queues3;\n      return ((_this$queues3 = this.queues) == null ? void 0 : _this$queues3[type].map(function (op) {\n        return op.label;\n      }).join(', ')) || '';\n    };\n    return BufferOperationQueue;\n  }();\n\n  var VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/;\n  var TRACK_REMOVED_ERROR_NAME = 'HlsJsTrackRemovedError';\n  var HlsJsTrackRemovedError = /*#__PURE__*/function (_Error) {\n    function HlsJsTrackRemovedError(message) {\n      var _this;\n      _this = _Error.call(this, message) || this;\n      _this.name = TRACK_REMOVED_ERROR_NAME;\n      return _this;\n    }\n    _inheritsLoose(HlsJsTrackRemovedError, _Error);\n    return HlsJsTrackRemovedError;\n  }(/*#__PURE__*/_wrapNativeSuper(Error));\n  var BufferController = /*#__PURE__*/function (_Logger) {\n    function BufferController(hls, fragmentTracker) {\n      var _this2;\n      _this2 = _Logger.call(this, 'buffer-controller', hls.logger) || this;\n      _this2.hls = void 0;\n      _this2.fragmentTracker = void 0;\n      // The level details used to determine duration, target-duration and live\n      _this2.details = null;\n      // cache the self generated object url to detect hijack of video tag\n      _this2._objectUrl = null;\n      // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n      _this2.operationQueue = null;\n      // The total number track codecs expected before any sourceBuffers are created (2: audio and video or 1: audiovideo | audio | video)\n      _this2.bufferCodecEventsTotal = 0;\n      // A reference to the attached media element\n      _this2.media = null;\n      // A reference to the active media source\n      _this2.mediaSource = null;\n      // Last MP3 audio chunk appended\n      _this2.lastMpegAudioChunk = null;\n      // Audio fragment blocked from appending until corresponding video appends or context changes\n      _this2.blockedAudioAppend = null;\n      // Keep track of video append position for unblocking audio\n      _this2.lastVideoAppendEnd = 0;\n      // Whether or not to use ManagedMediaSource API and append source element to media element.\n      _this2.appendSource = void 0;\n      // Transferred MediaSource information used to detmerine if duration end endstream may be appended\n      _this2.transferData = void 0;\n      // Directives used to override default MediaSource handling\n      _this2.overrides = void 0;\n      // Error counters\n      _this2.appendErrors = {\n        audio: 0,\n        video: 0,\n        audiovideo: 0\n      };\n      // Record of required or created buffers by type. SourceBuffer is stored in Track.buffer once created.\n      _this2.tracks = {};\n      // Array of SourceBuffer type and SourceBuffer (or null). One entry per TrackSet in this.tracks.\n      _this2.sourceBuffers = [[null, null], [null, null]];\n      _this2._onEndStreaming = function (event) {\n        var _this2$mediaSource;\n        if (!_this2.hls) {\n          return;\n        }\n        if (((_this2$mediaSource = _this2.mediaSource) == null ? void 0 : _this2$mediaSource.readyState) !== 'open') {\n          return;\n        }\n        _this2.hls.pauseBuffering();\n      };\n      _this2._onStartStreaming = function (event) {\n        if (!_this2.hls) {\n          return;\n        }\n        _this2.hls.resumeBuffering();\n      };\n      // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n      _this2._onMediaSourceOpen = function (e) {\n        var _this3 = _this2,\n          media = _this3.media,\n          mediaSource = _this3.mediaSource;\n        if (e) {\n          _this2.log('Media source opened');\n        }\n        if (!media || !mediaSource) {\n          return;\n        }\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', _this2._onMediaSourceOpen);\n        media.removeEventListener('emptied', _this2._onMediaEmptied);\n        _this2.updateDuration();\n        _this2.hls.trigger(Events.MEDIA_ATTACHED, {\n          media: media,\n          mediaSource: mediaSource\n        });\n        if (_this2.mediaSource !== null) {\n          _this2.checkPendingTracks();\n        }\n      };\n      _this2._onMediaSourceClose = function () {\n        _this2.log('Media source closed');\n      };\n      _this2._onMediaSourceEnded = function () {\n        _this2.log('Media source ended');\n      };\n      _this2._onMediaEmptied = function () {\n        var _this4 = _this2,\n          mediaSrc = _this4.mediaSrc,\n          _objectUrl = _this4._objectUrl;\n        if (mediaSrc !== _objectUrl) {\n          _this2.error(\"Media element src was set while attaching MediaSource (\" + _objectUrl + \" > \" + mediaSrc + \")\");\n        }\n      };\n      _this2.hls = hls;\n      _this2.fragmentTracker = fragmentTracker;\n      _this2.appendSource = isManagedMediaSource(getMediaSource(hls.config.preferManagedMediaSource));\n      _this2.initTracks();\n      _this2.registerListeners();\n      return _this2;\n    }\n    _inheritsLoose(BufferController, _Logger);\n    var _proto = BufferController.prototype;\n    _proto.hasSourceTypes = function hasSourceTypes() {\n      return Object.keys(this.tracks).length > 0;\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.details = null;\n      this.lastMpegAudioChunk = this.blockedAudioAppend = null;\n      this.transferData = this.overrides = undefined;\n      if (this.operationQueue) {\n        this.operationQueue.destroy();\n        this.operationQueue = null;\n      }\n      // @ts-ignore\n      this.hls = this.fragmentTracker = null;\n      // @ts-ignore\n      this._onMediaSourceOpen = this._onMediaSourceClose = null;\n      // @ts-ignore\n      this._onMediaSourceEnded = null;\n      // @ts-ignore\n      this._onStartStreaming = this._onEndStreaming = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n      hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n      hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n      hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n      hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n      hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n      hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n      hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n      hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.transferMedia = function transferMedia() {\n      var _this5 = this;\n      var media = this.media,\n        mediaSource = this.mediaSource;\n      if (!media) {\n        return null;\n      }\n      var tracks = {};\n      if (this.operationQueue) {\n        var updating = this.isUpdating();\n        if (!updating) {\n          this.operationQueue.removeBlockers();\n        }\n        var queued = this.isQueued();\n        if (updating || queued) {\n          this.warn(\"Transfering MediaSource with\" + (queued ? ' operations in queue' : '') + (updating ? ' updating SourceBuffer(s)' : '') + \" \" + this.operationQueue);\n        }\n        this.operationQueue.destroy();\n      }\n      var transferData = this.transferData;\n      if (!this.sourceBufferCount && transferData && transferData.mediaSource === mediaSource) {\n        _extends(tracks, transferData.tracks);\n      } else {\n        this.sourceBuffers.forEach(function (tuple) {\n          var type = tuple[0];\n          if (type) {\n            tracks[type] = _extends({}, _this5.tracks[type]);\n            _this5.removeBuffer(type);\n          }\n          tuple[0] = tuple[1] = null;\n        });\n      }\n      return {\n        media: media,\n        mediaSource: mediaSource,\n        tracks: tracks\n      };\n    };\n    _proto.initTracks = function initTracks() {\n      var tracks = {};\n      this.sourceBuffers = [[null, null], [null, null]];\n      this.tracks = tracks;\n      this.resetQueue();\n      this.resetAppendErrors();\n      this.lastMpegAudioChunk = this.blockedAudioAppend = null;\n      this.lastVideoAppendEnd = 0;\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.bufferCodecEventsTotal = 0;\n      this.details = null;\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      var _this$transferData;\n      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n      // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n      // it will contain the expected nb of source buffers, no need to compute it\n      var codecEvents = 2;\n      if (data.audio && !data.video || !data.altAudio) {\n        codecEvents = 1;\n      }\n      this.bufferCodecEventsTotal = codecEvents;\n      this.log(codecEvents + \" bufferCodec event(s) expected.\");\n      if ((_this$transferData = this.transferData) != null && _this$transferData.mediaSource && this.sourceBufferCount && codecEvents) {\n        this.bufferCreated();\n      }\n    };\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      var media = this.media = data.media;\n      this.transferData = this.overrides = undefined;\n      var MediaSource = getMediaSource(this.appendSource);\n      if (MediaSource) {\n        var transferringMedia = !!data.mediaSource;\n        if (transferringMedia || data.overrides) {\n          this.transferData = data;\n          this.overrides = data.overrides;\n        }\n        var ms = this.mediaSource = data.mediaSource || new MediaSource();\n        this.assignMediaSource(ms);\n        if (transferringMedia) {\n          this._objectUrl = media.src;\n          this.attachTransferred();\n        } else {\n          // cache the locally generated object url\n          var objectUrl = this._objectUrl = self.URL.createObjectURL(ms);\n          // link video and media Source\n          if (this.appendSource) {\n            try {\n              media.removeAttribute('src');\n              // ManagedMediaSource will not open without disableRemotePlayback set to false or source alternatives\n              var MMS = self.ManagedMediaSource;\n              media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;\n              removeSourceChildren(media);\n              addSource(media, objectUrl);\n              media.load();\n            } catch (error) {\n              media.src = objectUrl;\n            }\n          } else {\n            media.src = objectUrl;\n          }\n        }\n        media.addEventListener('emptied', this._onMediaEmptied);\n      }\n    };\n    _proto.assignMediaSource = function assignMediaSource(ms) {\n      var _this$transferData2, _ms$constructor;\n      this.log((((_this$transferData2 = this.transferData) == null ? void 0 : _this$transferData2.mediaSource) === ms ? 'transferred' : 'created') + \" media source: \" + ((_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name));\n      // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n      ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n      ms.addEventListener('sourceended', this._onMediaSourceEnded);\n      ms.addEventListener('sourceclose', this._onMediaSourceClose);\n      if (this.appendSource) {\n        ms.addEventListener('startstreaming', this._onStartStreaming);\n        ms.addEventListener('endstreaming', this._onEndStreaming);\n      }\n    };\n    _proto.attachTransferred = function attachTransferred() {\n      var _this6 = this;\n      var media = this.media;\n      var data = this.transferData;\n      if (!data || !media) {\n        return;\n      }\n      var requiredTracks = this.tracks;\n      var transferredTracks = data.tracks;\n      var trackNames = transferredTracks ? Object.keys(transferredTracks) : null;\n      var trackCount = trackNames ? trackNames.length : 0;\n      var mediaSourceOpenCallback = function mediaSourceOpenCallback() {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.resolve().then(function () {\n          if (_this6.media && _this6.mediaSourceOpenOrEnded) {\n            _this6._onMediaSourceOpen();\n          }\n        });\n      };\n      if (transferredTracks && trackNames && trackCount) {\n        if (!this.tracksReady) {\n          // Wait for CODECS event(s)\n          this.hls.config.startFragPrefetch = true;\n          this.log(\"attachTransferred: waiting for SourceBuffer track info\");\n          return;\n        }\n        this.log(\"attachTransferred: (bufferCodecEventsTotal \" + this.bufferCodecEventsTotal + \")\\nrequired tracks: \" + stringify(requiredTracks, function (key, value) {\n          return key === 'initSegment' ? undefined : value;\n        }) + \";\\ntransfer tracks: \" + stringify(transferredTracks, function (key, value) {\n          return key === 'initSegment' ? undefined : value;\n        }) + \"}\");\n        if (!isCompatibleTrackChange(transferredTracks, requiredTracks)) {\n          // destroy attaching media source\n          data.mediaSource = null;\n          data.tracks = undefined;\n          var currentTime = media.currentTime;\n          var details = this.details;\n          var startTime = Math.max(currentTime, (details == null ? void 0 : details.fragments[0].start) || 0);\n          if (startTime - currentTime > 1) {\n            this.log(\"attachTransferred: waiting for playback to reach new tracks start time \" + currentTime + \" -> \" + startTime);\n            return;\n          }\n          this.warn(\"attachTransferred: resetting MediaSource for incompatible tracks (\\\"\" + Object.keys(transferredTracks) + \"\\\"->\\\"\" + Object.keys(requiredTracks) + \"\\\") start time: \" + startTime + \" currentTime: \" + currentTime);\n          this.onMediaDetaching(Events.MEDIA_DETACHING, {});\n          this.onMediaAttaching(Events.MEDIA_ATTACHING, data);\n          media.currentTime = startTime;\n          return;\n        }\n        this.transferData = undefined;\n        trackNames.forEach(function (trackName) {\n          var type = trackName;\n          var track = transferredTracks[type];\n          if (track) {\n            var sb = track.buffer;\n            if (sb) {\n              // Purge fragment tracker of ejected segments for existing buffer\n              var fragmentTracker = _this6.fragmentTracker;\n              var playlistType = track.id;\n              if (fragmentTracker.hasFragments(playlistType) || fragmentTracker.hasParts(playlistType)) {\n                var bufferedTimeRanges = BufferHelper.getBuffered(sb);\n                fragmentTracker.detectEvictedFragments(type, bufferedTimeRanges, playlistType, null, true);\n              }\n              // Transfer SourceBuffer\n              var sbIndex = sourceBufferNameToIndex(type);\n              var sbTuple = [type, sb];\n              _this6.sourceBuffers[sbIndex] = sbTuple;\n              if (sb.updating && _this6.operationQueue) {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                _this6.operationQueue.prependBlocker(type);\n              }\n              _this6.trackSourceBuffer(type, track);\n            }\n          }\n        });\n        mediaSourceOpenCallback();\n        this.bufferCreated();\n      } else {\n        this.log(\"attachTransferred: MediaSource w/o SourceBuffers\");\n        mediaSourceOpenCallback();\n      }\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      var _this7 = this;\n      var transferringMedia = !!data.transferMedia;\n      this.transferData = this.overrides = undefined;\n      var media = this.media,\n        mediaSource = this.mediaSource,\n        _objectUrl = this._objectUrl;\n      if (mediaSource) {\n        this.log(\"media source \" + (transferringMedia ? 'transferring' : 'detaching'));\n        if (transferringMedia) {\n          // Detach SourceBuffers without removing from MediaSource\n          // and leave `tracks` (required SourceBuffers configuration)\n          this.sourceBuffers.forEach(function (_ref) {\n            var type = _ref[0];\n            if (type) {\n              _this7.removeBuffer(type);\n            }\n          });\n          this.resetQueue();\n        } else {\n          if (this.mediaSourceOpenOrEnded) {\n            var open = mediaSource.readyState === 'open';\n            try {\n              var sourceBuffers = mediaSource.sourceBuffers;\n              for (var i = sourceBuffers.length; i--;) {\n                if (open) {\n                  sourceBuffers[i].abort();\n                }\n                mediaSource.removeSourceBuffer(sourceBuffers[i]);\n              }\n              if (open) {\n                // endOfStream could trigger exception if any sourcebuffer is in updating state\n                // we don't really care about checking sourcebuffer state here,\n                // as we are anyway detaching the MediaSource\n                // let's just avoid this exception to propagate\n                mediaSource.endOfStream();\n              }\n            } catch (err) {\n              this.warn(\"onMediaDetaching: \" + err.message + \" while calling endOfStream\");\n            }\n          }\n          // Clean up the SourceBuffers by invoking onBufferReset\n          if (this.sourceBufferCount) {\n            this.onBufferReset();\n          }\n        }\n        mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n        mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n        mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n        if (this.appendSource) {\n          mediaSource.removeEventListener('startstreaming', this._onStartStreaming);\n          mediaSource.removeEventListener('endstreaming', this._onEndStreaming);\n        }\n        this.mediaSource = null;\n        this._objectUrl = null;\n      }\n\n      // Detach properly the MediaSource from the HTMLMediaElement as\n      // suggested in https://github.com/w3c/media-source/issues/53.\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        if (!transferringMedia) {\n          if (_objectUrl) {\n            self.URL.revokeObjectURL(_objectUrl);\n          }\n\n          // clean up video tag src only if it's our own url. some external libraries might\n          // hijack the video tag and change its 'src' without destroying the Hls instance first\n          if (this.mediaSrc === _objectUrl) {\n            media.removeAttribute('src');\n            if (this.appendSource) {\n              removeSourceChildren(media);\n            }\n            media.load();\n          } else {\n            this.warn('media|source.src was changed by a third party - skip cleanup');\n          }\n        }\n        this.media = null;\n      }\n      this.hls.trigger(Events.MEDIA_DETACHED, data);\n    };\n    _proto.onBufferReset = function onBufferReset() {\n      var _this8 = this;\n      this.sourceBuffers.forEach(function (_ref2) {\n        var type = _ref2[0];\n        if (type) {\n          _this8.resetBuffer(type);\n        }\n      });\n      this.initTracks();\n    };\n    _proto.resetBuffer = function resetBuffer(type) {\n      var _this$tracks$type;\n      var sb = (_this$tracks$type = this.tracks[type]) == null ? void 0 : _this$tracks$type.buffer;\n      this.removeBuffer(type);\n      if (sb) {\n        try {\n          var _this$mediaSource;\n          if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {\n            this.mediaSource.removeSourceBuffer(sb);\n          }\n        } catch (err) {\n          this.warn(\"onBufferReset \" + type, err);\n        }\n      }\n      delete this.tracks[type];\n    };\n    _proto.removeBuffer = function removeBuffer(type) {\n      this.removeBufferListeners(type);\n      this.sourceBuffers[sourceBufferNameToIndex(type)] = [null, null];\n      var track = this.tracks[type];\n      if (track) {\n        track.buffer = undefined;\n      }\n    };\n    _proto.resetQueue = function resetQueue() {\n      if (this.operationQueue) {\n        this.operationQueue.destroy();\n      }\n      this.operationQueue = new BufferOperationQueue(this.tracks);\n    };\n    _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n      var _this9 = this,\n        _data$audio;\n      var tracks = this.tracks;\n      var trackNames = Object.keys(data);\n      this.log(\"BUFFER_CODECS: \\\"\" + trackNames + \"\\\" (current SB count \" + this.sourceBufferCount + \")\");\n      var unmuxedToMuxed = 'audiovideo' in data && (tracks.audio || tracks.video) || tracks.audiovideo && ('audio' in data || 'video' in data);\n      var muxedToUnmuxed = !unmuxedToMuxed && this.sourceBufferCount && this.media && trackNames.some(function (sbName) {\n        return !tracks[sbName];\n      });\n      if (unmuxedToMuxed || muxedToUnmuxed) {\n        this.warn(\"Unsupported transition between \\\"\" + Object.keys(tracks) + \"\\\" and \\\"\" + trackNames + \"\\\" SourceBuffers\");\n        // Do not add incompatible track ('audiovideo' <-> 'video'/'audio').\n        // Allow following onBufferAppending handle to trigger BUFFER_APPEND_ERROR.\n        // This will either be resolved by level switch or could be handled with recoverMediaError().\n        return;\n      }\n      trackNames.forEach(function (trackName) {\n        var _this9$transferData, _trackCodec;\n        var parsedTrack = data[trackName];\n        var id = parsedTrack.id,\n          codec = parsedTrack.codec,\n          levelCodec = parsedTrack.levelCodec,\n          container = parsedTrack.container,\n          metadata = parsedTrack.metadata,\n          supplemental = parsedTrack.supplemental;\n        var track = tracks[trackName];\n        var transferredTrack = (_this9$transferData = _this9.transferData) == null || (_this9$transferData = _this9$transferData.tracks) == null ? void 0 : _this9$transferData[trackName];\n        var sbTrack = transferredTrack != null && transferredTrack.buffer ? transferredTrack : track;\n        var sbCodec = (sbTrack == null ? void 0 : sbTrack.pendingCodec) || (sbTrack == null ? void 0 : sbTrack.codec);\n        var trackLevelCodec = sbTrack == null ? void 0 : sbTrack.levelCodec;\n        if (!track) {\n          track = tracks[trackName] = {\n            buffer: undefined,\n            listeners: [],\n            codec: codec,\n            supplemental: supplemental,\n            container: container,\n            levelCodec: levelCodec,\n            metadata: metadata,\n            id: id\n          };\n        }\n        // check if SourceBuffer codec needs to change\n        var currentCodecFull = pickMostCompleteCodecName(sbCodec, trackLevelCodec);\n        var currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n        var trackCodec = pickMostCompleteCodecName(codec, levelCodec);\n        var nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n        if (trackCodec && currentCodecFull && currentCodec !== nextCodec) {\n          if (trackName.slice(0, 5) === 'audio') {\n            trackCodec = getCodecCompatibleName(trackCodec, _this9.appendSource);\n          }\n          _this9.log(\"switching codec \" + sbCodec + \" to \" + trackCodec);\n          if (trackCodec !== (track.pendingCodec || track.codec)) {\n            track.pendingCodec = trackCodec;\n          }\n          track.container = container;\n          _this9.appendChangeType(trackName, container, trackCodec);\n        }\n      });\n      if (this.tracksReady || this.sourceBufferCount) {\n        data.tracks = this.sourceBufferTracks;\n      }\n\n      // if sourcebuffers already created, do nothing ...\n      if (this.sourceBufferCount) {\n        return;\n      }\n      if (this.bufferCodecEventsTotal > 1 && !this.tracks.video && !data.video && ((_data$audio = data.audio) == null ? void 0 : _data$audio.id) === 'main') {\n        // MVP is missing CODECS and only audio was found in main segment (#7524)\n        this.log(\"Main audio-only\");\n        this.bufferCodecEventsTotal = 1;\n      }\n      if (this.mediaSourceOpenOrEnded) {\n        this.checkPendingTracks();\n      }\n    };\n    _proto.appendChangeType = function appendChangeType(type, container, codec) {\n      var _this0 = this;\n      var mimeType = container + \";codecs=\" + codec;\n      var operation = {\n        label: \"change-type=\" + mimeType,\n        execute: function execute() {\n          var track = _this0.tracks[type];\n          if (track) {\n            var sb = track.buffer;\n            if (sb != null && sb.changeType) {\n              _this0.log(\"changing \" + type + \" sourceBuffer type to \" + mimeType);\n              sb.changeType(mimeType);\n              track.codec = codec;\n              track.container = container;\n            }\n          }\n          _this0.shiftAndExecuteNext(type);\n        },\n        onStart: function onStart() {},\n        onComplete: function onComplete() {},\n        onError: function onError(error) {\n          _this0.warn(\"Failed to change \" + type + \" SourceBuffer type\", error);\n        }\n      };\n      this.append(operation, type, this.isPending(this.tracks[type]));\n    };\n    _proto.blockAudio = function blockAudio(partOrFrag) {\n      var _this$fragmentTracker,\n        _this1 = this;\n      var pStart = partOrFrag.start;\n      var pTime = pStart + partOrFrag.duration * 0.05;\n      var atGap = ((_this$fragmentTracker = this.fragmentTracker.getAppendedFrag(pStart, PlaylistLevelType.MAIN)) == null ? void 0 : _this$fragmentTracker.gap) === true;\n      if (atGap) {\n        return;\n      }\n      var op = {\n        label: 'block-audio',\n        execute: function execute() {\n          var _this1$fragmentTracke;\n          var videoTrack = _this1.tracks.video;\n          if (_this1.lastVideoAppendEnd > pTime || videoTrack != null && videoTrack.buffer && BufferHelper.isBuffered(videoTrack.buffer, pTime) || ((_this1$fragmentTracke = _this1.fragmentTracker.getAppendedFrag(pTime, PlaylistLevelType.MAIN)) == null ? void 0 : _this1$fragmentTracke.gap) === true) {\n            _this1.blockedAudioAppend = null;\n            _this1.shiftAndExecuteNext('audio');\n          }\n        },\n        onStart: function onStart() {},\n        onComplete: function onComplete() {},\n        onError: function onError(error) {\n          _this1.warn('Error executing block-audio operation', error);\n        }\n      };\n      this.blockedAudioAppend = {\n        op: op,\n        frag: partOrFrag\n      };\n      this.append(op, 'audio', true);\n    };\n    _proto.unblockAudio = function unblockAudio() {\n      var blockedAudioAppend = this.blockedAudioAppend,\n        operationQueue = this.operationQueue;\n      if (blockedAudioAppend && operationQueue) {\n        this.blockedAudioAppend = null;\n        operationQueue.unblockAudio(blockedAudioAppend.op);\n      }\n    };\n    _proto.onBufferAppending = function onBufferAppending(event, eventData) {\n      var _this10 = this;\n      var tracks = this.tracks;\n      var data = eventData.data,\n        type = eventData.type,\n        parent = eventData.parent,\n        frag = eventData.frag,\n        part = eventData.part,\n        chunkMeta = eventData.chunkMeta,\n        offset = eventData.offset;\n      var chunkStats = chunkMeta.buffering[type];\n      var sn = frag.sn,\n        cc = frag.cc;\n      var bufferAppendingStart = self.performance.now();\n      chunkStats.start = bufferAppendingStart;\n      var fragBuffering = frag.stats.buffering;\n      var partBuffering = part ? part.stats.buffering : null;\n      if (fragBuffering.start === 0) {\n        fragBuffering.start = bufferAppendingStart;\n      }\n      if (partBuffering && partBuffering.start === 0) {\n        partBuffering.start = bufferAppendingStart;\n      }\n\n      // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n      var audioTrack = tracks.audio;\n      var checkTimestampOffset = false;\n      if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n        checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n        this.lastMpegAudioChunk = chunkMeta;\n      }\n\n      // Block audio append until overlapping video append\n      var videoTrack = tracks.video;\n      var videoSb = videoTrack == null ? void 0 : videoTrack.buffer;\n      if (videoSb && sn !== 'initSegment') {\n        var partOrFrag = part || frag;\n        var blockedAudioAppend = this.blockedAudioAppend;\n        if (type === 'audio' && parent !== 'main' && !this.blockedAudioAppend && !(videoTrack.ending || videoTrack.ended)) {\n          var pStart = partOrFrag.start;\n          var pTime = pStart + partOrFrag.duration * 0.05;\n          var vbuffered = videoSb.buffered;\n          var vappending = this.currentOp('video');\n          if (!vbuffered.length && !vappending) {\n            // wait for video before appending audio\n            this.blockAudio(partOrFrag);\n          } else if (!vappending && !BufferHelper.isBuffered(videoSb, pTime) && this.lastVideoAppendEnd < pTime) {\n            // audio is ahead of video\n            this.blockAudio(partOrFrag);\n          }\n        } else if (type === 'video') {\n          var videoAppendEnd = partOrFrag.end;\n          if (blockedAudioAppend) {\n            var audioStart = blockedAudioAppend.frag.start;\n            if (videoAppendEnd > audioStart || videoAppendEnd < this.lastVideoAppendEnd || BufferHelper.isBuffered(videoSb, audioStart)) {\n              this.unblockAudio();\n            }\n          }\n          this.lastVideoAppendEnd = videoAppendEnd;\n        }\n      }\n      var fragStart = (part || frag).start;\n      var operation = {\n        label: \"append-\" + type,\n        execute: function execute() {\n          var _this10$tracks$type;\n          chunkStats.executeStart = self.performance.now();\n          var sb = (_this10$tracks$type = _this10.tracks[type]) == null ? void 0 : _this10$tracks$type.buffer;\n          if (sb) {\n            if (checkTimestampOffset) {\n              _this10.updateTimestampOffset(sb, fragStart, 0.1, type, sn, cc);\n            } else if (offset !== undefined && isFiniteNumber(offset)) {\n              _this10.updateTimestampOffset(sb, offset, 0.000001, type, sn, cc);\n            }\n          }\n          _this10.appendExecutor(data, type);\n        },\n        onStart: function onStart() {\n          // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n        },\n        onComplete: function onComplete() {\n          // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n          var end = self.performance.now();\n          chunkStats.executeEnd = chunkStats.end = end;\n          if (fragBuffering.first === 0) {\n            fragBuffering.first = end;\n          }\n          if (partBuffering && partBuffering.first === 0) {\n            partBuffering.first = end;\n          }\n          var timeRanges = {};\n          _this10.sourceBuffers.forEach(function (_ref3) {\n            var type = _ref3[0],\n              sb = _ref3[1];\n            if (type) {\n              timeRanges[type] = BufferHelper.getBuffered(sb);\n            }\n          });\n          _this10.appendErrors[type] = 0;\n          if (type === 'audio' || type === 'video') {\n            _this10.appendErrors.audiovideo = 0;\n          } else {\n            _this10.appendErrors.audio = 0;\n            _this10.appendErrors.video = 0;\n          }\n          _this10.hls.trigger(Events.BUFFER_APPENDED, {\n            type: type,\n            frag: frag,\n            part: part,\n            chunkMeta: chunkMeta,\n            parent: frag.type,\n            timeRanges: timeRanges\n          });\n        },\n        onError: function onError(error) {\n          var _this10$media;\n          // in case any error occured while appending, put back segment in segments table\n          var event = {\n            type: ErrorTypes.MEDIA_ERROR,\n            parent: frag.type,\n            details: ErrorDetails.BUFFER_APPEND_ERROR,\n            sourceBufferName: type,\n            frag: frag,\n            part: part,\n            chunkMeta: chunkMeta,\n            error: error,\n            err: error,\n            fatal: false\n          };\n          var mediaError = (_this10$media = _this10.media) == null ? void 0 : _this10$media.error;\n          if (error.code === DOMException.QUOTA_EXCEEDED_ERR || error.name == 'QuotaExceededError' || \"quota\" in error) {\n            // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n            // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n            event.details = ErrorDetails.BUFFER_FULL_ERROR;\n          } else if (error.code === DOMException.INVALID_STATE_ERR && _this10.mediaSourceOpenOrEnded && !mediaError) {\n            // Allow retry for \"Failed to execute 'appendBuffer' on 'SourceBuffer': This SourceBuffer is still processing\" errors\n            event.errorAction = createDoNothingErrorAction(true);\n          } else if (error.name === TRACK_REMOVED_ERROR_NAME && _this10.sourceBufferCount === 0) {\n            // Do nothing if sourceBuffers were removed (media is detached and append was not aborted)\n            event.errorAction = createDoNothingErrorAction(true);\n          } else {\n            var appendErrorCount = ++_this10.appendErrors[type];\n            /* with UHD content, we could get loop of quota exceeded error until\n              browser is able to evict some data from sourcebuffer. Retrying can help recover.\n            */\n            _this10.warn(\"Failed \" + appendErrorCount + \"/\" + _this10.hls.config.appendErrorMaxRetry + \" times to append segment in \\\"\" + type + \"\\\" sourceBuffer (\" + (mediaError ? mediaError : 'no media error') + \")\");\n            if (appendErrorCount >= _this10.hls.config.appendErrorMaxRetry || !!mediaError) {\n              event.fatal = true;\n            }\n          }\n          _this10.hls.trigger(Events.ERROR, event);\n        }\n      };\n      this.log(\"queuing \\\"\" + type + \"\\\" append sn: \" + sn + (part ? ' p: ' + part.index : '') + \" of \" + (frag.type === PlaylistLevelType.MAIN ? 'level' : 'track') + \" \" + frag.level + \" cc: \" + cc);\n      this.append(operation, type, this.isPending(this.tracks[type]));\n    };\n    _proto.getFlushOp = function getFlushOp(type, start, end) {\n      var _this11 = this;\n      this.log(\"queuing \\\"\" + type + \"\\\" remove \" + start + \"-\" + end);\n      return {\n        label: 'remove',\n        execute: function execute() {\n          _this11.removeExecutor(type, start, end);\n        },\n        onStart: function onStart() {\n          // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        },\n        onComplete: function onComplete() {\n          // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n          _this11.hls.trigger(Events.BUFFER_FLUSHED, {\n            type: type\n          });\n        },\n        onError: function onError(error) {\n          _this11.warn(\"Failed to remove \" + start + \"-\" + end + \" from \\\"\" + type + \"\\\" SourceBuffer\", error);\n        }\n      };\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n      var _this12 = this;\n      var type = data.type,\n        startOffset = data.startOffset,\n        endOffset = data.endOffset;\n      if (type) {\n        this.append(this.getFlushOp(type, startOffset, endOffset), type);\n      } else {\n        this.sourceBuffers.forEach(function (_ref4) {\n          var type = _ref4[0];\n          if (type) {\n            _this12.append(_this12.getFlushOp(type, startOffset, endOffset), type);\n          }\n        });\n      }\n    };\n    _proto.onFragParsed = function onFragParsed(event, data) {\n      var _this13 = this;\n      var frag = data.frag,\n        part = data.part;\n      var buffersAppendedTo = [];\n      var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n      if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n        buffersAppendedTo.push('audiovideo');\n      } else {\n        if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n          buffersAppendedTo.push('audio');\n        }\n        if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n          buffersAppendedTo.push('video');\n        }\n      }\n      var onUnblocked = function onUnblocked() {\n        var now = self.performance.now();\n        frag.stats.buffering.end = now;\n        if (part) {\n          part.stats.buffering.end = now;\n        }\n        var stats = part ? part.stats : frag.stats;\n        _this13.hls.trigger(Events.FRAG_BUFFERED, {\n          frag: frag,\n          part: part,\n          stats: stats,\n          id: frag.type\n        });\n      };\n      if (buffersAppendedTo.length === 0) {\n        this.warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + frag.type + \" level: \" + frag.level + \" sn: \" + frag.sn);\n      }\n      this.blockBuffers(onUnblocked, buffersAppendedTo).catch(function (error) {\n        _this13.warn(\"Fragment buffered callback \" + error);\n        _this13.stepOperationQueue(_this13.sourceBufferTypes);\n      });\n    };\n    _proto.onFragChanged = function onFragChanged(event, data) {\n      this.trimBuffers();\n    };\n    // on BUFFER_EOS mark matching sourcebuffer(s) as \"ending\" and \"ended\" and queue endOfStream after remaining operations(s)\n    // an undefined data.type will mark all buffers as EOS.\n    _proto.onBufferEos = function onBufferEos(event, data) {\n      var _this14 = this,\n        _this$overrides;\n      this.sourceBuffers.forEach(function (_ref5) {\n        var type = _ref5[0];\n        if (type) {\n          var track = _this14.tracks[type];\n          if (!data.type || data.type === type) {\n            track.ending = true;\n            if (!track.ended) {\n              track.ended = true;\n              _this14.log(type + \" buffer reached EOS\");\n            }\n          }\n        }\n      });\n      var allowEndOfStream = ((_this$overrides = this.overrides) == null ? void 0 : _this$overrides.endOfStream) !== false;\n      var allTracksEnding = this.sourceBufferCount > 0 && !this.sourceBuffers.some(function (_ref6) {\n        var _this14$tracks$type;\n        var type = _ref6[0];\n        return type && !((_this14$tracks$type = _this14.tracks[type]) != null && _this14$tracks$type.ended);\n      });\n      if (allTracksEnding) {\n        if (allowEndOfStream) {\n          this.log(\"Queueing EOS\");\n          this.blockUntilOpen(function () {\n            _this14.tracksEnded();\n            var mediaSource = _this14.mediaSource;\n            if (!mediaSource || mediaSource.readyState !== 'open') {\n              if (mediaSource) {\n                _this14.log(\"Could not call mediaSource.endOfStream(). mediaSource.readyState: \" + mediaSource.readyState);\n              }\n              return;\n            }\n            _this14.log(\"Calling mediaSource.endOfStream()\");\n            // Allow this to throw and be caught by the enqueueing function\n            mediaSource.endOfStream();\n            _this14.hls.trigger(Events.BUFFERED_TO_END, undefined);\n          });\n        } else {\n          this.tracksEnded();\n          this.hls.trigger(Events.BUFFERED_TO_END, undefined);\n        }\n      } else if (data.type === 'video') {\n        // Make sure pending audio appends are unblocked when video reaches end\n        this.unblockAudio();\n      }\n    };\n    _proto.tracksEnded = function tracksEnded() {\n      var _this15 = this;\n      this.sourceBuffers.forEach(function (_ref7) {\n        var type = _ref7[0];\n        if (type !== null) {\n          var track = _this15.tracks[type];\n          if (track) {\n            track.ending = false;\n          }\n        }\n      });\n    };\n    _proto.onLevelUpdated = function onLevelUpdated(event, _ref8) {\n      var details = _ref8.details;\n      if (!details.fragments.length) {\n        return;\n      }\n      this.details = details;\n      this.updateDuration();\n    };\n    _proto.updateDuration = function updateDuration() {\n      var _this16 = this;\n      this.blockUntilOpen(function () {\n        var durationAndRange = _this16.getDurationAndRange();\n        if (!durationAndRange) {\n          return;\n        }\n        _this16.updateMediaSource(durationAndRange);\n      });\n    };\n    _proto.onError = function onError(event, data) {\n      if (data.details === ErrorDetails.BUFFER_APPEND_ERROR && data.frag) {\n        var _data$errorAction;\n        var nextAutoLevel = (_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.nextAutoLevel;\n        if (isFiniteNumber(nextAutoLevel) && nextAutoLevel !== data.frag.level) {\n          this.resetAppendErrors();\n        }\n      }\n    };\n    _proto.resetAppendErrors = function resetAppendErrors() {\n      this.appendErrors = {\n        audio: 0,\n        video: 0,\n        audiovideo: 0\n      };\n    };\n    _proto.trimBuffers = function trimBuffers() {\n      var hls = this.hls,\n        details = this.details,\n        media = this.media;\n      if (!media || details === null) {\n        return;\n      }\n      if (!this.sourceBufferCount) {\n        return;\n      }\n      var config = hls.config;\n      var currentTime = media.currentTime;\n      var targetDuration = details.levelTargetDuration;\n\n      // Support for deprecated liveBackBufferLength\n      var backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;\n      if (isFiniteNumber(backBufferLength) && backBufferLength >= 0) {\n        var maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n        var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n        this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);\n      }\n      var frontBufferFlushThreshold = config.frontBufferFlushThreshold;\n      if (isFiniteNumber(frontBufferFlushThreshold) && frontBufferFlushThreshold > 0) {\n        var frontBufferLength = Math.max(config.maxBufferLength, frontBufferFlushThreshold);\n        var maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);\n        var targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;\n        this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);\n      }\n    };\n    _proto.flushBackBuffer = function flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {\n      var _this17 = this;\n      this.sourceBuffers.forEach(function (_ref9) {\n        var type = _ref9[0],\n          sb = _ref9[1];\n        if (sb) {\n          var buffered = BufferHelper.getBuffered(sb);\n          // when target buffer start exceeds actual buffer start\n          if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n            var _this17$details;\n            _this17.hls.trigger(Events.BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n\n            // Support for deprecated event:\n            var track = _this17.tracks[type];\n            if ((_this17$details = _this17.details) != null && _this17$details.live) {\n              _this17.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n                bufferEnd: targetBackBufferPosition\n              });\n            } else if (track != null && track.ended) {\n              _this17.log(\"Cannot flush \" + type + \" back buffer while SourceBuffer is in ended state\");\n              return;\n            }\n            _this17.hls.trigger(Events.BUFFER_FLUSHING, {\n              startOffset: 0,\n              endOffset: targetBackBufferPosition,\n              type: type\n            });\n          }\n        }\n      });\n    };\n    _proto.flushFrontBuffer = function flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {\n      var _this18 = this;\n      this.sourceBuffers.forEach(function (_ref0) {\n        var type = _ref0[0],\n          sb = _ref0[1];\n        if (sb) {\n          var buffered = BufferHelper.getBuffered(sb);\n          var numBufferedRanges = buffered.length;\n          // The buffer is either empty or contiguous\n          if (numBufferedRanges < 2) {\n            return;\n          }\n          var bufferStart = buffered.start(numBufferedRanges - 1);\n          var bufferEnd = buffered.end(numBufferedRanges - 1);\n          // No flush if we can tolerate the current buffer length or the current buffer range we would flush is contiguous with current position\n          if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {\n            return;\n          }\n          _this18.hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: bufferStart,\n            endOffset: Infinity,\n            type: type\n          });\n        }\n      });\n    }\n\n    /**\n     * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n     * 'liveDurationInfinity` is set to `true`\n     * More details: https://github.com/video-dev/hls.js/issues/355\n     */;\n    _proto.getDurationAndRange = function getDurationAndRange() {\n      var _this$overrides2;\n      var details = this.details,\n        mediaSource = this.mediaSource;\n      if (!details || !this.media || (mediaSource == null ? void 0 : mediaSource.readyState) !== 'open') {\n        return null;\n      }\n      var playlistEnd = details.edge;\n      if (details.live && this.hls.config.liveDurationInfinity) {\n        var len = details.fragments.length;\n        if (len && !!mediaSource.setLiveSeekableRange) {\n          var start = Math.max(0, details.fragmentStart);\n          var end = Math.max(start, playlistEnd);\n          return {\n            duration: Infinity,\n            start: start,\n            end: end\n          };\n        }\n        return {\n          duration: Infinity\n        };\n      }\n      var overrideDuration = (_this$overrides2 = this.overrides) == null ? void 0 : _this$overrides2.duration;\n      if (overrideDuration) {\n        if (!isFiniteNumber(overrideDuration)) {\n          return null;\n        }\n        return {\n          duration: overrideDuration\n        };\n      }\n      var mediaDuration = this.media.duration;\n      var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n      if (playlistEnd > msDuration && playlistEnd > mediaDuration || !isFiniteNumber(mediaDuration)) {\n        return {\n          duration: playlistEnd\n        };\n      }\n      return null;\n    };\n    _proto.updateMediaSource = function updateMediaSource(_ref1) {\n      var duration = _ref1.duration,\n        start = _ref1.start,\n        end = _ref1.end;\n      var mediaSource = this.mediaSource;\n      if (!this.media || !mediaSource || mediaSource.readyState !== 'open') {\n        return;\n      }\n      if (mediaSource.duration !== duration) {\n        if (isFiniteNumber(duration)) {\n          this.log(\"Updating MediaSource duration to \" + duration.toFixed(3));\n        }\n        mediaSource.duration = duration;\n      }\n      if (start !== undefined && end !== undefined) {\n        this.log(\"MediaSource duration is set to \" + mediaSource.duration + \". Setting seekable range to \" + start + \"-\" + end + \".\");\n        mediaSource.setLiveSeekableRange(start, end);\n      }\n    };\n    _proto.checkPendingTracks = function checkPendingTracks() {\n      var bufferCodecEventsTotal = this.bufferCodecEventsTotal,\n        pendingTrackCount = this.pendingTrackCount,\n        tracks = this.tracks;\n      this.log(\"checkPendingTracks (pending: \" + pendingTrackCount + \" codec events expected: \" + bufferCodecEventsTotal + \") \" + stringify(tracks));\n      // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n      // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n      // data has been appended to existing ones.\n      // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n      if (this.tracksReady) {\n        var _this$transferData3;\n        var transferredTracks = (_this$transferData3 = this.transferData) == null ? void 0 : _this$transferData3.tracks;\n        if (transferredTracks && Object.keys(transferredTracks).length) {\n          this.attachTransferred();\n        } else {\n          // ok, let's create them now !\n          this.createSourceBuffers();\n        }\n      }\n    };\n    _proto.bufferCreated = function bufferCreated() {\n      var _this19 = this;\n      if (this.sourceBufferCount) {\n        var tracks = {};\n        this.sourceBuffers.forEach(function (_ref10) {\n          var type = _ref10[0],\n            buffer = _ref10[1];\n          if (type) {\n            var track = _this19.tracks[type];\n            tracks[type] = {\n              buffer: buffer,\n              container: track.container,\n              codec: track.codec,\n              supplemental: track.supplemental,\n              levelCodec: track.levelCodec,\n              id: track.id,\n              metadata: track.metadata\n            };\n          }\n        });\n        this.hls.trigger(Events.BUFFER_CREATED, {\n          tracks: tracks\n        });\n        this.log(\"SourceBuffers created. Running queue: \" + this.operationQueue);\n        this.sourceBuffers.forEach(function (_ref11) {\n          var type = _ref11[0];\n          _this19.executeNext(type);\n        });\n      } else {\n        var error = new Error('could not create source buffer for media codec(s)');\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n          fatal: true,\n          error: error,\n          reason: error.message\n        });\n      }\n    };\n    _proto.createSourceBuffers = function createSourceBuffers() {\n      var tracks = this.tracks,\n        sourceBuffers = this.sourceBuffers,\n        mediaSource = this.mediaSource;\n      if (!mediaSource) {\n        throw new Error('createSourceBuffers called when mediaSource was null');\n      }\n      for (var trackName in tracks) {\n        var type = trackName;\n        var track = tracks[type];\n        if (this.isPending(track)) {\n          var codec = this.getTrackCodec(track, type);\n          var mimeType = track.container + \";codecs=\" + codec;\n          track.codec = codec;\n          this.log(\"creating sourceBuffer(\" + mimeType + \")\" + (this.currentOp(type) ? ' Queued' : '') + \" \" + stringify(track));\n          try {\n            var sb = mediaSource.addSourceBuffer(mimeType);\n            var sbIndex = sourceBufferNameToIndex(type);\n            var sbTuple = [type, sb];\n            sourceBuffers[sbIndex] = sbTuple;\n            track.buffer = sb;\n          } catch (error) {\n            var _this$operationQueue;\n            this.error(\"error while trying to add sourceBuffer: \" + error.message);\n            // remove init segment from queue and delete track info\n            this.shiftAndExecuteNext(type);\n            (_this$operationQueue = this.operationQueue) == null || _this$operationQueue.removeBlockers();\n            delete this.tracks[type];\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n              fatal: false,\n              error: error,\n              sourceBufferName: type,\n              mimeType: mimeType,\n              parent: track.id\n            });\n            return;\n          }\n          this.trackSourceBuffer(type, track);\n        }\n      }\n      this.bufferCreated();\n    };\n    _proto.getTrackCodec = function getTrackCodec(track, trackName) {\n      // Use supplemental video codec when supported when adding SourceBuffer (#5558)\n      var supplementalCodec = track.supplemental;\n      var trackCodec = track.codec;\n      if (supplementalCodec && (trackName === 'video' || trackName === 'audiovideo') && areCodecsMediaSourceSupported(supplementalCodec, 'video')) {\n        trackCodec = replaceVideoCodec(trackCodec, supplementalCodec);\n      }\n      var codec = pickMostCompleteCodecName(trackCodec, track.levelCodec);\n      if (codec) {\n        if (trackName.slice(0, 5) === 'audio') {\n          return getCodecCompatibleName(codec, this.appendSource);\n        }\n        return codec;\n      }\n      return '';\n    };\n    _proto.trackSourceBuffer = function trackSourceBuffer(type, track) {\n      var _this20 = this;\n      var buffer = track.buffer;\n      if (!buffer) {\n        return;\n      }\n      var codec = this.getTrackCodec(track, type);\n      this.tracks[type] = {\n        buffer: buffer,\n        codec: codec,\n        container: track.container,\n        levelCodec: track.levelCodec,\n        supplemental: track.supplemental,\n        metadata: track.metadata,\n        id: track.id,\n        listeners: []\n      };\n      this.removeBufferListeners(type);\n      this.addBufferListener(type, 'updatestart', this.onSBUpdateStart);\n      this.addBufferListener(type, 'updateend', this.onSBUpdateEnd);\n      this.addBufferListener(type, 'error', this.onSBUpdateError);\n      // ManagedSourceBuffer bufferedchange event\n      if (this.appendSource) {\n        this.addBufferListener(type, 'bufferedchange', function (type, event) {\n          // If media was ejected check for a change. Added ranges are redundant with changes on 'updateend' event.\n          var removedRanges = event.removedRanges;\n          if (removedRanges != null && removedRanges.length) {\n            _this20.hls.trigger(Events.BUFFER_FLUSHED, {\n              type: type\n            });\n          }\n        });\n      }\n    };\n    _proto.onSBUpdateStart = function onSBUpdateStart(type) {\n      var operation = this.currentOp(type);\n      if (!operation) {\n        return;\n      }\n      operation.onStart();\n    };\n    _proto.onSBUpdateEnd = function onSBUpdateEnd(type) {\n      var _this$mediaSource2;\n      if (((_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState) === 'closed') {\n        this.resetBuffer(type);\n        return;\n      }\n      var operation = this.currentOp(type);\n      if (!operation) {\n        return;\n      }\n      operation.onComplete();\n      this.shiftAndExecuteNext(type);\n    };\n    _proto.onSBUpdateError = function onSBUpdateError(type, event) {\n      var _this$mediaSource3;\n      var error = new Error(type + \" SourceBuffer error. MediaSource readyState: \" + ((_this$mediaSource3 = this.mediaSource) == null ? void 0 : _this$mediaSource3.readyState));\n      this.error(\"\" + error, event);\n      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n      // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_APPENDING_ERROR,\n        sourceBufferName: type,\n        error: error,\n        fatal: false\n      });\n      // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n      var operation = this.currentOp(type);\n      if (operation) {\n        operation.onError(error);\n      }\n    };\n    _proto.updateTimestampOffset = function updateTimestampOffset(sb, timestampOffset, tolerance, type, sn, cc) {\n      var delta = timestampOffset - sb.timestampOffset;\n      if (Math.abs(delta) >= tolerance) {\n        this.log(\"Updating \" + type + \" SourceBuffer timestampOffset to \" + timestampOffset + \" (sn: \" + sn + \" cc: \" + cc + \")\");\n        sb.timestampOffset = timestampOffset;\n      }\n    }\n\n    // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually\n    ;\n    _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {\n      var media = this.media,\n        mediaSource = this.mediaSource;\n      var track = this.tracks[type];\n      var sb = track == null ? void 0 : track.buffer;\n      if (!media || !mediaSource || !sb) {\n        this.warn(\"Attempting to remove from the \" + type + \" SourceBuffer, but it does not exist\");\n        this.shiftAndExecuteNext(type);\n        return;\n      }\n      var mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n      var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n      var removeStart = Math.max(0, startOffset);\n      var removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n      if (removeEnd > removeStart && (!track.ending || track.ended)) {\n        track.ended = false;\n        this.log(\"Removing [\" + removeStart + \",\" + removeEnd + \"] from the \" + type + \" SourceBuffer\");\n        sb.remove(removeStart, removeEnd);\n      } else {\n        // Cycle the queue\n        this.shiftAndExecuteNext(type);\n      }\n    }\n\n    // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually\n    ;\n    _proto.appendExecutor = function appendExecutor(data, type) {\n      var track = this.tracks[type];\n      var sb = track == null ? void 0 : track.buffer;\n      if (!sb) {\n        throw new HlsJsTrackRemovedError(\"Attempting to append to the \" + type + \" SourceBuffer, but it does not exist\");\n      }\n      track.ending = false;\n      track.ended = false;\n      sb.appendBuffer(data);\n    };\n    _proto.blockUntilOpen = function blockUntilOpen(callback) {\n      var _this21 = this;\n      if (this.isUpdating() || this.isQueued()) {\n        this.blockBuffers(callback).catch(function (error) {\n          _this21.warn(\"SourceBuffer blocked callback \" + error);\n          _this21.stepOperationQueue(_this21.sourceBufferTypes);\n        });\n      } else {\n        try {\n          callback();\n        } catch (error) {\n          this.warn(\"Callback run without blocking \" + this.operationQueue + \" \" + error);\n        }\n      }\n    };\n    _proto.isUpdating = function isUpdating() {\n      return this.sourceBuffers.some(function (_ref12) {\n        var type = _ref12[0],\n          sb = _ref12[1];\n        return type && sb.updating;\n      });\n    };\n    _proto.isQueued = function isQueued() {\n      var _this22 = this;\n      return this.sourceBuffers.some(function (_ref13) {\n        var type = _ref13[0];\n        return type && !!_this22.currentOp(type);\n      });\n    };\n    _proto.isPending = function isPending(track) {\n      return !!track && !track.buffer;\n    }\n\n    // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n    // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n    // upon completion, since we already do it here\n    ;\n    _proto.blockBuffers = function blockBuffers(onUnblocked, bufferNames) {\n      var _this23 = this;\n      if (bufferNames === void 0) {\n        bufferNames = this.sourceBufferTypes;\n      }\n      if (!bufferNames.length) {\n        this.log('Blocking operation requested, but no SourceBuffers exist');\n        return Promise.resolve().then(onUnblocked);\n      }\n      var operationQueue = this.operationQueue;\n\n      // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n      var blockingOperations = bufferNames.map(function (type) {\n        return _this23.appendBlocker(type);\n      });\n      var audioBlocked = bufferNames.length > 1 && !!this.blockedAudioAppend;\n      if (audioBlocked) {\n        this.unblockAudio();\n      }\n      return Promise.all(blockingOperations).then(function (result) {\n        if (operationQueue !== _this23.operationQueue) {\n          return;\n        }\n        // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n        onUnblocked();\n        _this23.stepOperationQueue(_this23.sourceBufferTypes);\n      });\n    };\n    _proto.stepOperationQueue = function stepOperationQueue(bufferNames) {\n      var _this24 = this;\n      bufferNames.forEach(function (type) {\n        var _this24$tracks$type;\n        var sb = (_this24$tracks$type = _this24.tracks[type]) == null ? void 0 : _this24$tracks$type.buffer;\n        // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n        // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n        // While this is a workaround, it's probably useful to have around\n        if (!sb || sb.updating) {\n          return;\n        }\n        _this24.shiftAndExecuteNext(type);\n      });\n    };\n    _proto.append = function append(operation, type, pending) {\n      if (this.operationQueue) {\n        this.operationQueue.append(operation, type, pending);\n      }\n    };\n    _proto.appendBlocker = function appendBlocker(type) {\n      if (this.operationQueue) {\n        return this.operationQueue.appendBlocker(type);\n      }\n    };\n    _proto.currentOp = function currentOp(type) {\n      if (this.operationQueue) {\n        return this.operationQueue.current(type);\n      }\n      return null;\n    };\n    _proto.executeNext = function executeNext(type) {\n      if (type && this.operationQueue) {\n        this.operationQueue.executeNext(type);\n      }\n    };\n    _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {\n      if (this.operationQueue) {\n        this.operationQueue.shiftAndExecuteNext(type);\n      }\n    };\n    _proto.addBufferListener = function addBufferListener(type, event, fn) {\n      var track = this.tracks[type];\n      if (!track) {\n        return;\n      }\n      var buffer = track.buffer;\n      if (!buffer) {\n        return;\n      }\n      var listener = fn.bind(this, type);\n      track.listeners.push({\n        event: event,\n        listener: listener\n      });\n      buffer.addEventListener(event, listener);\n    };\n    _proto.removeBufferListeners = function removeBufferListeners(type) {\n      var track = this.tracks[type];\n      if (!track) {\n        return;\n      }\n      var buffer = track.buffer;\n      if (!buffer) {\n        return;\n      }\n      track.listeners.forEach(function (l) {\n        buffer.removeEventListener(l.event, l.listener);\n      });\n      track.listeners.length = 0;\n    };\n    return _createClass(BufferController, [{\n      key: \"mediaSourceOpenOrEnded\",\n      get: function get() {\n        var _this$mediaSource4;\n        var readyState = (_this$mediaSource4 = this.mediaSource) == null ? void 0 : _this$mediaSource4.readyState;\n        return readyState === 'open' || readyState === 'ended';\n      }\n    }, {\n      key: \"sourceBufferTracks\",\n      get: function get() {\n        var _this25 = this;\n        return Object.keys(this.tracks).reduce(function (baseTracks, type) {\n          var track = _this25.tracks[type];\n          baseTracks[type] = {\n            id: track.id,\n            container: track.container,\n            codec: track.codec,\n            levelCodec: track.levelCodec\n          };\n          return baseTracks;\n        }, {});\n      }\n    }, {\n      key: \"bufferedToEnd\",\n      get: function get() {\n        var _this26 = this;\n        return this.sourceBufferCount > 0 && !this.sourceBuffers.some(function (_ref14) {\n          var type = _ref14[0];\n          if (type) {\n            var track = _this26.tracks[type];\n            if (track) {\n              return !track.ended || track.ending;\n            }\n          }\n          return false;\n        });\n      }\n    }, {\n      key: \"tracksReady\",\n      get: function get() {\n        var pendingTrackCount = this.pendingTrackCount;\n        return pendingTrackCount > 0 && (pendingTrackCount >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));\n      }\n    }, {\n      key: \"mediaSrc\",\n      get: function get() {\n        var _this$media, _this$media$querySele;\n        var media = ((_this$media = this.media) == null || (_this$media$querySele = _this$media.querySelector) == null ? void 0 : _this$media$querySele.call(_this$media, 'source')) || this.media;\n        return media == null ? void 0 : media.src;\n      }\n    }, {\n      key: \"pendingTrackCount\",\n      get: function get() {\n        var _this27 = this;\n        return Object.keys(this.tracks).reduce(function (acc, type) {\n          return acc + (_this27.isPending(_this27.tracks[type]) ? 1 : 0);\n        }, 0);\n      }\n    }, {\n      key: \"sourceBufferCount\",\n      get: function get() {\n        return this.sourceBuffers.reduce(function (acc, _ref15) {\n          var type = _ref15[0];\n          return acc + (type ? 1 : 0);\n        }, 0);\n      }\n    }, {\n      key: \"sourceBufferTypes\",\n      get: function get() {\n        return this.sourceBuffers.map(function (_ref16) {\n          var type = _ref16[0];\n          return type;\n        }).filter(function (type) {\n          return !!type;\n        });\n      }\n    }]);\n  }(Logger);\n  function removeSourceChildren(node) {\n    var sourceChildren = node.querySelectorAll('source');\n    [].slice.call(sourceChildren).forEach(function (source) {\n      node.removeChild(source);\n    });\n  }\n  function addSource(media, url) {\n    var source = self.document.createElement('source');\n    source.type = 'video/mp4';\n    source.src = url;\n    media.appendChild(source);\n  }\n  function sourceBufferNameToIndex(type) {\n    return type === 'audio' ? 1 : 0;\n  }\n\n  var CapLevelController = /*#__PURE__*/function () {\n    function CapLevelController(hls) {\n      this.hls = void 0;\n      this.autoLevelCapping = void 0;\n      this.firstLevel = void 0;\n      this.media = void 0;\n      this.restrictedLevels = void 0;\n      this.timer = void 0;\n      this.clientRect = void 0;\n      this.streamController = void 0;\n      this.hls = hls;\n      this.autoLevelCapping = Number.POSITIVE_INFINITY;\n      this.firstLevel = -1;\n      this.media = null;\n      this.restrictedLevels = [];\n      this.timer = undefined;\n      this.clientRect = null;\n      this.registerListeners();\n    }\n    var _proto = CapLevelController.prototype;\n    _proto.setStreamController = function setStreamController(streamController) {\n      this.streamController = streamController;\n    };\n    _proto.destroy = function destroy() {\n      if (this.hls) {\n        this.unregisterListener();\n      }\n      if (this.timer) {\n        this.stopCapping();\n      }\n      this.media = null;\n      this.clientRect = null;\n      // @ts-ignore\n      this.hls = this.streamController = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    };\n    _proto.unregisterListener = function unregisterListener() {\n      var hls = this.hls;\n      hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    };\n    _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {\n      // Don't add a restricted level more than once\n      var level = this.hls.levels[data.droppedLevel];\n      if (this.isLevelAllowed(level)) {\n        this.restrictedLevels.push({\n          bitrate: level.bitrate,\n          height: level.height,\n          width: level.width\n        });\n      }\n    };\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n      this.clientRect = null;\n      if (this.timer && this.hls.levels.length) {\n        this.detectPlayerSize();\n      }\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      var hls = this.hls;\n      this.restrictedLevels = [];\n      this.firstLevel = data.firstLevel;\n      if (hls.config.capLevelToPlayerSize && data.video) {\n        // Start capping immediately if the manifest has signaled video codecs\n        this.startCapping();\n      }\n    };\n    _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n      if (this.timer && isFiniteNumber(this.autoLevelCapping)) {\n        this.detectPlayerSize();\n      }\n    }\n\n    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n    // to the first level\n    ;\n    _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n      var hls = this.hls;\n      if (hls.config.capLevelToPlayerSize && data.video) {\n        // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n        this.startCapping();\n      }\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      this.stopCapping();\n      this.media = null;\n    };\n    _proto.detectPlayerSize = function detectPlayerSize() {\n      if (this.media) {\n        if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {\n          this.clientRect = null;\n          return;\n        }\n        var levels = this.hls.levels;\n        if (levels.length) {\n          var hls = this.hls;\n          var maxLevel = this.getMaxLevel(levels.length - 1);\n          if (maxLevel !== this.autoLevelCapping) {\n            hls.logger.log(\"Setting autoLevelCapping to \" + maxLevel + \": \" + levels[maxLevel].height + \"p@\" + levels[maxLevel].bitrate + \" for media \" + this.mediaWidth + \"x\" + this.mediaHeight);\n          }\n          hls.autoLevelCapping = maxLevel;\n          if (hls.autoLevelEnabled && hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n            // usually happen when the user go to the fullscreen mode.\n            this.streamController.nextLevelSwitch();\n          }\n          this.autoLevelCapping = hls.autoLevelCapping;\n        }\n      }\n    }\n\n    /*\n     * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n     */;\n    _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {\n      var _this = this;\n      var levels = this.hls.levels;\n      if (!levels.length) {\n        return -1;\n      }\n      var validLevels = levels.filter(function (level, index) {\n        return _this.isLevelAllowed(level) && index <= capLevelIndex;\n      });\n      this.clientRect = null;\n      return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n    };\n    _proto.startCapping = function startCapping() {\n      if (this.timer) {\n        // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n        return;\n      }\n      this.autoLevelCapping = Number.POSITIVE_INFINITY;\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n      this.detectPlayerSize();\n    };\n    _proto.stopCapping = function stopCapping() {\n      this.restrictedLevels = [];\n      this.firstLevel = -1;\n      this.autoLevelCapping = Number.POSITIVE_INFINITY;\n      if (this.timer) {\n        self.clearInterval(this.timer);\n        this.timer = undefined;\n      }\n    };\n    _proto.getDimensions = function getDimensions() {\n      if (this.clientRect) {\n        return this.clientRect;\n      }\n      var media = this.media;\n      var boundsRect = {\n        width: 0,\n        height: 0\n      };\n      if (media) {\n        var clientRect = media.getBoundingClientRect();\n        boundsRect.width = clientRect.width;\n        boundsRect.height = clientRect.height;\n        if (!boundsRect.width && !boundsRect.height) {\n          // When the media element has no width or height (equivalent to not being in the DOM),\n          // then use its width and height attributes (media.width, media.height)\n          boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n          boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n        }\n      }\n      this.clientRect = boundsRect;\n      return boundsRect;\n    };\n    _proto.isLevelAllowed = function isLevelAllowed(level) {\n      var restrictedLevels = this.restrictedLevels;\n      return !restrictedLevels.some(function (restrictedLevel) {\n        return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n      });\n    };\n    CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {\n      if (!(levels != null && levels.length)) {\n        return -1;\n      }\n\n      // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n      // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n      var atGreatestBandwidth = function atGreatestBandwidth(curLevel, nextLevel) {\n        if (!nextLevel) {\n          return true;\n        }\n        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n      };\n\n      // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n      // the max level\n      var maxLevelIndex = levels.length - 1;\n      // Prevent changes in aspect-ratio from causing capping to toggle back and forth\n      var squareSize = Math.max(width, height);\n      for (var i = 0; i < levels.length; i += 1) {\n        var level = levels[i];\n        if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {\n          maxLevelIndex = i;\n          break;\n        }\n      }\n      return maxLevelIndex;\n    };\n    return _createClass(CapLevelController, [{\n      key: \"mediaWidth\",\n      get: function get() {\n        return this.getDimensions().width * this.contentScaleFactor;\n      }\n    }, {\n      key: \"mediaHeight\",\n      get: function get() {\n        return this.getDimensions().height * this.contentScaleFactor;\n      }\n    }, {\n      key: \"contentScaleFactor\",\n      get: function get() {\n        var pixelRatio = 1;\n        if (!this.hls.config.ignoreDevicePixelRatio) {\n          try {\n            pixelRatio = self.devicePixelRatio;\n          } catch (e) {\n            /* no-op */\n          }\n        }\n        return Math.min(pixelRatio, this.hls.config.maxDevicePixelRatio);\n      }\n    }]);\n  }();\n\n  /**\n   * Common Media Object Type\n   *\n   * @internal\n   */\n  var CmObjectType = {\n    /**\n     * text file, such as a manifest or playlist\n     */\n    MANIFEST: 'm',\n    /**\n     * audio only\n     */\n    AUDIO: 'a',\n    /**\n     * video only\n     */\n    VIDEO: 'v',\n    /**\n     * muxed audio and video\n     */\n    MUXED: 'av',\n    /**\n     * init segment\n     */\n    INIT: 'i',\n    /**\n     * caption or subtitle\n     */\n    CAPTION: 'c',\n    /**\n     * ISOBMFF timed text track\n     */\n    TIMED_TEXT: 'tt',\n    /**\n     * cryptographic key, license or certificate.\n     */\n    KEY: 'k',\n    /**\n     * other\n     */\n    OTHER: 'o'\n  };\n\n  /**\n   * Common Media Client Data Object Type\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @enum\n   */\n  var CmcdObjectType = CmObjectType;\n\n  /**\n   * Common Media Streaming Format\n   *\n   * @internal\n   */\n  var CmStreamingFormat = {\n    /**\n     * HTTP Live Streaming (HLS)\n     */\n    HLS: 'h'};\n\n  /**\n   * Common Media Client Data Streaming Format\n   *\n   * @group CMCD\n   *\n   * @enum\n   *\n   * @beta\n   */\n  var CmcdStreamingFormat = CmStreamingFormat;\n\n  /**\n   * Structured Field Item\n   *\n   * @group Structured Field\n   *\n   * @beta\n   */\n  var SfItem = function SfItem(value, params) {\n    if (Array.isArray(value)) {\n      value = value.map(function (v) {\n        return v instanceof SfItem ? v : new SfItem(v);\n      });\n    }\n    this.value = value;\n    this.params = params;\n  };\n\n  var DICT = 'Dict';\n\n  function format(value) {\n    if (Array.isArray(value)) {\n      return JSON.stringify(value);\n    }\n    if (value instanceof Map) {\n      return 'Map{}';\n    }\n    if (value instanceof Set) {\n      return 'Set{}';\n    }\n    if (typeof value === 'object') {\n      return JSON.stringify(value);\n    }\n    return String(value);\n  }\n  function throwError(action, src, type, cause) {\n    return new Error(\"failed to \" + action + \" \\\"\" + format(src) + \"\\\" as \" + type, {\n      cause: cause\n    });\n  }\n\n  function serializeError(src, type, cause) {\n    return throwError('serialize', src, type, cause);\n  }\n\n  /**\n   * A class to represent structured field tokens when `Symbol` is not available.\n   *\n   * @group Structured Field\n   *\n   * @beta\n   */\n  var SfToken = function SfToken(description) {\n    this.description = description;\n  };\n\n  var BARE_ITEM = 'Bare Item';\n\n  var BOOLEAN = 'Boolean';\n\n  // 4.1.9.  Serializing a Boolean\n  //\n  // Given a Boolean as input_boolean, return an ASCII string suitable for\n  // use in a HTTP field value.\n  //\n  // 1.  If input_boolean is not a boolean, fail serialization.\n  //\n  // 2.  Let output be an empty string.\n  //\n  // 3.  Append \"?\" to output.\n  //\n  // 4.  If input_boolean is true, append \"1\" to output.\n  //\n  // 5.  If input_boolean is false, append \"0\" to output.\n  //\n  // 6.  Return output.\n  function serializeBoolean(value) {\n    if (typeof value !== 'boolean') {\n      throw serializeError(value, BOOLEAN);\n    }\n    return value ? '?1' : '?0';\n  }\n\n  /**\n   * Encodes binary data to base64\n   *\n   * @param binary - The binary data to encode\n   * @returns The base64 encoded string\n   *\n   * @group Utils\n   *\n   * @beta\n   */\n  function encodeBase64(binary) {\n    return btoa(String.fromCharCode.apply(String, binary));\n  }\n\n  var BYTES = 'Byte Sequence';\n\n  // 4.1.8.  Serializing a Byte Sequence\n  //\n  // Given a Byte Sequence as input_bytes, return an ASCII string suitable\n  // for use in a HTTP field value.\n  //\n  // 1.  If input_bytes is not a sequence of bytes, fail serialization.\n  //\n  // 2.  Let output be an empty string.\n  //\n  // 3.  Append \":\" to output.\n  //\n  // 4.  Append the result of base64-encoding input_bytes as per\n  //     [RFC4648], Section 4, taking account of the requirements below.\n  //\n  // 5.  Append \":\" to output.\n  //\n  // 6.  Return output.\n  //\n  // The encoded data is required to be padded with \"=\", as per [RFC4648],\n  // Section 3.2.\n  //\n  // Likewise, encoded data SHOULD have pad bits set to zero, as per\n  // [RFC4648], Section 3.5, unless it is not possible to do so due to\n  // implementation constraints.\n  function serializeByteSequence(value) {\n    if (ArrayBuffer.isView(value) === false) {\n      throw serializeError(value, BYTES);\n    }\n    return \":\" + encodeBase64(value) + \":\";\n  }\n\n  var INTEGER = 'Integer';\n\n  function isInvalidInt(value) {\n    return value < -999999999999999 || 999999999999999 < value;\n  }\n\n  // 4.1.4.  Serializing an Integer\n  //\n  // Given an Integer as input_integer, return an ASCII string suitable\n  // for use in a HTTP field value.\n  //\n  // 1.  If input_integer is not an integer in the range of\n  //     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail\n  //     serialization.\n  //\n  // 2.  Let output be an empty string.\n  //\n  // 3.  If input_integer is less than (but not equal to) 0, append \"-\" to\n  //     output.\n  //\n  // 4.  Append input_integer's numeric value represented in base 10 using\n  //     only decimal digits to output.\n  //\n  // 5.  Return output.\n  function serializeInteger(value) {\n    if (isInvalidInt(value)) {\n      throw serializeError(value, INTEGER);\n    }\n    return value.toString();\n  }\n\n  // 4.1.10.  Serializing a Date\n  //\n  // Given a Date as input_integer, return an ASCII string suitable for\n  // use in an HTTP field value.\n  // 1.  Let output be \"@\".\n  // 2.  Append to output the result of running Serializing an Integer\n  //     with input_date (Section 4.1.4).\n  // 3.  Return output.\n  function serializeDate(value) {\n    return \"@\" + serializeInteger(value.getTime() / 1000);\n  }\n\n  /**\n   * This implements the rounding procedure described in step 2 of the \"Serializing a Decimal\" specification.\n   * This rounding style is known as \"even rounding\", \"banker's rounding\", or \"commercial rounding\".\n   *\n   * @param value - The value to round\n   * @param precision - The number of decimal places to round to\n   * @returns The rounded value\n   *\n   * @group Utils\n   *\n   * @beta\n   */\n  function roundToEven(value, precision) {\n    if (value < 0) {\n      return -roundToEven(-value, precision);\n    }\n    var decimalShift = Math.pow(10, precision);\n    var isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;\n    if (isEquidistant) {\n      // If the tail of the decimal place is 'equidistant' we round to the nearest even value\n      var flooredValue = Math.floor(value * decimalShift);\n      return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;\n    } else {\n      // Otherwise, proceed as normal\n      return Math.round(value * decimalShift) / decimalShift;\n    }\n  }\n\n  var DECIMAL = 'Decimal';\n\n  // 4.1.5.  Serializing a Decimal\n  //\n  // Given a decimal number as input_decimal, return an ASCII string\n  // suitable for use in a HTTP field value.\n  //\n  // 1.   If input_decimal is not a decimal number, fail serialization.\n  //\n  // 2.   If input_decimal has more than three significant digits to the\n  //      right of the decimal point, round it to three decimal places,\n  //      rounding the final digit to the nearest value, or to the even\n  //      value if it is equidistant.\n  //\n  // 3.   If input_decimal has more than 12 significant digits to the left\n  //      of the decimal point after rounding, fail serialization.\n  //\n  // 4.   Let output be an empty string.\n  //\n  // 5.   If input_decimal is less than (but not equal to) 0, append \"-\"\n  //      to output.\n  //\n  // 6.   Append input_decimal's integer component represented in base 10\n  //      (using only decimal digits) to output; if it is zero, append\n  //      \"0\".\n  //\n  // 7.   Append \".\" to output.\n  //\n  // 8.   If input_decimal's fractional component is zero, append \"0\" to\n  //      output.\n  //\n  // 9.   Otherwise, append the significant digits of input_decimal's\n  //      fractional component represented in base 10 (using only decimal\n  //      digits) to output.\n  //\n  // 10.  Return output.\n  function serializeDecimal(value) {\n    var roundedValue = roundToEven(value, 3); // round to 3 decimal places\n    if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {\n      throw serializeError(value, DECIMAL);\n    }\n    var stringValue = roundedValue.toString();\n    return stringValue.includes('.') ? stringValue : stringValue + \".0\";\n  }\n\n  var STRING = 'String';\n\n  var STRING_REGEX = /[\\x00-\\x1f\\x7f]+/;\n\n  // 4.1.6.  Serializing a String\n  //\n  // Given a String as input_string, return an ASCII string suitable for\n  // use in a HTTP field value.\n  //\n  // 1.  Convert input_string into a sequence of ASCII characters; if\n  //     conversion fails, fail serialization.\n  //\n  // 2.  If input_string contains characters in the range %x00-1f or %x7f\n  //     (i.e., not in VCHAR or SP), fail serialization.\n  //\n  // 3.  Let output be the string DQUOTE.\n  //\n  // 4.  For each character char in input_string:\n  //\n  //     1.  If char is \"\\\" or DQUOTE:\n  //\n  //         1.  Append \"\\\" to output.\n  //\n  //     2.  Append char to output.\n  //\n  // 5.  Append DQUOTE to output.\n  //\n  // 6.  Return output.\n  function serializeString(value) {\n    if (STRING_REGEX.test(value)) {\n      throw serializeError(value, STRING);\n    }\n    return \"\\\"\" + value.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + \"\\\"\";\n  }\n\n  /**\n   * Converts a symbol to a string.\n   *\n   * @param symbol - The symbol to convert.\n   *\n   * @returns The string representation of the symbol.\n   *\n   * @internal\n   */\n  function symbolToStr(symbol) {\n    return symbol.description || symbol.toString().slice(7, -1);\n  }\n\n  var TOKEN = 'Token';\n\n  function serializeToken(token) {\n    var value = symbolToStr(token);\n    if (/^([a-zA-Z*])([!#$%&'*+\\-.^_`|~\\w:/]*)$/.test(value) === false) {\n      throw serializeError(value, TOKEN);\n    }\n    return value;\n  }\n\n  // 4.1.3.1.  Serializing a Bare Item\n  //\n  // Given an Item as input_item, return an ASCII string suitable for use\n  // in a HTTP field value.\n  //\n  // 1.  If input_item is an Integer, return the result of running\n  //     Serializing an Integer (Section 4.1.4) with input_item.\n  //\n  // 2.  If input_item is a Decimal, return the result of running\n  //     Serializing a Decimal (Section 4.1.5) with input_item.\n  //\n  // 3.  If input_item is a String, return the result of running\n  //     Serializing a String (Section 4.1.6) with input_item.\n  //\n  // 4.  If input_item is a Token, return the result of running\n  //     Serializing a Token (Section 4.1.7) with input_item.\n  //\n  // 5.  If input_item is a Boolean, return the result of running\n  //     Serializing a Boolean (Section 4.1.9) with input_item.\n  //\n  // 6.  If input_item is a Byte Sequence, return the result of running\n  //     Serializing a Byte Sequence (Section 4.1.8) with input_item.\n  //\n  // 7.  If input_item is a Date, return the result of running Serializing\n  //     a Date (Section 4.1.10) with input_item.\n  //\n  // 8.  Otherwise, fail serialization.\n  function serializeBareItem(value) {\n    switch (typeof value) {\n      case 'number':\n        if (!isFiniteNumber(value)) {\n          throw serializeError(value, BARE_ITEM);\n        }\n        if (Number.isInteger(value)) {\n          return serializeInteger(value);\n        }\n        return serializeDecimal(value);\n      case 'string':\n        return serializeString(value);\n      case 'symbol':\n        return serializeToken(value);\n      case 'boolean':\n        return serializeBoolean(value);\n      case 'object':\n        if (value instanceof Date) {\n          return serializeDate(value);\n        }\n        if (value instanceof Uint8Array) {\n          return serializeByteSequence(value);\n        }\n        if (value instanceof SfToken) {\n          return serializeToken(value);\n        }\n      default:\n        // fail\n        throw serializeError(value, BARE_ITEM);\n    }\n  }\n\n  var KEY = 'Key';\n\n  // 4.1.1.3.  Serializing a Key\n  //\n  // Given a key as input_key, return an ASCII string suitable for use in\n  // a HTTP field value.\n  //\n  // 1.  Convert input_key into a sequence of ASCII characters; if\n  //     conversion fails, fail serialization.\n  //\n  // 2.  If input_key contains characters not in lcalpha, DIGIT, \"_\", \"-\",\n  //     \".\", or \"*\" fail serialization.\n  //\n  // 3.  If the first character of input_key is not lcalpha or \"*\", fail\n  //     serialization.\n  //\n  // 4.  Let output be an empty string.\n  //\n  // 5.  Append input_key to output.\n  //\n  // 6.  Return output.\n  function serializeKey(value) {\n    if (/^[a-z*][a-z0-9\\-_.*]*$/.test(value) === false) {\n      throw serializeError(value, KEY);\n    }\n    return value;\n  }\n\n  // 4.1.1.2.  Serializing Parameters\n  //\n  // Given an ordered Dictionary as input_parameters (each member having a\n  // param_name and a param_value), return an ASCII string suitable for\n  // use in a HTTP field value.\n  //\n  // 1.  Let output be an empty string.\n  //\n  // 2.  For each param_name with a value of param_value in\n  //     input_parameters:\n  //\n  //     1.  Append \";\" to output.\n  //\n  //     2.  Append the result of running Serializing a Key\n  //         (Section 4.1.1.3) with param_name to output.\n  //\n  //     3.  If param_value is not Boolean true:\n  //\n  //         1.  Append \"=\" to output.\n  //\n  //         2.  Append the result of running Serializing a bare Item\n  //             (Section 4.1.3.1) with param_value to output.\n  //\n  // 3.  Return output.\n  function serializeParams(params) {\n    if (params == null) {\n      return '';\n    }\n    return Object.entries(params).map(function (_ref) {\n      var key = _ref[0],\n        value = _ref[1];\n      if (value === true) {\n        return \";\" + serializeKey(key); // omit true\n      }\n      return \";\" + serializeKey(key) + \"=\" + serializeBareItem(value);\n    }).join('');\n  }\n\n  // 4.1.3.  Serializing an Item\n  //\n  // Given an Item as bare_item and Parameters as item_parameters, return\n  // an ASCII string suitable for use in a HTTP field value.\n  //\n  // 1.  Let output be an empty string.\n  //\n  // 2.  Append the result of running Serializing a Bare Item\n  //     Section 4.1.3.1 with bare_item to output.\n  //\n  // 3.  Append the result of running Serializing Parameters\n  //     Section 4.1.1.2 with item_parameters to output.\n  //\n  // 4.  Return output.\n  function serializeItem(value) {\n    if (value instanceof SfItem) {\n      return \"\" + serializeBareItem(value.value) + serializeParams(value.params);\n    } else {\n      return serializeBareItem(value);\n    }\n  }\n\n  // 4.1.1.1.  Serializing an Inner List\n  //\n  // Given an array of (member_value, parameters) tuples as inner_list,\n  // and parameters as list_parameters, return an ASCII string suitable\n  // for use in a HTTP field value.\n  //\n  // 1.  Let output be the string \"(\".\n  //\n  // 2.  For each (member_value, parameters) of inner_list:\n  //\n  //     1.  Append the result of running Serializing an Item\n  //         (Section 4.1.3) with (member_value, parameters) to output.\n  //\n  //     2.  If more values remain in inner_list, append a single SP to\n  //         output.\n  //\n  // 3.  Append \")\" to output.\n  //\n  // 4.  Append the result of running Serializing Parameters\n  //     (Section 4.1.1.2) with list_parameters to output.\n  //\n  // 5.  Return output.\n  function serializeInnerList(value) {\n    return \"(\" + value.value.map(serializeItem).join(' ') + \")\" + serializeParams(value.params);\n  }\n\n  // 4.1.2.  Serializing a Dictionary\n  //\n  // Given an ordered Dictionary as input_dictionary (each member having a\n  // member_name and a tuple value of (member_value, parameters)), return\n  // an ASCII string suitable for use in a HTTP field value.\n  //\n  // 1.  Let output be an empty string.\n  //\n  // 2.  For each member_name with a value of (member_value, parameters)\n  //     in input_dictionary:\n  //\n  //     1.  Append the result of running Serializing a Key\n  //         (Section 4.1.1.3) with member's member_name to output.\n  //\n  //     2.  If member_value is Boolean true:\n  //\n  //         1.  Append the result of running Serializing Parameters\n  //             (Section 4.1.1.2) with parameters to output.\n  //\n  //     3.  Otherwise:\n  //\n  //         1.  Append \"=\" to output.\n  //\n  //         2.  If member_value is an array, append the result of running\n  //             Serializing an Inner List (Section 4.1.1.1) with\n  //             (member_value, parameters) to output.\n  //\n  //         3.  Otherwise, append the result of running Serializing an\n  //             Item (Section 4.1.3) with (member_value, parameters) to\n  //             output.\n  //\n  //     4.  If more members remain in input_dictionary:\n  //\n  //         1.  Append \",\" to output.\n  //\n  //         2.  Append a single SP to output.\n  //\n  // 3.  Return output.\n  function serializeDict(dict, options) {\n    if (options === void 0) {\n      options = {\n        whitespace: true\n      };\n    }\n    if (typeof dict !== 'object' || dict == null) {\n      throw serializeError(dict, DICT);\n    }\n    var entries = dict instanceof Map ? dict.entries() : Object.entries(dict);\n    var optionalWhiteSpace = (options === null || options === void 0 ? void 0 : options.whitespace) ? ' ' : '';\n    return Array.from(entries).map(function (_ref) {\n      var key = _ref[0],\n        item = _ref[1];\n      if (item instanceof SfItem === false) {\n        item = new SfItem(item);\n      }\n      var output = serializeKey(key);\n      if (item.value === true) {\n        output += serializeParams(item.params);\n      } else {\n        output += '=';\n        if (Array.isArray(item.value)) {\n          output += serializeInnerList(item);\n        } else {\n          output += serializeItem(item);\n        }\n      }\n      return output;\n    }).join(\",\" + optionalWhiteSpace);\n  }\n\n  /**\n   * Encode an object into a structured field dictionary\n   *\n   * @param value - The structured field dictionary to encode\n   * @param options - Encoding options\n   *\n   * @returns The structured field string\n   *\n   * @group Structured Field\n   *\n   * @beta\n   */\n  function encodeSfDict(value, options) {\n    return serializeDict(value, options);\n  }\n\n  /**\n   * CMCD object header name.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_OBJECT = 'CMCD-Object';\n\n  /**\n   * CMCD request header name.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_REQUEST = 'CMCD-Request';\n\n  /**\n   * CMCD session header name.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_SESSION = 'CMCD-Session';\n\n  /**\n   * CMCD status header name.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_STATUS = 'CMCD-Status';\n\n  /**\n   * The map of CMCD keys to their appropriate header shard.\n   *\n   * @group CMCD\n   *\n   * @internal\n   */\n  var CMCD_HEADER_MAP = {\n    // Object\n    br: CMCD_OBJECT,\n    ab: CMCD_OBJECT,\n    d: CMCD_OBJECT,\n    ot: CMCD_OBJECT,\n    tb: CMCD_OBJECT,\n    tpb: CMCD_OBJECT,\n    lb: CMCD_OBJECT,\n    tab: CMCD_OBJECT,\n    lab: CMCD_OBJECT,\n    url: CMCD_OBJECT,\n    // Request\n    pb: CMCD_REQUEST,\n    bl: CMCD_REQUEST,\n    tbl: CMCD_REQUEST,\n    dl: CMCD_REQUEST,\n    ltc: CMCD_REQUEST,\n    mtp: CMCD_REQUEST,\n    nor: CMCD_REQUEST,\n    nrr: CMCD_REQUEST,\n    rc: CMCD_REQUEST,\n    sn: CMCD_REQUEST,\n    sta: CMCD_REQUEST,\n    su: CMCD_REQUEST,\n    ttfb: CMCD_REQUEST,\n    ttfbb: CMCD_REQUEST,\n    ttlb: CMCD_REQUEST,\n    cmsdd: CMCD_REQUEST,\n    cmsds: CMCD_REQUEST,\n    smrt: CMCD_REQUEST,\n    df: CMCD_REQUEST,\n    cs: CMCD_REQUEST,\n    // TODO: Which header to put the `ts` field is not defined yet.\n    ts: CMCD_REQUEST,\n    // Session\n    cid: CMCD_SESSION,\n    pr: CMCD_SESSION,\n    sf: CMCD_SESSION,\n    sid: CMCD_SESSION,\n    st: CMCD_SESSION,\n    v: CMCD_SESSION,\n    msd: CMCD_SESSION,\n    // Status\n    bs: CMCD_STATUS,\n    bsd: CMCD_STATUS,\n    cdn: CMCD_STATUS,\n    rtp: CMCD_STATUS,\n    bg: CMCD_STATUS,\n    pt: CMCD_STATUS,\n    ec: CMCD_STATUS,\n    e: CMCD_STATUS\n  };\n\n  /**\n   * CMCD header fields.\n   *\n   * @group CMCD\n   *\n   * @enum\n   *\n   * @beta\n   */\n  var CmcdHeaderField = {\n    /**\n     * keys whose values vary with each request.\n     */\n    REQUEST: CMCD_REQUEST};\n\n  function createHeaderMap(headerMap) {\n    return Object.keys(headerMap).reduce(function (acc, field) {\n      var _a;\n      (_a = headerMap[field]) === null || _a === void 0 ? void 0 : _a.forEach(function (key) {\n        return acc[key] = field;\n      });\n      return acc;\n    }, {});\n  }\n  /**\n   * Group a CMCD data object into header shards\n   *\n   * @param cmcd - The CMCD data object to convert.\n   * @param customHeaderMap - A map of CMCD header fields to custom CMCD keys.\n   *\n   * @returns The CMCD header shards.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  function groupCmcdHeaders(cmcd, customHeaderMap) {\n    var result = {};\n    if (!cmcd) {\n      return result;\n    }\n    var keys = Object.keys(cmcd);\n    var custom = customHeaderMap ? createHeaderMap(customHeaderMap) : {};\n    return keys.reduce(function (acc, key) {\n      var _a;\n      var field = CMCD_HEADER_MAP[key] || custom[key] || CmcdHeaderField.REQUEST;\n      var data = (_a = acc[field]) !== null && _a !== void 0 ? _a : acc[field] = {};\n      data[key] = cmcd[key];\n      return acc;\n    }, result);\n  }\n\n  /**\n   * Checks if the given key is a token field.\n   *\n   * @param key - The key to check.\n   *\n   * @returns `true` if the key is a token field.\n   *\n   * @internal\n   */\n  function isTokenField(key) {\n    return ['ot', 'sf', 'st', 'e', 'sta'].includes(key);\n  }\n\n  /**\n   * Checks if the given value is valid\n   *\n   * @param value - The value to check.\n   *\n   * @returns `true` if the key is a value is valid.\n   *\n   * @internal\n   */\n  function isValid(value) {\n    if (typeof value === 'number') {\n      return isFiniteNumber(value);\n    }\n    return value != null && value !== '' && value !== false;\n  }\n\n  /**\n   * CMCD event mode variable name.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_EVENT_MODE = 'event';\n\n  /**\n   * Constructs a relative path from a URL.\n   *\n   * @param url - The destination URL\n   * @param base - The base URL\n   * @returns The relative path\n   *\n   * @group Utils\n   *\n   * @beta\n   */\n  function urlToRelativePath(url, base) {\n    var to = new URL(url);\n    var from = new URL(base);\n    if (to.origin !== from.origin) {\n      return url;\n    }\n    var toPath = to.pathname.split('/').slice(1);\n    var fromPath = from.pathname.split('/').slice(1, -1);\n    // remove common parents\n    while (toPath[0] === fromPath[0]) {\n      toPath.shift();\n      fromPath.shift();\n    }\n    // add back paths\n    while (fromPath.length) {\n      fromPath.shift();\n      toPath.unshift('..');\n    }\n    var relativePath = toPath.join('/');\n    // preserve query parameters and hash of the destination url\n    return relativePath + to.search + to.hash;\n  }\n\n  var toRounded = function toRounded(value) {\n    return Math.round(value);\n  };\n  var _toUrlSafe = function toUrlSafe(value, options) {\n    if (Array.isArray(value)) {\n      return value.map(function (item) {\n        return _toUrlSafe(item, options);\n      });\n    }\n    if (value instanceof SfItem && typeof value.value === 'string') {\n      return new SfItem(_toUrlSafe(value.value, options), value.params);\n    } else {\n      if (options.baseUrl) {\n        value = urlToRelativePath(value, options.baseUrl);\n      }\n      return options.version === 1 ? encodeURIComponent(value) : value;\n    }\n  };\n  var toHundred = function toHundred(value) {\n    return toRounded(value / 100) * 100;\n  };\n  var nor = function nor(value, options) {\n    var norValue = value;\n    if (options.version >= 2) {\n      if (value instanceof SfItem && typeof value.value === 'string') {\n        norValue = new SfItem([value]);\n      } else if (typeof value === 'string') {\n        norValue = [value];\n      }\n    }\n    return _toUrlSafe(norValue, options);\n  };\n  /**\n   * The default formatters for CMCD values.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_FORMATTER_MAP = {\n    /**\n     * Bitrate (kbps) rounded integer\n     */\n    br: toRounded,\n    /**\n     * Duration (milliseconds) rounded integer\n     */\n    d: toRounded,\n    /**\n     * Buffer Length (milliseconds) rounded nearest 100ms\n     */\n    bl: toHundred,\n    /**\n     * Deadline (milliseconds) rounded nearest 100ms\n     */\n    dl: toHundred,\n    /**\n     * Measured Throughput (kbps) rounded nearest 100kbps\n     */\n    mtp: toHundred,\n    /**\n     * Next Object Request URL encoded\n     */\n    nor: nor,\n    /**\n     * Requested maximum throughput (kbps) rounded nearest 100kbps\n     */\n    rtp: toHundred,\n    /**\n     * Top Bitrate (kbps) rounded integer\n     */\n    tb: toRounded\n  };\n\n  /**\n   * CMCD request mode variable name.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_REQUEST_MODE = 'request';\n\n  /**\n   * CMCD response mode variable name.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_RESPONSE_MODE = 'response';\n\n  /**\n   * Defines the common keys for CMCD (Common Media Client Data) version 2.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_COMMON_KEYS = ['ab', 'bg', 'bl', 'br', 'bs', 'bsd', 'cdn', 'cid', 'cs', 'df', 'ec', 'lab', 'lb', 'ltc', 'msd', 'mtp', 'pb', 'pr', 'pt', 'sf', 'sid', 'sn', 'st', 'sta', 'tab', 'tb', 'tbl', 'tpb', 'ts', 'v'];\n\n  /**\n   * Defines the event-specific keys for CMCD (Common Media Client Data) version 2.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_EVENT_KEYS = ['e'];\n\n  var CUSTOM_KEY_REGEX = /^[a-zA-Z0-9-.]+-[a-zA-Z0-9-.]+$/;\n  /**\n   * Check if a key is a custom key.\n   *\n   * @param key - The key to check.\n   *\n   * @returns `true` if the key is a custom key, `false` otherwise.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  function isCmcdCustomKey(key) {\n    return CUSTOM_KEY_REGEX.test(key);\n  }\n\n  /**\n   * Check if a key is a valid CMCD event key.\n   *\n   * @param key - The key to check.\n   *\n   * @returns `true` if the key is a valid CMCD event key, `false` otherwise.\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @example\n   * {@includeCode ../../test/cmcd/isCmcdEventKey.test.ts#example}\n   */\n  function isCmcdEventKey(key) {\n    return CMCD_COMMON_KEYS.includes(key) || CMCD_EVENT_KEYS.includes(key) || isCmcdCustomKey(key);\n  }\n\n  /**\n   * Defines the request-specific keys for CMCD (Common Media Client Data) version 2.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_REQUEST_KEYS = ['d', 'dl', 'nor', 'ot', 'rtp', 'su'];\n\n  /**\n   * Check if a key is a valid CMCD request key.\n   *\n   * @param key - The key to check.\n   *\n   * @returns `true` if the key is a valid CMCD request key, `false` otherwise.\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @example\n   * {@includeCode ../../test/cmcd/isCmcdRequestKey.test.ts#example}\n   */\n  function isCmcdRequestKey(key) {\n    return CMCD_COMMON_KEYS.includes(key) || CMCD_REQUEST_KEYS.includes(key) || isCmcdCustomKey(key);\n  }\n\n  /**\n   * CMCD v2 - Response-only and timing keys.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_RESPONSE_KEYS = ['cmsdd', 'cmsds', 'rc', 'smrt', 'ttfb', 'ttfbb', 'ttlb', 'url'];\n\n  /**\n   * Check if a key is a valid CMCD response key.\n   *\n   * @param key - The key to check.\n   *\n   * @returns `true` if the key is a valid CMCD request key, `false` otherwise.\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @example\n   * {@includeCode ../../test/cmcd/isCmcdResponseKey.test.ts#example}\n   */\n  function isCmcdResponseKey(key) {\n    return CMCD_COMMON_KEYS.includes(key) || CMCD_REQUEST_KEYS.includes(key) || CMCD_RESPONSE_KEYS.includes(key) || isCmcdCustomKey(key);\n  }\n\n  /**\n   * Defines the keys for CMCD (Common Media Client Data) version 1.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_V1_KEYS = ['bl', 'br', 'bs', 'cid', 'd', 'dl', 'mtp', 'nor', 'nrr', 'ot', 'pr', 'rtp', 'sf', 'sid', 'st', 'su', 'tb', 'v'];\n\n  /**\n   * Filter function for CMCD v1 keys.\n   *\n   * @param key - The CMCD key to filter.\n   *\n   * @returns `true` if the key should be included, `false` otherwise.\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @example\n   * {@includeCode ../../test/cmcd/isCmcdV1Key.test.ts#example}\n   */\n  function isCmcdV1Key(key) {\n    return CMCD_V1_KEYS.includes(key) || isCmcdCustomKey(key);\n  }\n\n  var _filterMap;\n  var filterMap = (_filterMap = {}, _filterMap[CMCD_RESPONSE_MODE] = isCmcdResponseKey, _filterMap[CMCD_EVENT_MODE] = isCmcdEventKey, _filterMap[CMCD_REQUEST_MODE] = isCmcdRequestKey, _filterMap);\n  /**\n   * Convert a generic object to CMCD data.\n   *\n   * @param obj - The CMCD object to process.\n   * @param options - Options for encoding.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  function prepareCmcdData(obj, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var results = {};\n    if (obj == null || typeof obj !== 'object') {\n      return results;\n    }\n    var version = options.version || obj['v'] || 1;\n    var reportingMode = options.reportingMode || CMCD_REQUEST_MODE;\n    var keyFilter = version === 1 ? isCmcdV1Key : filterMap[reportingMode];\n    // Filter keys based on the version, reporting mode and options\n    var keys = Object.keys(obj).filter(keyFilter);\n    var filter = options.filter;\n    if (typeof filter === 'function') {\n      keys = keys.filter(filter);\n    }\n    // Ensure all required keys are present before sorting\n    var needsTimestamp = reportingMode === CMCD_RESPONSE_MODE || reportingMode === CMCD_EVENT_MODE;\n    if (needsTimestamp && !keys.includes('ts')) {\n      keys.push('ts');\n    }\n    if (version > 1 && !keys.includes('v')) {\n      keys.push('v');\n    }\n    var formatters = _extends({}, CMCD_FORMATTER_MAP, options.formatters);\n    var formatterOptions = {\n      version: version,\n      reportingMode: reportingMode,\n      baseUrl: options.baseUrl\n    };\n    keys.sort().forEach(function (key) {\n      var value = obj[key];\n      var formatter = formatters[key];\n      if (typeof formatter === 'function') {\n        value = formatter(value, formatterOptions);\n      }\n      // Version should only be reported if not equal to 1.\n      if (key === 'v') {\n        if (version === 1) {\n          return;\n        } else {\n          value = version;\n        }\n      }\n      // Playback rate should only be sent if not equal to 1.\n      if (key == 'pr' && value === 1) {\n        return;\n      }\n      // Ensure a timestamp is set for response and event modes\n      if (needsTimestamp && key === 'ts' && !isFiniteNumber(value)) {\n        value = Date.now();\n      }\n      // ignore invalid values\n      if (!isValid(value)) {\n        return;\n      }\n      if (isTokenField(key) && typeof value === 'string') {\n        value = new SfToken(value);\n      }\n      results[key] = value;\n    });\n    return results;\n  }\n\n  /**\n   * Convert a CMCD data object to request headers\n   *\n   * @param cmcd - The CMCD data object to convert.\n   * @param options - Options for encoding the CMCD object.\n   *\n   * @returns The CMCD header shards.\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @example\n   * {@includeCode ../../test/cmcd/toCmcdHeaders.test.ts#example}\n   */\n  function toCmcdHeaders(cmcd, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var result = {};\n    if (!cmcd) {\n      return result;\n    }\n    var data = prepareCmcdData(cmcd, options);\n    var shards = groupCmcdHeaders(data, options === null || options === void 0 ? void 0 : options.customHeaderMap);\n    return Object.entries(shards).reduce(function (acc, _ref) {\n      var field = _ref[0],\n        value = _ref[1];\n      var shard = encodeSfDict(value, {\n        whitespace: false\n      });\n      if (shard) {\n        acc[field] = shard;\n      }\n      return acc;\n    }, result);\n  }\n\n  /**\n   * Append CMCD query args to a header object.\n   *\n   * @param headers - The headers to append to.\n   * @param cmcd - The CMCD object to append.\n   * @param options - Encode options.\n   *\n   * @returns The headers with the CMCD header shards appended.\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @example\n   * {@includeCode ../../test/cmcd/appendCmcdHeaders.test.ts#example}\n   */\n  function appendCmcdHeaders(headers, cmcd, options) {\n    return _extends(headers, toCmcdHeaders(cmcd, options));\n  }\n\n  /**\n   * CMCD parameter name.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_PARAM = 'CMCD';\n\n  /**\n   * Encode a CMCD object to a string.\n   *\n   * @param cmcd - The CMCD object to encode.\n   * @param options - Options for encoding.\n   *\n   * @returns The encoded CMCD string.\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @example\n   * {@includeCode ../../test/cmcd/encodeCmcd.test.ts#example}\n   */\n  function encodeCmcd(cmcd, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!cmcd) {\n      return '';\n    }\n    return encodeSfDict(prepareCmcdData(cmcd, options), {\n      whitespace: false\n    });\n  }\n\n  /**\n   * Convert a CMCD data object to a URL encoded string.\n   *\n   * @param cmcd - The CMCD object to convert.\n   * @param options - Options for encoding the CMCD object.\n   *\n   * @returns The URL encoded CMCD data.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  function toCmcdUrl(cmcd, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!cmcd) {\n      return '';\n    }\n    var params = encodeCmcd(cmcd, options);\n    return encodeURIComponent(params);\n  }\n\n  /**\n   * Convert a CMCD data object to a query arg.\n   *\n   * @param cmcd - The CMCD object to convert.\n   * @param options - Options for encoding the CMCD object.\n   *\n   * @returns The CMCD query arg.\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @example\n   * {@includeCode ../../test/cmcd/toCmcdQuery.test.ts#example}\n   */\n  function toCmcdQuery(cmcd, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!cmcd) {\n      return '';\n    }\n    var value = toCmcdUrl(cmcd, options);\n    return CMCD_PARAM + \"=\" + value;\n  }\n\n  var REGEX = /CMCD=[^&#]+/;\n  /**\n   * Append CMCD query args to a URL.\n   *\n   * @param url - The URL to append to.\n   * @param cmcd - The CMCD object to append.\n   * @param options - Options for encoding the CMCD object.\n   *\n   * @returns The URL with the CMCD query args appended.\n   *\n   * @group CMCD\n   *\n   * @beta\n   *\n   * @example\n   * {@includeCode ../../test/cmcd/appendCmcdQuery.test.ts#example}\n   */\n  function appendCmcdQuery(url, cmcd, options) {\n    // TODO: Replace with URLSearchParams once we drop Safari < 10.1 & Chrome < 49 support.\n    // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n    var query = toCmcdQuery(cmcd, options);\n    if (!query) {\n      return url;\n    }\n    if (REGEX.test(url)) {\n      return url.replace(REGEX, query);\n    }\n    var separator = url.includes('?') ? '&' : '?';\n    return \"\" + url + separator + query;\n  }\n\n  /**\n   * Controller to deal with Common Media Client Data (CMCD)\n   * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n   */\n  var CMCDController = /*#__PURE__*/function () {\n    function CMCDController(hls) {\n      var _this = this;\n      this.hls = void 0;\n      this.config = void 0;\n      this.media = void 0;\n      this.sid = void 0;\n      this.cid = void 0;\n      this.useHeaders = false;\n      this.includeKeys = void 0;\n      this.initialized = false;\n      this.starved = false;\n      this.buffering = true;\n      this.audioBuffer = void 0;\n      this.videoBuffer = void 0;\n      this.onWaiting = function () {\n        if (_this.initialized) {\n          _this.starved = true;\n        }\n        _this.buffering = true;\n      };\n      this.onPlaying = function () {\n        if (!_this.initialized) {\n          _this.initialized = true;\n        }\n        _this.buffering = false;\n      };\n      /**\n       * Apply CMCD data to a manifest request.\n       */\n      this.applyPlaylistData = function (context) {\n        try {\n          _this.apply(context, {\n            ot: CmcdObjectType.MANIFEST,\n            su: !_this.initialized\n          });\n        } catch (error) {\n          _this.hls.logger.warn('Could not generate manifest CMCD data.', error);\n        }\n      };\n      /**\n       * Apply CMCD data to a segment request\n       */\n      this.applyFragmentData = function (context) {\n        try {\n          var frag = context.frag,\n            part = context.part;\n          var level = _this.hls.levels[frag.level];\n          var ot = _this.getObjectType(frag);\n          var data = {\n            d: (part || frag).duration * 1000,\n            ot: ot\n          };\n          if (ot === CmcdObjectType.VIDEO || ot === CmcdObjectType.AUDIO || ot == CmcdObjectType.MUXED) {\n            data.br = level.bitrate / 1000;\n            data.tb = _this.getTopBandwidth(ot) / 1000;\n            data.bl = _this.getBufferLength(ot);\n          }\n          var next = part ? _this.getNextPart(part) : _this.getNextFrag(frag);\n          if (next != null && next.url && next.url !== frag.url) {\n            data.nor = next.url;\n          }\n          _this.apply(context, data);\n        } catch (error) {\n          _this.hls.logger.warn('Could not generate segment CMCD data.', error);\n        }\n      };\n      this.hls = hls;\n      var config = this.config = hls.config;\n      var cmcd = config.cmcd;\n      if (cmcd != null) {\n        config.pLoader = this.createPlaylistLoader();\n        config.fLoader = this.createFragmentLoader();\n        this.sid = cmcd.sessionId || hls.sessionId;\n        this.cid = cmcd.contentId;\n        this.useHeaders = cmcd.useHeaders === true;\n        this.includeKeys = cmcd.includeKeys;\n        this.registerListeners();\n      }\n    }\n    var _proto = CMCDController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.onMediaDetached();\n\n      // @ts-ignore\n      this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n      // @ts-ignore\n      this.onWaiting = this.onPlaying = this.media = null;\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      this.media = data.media;\n      this.media.addEventListener('waiting', this.onWaiting);\n      this.media.addEventListener('playing', this.onPlaying);\n    };\n    _proto.onMediaDetached = function onMediaDetached() {\n      if (!this.media) {\n        return;\n      }\n      this.media.removeEventListener('waiting', this.onWaiting);\n      this.media.removeEventListener('playing', this.onPlaying);\n\n      // @ts-ignore\n      this.media = null;\n    };\n    _proto.onBufferCreated = function onBufferCreated(event, data) {\n      var _data$tracks$audio, _data$tracks$video;\n      this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;\n      this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;\n    };\n    /**\n     * Create baseline CMCD data\n     */\n    _proto.createData = function createData() {\n      var _this$media;\n      return {\n        v: 1,\n        sf: CmcdStreamingFormat.HLS,\n        sid: this.sid,\n        cid: this.cid,\n        pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,\n        mtp: this.hls.bandwidthEstimate / 1000\n      };\n    }\n\n    /**\n     * Apply CMCD data to a request.\n     */;\n    _proto.apply = function apply(context, data) {\n      if (data === void 0) {\n        data = {};\n      }\n      // apply baseline data\n      _extends(data, this.createData());\n      var isVideo = data.ot === CmcdObjectType.INIT || data.ot === CmcdObjectType.VIDEO || data.ot === CmcdObjectType.MUXED;\n      if (this.starved && isVideo) {\n        data.bs = true;\n        data.su = true;\n        this.starved = false;\n      }\n      if (data.su == null) {\n        data.su = this.buffering;\n      }\n\n      // TODO: Implement rtp, nrr, dl\n\n      var includeKeys = this.includeKeys;\n      if (includeKeys) {\n        data = Object.keys(data).reduce(function (acc, key) {\n          includeKeys.includes(key) && (acc[key] = data[key]);\n          return acc;\n        }, {});\n      }\n      var options = {\n        baseUrl: context.url\n      };\n      if (this.useHeaders) {\n        if (!context.headers) {\n          context.headers = {};\n        }\n        appendCmcdHeaders(context.headers, data, options);\n      } else {\n        context.url = appendCmcdQuery(context.url, data, options);\n      }\n    };\n    _proto.getNextFrag = function getNextFrag(fragment) {\n      var _this$hls$levels$frag;\n      var levelDetails = (_this$hls$levels$frag = this.hls.levels[fragment.level]) == null ? void 0 : _this$hls$levels$frag.details;\n      if (levelDetails) {\n        var index = fragment.sn - levelDetails.startSN;\n        return levelDetails.fragments[index + 1];\n      }\n      return undefined;\n    };\n    _proto.getNextPart = function getNextPart(part) {\n      var _this$hls$levels$frag2;\n      var index = part.index,\n        fragment = part.fragment;\n      var partList = (_this$hls$levels$frag2 = this.hls.levels[fragment.level]) == null || (_this$hls$levels$frag2 = _this$hls$levels$frag2.details) == null ? void 0 : _this$hls$levels$frag2.partList;\n      if (partList) {\n        var sn = fragment.sn;\n        for (var i = partList.length - 1; i >= 0; i--) {\n          var p = partList[i];\n          if (p.index === index && p.fragment.sn === sn) {\n            return partList[i + 1];\n          }\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * The CMCD object type.\n     */;\n    _proto.getObjectType = function getObjectType(fragment) {\n      var type = fragment.type;\n      if (type === 'subtitle') {\n        return CmcdObjectType.TIMED_TEXT;\n      }\n      if (fragment.sn === 'initSegment') {\n        return CmcdObjectType.INIT;\n      }\n      if (type === 'audio') {\n        return CmcdObjectType.AUDIO;\n      }\n      if (type === 'main') {\n        if (!this.hls.audioTracks.length) {\n          return CmcdObjectType.MUXED;\n        }\n        return CmcdObjectType.VIDEO;\n      }\n      return undefined;\n    }\n\n    /**\n     * Get the highest bitrate.\n     */;\n    _proto.getTopBandwidth = function getTopBandwidth(type) {\n      var bitrate = 0;\n      var levels;\n      var hls = this.hls;\n      if (type === CmcdObjectType.AUDIO) {\n        levels = hls.audioTracks;\n      } else {\n        var max = hls.maxAutoLevel;\n        var len = max > -1 ? max + 1 : hls.levels.length;\n        levels = hls.levels.slice(0, len);\n      }\n      levels.forEach(function (level) {\n        if (level.bitrate > bitrate) {\n          bitrate = level.bitrate;\n        }\n      });\n      return bitrate > 0 ? bitrate : NaN;\n    }\n\n    /**\n     * Get the buffer length for a media type in milliseconds\n     */;\n    _proto.getBufferLength = function getBufferLength(type) {\n      var media = this.media;\n      var buffer = type === CmcdObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n      if (!buffer || !media) {\n        return NaN;\n      }\n      var info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n      return info.len * 1000;\n    }\n\n    /**\n     * Create a playlist loader\n     */;\n    _proto.createPlaylistLoader = function createPlaylistLoader() {\n      var pLoader = this.config.pLoader;\n      var apply = this.applyPlaylistData;\n      var Ctor = pLoader || this.config.loader;\n      return /*#__PURE__*/function () {\n        function CmcdPlaylistLoader(config) {\n          this.loader = void 0;\n          this.loader = new Ctor(config);\n        }\n        var _proto2 = CmcdPlaylistLoader.prototype;\n        _proto2.destroy = function destroy() {\n          this.loader.destroy();\n        };\n        _proto2.abort = function abort() {\n          this.loader.abort();\n        };\n        _proto2.load = function load(context, config, callbacks) {\n          apply(context);\n          this.loader.load(context, config, callbacks);\n        };\n        return _createClass(CmcdPlaylistLoader, [{\n          key: \"stats\",\n          get: function get() {\n            return this.loader.stats;\n          }\n        }, {\n          key: \"context\",\n          get: function get() {\n            return this.loader.context;\n          }\n        }]);\n      }();\n    }\n\n    /**\n     * Create a playlist loader\n     */;\n    _proto.createFragmentLoader = function createFragmentLoader() {\n      var fLoader = this.config.fLoader;\n      var apply = this.applyFragmentData;\n      var Ctor = fLoader || this.config.loader;\n      return /*#__PURE__*/function () {\n        function CmcdFragmentLoader(config) {\n          this.loader = void 0;\n          this.loader = new Ctor(config);\n        }\n        var _proto3 = CmcdFragmentLoader.prototype;\n        _proto3.destroy = function destroy() {\n          this.loader.destroy();\n        };\n        _proto3.abort = function abort() {\n          this.loader.abort();\n        };\n        _proto3.load = function load(context, config, callbacks) {\n          apply(context);\n          this.loader.load(context, config, callbacks);\n        };\n        return _createClass(CmcdFragmentLoader, [{\n          key: \"stats\",\n          get: function get() {\n            return this.loader.stats;\n          }\n        }, {\n          key: \"context\",\n          get: function get() {\n            return this.loader.context;\n          }\n        }]);\n      }();\n    };\n    return CMCDController;\n  }();\n\n  var PATHWAY_PENALTY_DURATION_MS = 300000;\n  var ContentSteeringController = /*#__PURE__*/function (_Logger) {\n    function ContentSteeringController(hls) {\n      var _this;\n      _this = _Logger.call(this, 'content-steering', hls.logger) || this;\n      _this.hls = void 0;\n      _this.loader = null;\n      _this.uri = null;\n      _this.pathwayId = '.';\n      _this._pathwayPriority = null;\n      _this.timeToLoad = 300;\n      _this.reloadTimer = -1;\n      _this.updated = 0;\n      _this.started = false;\n      _this.enabled = true;\n      _this.levels = null;\n      _this.audioTracks = null;\n      _this.subtitleTracks = null;\n      _this.penalizedPathways = {};\n      _this.hls = hls;\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(ContentSteeringController, _Logger);\n    var _proto = ContentSteeringController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.pathways = function pathways() {\n      return (this.levels || []).reduce(function (pathways, level) {\n        if (pathways.indexOf(level.pathwayId) === -1) {\n          pathways.push(level.pathwayId);\n        }\n        return pathways;\n      }, []);\n    };\n    _proto.startLoad = function startLoad() {\n      this.started = true;\n      this.clearTimeout();\n      if (this.enabled && this.uri) {\n        if (this.updated) {\n          var ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);\n          if (ttl > 0) {\n            this.scheduleRefresh(this.uri, ttl);\n            return;\n          }\n        }\n        this.loadSteeringManifest(this.uri);\n      }\n    };\n    _proto.stopLoad = function stopLoad() {\n      this.started = false;\n      if (this.loader) {\n        this.loader.destroy();\n        this.loader = null;\n      }\n      this.clearTimeout();\n    };\n    _proto.clearTimeout = function clearTimeout() {\n      if (this.reloadTimer !== -1) {\n        self.clearTimeout(this.reloadTimer);\n        this.reloadTimer = -1;\n      }\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.stopLoad();\n      // @ts-ignore\n      this.hls = null;\n      this.levels = this.audioTracks = this.subtitleTracks = null;\n    };\n    _proto.removeLevel = function removeLevel(levelToRemove) {\n      var levels = this.levels;\n      if (levels) {\n        this.levels = levels.filter(function (level) {\n          return level !== levelToRemove;\n        });\n      }\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.stopLoad();\n      this.enabled = true;\n      this.timeToLoad = 300;\n      this.updated = 0;\n      this.uri = null;\n      this.pathwayId = '.';\n      this.levels = this.audioTracks = this.subtitleTracks = null;\n    };\n    _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n      var contentSteering = data.contentSteering;\n      if (contentSteering === null) {\n        return;\n      }\n      this.pathwayId = contentSteering.pathwayId;\n      this.uri = contentSteering.uri;\n      if (this.started) {\n        this.startLoad();\n      }\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      this.audioTracks = data.audioTracks;\n      this.subtitleTracks = data.subtitleTracks;\n    };\n    _proto.onError = function onError(event, data) {\n      var errorAction = data.errorAction;\n      if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n        var levels = this.levels;\n        var pathwayPriority = this._pathwayPriority;\n        var errorPathway = this.pathwayId;\n        if (data.context) {\n          var _data$context = data.context,\n            groupId = _data$context.groupId,\n            pathwayId = _data$context.pathwayId,\n            type = _data$context.type;\n          if (groupId && levels) {\n            errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);\n          } else if (pathwayId) {\n            errorPathway = pathwayId;\n          }\n        }\n        if (!(errorPathway in this.penalizedPathways)) {\n          this.penalizedPathways[errorPathway] = performance.now();\n        }\n        if (!pathwayPriority && levels) {\n          // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n          pathwayPriority = this.pathways();\n        }\n        if (pathwayPriority && pathwayPriority.length > 1) {\n          this.updatePathwayPriority(pathwayPriority);\n          errorAction.resolved = this.pathwayId !== errorPathway;\n        }\n        if (data.details === ErrorDetails.BUFFER_APPEND_ERROR && !data.fatal) {\n          // Error will become fatal in buffer-controller when reaching `appendErrorMaxRetry`\n          // Stream-controllers are expected to reduce buffer length even if this is not deemed a QuotaExceededError\n          errorAction.resolved = true;\n        } else if (!errorAction.resolved) {\n          this.warn(\"Could not resolve \" + data.details + \" (\\\"\" + data.error.message + \"\\\") with content-steering for Pathway: \" + errorPathway + \" levels: \" + (levels ? levels.length : levels) + \" priorities: \" + stringify(pathwayPriority) + \" penalized: \" + stringify(this.penalizedPathways));\n        }\n      }\n    };\n    _proto.filterParsedLevels = function filterParsedLevels(levels) {\n      // Filter levels to only include those that are in the initial pathway\n      this.levels = levels;\n      var pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n      if (pathwayLevels.length === 0) {\n        var pathwayId = levels[0].pathwayId;\n        this.log(\"No levels found in Pathway \" + this.pathwayId + \". Setting initial Pathway to \\\"\" + pathwayId + \"\\\"\");\n        pathwayLevels = this.getLevelsForPathway(pathwayId);\n        this.pathwayId = pathwayId;\n      }\n      if (pathwayLevels.length !== levels.length) {\n        this.log(\"Found \" + pathwayLevels.length + \"/\" + levels.length + \" levels in Pathway \\\"\" + this.pathwayId + \"\\\"\");\n      }\n      return pathwayLevels;\n    };\n    _proto.getLevelsForPathway = function getLevelsForPathway(pathwayId) {\n      if (this.levels === null) {\n        return [];\n      }\n      return this.levels.filter(function (level) {\n        return pathwayId === level.pathwayId;\n      });\n    };\n    _proto.updatePathwayPriority = function updatePathwayPriority(pathwayPriority) {\n      this._pathwayPriority = pathwayPriority;\n      var levels;\n\n      // Evaluate if we should remove the pathway from the penalized list\n      var penalizedPathways = this.penalizedPathways;\n      var now = performance.now();\n      Object.keys(penalizedPathways).forEach(function (pathwayId) {\n        if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n          delete penalizedPathways[pathwayId];\n        }\n      });\n      for (var i = 0; i < pathwayPriority.length; i++) {\n        var pathwayId = pathwayPriority[i];\n        if (pathwayId in penalizedPathways) {\n          continue;\n        }\n        if (pathwayId === this.pathwayId) {\n          return;\n        }\n        var selectedIndex = this.hls.nextLoadLevel;\n        var selectedLevel = this.hls.levels[selectedIndex];\n        levels = this.getLevelsForPathway(pathwayId);\n        if (levels.length > 0) {\n          this.log(\"Setting Pathway to \\\"\" + pathwayId + \"\\\"\");\n          this.pathwayId = pathwayId;\n          reassignFragmentLevelIndexes(levels);\n          this.hls.trigger(Events.LEVELS_UPDATED, {\n            levels: levels\n          });\n          // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n          var levelAfterChange = this.hls.levels[selectedIndex];\n          if (selectedLevel && levelAfterChange && this.levels) {\n            if (levelAfterChange.attrs['STABLE-VARIANT-ID'] !== selectedLevel.attrs['STABLE-VARIANT-ID'] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n              this.log(\"Unstable Pathways change from bitrate \" + selectedLevel.bitrate + \" to \" + levelAfterChange.bitrate);\n            }\n            this.hls.nextLoadLevel = selectedIndex;\n          }\n          break;\n        }\n      }\n    };\n    _proto.getPathwayForGroupId = function getPathwayForGroupId(groupId, type, defaultPathway) {\n      var levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);\n      for (var i = 0; i < levels.length; i++) {\n        if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {\n          return levels[i].pathwayId;\n        }\n      }\n      return defaultPathway;\n    };\n    _proto.clonePathways = function clonePathways(pathwayClones) {\n      var _this2 = this;\n      var levels = this.levels;\n      if (!levels) {\n        return;\n      }\n      var audioGroupCloneMap = {};\n      var subtitleGroupCloneMap = {};\n      pathwayClones.forEach(function (pathwayClone) {\n        var cloneId = pathwayClone.ID,\n          baseId = pathwayClone['BASE-ID'],\n          uriReplacement = pathwayClone['URI-REPLACEMENT'];\n        if (levels.some(function (level) {\n          return level.pathwayId === cloneId;\n        })) {\n          return;\n        }\n        var clonedVariants = _this2.getLevelsForPathway(baseId).map(function (baseLevel) {\n          var attributes = new AttrList(baseLevel.attrs);\n          attributes['PATHWAY-ID'] = cloneId;\n          var clonedAudioGroupId = attributes.AUDIO && attributes.AUDIO + \"_clone_\" + cloneId;\n          var clonedSubtitleGroupId = attributes.SUBTITLES && attributes.SUBTITLES + \"_clone_\" + cloneId;\n          if (clonedAudioGroupId) {\n            audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n            attributes.AUDIO = clonedAudioGroupId;\n          }\n          if (clonedSubtitleGroupId) {\n            subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n            attributes.SUBTITLES = clonedSubtitleGroupId;\n          }\n          var url = performUriReplacement(baseLevel.uri, attributes['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', uriReplacement);\n          var clonedLevel = new Level({\n            attrs: attributes,\n            audioCodec: baseLevel.audioCodec,\n            bitrate: baseLevel.bitrate,\n            height: baseLevel.height,\n            name: baseLevel.name,\n            url: url,\n            videoCodec: baseLevel.videoCodec,\n            width: baseLevel.width\n          });\n          if (baseLevel.audioGroups) {\n            for (var i = 1; i < baseLevel.audioGroups.length; i++) {\n              clonedLevel.addGroupId('audio', baseLevel.audioGroups[i] + \"_clone_\" + cloneId);\n            }\n          }\n          if (baseLevel.subtitleGroups) {\n            for (var _i = 1; _i < baseLevel.subtitleGroups.length; _i++) {\n              clonedLevel.addGroupId('text', baseLevel.subtitleGroups[_i] + \"_clone_\" + cloneId);\n            }\n          }\n          return clonedLevel;\n        });\n        levels.push.apply(levels, clonedVariants);\n        cloneRenditionGroups(_this2.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n        cloneRenditionGroups(_this2.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n      });\n    };\n    _proto.loadSteeringManifest = function loadSteeringManifest(uri) {\n      var _this3 = this;\n      var config = this.hls.config;\n      var Loader = config.loader;\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      this.loader = new Loader(config);\n      var url;\n      try {\n        url = new self.URL(uri);\n      } catch (error) {\n        this.enabled = false;\n        this.log(\"Failed to parse Steering Manifest URI: \" + uri);\n        return;\n      }\n      if (url.protocol !== 'data:') {\n        var throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n        url.searchParams.set('_HLS_pathway', this.pathwayId);\n        url.searchParams.set('_HLS_throughput', '' + throughput);\n      }\n      var context = {\n        responseType: 'json',\n        url: url.href\n      };\n      var loadPolicy = config.steeringManifestLoadPolicy.default;\n      var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n      var loaderConfig = {\n        loadPolicy: loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n      };\n      var callbacks = {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          _this3.log(\"Loaded steering manifest: \\\"\" + url + \"\\\"\");\n          var steeringData = response.data;\n          if ((steeringData == null ? void 0 : steeringData.VERSION) !== 1) {\n            _this3.log(\"Steering VERSION \" + steeringData.VERSION + \" not supported!\");\n            return;\n          }\n          _this3.updated = performance.now();\n          _this3.timeToLoad = steeringData.TTL;\n          var reloadUri = steeringData['RELOAD-URI'],\n            pathwayClones = steeringData['PATHWAY-CLONES'],\n            pathwayPriority = steeringData['PATHWAY-PRIORITY'];\n          if (reloadUri) {\n            try {\n              _this3.uri = new self.URL(reloadUri, url).href;\n            } catch (error) {\n              _this3.enabled = false;\n              _this3.log(\"Failed to parse Steering Manifest RELOAD-URI: \" + reloadUri);\n              return;\n            }\n          }\n          _this3.scheduleRefresh(_this3.uri || context.url);\n          if (pathwayClones) {\n            _this3.clonePathways(pathwayClones);\n          }\n          var loadedSteeringData = {\n            steeringManifest: steeringData,\n            url: url.toString()\n          };\n          _this3.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);\n          if (pathwayPriority) {\n            _this3.updatePathwayPriority(pathwayPriority);\n          }\n        },\n        onError: function onError(error, context, networkDetails, stats) {\n          _this3.log(\"Error loading steering manifest: \" + error.code + \" \" + error.text + \" (\" + context.url + \")\");\n          _this3.stopLoad();\n          if (error.code === 410) {\n            _this3.enabled = false;\n            _this3.log(\"Steering manifest \" + context.url + \" no longer available\");\n            return;\n          }\n          var ttl = _this3.timeToLoad * 1000;\n          if (error.code === 429) {\n            var loader = _this3.loader;\n            if (typeof (loader == null ? void 0 : loader.getResponseHeader) === 'function') {\n              var retryAfter = loader.getResponseHeader('Retry-After');\n              if (retryAfter) {\n                ttl = parseFloat(retryAfter) * 1000;\n              }\n            }\n            _this3.log(\"Steering manifest \" + context.url + \" rate limited\");\n            return;\n          }\n          _this3.scheduleRefresh(_this3.uri || context.url, ttl);\n        },\n        onTimeout: function onTimeout(stats, context, networkDetails) {\n          _this3.log(\"Timeout loading steering manifest (\" + context.url + \")\");\n          _this3.scheduleRefresh(_this3.uri || context.url);\n        }\n      };\n      this.log(\"Requesting steering manifest: \" + url);\n      this.loader.load(context, loaderConfig, callbacks);\n    };\n    _proto.scheduleRefresh = function scheduleRefresh(uri, ttlMs) {\n      var _this4 = this;\n      if (ttlMs === void 0) {\n        ttlMs = this.timeToLoad * 1000;\n      }\n      this.clearTimeout();\n      this.reloadTimer = self.setTimeout(function () {\n        var _this4$hls;\n        var media = (_this4$hls = _this4.hls) == null ? void 0 : _this4$hls.media;\n        if (media && !media.ended) {\n          _this4.loadSteeringManifest(uri);\n          return;\n        }\n        _this4.scheduleRefresh(uri, _this4.timeToLoad * 1000);\n      }, ttlMs);\n    };\n    return _createClass(ContentSteeringController, [{\n      key: \"pathwayPriority\",\n      get: function get() {\n        return this._pathwayPriority;\n      },\n      set: function set(pathwayPriority) {\n        this.updatePathwayPriority(pathwayPriority);\n      }\n    }]);\n  }(Logger);\n  function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n    if (!tracks) {\n      return;\n    }\n    Object.keys(groupCloneMap).forEach(function (audioGroupId) {\n      var clonedTracks = tracks.filter(function (track) {\n        return track.groupId === audioGroupId;\n      }).map(function (track) {\n        var clonedTrack = _extends({}, track);\n        clonedTrack.details = undefined;\n        clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n        clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', uriReplacement);\n        clonedTrack.groupId = clonedTrack.attrs['GROUP-ID'] = groupCloneMap[audioGroupId];\n        clonedTrack.attrs['PATHWAY-ID'] = cloneId;\n        return clonedTrack;\n      });\n      tracks.push.apply(tracks, clonedTracks);\n    });\n  }\n  function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n    var host = uriReplacement.HOST,\n      params = uriReplacement.PARAMS,\n      perOptionUris = uriReplacement[perOptionKey];\n    var perVariantUri;\n    if (stableId) {\n      perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n      if (perVariantUri) {\n        uri = perVariantUri;\n      }\n    }\n    var url = new self.URL(uri);\n    if (host && !perVariantUri) {\n      url.host = host;\n    }\n    if (params) {\n      Object.keys(params).sort().forEach(function (key) {\n        if (key) {\n          url.searchParams.set(key, params[key]);\n        }\n      });\n    }\n    return url.href;\n  }\n\n  /**\n   * Controller to deal with encrypted media extensions (EME)\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n   *\n   * @class\n   * @constructor\n   */\n  var EMEController = /*#__PURE__*/function (_Logger) {\n    function EMEController(hls) {\n      var _this;\n      _this = _Logger.call(this, 'eme', hls.logger) || this;\n      _this.hls = void 0;\n      _this.config = void 0;\n      _this.media = null;\n      _this.mediaResolved = void 0;\n      _this.keyFormatPromise = null;\n      _this.keySystemAccessPromises = {};\n      _this._requestLicenseFailureCount = 0;\n      _this.mediaKeySessions = [];\n      _this.keyIdToKeySessionPromise = {};\n      _this.mediaKeys = null;\n      _this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];\n      _this.bannedKeyIds = {};\n      _this.onMediaEncrypted = function (event) {\n        var initDataType = event.initDataType,\n          initData = event.initData;\n        var logMessage = \"\\\"\" + event.type + \"\\\" event: init data type: \\\"\" + initDataType + \"\\\"\";\n        _this.debug(logMessage);\n\n        // Ignore event when initData is null\n        if (initData === null) {\n          return;\n        }\n        if (!_this.keyFormatPromise) {\n          var keySystems = Object.keys(_this.keySystemAccessPromises);\n          if (!keySystems.length) {\n            keySystems = getKeySystemsForConfig(_this.config);\n          }\n          var keyFormats = keySystems.map(keySystemDomainToKeySystemFormat).filter(function (k) {\n            return !!k;\n          });\n          _this.keyFormatPromise = _this.getKeyFormatPromise(keyFormats);\n        }\n        _this.keyFormatPromise.then(function (keySystemFormat) {\n          var keySystem = keySystemFormatToKeySystemDomain(keySystemFormat);\n          if (initDataType !== 'sinf' || keySystem !== KeySystems.FAIRPLAY) {\n            _this.log(\"Ignoring \\\"\" + event.type + \"\\\" event with init data type: \\\"\" + initDataType + \"\\\" for selected key-system \" + keySystem);\n            return;\n          }\n\n          // Match sinf keyId to playlist skd://keyId=\n          var keyId;\n          try {\n            var json = bin2str(new Uint8Array(initData));\n            var sinf = base64Decode(JSON.parse(json).sinf);\n            var tenc = parseSinf(sinf);\n            if (!tenc) {\n              throw new Error(\"'schm' box missing or not cbcs/cenc with schi > tenc\");\n            }\n            keyId = new Uint8Array(tenc.subarray(8, 24));\n          } catch (error) {\n            _this.warn(logMessage + \" Failed to parse sinf: \" + error);\n            return;\n          }\n          var keyIdHex = arrayToHex(keyId);\n          var _this2 = _this,\n            keyIdToKeySessionPromise = _this2.keyIdToKeySessionPromise,\n            mediaKeySessions = _this2.mediaKeySessions;\n          var keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];\n          var _loop = function _loop() {\n              // Match playlist key\n              var keyContext = mediaKeySessions[i];\n              var decryptdata = keyContext.decryptdata;\n              if (!decryptdata.keyId) {\n                return 0; // continue\n              }\n              var oldKeyIdHex = arrayToHex(decryptdata.keyId);\n              if (arrayValuesMatch(keyId, decryptdata.keyId) || decryptdata.uri.replace(/-/g, '').indexOf(keyIdHex) !== -1) {\n                keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];\n                if (!keySessionContextPromise) {\n                  return 0; // continue\n                }\n                if (decryptdata.pssh) {\n                  return 1; // break\n                }\n                delete keyIdToKeySessionPromise[oldKeyIdHex];\n                decryptdata.pssh = new Uint8Array(initData);\n                decryptdata.keyId = keyId;\n                keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(function () {\n                  return _this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, 'encrypted-event-key-match');\n                });\n                keySessionContextPromise.catch(function (error) {\n                  return _this.handleError(error);\n                });\n                return 1; // break\n              }\n            },\n            _ret;\n          for (var i = 0; i < mediaKeySessions.length; i++) {\n            _ret = _loop();\n            if (_ret === 0) continue;\n            if (_ret === 1) break;\n          }\n          if (!keySessionContextPromise) {\n            _this.handleError(new Error(\"Key ID \" + keyIdHex + \" not encountered in playlist. Key-system sessions \" + mediaKeySessions.length + \".\"));\n          }\n        }).catch(function (error) {\n          return _this.handleError(error);\n        });\n      };\n      _this.onWaitingForKey = function (event) {\n        _this.log(\"\\\"\" + event.type + \"\\\" event\");\n      };\n      _this.hls = hls;\n      _this.config = hls.config;\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(EMEController, _Logger);\n    var _proto = EMEController.prototype;\n    _proto.destroy = function destroy() {\n      this.onDestroying();\n      this.onMediaDetached();\n      // Remove any references that could be held in config options or callbacks\n      var config = this.config;\n      config.requestMediaKeySystemAccessFunc = null;\n      config.licenseXhrSetup = config.licenseResponseCallback = undefined;\n      config.drmSystems = config.drmSystemOptions = {};\n      // @ts-ignore\n      this.hls = this.config = this.keyIdToKeySessionPromise = null;\n      // @ts-ignore\n      this.onMediaEncrypted = this.onWaitingForKey = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n      this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      this.hls.on(Events.DESTROYING, this.onDestroying, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n      this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      this.hls.off(Events.DESTROYING, this.onDestroying, this);\n    };\n    _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {\n      var _this$config = this.config,\n        drmSystems = _this$config.drmSystems,\n        widevineLicenseUrl = _this$config.widevineLicenseUrl;\n      var keySystemConfiguration = drmSystems == null ? void 0 : drmSystems[keySystem];\n      if (keySystemConfiguration) {\n        return keySystemConfiguration.licenseUrl;\n      }\n\n      // For backward compatibility\n      if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {\n        return widevineLicenseUrl;\n      }\n    };\n    _proto.getLicenseServerUrlOrThrow = function getLicenseServerUrlOrThrow(keySystem) {\n      var url = this.getLicenseServerUrl(keySystem);\n      if (url === undefined) {\n        throw new Error(\"no license server URL configured for key-system \\\"\" + keySystem + \"\\\"\");\n      }\n      return url;\n    };\n    _proto.getServerCertificateUrl = function getServerCertificateUrl(keySystem) {\n      var drmSystems = this.config.drmSystems;\n      var keySystemConfiguration = drmSystems == null ? void 0 : drmSystems[keySystem];\n      if (keySystemConfiguration) {\n        return keySystemConfiguration.serverCertificateUrl;\n      } else {\n        this.log(\"No Server Certificate in config.drmSystems[\\\"\" + keySystem + \"\\\"]\");\n      }\n    };\n    _proto.attemptKeySystemAccess = function attemptKeySystemAccess(keySystemsToAttempt) {\n      var _this3 = this;\n      var levels = this.hls.levels;\n      var uniqueCodec = function uniqueCodec(value, i, a) {\n        return !!value && a.indexOf(value) === i;\n      };\n      var audioCodecs = levels.map(function (level) {\n        return level.audioCodec;\n      }).filter(uniqueCodec);\n      var videoCodecs = levels.map(function (level) {\n        return level.videoCodec;\n      }).filter(uniqueCodec);\n      if (audioCodecs.length + videoCodecs.length === 0) {\n        videoCodecs.push('avc1.42e01e');\n      }\n      return new Promise(function (resolve, reject) {\n        var _attempt = function attempt(keySystems) {\n          var keySystem = keySystems.shift();\n          _this3.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(function (mediaKeys) {\n            return resolve({\n              keySystem: keySystem,\n              mediaKeys: mediaKeys\n            });\n          }).catch(function (error) {\n            if (keySystems.length) {\n              _attempt(keySystems);\n            } else if (error instanceof EMEKeyError) {\n              reject(error);\n            } else {\n              reject(new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n                error: error,\n                fatal: true\n              }, error.message));\n            }\n          });\n        };\n        _attempt(keySystemsToAttempt);\n      });\n    };\n    _proto.requestMediaKeySystemAccess = function requestMediaKeySystemAccess$1(keySystem, supportedConfigurations) {\n      var requestMediaKeySystemAccessFunc = this.config.requestMediaKeySystemAccessFunc;\n      if (!(typeof requestMediaKeySystemAccessFunc === 'function')) {\n        var errMessage = \"Configured requestMediaKeySystemAccess is not a function \" + requestMediaKeySystemAccessFunc;\n        if (requestMediaKeySystemAccess === null && self.location.protocol === 'http:') {\n          errMessage = \"navigator.requestMediaKeySystemAccess is not available over insecure protocol \" + location.protocol;\n        }\n        return Promise.reject(new Error(errMessage));\n      }\n      return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n    };\n    _proto.getMediaKeysPromise = function getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n      var _keySystemAccessPromi,\n        _this4 = this;\n      // This can throw, but is caught in event handler callpath\n      var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions || {});\n      var keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n      var keySystemAccess = (_keySystemAccessPromi = keySystemAccessPromises) == null ? void 0 : _keySystemAccessPromi.keySystemAccess;\n      if (!keySystemAccess) {\n        this.log(\"Requesting encrypted media \\\"\" + keySystem + \"\\\" key-system access with config: \" + stringify(mediaKeySystemConfigs));\n        keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n        var keySystemAccessPromisesNew = keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n          keySystemAccess: keySystemAccess\n        };\n        keySystemAccess.catch(function (error) {\n          _this4.log(\"Failed to obtain access to key-system \\\"\" + keySystem + \"\\\": \" + error);\n        });\n        return keySystemAccess.then(function (mediaKeySystemAccess) {\n          _this4.log(\"Access for key-system \\\"\" + mediaKeySystemAccess.keySystem + \"\\\" obtained\");\n          var certificateRequest = _this4.fetchServerCertificate(keySystem);\n          _this4.log(\"Create media-keys for \\\"\" + keySystem + \"\\\"\");\n          var mediaKeys = keySystemAccessPromisesNew.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(function (mediaKeys) {\n            _this4.log(\"Media-keys created for \\\"\" + keySystem + \"\\\"\");\n            keySystemAccessPromisesNew.hasMediaKeys = true;\n            return certificateRequest.then(function (certificate) {\n              if (certificate) {\n                return _this4.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n              }\n              return mediaKeys;\n            });\n          });\n          mediaKeys.catch(function (error) {\n            _this4.error(\"Failed to create media-keys for \\\"\" + keySystem + \"\\\"}: \" + error);\n          });\n          return mediaKeys;\n        });\n      }\n      return keySystemAccess.then(function () {\n        return keySystemAccessPromises.mediaKeys;\n      });\n    };\n    _proto.createMediaKeySessionContext = function createMediaKeySessionContext(_ref) {\n      var decryptdata = _ref.decryptdata,\n        keySystem = _ref.keySystem,\n        mediaKeys = _ref.mediaKeys;\n      this.log(\"Creating key-system session \\\"\" + keySystem + \"\\\" keyId: \" + arrayToHex(decryptdata.keyId || []) + \" keyUri: \" + decryptdata.uri);\n      var mediaKeysSession = mediaKeys.createSession();\n      var mediaKeySessionContext = {\n        decryptdata: decryptdata,\n        keySystem: keySystem,\n        mediaKeys: mediaKeys,\n        mediaKeysSession: mediaKeysSession,\n        keyStatus: 'status-pending'\n      };\n      this.mediaKeySessions.push(mediaKeySessionContext);\n      return mediaKeySessionContext;\n    };\n    _proto.renewKeySession = function renewKeySession(mediaKeySessionContext) {\n      var decryptdata = mediaKeySessionContext.decryptdata;\n      if (decryptdata.pssh) {\n        var keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n        var keyId = getKeyIdString(decryptdata);\n        var scheme = 'cenc';\n        this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh.buffer, 'expired');\n      } else {\n        this.warn(\"Could not renew expired session. Missing pssh initData.\");\n      }\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.removeSession(mediaKeySessionContext);\n    };\n    _proto.updateKeySession = function updateKeySession(mediaKeySessionContext, data) {\n      var keySession = mediaKeySessionContext.mediaKeysSession;\n      this.log(\"Updating key-session \\\"\" + keySession.sessionId + \"\\\" for keyId \" + arrayToHex(mediaKeySessionContext.decryptdata.keyId || []) + \"\\n      } (data length: \" + data.byteLength + \")\");\n      return keySession.update(data);\n    };\n    _proto.getSelectedKeySystemFormats = function getSelectedKeySystemFormats() {\n      var _this5 = this;\n      return Object.keys(this.keySystemAccessPromises).map(function (keySystem) {\n        return {\n          keySystem: keySystem,\n          hasMediaKeys: _this5.keySystemAccessPromises[keySystem].hasMediaKeys\n        };\n      }).filter(function (_ref2) {\n        var hasMediaKeys = _ref2.hasMediaKeys;\n        return !!hasMediaKeys;\n      }).map(function (_ref3) {\n        var keySystem = _ref3.keySystem;\n        return keySystemDomainToKeySystemFormat(keySystem);\n      }).filter(function (keySystem) {\n        return !!keySystem;\n      });\n    };\n    _proto.getKeySystemAccess = function getKeySystemAccess(keySystemsToAttempt) {\n      var _this6 = this;\n      return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(function (_ref4) {\n        var keySystem = _ref4.keySystem,\n          mediaKeys = _ref4.mediaKeys;\n        return _this6.attemptSetMediaKeys(keySystem, mediaKeys);\n      });\n    };\n    _proto.selectKeySystem = function selectKeySystem(keySystemsToAttempt) {\n      var _this7 = this;\n      return new Promise(function (resolve, reject) {\n        _this7.getKeySystemSelectionPromise(keySystemsToAttempt).then(function (_ref5) {\n          var keySystem = _ref5.keySystem;\n          var keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);\n          if (keySystemFormat) {\n            resolve(keySystemFormat);\n          } else {\n            reject(new Error(\"Unable to find format for key-system \\\"\" + keySystem + \"\\\"\"));\n          }\n        }).catch(reject);\n      });\n    };\n    _proto.selectKeySystemFormat = function selectKeySystemFormat(frag) {\n      var keyFormats = Object.keys(frag.levelkeys || {});\n      if (!this.keyFormatPromise) {\n        this.log(\"Selecting key-system from fragment (sn: \" + frag.sn + \" \" + frag.type + \": \" + frag.level + \") key formats \" + keyFormats.join(', '));\n        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n      }\n      return this.keyFormatPromise;\n    };\n    _proto.getKeyFormatPromise = function getKeyFormatPromise(keyFormats) {\n      var keySystemsInConfig = getKeySystemsForConfig(this.config);\n      var keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(function (value) {\n        return !!value && keySystemsInConfig.indexOf(value) !== -1;\n      });\n      return this.selectKeySystem(keySystemsToAttempt);\n    };\n    _proto.getKeyStatus = function getKeyStatus(decryptdata) {\n      var mediaKeySessions = this.mediaKeySessions;\n      for (var i = 0; i < mediaKeySessions.length; i++) {\n        var status = _getKeyStatus(decryptdata, mediaKeySessions[i]);\n        if (status) {\n          return status;\n        }\n      }\n      return undefined;\n    };\n    _proto.loadKey = function loadKey(data) {\n      var _this8 = this;\n      var decryptdata = data.keyInfo.decryptdata;\n      var keyId = getKeyIdString(decryptdata);\n      var badStatus = this.bannedKeyIds[keyId];\n      if (badStatus || this.getKeyStatus(decryptdata) === 'internal-error') {\n        var error = getKeyStatusError(badStatus || 'internal-error', decryptdata);\n        this.handleError(error, data.frag);\n        return Promise.reject(error);\n      }\n      var keyDetails = \"(keyId: \" + keyId + \" format: \\\"\" + decryptdata.keyFormat + \"\\\" method: \" + decryptdata.method + \" uri: \" + decryptdata.uri + \")\";\n      this.log(\"Starting session for key \" + keyDetails);\n      var keyContextPromise = this.keyIdToKeySessionPromise[keyId];\n      if (!keyContextPromise) {\n        var keySessionContextPromise = this.getKeySystemForKeyPromise(decryptdata).then(function (_ref6) {\n          var keySystem = _ref6.keySystem,\n            mediaKeys = _ref6.mediaKeys;\n          _this8.throwIfDestroyed();\n          _this8.log(\"Handle encrypted media sn: \" + data.frag.sn + \" \" + data.frag.type + \": \" + data.frag.level + \" using key \" + keyDetails);\n          return _this8.attemptSetMediaKeys(keySystem, mediaKeys).then(function () {\n            _this8.throwIfDestroyed();\n            return _this8.createMediaKeySessionContext({\n              keySystem: keySystem,\n              mediaKeys: mediaKeys,\n              decryptdata: decryptdata\n            });\n          });\n        }).then(function (keySessionContext) {\n          var scheme = 'cenc';\n          var initData = decryptdata.pssh ? decryptdata.pssh.buffer : null;\n          return _this8.generateRequestWithPreferredKeySession(keySessionContext, scheme, initData, 'playlist-key');\n        });\n        keySessionContextPromise.catch(function (error) {\n          return _this8.handleError(error, data.frag);\n        });\n        this.keyIdToKeySessionPromise[keyId] = keySessionContextPromise;\n        return keySessionContextPromise;\n      }\n\n      // Re-emit error for playlist key loading\n      keyContextPromise.catch(function (error) {\n        if (error instanceof EMEKeyError) {\n          var errorData = _objectSpread2({}, error.data);\n          if (_this8.getKeyStatus(decryptdata) === 'internal-error') {\n            errorData.decryptdata = decryptdata;\n          }\n          var clonedError = new EMEKeyError(errorData, error.message);\n          _this8.handleError(clonedError, data.frag);\n        }\n      });\n      return keyContextPromise;\n    };\n    _proto.throwIfDestroyed = function throwIfDestroyed(message) {\n      if (!this.hls) {\n        throw new Error('invalid state');\n      }\n    };\n    _proto.handleError = function handleError(error, frag) {\n      if (!this.hls) {\n        return;\n      }\n      if (error instanceof EMEKeyError) {\n        if (frag) {\n          error.data.frag = frag;\n        }\n        var levelKey = error.data.decryptdata;\n        this.error(\"\" + error.message + (levelKey ? \" (\" + arrayToHex(levelKey.keyId || []) + \")\" : ''));\n        this.hls.trigger(Events.ERROR, error.data);\n      } else {\n        this.error(error.message);\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n          error: error,\n          fatal: true\n        });\n      }\n    };\n    _proto.getKeySystemForKeyPromise = function getKeySystemForKeyPromise(decryptdata) {\n      var keyId = getKeyIdString(decryptdata);\n      var mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n      if (!mediaKeySessionContext) {\n        var keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);\n        var keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);\n        return this.attemptKeySystemAccess(keySystemsToAttempt);\n      }\n      return mediaKeySessionContext;\n    };\n    _proto.getKeySystemSelectionPromise = function getKeySystemSelectionPromise(keySystemsToAttempt) {\n      if (!keySystemsToAttempt.length) {\n        keySystemsToAttempt = getKeySystemsForConfig(this.config);\n      }\n      if (keySystemsToAttempt.length === 0) {\n        throw new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n          fatal: true\n        }, \"Missing key-system license configuration options \" + stringify({\n          drmSystems: this.config.drmSystems\n        }));\n      }\n      return this.attemptKeySystemAccess(keySystemsToAttempt);\n    };\n    _proto.attemptSetMediaKeys = function attemptSetMediaKeys(keySystem, mediaKeys) {\n      var _this9 = this;\n      this.mediaResolved = undefined;\n      if (this.mediaKeys === mediaKeys) {\n        return Promise.resolve();\n      }\n      var queue = this.setMediaKeysQueue.slice();\n      this.log(\"Setting media-keys for \\\"\" + keySystem + \"\\\"\");\n      // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n      // can be queued for execution for multiple key sessions.\n      var setMediaKeysPromise = Promise.all(queue).then(function () {\n        if (!_this9.media) {\n          return new Promise(function (resolve, reject) {\n            _this9.mediaResolved = function () {\n              _this9.mediaResolved = undefined;\n              if (!_this9.media) {\n                return reject(new Error('Attempted to set mediaKeys without media element attached'));\n              }\n              _this9.mediaKeys = mediaKeys;\n              _this9.media.setMediaKeys(mediaKeys).then(resolve).catch(reject);\n            };\n          });\n        }\n        return _this9.media.setMediaKeys(mediaKeys);\n      });\n      this.mediaKeys = mediaKeys;\n      this.setMediaKeysQueue.push(setMediaKeysPromise);\n      return setMediaKeysPromise.then(function () {\n        _this9.log(\"Media-keys set for \\\"\" + keySystem + \"\\\"\");\n        queue.push(setMediaKeysPromise);\n        _this9.setMediaKeysQueue = _this9.setMediaKeysQueue.filter(function (p) {\n          return queue.indexOf(p) === -1;\n        });\n      });\n    };\n    _proto.generateRequestWithPreferredKeySession = function generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n      var _this$config$drmSyste,\n        _this0 = this;\n      var generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null || (_this$config$drmSyste = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste.generateRequest;\n      if (generateRequestFilter) {\n        try {\n          var mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n          if (!mappedInitData) {\n            throw new Error('Invalid response from configured generateRequest filter');\n          }\n          initDataType = mappedInitData.initDataType;\n          initData = mappedInitData.initData ? mappedInitData.initData : null;\n          context.decryptdata.pssh = initData ? new Uint8Array(initData) : null;\n        } catch (error) {\n          this.warn(error.message);\n          if (this.hls && this.hls.config.debug) {\n            throw error;\n          }\n        }\n      }\n      if (initData === null) {\n        this.log(\"Skipping key-session request for \\\"\" + reason + \"\\\" (no initData)\");\n        return Promise.resolve(context);\n      }\n      var keyId = getKeyIdString(context.decryptdata);\n      var keyUri = context.decryptdata.uri;\n      this.log(\"Generating key-session request for \\\"\" + reason + \"\\\" keyId: \" + keyId + \" URI: \" + keyUri + \" (init data type: \" + initDataType + \" length: \" + initData.byteLength + \")\");\n      var licenseStatus = new EventEmitter();\n      var onmessage = context._onmessage = function (event) {\n        var keySession = context.mediaKeysSession;\n        if (!keySession) {\n          licenseStatus.emit('error', new Error('invalid state'));\n          return;\n        }\n        var messageType = event.messageType,\n          message = event.message;\n        _this0.log(\"\\\"\" + messageType + \"\\\" message event for session \\\"\" + keySession.sessionId + \"\\\" message size: \" + message.byteLength);\n        if (messageType === 'license-request' || messageType === 'license-renewal') {\n          _this0.renewLicense(context, message).catch(function (error) {\n            if (licenseStatus.eventNames().length) {\n              licenseStatus.emit('error', error);\n            } else {\n              _this0.handleError(error);\n            }\n          });\n        } else if (messageType === 'license-release') {\n          if (context.keySystem === KeySystems.FAIRPLAY) {\n            _this0.updateKeySession(context, strToUtf8array('acknowledged')).then(function () {\n              return _this0.removeSession(context);\n            }).catch(function (error) {\n              return _this0.handleError(error);\n            });\n          }\n        } else {\n          _this0.warn(\"unhandled media key message type \\\"\" + messageType + \"\\\"\");\n        }\n      };\n      var handleKeyStatus = function handleKeyStatus(keyStatus, context) {\n        context.keyStatus = keyStatus;\n        var keyError;\n        if (keyStatus.startsWith('usable')) {\n          licenseStatus.emit('resolved');\n        } else if (keyStatus === 'internal-error' || keyStatus === 'output-restricted' || keyStatus === 'output-downscaled') {\n          keyError = getKeyStatusError(keyStatus, context.decryptdata);\n        } else if (keyStatus === 'expired') {\n          keyError = new Error(\"key expired (keyId: \" + keyId + \")\");\n        } else if (keyStatus === 'released') {\n          keyError = new Error(\"key released\");\n        } else if (keyStatus === 'status-pending') ; else {\n          _this0.warn(\"unhandled key status change \\\"\" + keyStatus + \"\\\" (keyId: \" + keyId + \")\");\n        }\n        if (keyError) {\n          if (licenseStatus.eventNames().length) {\n            licenseStatus.emit('error', keyError);\n          } else {\n            _this0.handleError(keyError);\n          }\n        }\n      };\n      var onkeystatuseschange = context._onkeystatuseschange = function (event) {\n        var keySession = context.mediaKeysSession;\n        if (!keySession) {\n          licenseStatus.emit('error', new Error('invalid state'));\n          return;\n        }\n        var keyStatuses = _this0.getKeyStatuses(context);\n        var keyIds = Object.keys(keyStatuses);\n\n        // exit if all keys are status-pending\n        if (!keyIds.some(function (id) {\n          return keyStatuses[id] !== 'status-pending';\n        })) {\n          return;\n        }\n\n        // renew when a key status for a levelKey comes back expired\n        if (keyStatuses[keyId] === 'expired') {\n          // renew when a key status comes back expired\n          _this0.log(\"Expired key \" + stringify(keyStatuses) + \" in key-session \\\"\" + context.mediaKeysSession.sessionId + \"\\\"\");\n          _this0.renewKeySession(context);\n          return;\n        }\n        var keyStatus = keyStatuses[keyId];\n        if (keyStatus) {\n          // handle status of current key\n          handleKeyStatus(keyStatus, context);\n        } else {\n          var _context$keyStatusTim;\n          // Timeout key-status\n          var timeout = 1000;\n          context.keyStatusTimeouts || (context.keyStatusTimeouts = {});\n          (_context$keyStatusTim = context.keyStatusTimeouts)[keyId] || (_context$keyStatusTim[keyId] = self.setTimeout(function () {\n            if (!context.mediaKeysSession || !_this0.mediaKeys) {\n              return;\n            }\n\n            // Find key status in another session if missing (PlayReady #7519 no key-status \"single-key\" setup with shared key)\n            var sessionKeyStatus = _this0.getKeyStatus(context.decryptdata);\n            if (sessionKeyStatus && sessionKeyStatus !== 'status-pending') {\n              _this0.log(\"No status for keyId \" + keyId + \" in key-session \\\"\" + context.mediaKeysSession.sessionId + \"\\\". Using session key-status \" + sessionKeyStatus + \" from other session.\");\n              return handleKeyStatus(sessionKeyStatus, context);\n            }\n\n            // Timeout key with internal-error\n            _this0.log(\"key status for \" + keyId + \" in key-session \\\"\" + context.mediaKeysSession.sessionId + \"\\\" timed out after \" + timeout + \"ms\");\n            keyStatus = 'internal-error';\n            handleKeyStatus(keyStatus, context);\n          }, timeout));\n          _this0.log(\"No status for keyId \" + keyId + \" (\" + stringify(keyStatuses) + \").\");\n        }\n      };\n      addEventListener(context.mediaKeysSession, 'message', onmessage);\n      addEventListener(context.mediaKeysSession, 'keystatuseschange', onkeystatuseschange);\n      var keyUsablePromise = new Promise(function (resolve, reject) {\n        licenseStatus.on('error', reject);\n        licenseStatus.on('resolved', resolve);\n      });\n      return context.mediaKeysSession.generateRequest(initDataType, initData).then(function () {\n        _this0.log(\"Request generated for key-session \\\"\" + context.mediaKeysSession.sessionId + \"\\\" keyId: \" + keyId + \" URI: \" + keyUri);\n      }).catch(function (error) {\n        throw new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_NO_SESSION,\n          error: error,\n          decryptdata: context.decryptdata,\n          fatal: false\n        }, \"Error generating key-session request: \" + error);\n      }).then(function () {\n        return keyUsablePromise;\n      }).catch(function (error) {\n        licenseStatus.removeAllListeners();\n        return _this0.removeSession(context).then(function () {\n          throw error;\n        });\n      }).then(function () {\n        licenseStatus.removeAllListeners();\n        return context;\n      });\n    };\n    _proto.getKeyStatuses = function getKeyStatuses(mediaKeySessionContext) {\n      var _this1 = this;\n      var keyStatuses = {};\n      mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach(function (status, keyId) {\n        // keyStatuses.forEach is not standard API so the callback value looks weird on xboxone\n        // xboxone callback(keyId, status) so we need to exchange them\n        if (typeof keyId === 'string' && typeof status === 'object') {\n          var temp = keyId;\n          keyId = status;\n          status = temp;\n        }\n        var keyIdArray = 'buffer' in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId);\n        if (mediaKeySessionContext.keySystem === KeySystems.PLAYREADY && keyIdArray.length === 16) {\n          // On some devices, the key ID has already been converted for endianness.\n          // In such cases, this key ID is the one we need to cache.\n          var originKeyIdWithStatusChange = arrayToHex(keyIdArray);\n          // Cache the original key IDs to ensure compatibility across all cases.\n          keyStatuses[originKeyIdWithStatusChange] = status;\n          changeEndianness(keyIdArray);\n        }\n        var keyIdWithStatusChange = arrayToHex(keyIdArray);\n        // Add to banned keys to prevent playlist usage and license requests\n        if (status === 'internal-error') {\n          _this1.bannedKeyIds[keyIdWithStatusChange] = status;\n        }\n        _this1.log(\"key status change \\\"\" + status + \"\\\" for keyStatuses keyId: \" + keyIdWithStatusChange + \" key-session \\\"\" + mediaKeySessionContext.mediaKeysSession.sessionId + \"\\\"\");\n        keyStatuses[keyIdWithStatusChange] = status;\n      });\n      return keyStatuses;\n    };\n    _proto.fetchServerCertificate = function fetchServerCertificate(keySystem) {\n      var config = this.config;\n      var Loader = config.loader;\n      var certLoader = new Loader(config);\n      var url = this.getServerCertificateUrl(keySystem);\n      if (!url) {\n        return Promise.resolve();\n      }\n      this.log(\"Fetching server certificate for \\\"\" + keySystem + \"\\\"\");\n      return new Promise(function (resolve, reject) {\n        var loaderContext = {\n          responseType: 'arraybuffer',\n          url: url\n        };\n        var loadPolicy = config.certLoadPolicy.default;\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: 0,\n          retryDelay: 0,\n          maxRetryDelay: 0\n        };\n        var loaderCallbacks = {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            resolve(response.data);\n          },\n          onError: function onError(response, contex, networkDetails, stats) {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n              fatal: true,\n              networkDetails: networkDetails,\n              response: _objectSpread2({\n                url: loaderContext.url,\n                data: undefined\n              }, response)\n            }, \"\\\"\" + keySystem + \"\\\" certificate request failed (\" + url + \"). Status: \" + response.code + \" (\" + response.text + \")\"));\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n              fatal: true,\n              networkDetails: networkDetails,\n              response: {\n                url: loaderContext.url,\n                data: undefined\n              }\n            }, \"\\\"\" + keySystem + \"\\\" certificate request timed out (\" + url + \")\"));\n          },\n          onAbort: function onAbort(stats, context, networkDetails) {\n            reject(new Error('aborted'));\n          }\n        };\n        certLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n      });\n    };\n    _proto.setMediaKeysServerCertificate = function setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n      var _this10 = this;\n      return new Promise(function (resolve, reject) {\n        mediaKeys.setServerCertificate(cert).then(function (success) {\n          _this10.log(\"setServerCertificate \" + (success ? 'success' : 'not supported by CDM') + \" (\" + cert.byteLength + \") on \\\"\" + keySystem + \"\\\"\");\n          resolve(mediaKeys);\n        }).catch(function (error) {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n            error: error,\n            fatal: true\n          }, error.message));\n        });\n      });\n    };\n    _proto.renewLicense = function renewLicense(context, keyMessage) {\n      var _this11 = this;\n      return this.requestLicense(context, new Uint8Array(keyMessage)).then(function (data) {\n        return _this11.updateKeySession(context, new Uint8Array(data)).catch(function (error) {\n          throw new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n            decryptdata: context.decryptdata,\n            error: error,\n            fatal: false\n          }, error.message);\n        });\n      });\n    };\n    _proto.unpackPlayReadyKeyMessage = function unpackPlayReadyKeyMessage(xhr, licenseChallenge) {\n      // On Edge, the raw license message is UTF-16-encoded XML.  We need\n      // to unpack the Challenge element (base64-encoded string containing the\n      // actual license request) and any HttpHeader elements (sent as request\n      // headers).\n      // For PlayReady CDMs, we need to dig the Challenge out of the XML.\n      var xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));\n      if (!xmlString.includes('PlayReadyKeyMessage')) {\n        // This does not appear to be a wrapped message as on Edge.  Some\n        // clients do not need this unwrapping, so we will assume this is one of\n        // them.  Note that \"xml\" at this point probably looks like random\n        // garbage, since we interpreted UTF-8 as UTF-16.\n        xhr.setRequestHeader('Content-Type', 'text/xml; charset=utf-8');\n        return licenseChallenge;\n      }\n      var keyMessageXml = new DOMParser().parseFromString(xmlString, 'application/xml');\n      // Set request headers.\n      var headers = keyMessageXml.querySelectorAll('HttpHeader');\n      if (headers.length > 0) {\n        var header;\n        for (var i = 0, len = headers.length; i < len; i++) {\n          var _header$querySelector, _header$querySelector2;\n          header = headers[i];\n          var name = (_header$querySelector = header.querySelector('name')) == null ? void 0 : _header$querySelector.textContent;\n          var value = (_header$querySelector2 = header.querySelector('value')) == null ? void 0 : _header$querySelector2.textContent;\n          if (name && value) {\n            xhr.setRequestHeader(name, value);\n          }\n        }\n      }\n      var challengeElement = keyMessageXml.querySelector('Challenge');\n      var challengeText = challengeElement == null ? void 0 : challengeElement.textContent;\n      if (!challengeText) {\n        throw new Error(\"Cannot find <Challenge> in key message\");\n      }\n      return strToUtf8array(atob(challengeText));\n    };\n    _proto.setupLicenseXHR = function setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n      var _this12 = this;\n      var licenseXhrSetup = this.config.licenseXhrSetup;\n      if (!licenseXhrSetup) {\n        xhr.open('POST', url, true);\n        return Promise.resolve({\n          xhr: xhr,\n          licenseChallenge: licenseChallenge\n        });\n      }\n      return Promise.resolve().then(function () {\n        if (!keysListItem.decryptdata) {\n          throw new Error('Key removed');\n        }\n        return licenseXhrSetup.call(_this12.hls, xhr, url, keysListItem, licenseChallenge);\n      }).catch(function (error) {\n        if (!keysListItem.decryptdata) {\n          // Key session removed. Cancel license request.\n          throw error;\n        }\n        // let's try to open before running setup\n        xhr.open('POST', url, true);\n        return licenseXhrSetup.call(_this12.hls, xhr, url, keysListItem, licenseChallenge);\n      }).then(function (licenseXhrSetupResult) {\n        // if licenseXhrSetup did not yet call open, let's do it now\n        if (!xhr.readyState) {\n          xhr.open('POST', url, true);\n        }\n        var finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n        return {\n          xhr: xhr,\n          licenseChallenge: finalLicenseChallenge\n        };\n      });\n    };\n    _proto.requestLicense = function requestLicense(keySessionContext, licenseChallenge) {\n      var _this13 = this;\n      var keyLoadPolicy = this.config.keyLoadPolicy.default;\n      return new Promise(function (resolve, reject) {\n        var url = _this13.getLicenseServerUrlOrThrow(keySessionContext.keySystem);\n        _this13.log(\"Sending license request to URL: \" + url);\n        var xhr = new XMLHttpRequest();\n        xhr.responseType = 'arraybuffer';\n        xhr.onreadystatechange = function () {\n          if (!_this13.hls || !keySessionContext.mediaKeysSession) {\n            return reject(new Error('invalid state'));\n          }\n          if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n              _this13._requestLicenseFailureCount = 0;\n              var data = xhr.response;\n              _this13.log(\"License received \" + (data instanceof ArrayBuffer ? data.byteLength : data));\n              var licenseResponseCallback = _this13.config.licenseResponseCallback;\n              if (licenseResponseCallback) {\n                try {\n                  data = licenseResponseCallback.call(_this13.hls, xhr, url, keySessionContext);\n                } catch (error) {\n                  _this13.error(error);\n                }\n              }\n              resolve(data);\n            } else {\n              var retryConfig = keyLoadPolicy.errorRetry;\n              var maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;\n              _this13._requestLicenseFailureCount++;\n              if (_this13._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {\n                reject(new EMEKeyError({\n                  type: ErrorTypes.KEY_SYSTEM_ERROR,\n                  details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                  decryptdata: keySessionContext.decryptdata,\n                  fatal: true,\n                  networkDetails: xhr,\n                  response: {\n                    url: url,\n                    data: undefined,\n                    code: xhr.status,\n                    text: xhr.statusText\n                  }\n                }, \"License Request XHR failed (\" + url + \"). Status: \" + xhr.status + \" (\" + xhr.statusText + \")\"));\n              } else {\n                var attemptsLeft = maxNumRetry - _this13._requestLicenseFailureCount + 1;\n                _this13.warn(\"Retrying license request, \" + attemptsLeft + \" attempts left\");\n                _this13.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n              }\n            }\n          }\n        };\n        if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n          keySessionContext.licenseXhr.abort();\n        }\n        keySessionContext.licenseXhr = xhr;\n        _this13.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(function (_ref7) {\n          var xhr = _ref7.xhr,\n            licenseChallenge = _ref7.licenseChallenge;\n          if (keySessionContext.keySystem == KeySystems.PLAYREADY) {\n            licenseChallenge = _this13.unpackPlayReadyKeyMessage(xhr, licenseChallenge);\n          }\n          xhr.send(licenseChallenge);\n        }).catch(reject);\n      });\n    };\n    _proto.onDestroying = function onDestroying() {\n      this.unregisterListeners();\n      this._clear();\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      if (!this.config.emeEnabled) {\n        return;\n      }\n      var media = data.media;\n\n      // keep reference of media\n      this.media = media;\n      addEventListener(media, 'encrypted', this.onMediaEncrypted);\n      addEventListener(media, 'waitingforkey', this.onWaitingForKey);\n      var mediaResolved = this.mediaResolved;\n      if (mediaResolved) {\n        mediaResolved();\n      } else {\n        this.mediaKeys = media.mediaKeys;\n      }\n    };\n    _proto.onMediaDetached = function onMediaDetached() {\n      var media = this.media;\n      if (media) {\n        removeEventListener(media, 'encrypted', this.onMediaEncrypted);\n        removeEventListener(media, 'waitingforkey', this.onWaitingForKey);\n        this.media = null;\n        this.mediaKeys = null;\n      }\n    };\n    _proto._clear = function _clear() {\n      var _this14 = this,\n        _media$setMediaKeys;\n      this._requestLicenseFailureCount = 0;\n      this.keyIdToKeySessionPromise = {};\n      this.bannedKeyIds = {};\n      var mediaResolved = this.mediaResolved;\n      if (mediaResolved) {\n        mediaResolved();\n      }\n      if (!this.mediaKeys && !this.mediaKeySessions.length) {\n        return;\n      }\n      var media = this.media;\n      var mediaKeysList = this.mediaKeySessions.slice();\n      this.mediaKeySessions = [];\n      this.mediaKeys = null;\n      LevelKey.clearKeyUriToKeyIdMap();\n\n      // Close all sessions and remove media keys from the video element.\n      var keySessionCount = mediaKeysList.length;\n      EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map(function (mediaKeySessionContext) {\n        return _this14.removeSession(mediaKeySessionContext);\n      }).concat((media == null || (_media$setMediaKeys = media.setMediaKeys(null)) == null ? void 0 : _media$setMediaKeys.catch(function (error) {\n        _this14.log(\"Could not clear media keys: \" + error);\n        if (!_this14.hls) return;\n        _this14.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,\n          fatal: false,\n          error: new Error(\"Could not clear media keys: \" + error)\n        });\n      })) || Promise.resolve())).catch(function (error) {\n        _this14.log(\"Could not close sessions and clear media keys: \" + error);\n        if (!_this14.hls) return;\n        _this14.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,\n          fatal: false,\n          error: new Error(\"Could not close sessions and clear media keys: \" + error)\n        });\n      }).then(function () {\n        if (keySessionCount) {\n          _this14.log('finished closing key sessions and clearing media keys');\n        }\n      });\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this._clear();\n    };\n    _proto.onManifestLoaded = function onManifestLoaded(event, _ref8) {\n      var sessionKeys = _ref8.sessionKeys;\n      if (!sessionKeys || !this.config.emeEnabled) {\n        return;\n      }\n      if (!this.keyFormatPromise) {\n        var keyFormats = sessionKeys.reduce(function (formats, sessionKey) {\n          if (formats.indexOf(sessionKey.keyFormat) === -1) {\n            formats.push(sessionKey.keyFormat);\n          }\n          return formats;\n        }, []);\n        this.log(\"Selecting key-system from session-keys \" + keyFormats.join(', '));\n        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n      }\n    };\n    _proto.removeSession = function removeSession(mediaKeySessionContext) {\n      var _this15 = this;\n      var mediaKeysSession = mediaKeySessionContext.mediaKeysSession,\n        licenseXhr = mediaKeySessionContext.licenseXhr,\n        decryptdata = mediaKeySessionContext.decryptdata;\n      if (mediaKeysSession) {\n        this.log(\"Remove licenses and keys and close session \\\"\" + mediaKeysSession.sessionId + \"\\\" keyId: \" + arrayToHex((decryptdata == null ? void 0 : decryptdata.keyId) || []));\n        if (mediaKeySessionContext._onmessage) {\n          mediaKeysSession.removeEventListener('message', mediaKeySessionContext._onmessage);\n          mediaKeySessionContext._onmessage = undefined;\n        }\n        if (mediaKeySessionContext._onkeystatuseschange) {\n          mediaKeysSession.removeEventListener('keystatuseschange', mediaKeySessionContext._onkeystatuseschange);\n          mediaKeySessionContext._onkeystatuseschange = undefined;\n        }\n        if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n          licenseXhr.abort();\n        }\n        mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n        var index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n        if (index > -1) {\n          this.mediaKeySessions.splice(index, 1);\n        }\n        var keyStatusTimeouts = mediaKeySessionContext.keyStatusTimeouts;\n        if (keyStatusTimeouts) {\n          Object.keys(keyStatusTimeouts).forEach(function (keyId) {\n            return self.clearTimeout(keyStatusTimeouts[keyId]);\n          });\n        }\n        var drmSystemOptions = this.config.drmSystemOptions;\n        var removePromise = isPersistentSessionType(drmSystemOptions) ? new Promise(function (resolve, reject) {\n          self.setTimeout(function () {\n            return reject(new Error(\"MediaKeySession.remove() timeout\"));\n          }, 8000);\n          mediaKeysSession.remove().then(resolve).catch(reject);\n        }) : Promise.resolve();\n        return removePromise.catch(function (error) {\n          _this15.log(\"Could not remove session: \" + error);\n          if (!_this15.hls) return;\n          _this15.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,\n            fatal: false,\n            error: new Error(\"Could not remove session: \" + error)\n          });\n        }).then(function () {\n          return mediaKeysSession.close();\n        }).catch(function (error) {\n          _this15.log(\"Could not close session: \" + error);\n          if (!_this15.hls) return;\n          _this15.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,\n            fatal: false,\n            error: new Error(\"Could not close session: \" + error)\n          });\n        });\n      }\n      return Promise.resolve();\n    };\n    return EMEController;\n  }(Logger);\n  EMEController.CDMCleanupPromise = void 0;\n  function getKeyIdString(decryptdata) {\n    if (!decryptdata) {\n      throw new Error('Could not read keyId of undefined decryptdata');\n    }\n    if (decryptdata.keyId === null) {\n      throw new Error('keyId is null');\n    }\n    return arrayToHex(decryptdata.keyId);\n  }\n  function _getKeyStatus(decryptdata, keyContext) {\n    if (decryptdata.keyId && keyContext.mediaKeysSession.keyStatuses.has(decryptdata.keyId)) {\n      return keyContext.mediaKeysSession.keyStatuses.get(decryptdata.keyId);\n    }\n    if (decryptdata.matches(keyContext.decryptdata)) {\n      return keyContext.keyStatus;\n    }\n    return undefined;\n  }\n  var EMEKeyError = /*#__PURE__*/function (_Error) {\n    function EMEKeyError(data, message) {\n      var _this16;\n      _this16 = _Error.call(this, message) || this;\n      _this16.data = void 0;\n      data.error || (data.error = new Error(message));\n      _this16.data = data;\n      data.err = data.error;\n      return _this16;\n    }\n    _inheritsLoose(EMEKeyError, _Error);\n    return EMEKeyError;\n  }(/*#__PURE__*/_wrapNativeSuper(Error));\n  function getKeyStatusError(keyStatus, decryptdata) {\n    var outputRestricted = keyStatus === 'output-restricted';\n    var details = outputRestricted ? ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED : ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR;\n    return new EMEKeyError({\n      type: ErrorTypes.KEY_SYSTEM_ERROR,\n      details: details,\n      fatal: false,\n      decryptdata: decryptdata\n    }, outputRestricted ? 'HDCP level output restricted' : \"key status changed to \\\"\" + keyStatus + \"\\\"\");\n  }\n\n  var FPSController = /*#__PURE__*/function () {\n    function FPSController(hls) {\n      this.hls = void 0;\n      this.isVideoPlaybackQualityAvailable = false;\n      this.timer = void 0;\n      this.media = null;\n      this.lastTime = void 0;\n      this.lastDroppedFrames = 0;\n      this.lastDecodedFrames = 0;\n      // stream controller must be provided as a dependency!\n      this.streamController = void 0;\n      this.hls = hls;\n      this.registerListeners();\n    }\n    var _proto = FPSController.prototype;\n    _proto.setStreamController = function setStreamController(streamController) {\n      this.streamController = streamController;\n    };\n    _proto.registerListeners = function registerListeners() {\n      this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    };\n    _proto.destroy = function destroy() {\n      if (this.timer) {\n        clearInterval(this.timer);\n      }\n      this.unregisterListeners();\n      this.isVideoPlaybackQualityAvailable = false;\n      this.media = null;\n    };\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      var config = this.hls.config;\n      if (config.capLevelOnFPSDrop) {\n        var media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n        this.media = media;\n        if (media && typeof media.getVideoPlaybackQuality === 'function') {\n          this.isVideoPlaybackQualityAvailable = true;\n        }\n        self.clearInterval(this.timer);\n        this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n      }\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      this.media = null;\n    };\n    _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {\n      var currentTime = performance.now();\n      if (decodedFrames) {\n        if (this.lastTime) {\n          var currentPeriod = currentTime - this.lastTime;\n          var currentDropped = droppedFrames - this.lastDroppedFrames;\n          var currentDecoded = decodedFrames - this.lastDecodedFrames;\n          var droppedFPS = 1000 * currentDropped / currentPeriod;\n          var hls = this.hls;\n          hls.trigger(Events.FPS_DROP, {\n            currentDropped: currentDropped,\n            currentDecoded: currentDecoded,\n            totalDroppedFrames: droppedFrames\n          });\n          if (droppedFPS > 0) {\n            // hls.logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n              var currentLevel = hls.currentLevel;\n              hls.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n                currentLevel = currentLevel - 1;\n                hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                  level: currentLevel,\n                  droppedLevel: hls.currentLevel\n                });\n                hls.autoLevelCapping = currentLevel;\n                this.streamController.nextLevelSwitch();\n              }\n            }\n          }\n        }\n        this.lastTime = currentTime;\n        this.lastDroppedFrames = droppedFrames;\n        this.lastDecodedFrames = decodedFrames;\n      }\n    };\n    _proto.checkFPSInterval = function checkFPSInterval() {\n      var video = this.media;\n      if (video) {\n        if (this.isVideoPlaybackQualityAvailable) {\n          var videoPlaybackQuality = video.getVideoPlaybackQuality();\n          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n        } else {\n          // HTMLVideoElement doesn't include the webkit types\n          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n        }\n      }\n    };\n    return FPSController;\n  }();\n\n  // From https://github.com/darkskyapp/string-hash\n  function hash(text) {\n    var hash = 5381;\n    var i = text.length;\n    while (i) {\n      hash = hash * 33 ^ text.charCodeAt(--i);\n    }\n    return (hash >>> 0).toString();\n  }\n\n  var ALIGNED_END_THRESHOLD_SECONDS = 0.025;\n  var TimelineOccupancy = /*#__PURE__*/function (TimelineOccupancy) {\n    TimelineOccupancy[TimelineOccupancy[\"Point\"] = 0] = \"Point\";\n    TimelineOccupancy[TimelineOccupancy[\"Range\"] = 1] = \"Range\";\n    return TimelineOccupancy;\n  }({});\n  function generateAssetIdentifier(interstitial, uri, assetListIndex) {\n    return interstitial.identifier + \"-\" + (assetListIndex + 1) + \"-\" + hash(uri);\n  }\n  var InterstitialEvent = /*#__PURE__*/function () {\n    function InterstitialEvent(dateRange, base) {\n      this.base = void 0;\n      this._duration = null;\n      this._timelineStart = null;\n      this.appendInPlaceDisabled = void 0;\n      this.appendInPlaceStarted = void 0;\n      this.dateRange = void 0;\n      this.hasPlayed = false;\n      this.cumulativeDuration = 0;\n      this.resumeOffset = NaN;\n      this.playoutLimit = NaN;\n      this.restrictions = {\n        skip: false,\n        jump: false\n      };\n      this.snapOptions = {\n        out: false,\n        in: false\n      };\n      this.assetList = [];\n      this.assetListLoader = void 0;\n      this.assetListResponse = null;\n      this.resumeAnchor = void 0;\n      this.error = void 0;\n      this.resetOnResume = void 0;\n      this.base = base;\n      this.dateRange = dateRange;\n      this.setDateRange(dateRange);\n    }\n    var _proto = InterstitialEvent.prototype;\n    _proto.setDateRange = function setDateRange(dateRange) {\n      this.dateRange = dateRange;\n      this.resumeOffset = dateRange.attr.optionalFloat('X-RESUME-OFFSET', this.resumeOffset);\n      this.playoutLimit = dateRange.attr.optionalFloat('X-PLAYOUT-LIMIT', this.playoutLimit);\n      this.restrictions = dateRange.attr.enumeratedStringList('X-RESTRICT', this.restrictions);\n      this.snapOptions = dateRange.attr.enumeratedStringList('X-SNAP', this.snapOptions);\n    };\n    _proto.reset = function reset() {\n      var _this$assetListLoader;\n      this.appendInPlaceStarted = false;\n      (_this$assetListLoader = this.assetListLoader) == null || _this$assetListLoader.destroy();\n      this.assetListLoader = undefined;\n      if (!this.supplementsPrimary) {\n        this.assetListResponse = null;\n        this.assetList = [];\n        this._duration = null;\n      }\n      // `error?` is reset when seeking back over interstitial `startOffset`\n      //  using `schedule.resetErrorsInRange(start, end)`.\n    };\n    _proto.isAssetPastPlayoutLimit = function isAssetPastPlayoutLimit(assetIndex) {\n      var _this$assetList$asset;\n      if (assetIndex > 0 && assetIndex >= this.assetList.length) {\n        return true;\n      }\n      var playoutLimit = this.playoutLimit;\n      if (assetIndex <= 0 || isNaN(playoutLimit)) {\n        return false;\n      }\n      if (playoutLimit === 0) {\n        return true;\n      }\n      var assetOffset = ((_this$assetList$asset = this.assetList[assetIndex]) == null ? void 0 : _this$assetList$asset.startOffset) || 0;\n      return assetOffset > playoutLimit;\n    };\n    _proto.findAssetIndex = function findAssetIndex(asset) {\n      var index = this.assetList.indexOf(asset);\n      return index;\n    };\n    _proto.toString = function toString() {\n      return eventToString(this);\n    };\n    return _createClass(InterstitialEvent, [{\n      key: \"identifier\",\n      get: function get() {\n        return this.dateRange.id;\n      }\n    }, {\n      key: \"startDate\",\n      get: function get() {\n        return this.dateRange.startDate;\n      }\n    }, {\n      key: \"startTime\",\n      get: function get() {\n        // Primary media timeline start time\n        var startTime = this.dateRange.startTime;\n        if (this.snapOptions.out) {\n          var frag = this.dateRange.tagAnchor;\n          if (frag) {\n            return getSnapToFragmentTime(startTime, frag);\n          }\n        }\n        return startTime;\n      }\n    }, {\n      key: \"startOffset\",\n      get: function get() {\n        return this.cue.pre ? 0 : this.startTime;\n      }\n    }, {\n      key: \"startIsAligned\",\n      get: function get() {\n        if (this.startTime === 0 || this.snapOptions.out) {\n          return true;\n        }\n        var frag = this.dateRange.tagAnchor;\n        if (frag) {\n          var startTime = this.dateRange.startTime;\n          var snappedStart = getSnapToFragmentTime(startTime, frag);\n          return startTime - snappedStart < 0.1;\n        }\n        return false;\n      }\n    }, {\n      key: \"resumptionOffset\",\n      get: function get() {\n        var resumeOffset = this.resumeOffset;\n        var offset = isFiniteNumber(resumeOffset) ? resumeOffset : this.duration;\n        return this.cumulativeDuration + offset;\n      }\n    }, {\n      key: \"resumeTime\",\n      get: function get() {\n        // Primary media timeline resumption time\n        var resumeTime = this.startOffset + this.resumptionOffset;\n        if (this.snapOptions.in) {\n          var frag = this.resumeAnchor;\n          if (frag) {\n            return getSnapToFragmentTime(resumeTime, frag);\n          }\n        }\n        return resumeTime;\n      }\n    }, {\n      key: \"appendInPlace\",\n      get: function get() {\n        if (this.appendInPlaceStarted) {\n          return true;\n        }\n        if (this.appendInPlaceDisabled) {\n          return false;\n        }\n        if (!this.cue.once && !this.cue.pre &&\n        // preroll starts at startPosition before startPosition is known (live)\n        this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < ALIGNED_END_THRESHOLD_SECONDS)) {\n          return true;\n        }\n        return false;\n      },\n      set: function set(value) {\n        if (this.appendInPlaceStarted) {\n          this.resetOnResume = !value;\n          return;\n        }\n        this.appendInPlaceDisabled = !value;\n      }\n\n      // Extended timeline start time\n    }, {\n      key: \"timelineStart\",\n      get: function get() {\n        if (this._timelineStart !== null) {\n          return this._timelineStart;\n        }\n        return this.startTime;\n      },\n      set: function set(value) {\n        this._timelineStart = value;\n      }\n    }, {\n      key: \"duration\",\n      get: function get() {\n        var playoutLimit = this.playoutLimit;\n        var duration;\n        if (this._duration !== null) {\n          duration = this._duration;\n        } else if (this.dateRange.duration) {\n          duration = this.dateRange.duration;\n        } else {\n          duration = this.dateRange.plannedDuration || 0;\n        }\n        if (!isNaN(playoutLimit) && playoutLimit < duration) {\n          duration = playoutLimit;\n        }\n        return duration;\n      },\n      set: function set(value) {\n        this._duration = value;\n      }\n    }, {\n      key: \"cue\",\n      get: function get() {\n        return this.dateRange.cue;\n      }\n    }, {\n      key: \"timelineOccupancy\",\n      get: function get() {\n        if (this.dateRange.attr['X-TIMELINE-OCCUPIES'] === 'RANGE') {\n          return TimelineOccupancy.Range;\n        }\n        return TimelineOccupancy.Point;\n      }\n    }, {\n      key: \"supplementsPrimary\",\n      get: function get() {\n        return this.dateRange.attr['X-TIMELINE-STYLE'] === 'PRIMARY';\n      }\n    }, {\n      key: \"contentMayVary\",\n      get: function get() {\n        return this.dateRange.attr['X-CONTENT-MAY-VARY'] !== 'NO';\n      }\n    }, {\n      key: \"assetUrl\",\n      get: function get() {\n        return this.dateRange.attr['X-ASSET-URI'];\n      }\n    }, {\n      key: \"assetListUrl\",\n      get: function get() {\n        return this.dateRange.attr['X-ASSET-LIST'];\n      }\n    }, {\n      key: \"baseUrl\",\n      get: function get() {\n        return this.base.url;\n      }\n    }, {\n      key: \"assetListLoaded\",\n      get: function get() {\n        return this.assetList.length > 0 || this.assetListResponse !== null;\n      }\n    }]);\n  }();\n  function getSnapToFragmentTime(time, frag) {\n    return time - frag.start < frag.duration / 2 && !(Math.abs(time - (frag.start + frag.duration)) < ALIGNED_END_THRESHOLD_SECONDS) ? frag.start : frag.start + frag.duration;\n  }\n  function getInterstitialUrl(uri, sessionId, baseUrl) {\n    var url = new self.URL(uri, baseUrl);\n    if (url.protocol !== 'data:') {\n      url.searchParams.set('_HLS_primary_id', sessionId);\n    }\n    return url;\n  }\n  function getNextAssetIndex(interstitial, assetListIndex) {\n    while ((_interstitial$assetLi = interstitial.assetList[++assetListIndex]) != null && _interstitial$assetLi.error) {\n      var _interstitial$assetLi;\n    } /* no-op */\n    return assetListIndex;\n  }\n  function eventToString(interstitial) {\n    return \"[\\\"\" + interstitial.identifier + \"\\\" \" + (interstitial.cue.pre ? '<pre>' : interstitial.cue.post ? '<post>' : '') + interstitial.timelineStart.toFixed(2) + \"-\" + interstitial.resumeTime.toFixed(2) + \"]\";\n  }\n  function eventAssetToString(asset) {\n    var start = asset.timelineStart;\n    var duration = asset.duration || 0;\n    return \"[\\\"\" + asset.identifier + \"\\\" \" + start.toFixed(2) + \"-\" + (start + duration).toFixed(2) + \"]\";\n  }\n\n  var HlsAssetPlayer = /*#__PURE__*/function () {\n    function HlsAssetPlayer(HlsPlayerClass, userConfig, interstitial, assetItem) {\n      var _this = this;\n      this.hls = void 0;\n      this.interstitial = void 0;\n      this.assetItem = void 0;\n      this.tracks = null;\n      this.hasDetails = false;\n      this.mediaAttached = null;\n      this._currentTime = void 0;\n      this._bufferedEosTime = void 0;\n      this.checkPlayout = function () {\n        if (_this.reachedPlayout(_this.currentTime) && _this.hls) {\n          _this.hls.trigger(Events.PLAYOUT_LIMIT_REACHED, {});\n        }\n      };\n      var hls = this.hls = new HlsPlayerClass(userConfig);\n      this.interstitial = interstitial;\n      this.assetItem = assetItem;\n      var detailsLoaded = function detailsLoaded() {\n        _this.hasDetails = true;\n      };\n      hls.once(Events.LEVEL_LOADED, detailsLoaded);\n      hls.once(Events.AUDIO_TRACK_LOADED, detailsLoaded);\n      hls.once(Events.SUBTITLE_TRACK_LOADED, detailsLoaded);\n      hls.on(Events.MEDIA_ATTACHING, function (name, _ref) {\n        var media = _ref.media;\n        _this.removeMediaListeners();\n        _this.mediaAttached = media;\n        var event = _this.interstitial;\n        if (event.playoutLimit) {\n          media.addEventListener('timeupdate', _this.checkPlayout);\n          if (_this.appendInPlace) {\n            hls.on(Events.BUFFER_APPENDED, function () {\n              var bufferedEnd = _this.bufferedEnd;\n              if (_this.reachedPlayout(bufferedEnd)) {\n                _this._bufferedEosTime = bufferedEnd;\n                hls.trigger(Events.BUFFERED_TO_END, undefined);\n              }\n            });\n          }\n        }\n      });\n    }\n    var _proto = HlsAssetPlayer.prototype;\n    _proto.loadSource = function loadSource() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      if (!hls.url) {\n        var uri = this.assetItem.uri;\n        try {\n          uri = getInterstitialUrl(uri, hls.config.primarySessionId || '').href;\n        } catch (error) {\n          // Ignore error parsing ASSET_URI or adding _HLS_primary_id to it. The\n          // issue should surface as an INTERSTITIAL_ASSET_ERROR loading the asset.\n        }\n        hls.loadSource(uri);\n      } else if (hls.levels.length && !hls.started) {\n        hls.startLoad(-1, true);\n      }\n    };\n    _proto.bufferedInPlaceToEnd = function bufferedInPlaceToEnd(media) {\n      var _this$hls;\n      if (!this.appendInPlace) {\n        return false;\n      }\n      if ((_this$hls = this.hls) != null && _this$hls.bufferedToEnd) {\n        return true;\n      }\n      if (!media) {\n        return false;\n      }\n      var duration = Math.min(this._bufferedEosTime || Infinity, this.duration);\n      var start = this.timelineOffset;\n      var bufferInfo = BufferHelper.bufferInfo(media, start, 0);\n      var bufferedEnd = this.getAssetTime(bufferInfo.end);\n      return bufferedEnd >= duration - 0.02;\n    };\n    _proto.reachedPlayout = function reachedPlayout(time) {\n      var interstitial = this.interstitial;\n      var playoutLimit = interstitial.playoutLimit;\n      return this.startOffset + time >= playoutLimit;\n    };\n    _proto.getAssetTime = function getAssetTime(time) {\n      var timelineOffset = this.timelineOffset;\n      var duration = this.duration;\n      return Math.min(Math.max(0, time - timelineOffset), duration);\n    };\n    _proto.removeMediaListeners = function removeMediaListeners() {\n      var media = this.mediaAttached;\n      if (media) {\n        this._currentTime = media.currentTime;\n        this.bufferSnapShot();\n        media.removeEventListener('timeupdate', this.checkPlayout);\n      }\n    };\n    _proto.bufferSnapShot = function bufferSnapShot() {\n      if (this.mediaAttached) {\n        var _this$hls2;\n        if ((_this$hls2 = this.hls) != null && _this$hls2.bufferedToEnd) {\n          this._bufferedEosTime = this.bufferedEnd;\n        }\n      }\n    };\n    _proto.destroy = function destroy() {\n      this.removeMediaListeners();\n      if (this.hls) {\n        this.hls.destroy();\n      }\n      this.hls = null;\n      // @ts-ignore\n      this.tracks = this.mediaAttached = this.checkPlayout = null;\n    };\n    _proto.attachMedia = function attachMedia(data) {\n      var _this$hls3;\n      this.loadSource();\n      (_this$hls3 = this.hls) == null || _this$hls3.attachMedia(data);\n    };\n    _proto.detachMedia = function detachMedia() {\n      var _this$hls4;\n      this.removeMediaListeners();\n      this.mediaAttached = null;\n      (_this$hls4 = this.hls) == null || _this$hls4.detachMedia();\n    };\n    _proto.resumeBuffering = function resumeBuffering() {\n      var _this$hls5;\n      (_this$hls5 = this.hls) == null || _this$hls5.resumeBuffering();\n    };\n    _proto.pauseBuffering = function pauseBuffering() {\n      var _this$hls6;\n      (_this$hls6 = this.hls) == null || _this$hls6.pauseBuffering();\n    };\n    _proto.transferMedia = function transferMedia() {\n      var _this$hls7;\n      this.bufferSnapShot();\n      return ((_this$hls7 = this.hls) == null ? void 0 : _this$hls7.transferMedia()) || null;\n    };\n    _proto.resetDetails = function resetDetails() {\n      var hls = this.hls;\n      if (hls && this.hasDetails) {\n        hls.stopLoad();\n        var deleteDetails = function deleteDetails(obj) {\n          return delete obj.details;\n        };\n        hls.levels.forEach(deleteDetails);\n        hls.allAudioTracks.forEach(deleteDetails);\n        hls.allSubtitleTracks.forEach(deleteDetails);\n        this.hasDetails = false;\n      }\n    };\n    _proto.on = function on(event, listener, context) {\n      var _this$hls8;\n      (_this$hls8 = this.hls) == null || _this$hls8.on(event, listener);\n    };\n    _proto.once = function once(event, listener, context) {\n      var _this$hls9;\n      (_this$hls9 = this.hls) == null || _this$hls9.once(event, listener);\n    };\n    _proto.off = function off(event, listener, context) {\n      var _this$hls0;\n      (_this$hls0 = this.hls) == null || _this$hls0.off(event, listener);\n    };\n    _proto.toString = function toString() {\n      var _this$hls1;\n      return \"HlsAssetPlayer: \" + eventAssetToString(this.assetItem) + \" \" + ((_this$hls1 = this.hls) == null ? void 0 : _this$hls1.sessionId) + \" \" + (this.appendInPlace ? 'append-in-place' : '');\n    };\n    return _createClass(HlsAssetPlayer, [{\n      key: \"appendInPlace\",\n      get: function get() {\n        return this.interstitial.appendInPlace;\n      }\n    }, {\n      key: \"destroyed\",\n      get: function get() {\n        var _this$hls10;\n        return !((_this$hls10 = this.hls) != null && _this$hls10.userConfig);\n      }\n    }, {\n      key: \"assetId\",\n      get: function get() {\n        return this.assetItem.identifier;\n      }\n    }, {\n      key: \"interstitialId\",\n      get: function get() {\n        return this.assetItem.parentIdentifier;\n      }\n    }, {\n      key: \"media\",\n      get: function get() {\n        var _this$hls11;\n        return ((_this$hls11 = this.hls) == null ? void 0 : _this$hls11.media) || null;\n      }\n    }, {\n      key: \"bufferedEnd\",\n      get: function get() {\n        var media = this.media || this.mediaAttached;\n        if (!media) {\n          if (this._bufferedEosTime) {\n            return this._bufferedEosTime;\n          }\n          return this.currentTime;\n        }\n        var bufferInfo = BufferHelper.bufferInfo(media, media.currentTime, 0.001);\n        return this.getAssetTime(bufferInfo.end);\n      }\n    }, {\n      key: \"currentTime\",\n      get: function get() {\n        var media = this.media || this.mediaAttached;\n        if (!media) {\n          return this._currentTime || 0;\n        }\n        return this.getAssetTime(media.currentTime);\n      }\n    }, {\n      key: \"duration\",\n      get: function get() {\n        var duration = this.assetItem.duration;\n        if (!duration) {\n          return 0;\n        }\n        var playoutLimit = this.interstitial.playoutLimit;\n        if (playoutLimit) {\n          var assetPlayout = playoutLimit - this.startOffset;\n          if (assetPlayout > 0 && assetPlayout < duration) {\n            return assetPlayout;\n          }\n        }\n        return duration;\n      }\n    }, {\n      key: \"remaining\",\n      get: function get() {\n        var duration = this.duration;\n        if (!duration) {\n          return 0;\n        }\n        return Math.max(0, duration - this.currentTime);\n      }\n    }, {\n      key: \"startOffset\",\n      get: function get() {\n        return this.assetItem.startOffset;\n      }\n    }, {\n      key: \"timelineOffset\",\n      get: function get() {\n        var _this$hls12;\n        return ((_this$hls12 = this.hls) == null ? void 0 : _this$hls12.config.timelineOffset) || 0;\n      },\n      set: function set(value) {\n        var timelineOffset = this.timelineOffset;\n        if (value !== timelineOffset) {\n          var diff = value - timelineOffset;\n          if (Math.abs(diff) > 1 / 90000 && this.hls) {\n            if (this.hasDetails) {\n              throw new Error(\"Cannot set timelineOffset after playlists are loaded\");\n            }\n            this.hls.config.timelineOffset = value;\n          }\n        }\n      }\n    }]);\n  }();\n\n  var ABUTTING_THRESHOLD_SECONDS = 0.033;\n  var InterstitialsSchedule = /*#__PURE__*/function (_Logger) {\n    function InterstitialsSchedule(onScheduleUpdate, logger) {\n      var _this;\n      _this = _Logger.call(this, 'interstitials-sched', logger) || this;\n      _this.onScheduleUpdate = void 0;\n      _this.eventMap = {};\n      _this.events = null;\n      _this.items = null;\n      _this.durations = {\n        primary: 0,\n        playout: 0,\n        integrated: 0\n      };\n      _this.onScheduleUpdate = onScheduleUpdate;\n      return _this;\n    }\n    _inheritsLoose(InterstitialsSchedule, _Logger);\n    var _proto = InterstitialsSchedule.prototype;\n    _proto.destroy = function destroy() {\n      this.reset();\n      // @ts-ignore\n      this.onScheduleUpdate = null;\n    };\n    _proto.reset = function reset() {\n      this.eventMap = {};\n      this.setDurations(0, 0, 0);\n      if (this.events) {\n        this.events.forEach(function (interstitial) {\n          return interstitial.reset();\n        });\n      }\n      this.events = this.items = null;\n    };\n    _proto.resetErrorsInRange = function resetErrorsInRange(start, end) {\n      if (this.events) {\n        return this.events.reduce(function (count, interstitial) {\n          if (start <= interstitial.startOffset && end > interstitial.startOffset) {\n            delete interstitial.error;\n            return count + 1;\n          }\n          return count;\n        }, 0);\n      }\n      return 0;\n    };\n    _proto.getEvent = function getEvent(identifier) {\n      return identifier ? this.eventMap[identifier] || null : null;\n    };\n    _proto.hasEvent = function hasEvent(identifier) {\n      return identifier in this.eventMap;\n    };\n    _proto.findItemIndex = function findItemIndex(item, time) {\n      if (item.event) {\n        // Find Event Item\n        return this.findEventIndex(item.event.identifier);\n      }\n      // Find Primary Item\n      var index = -1;\n      if (item.nextEvent) {\n        index = this.findEventIndex(item.nextEvent.identifier) - 1;\n      } else if (item.previousEvent) {\n        index = this.findEventIndex(item.previousEvent.identifier) + 1;\n      }\n      var items = this.items;\n      if (items) {\n        if (!items[index]) {\n          if (time === undefined) {\n            time = item.start;\n          }\n          index = this.findItemIndexAtTime(time);\n        }\n        // Only return index of a Primary Item\n        while (index >= 0 && (_items$index = items[index]) != null && _items$index.event) {\n          var _items$index;\n          // If index found is an interstitial it is not a valid result as it should have been matched up top\n          // decrement until result is negative (not found) or a primary segment\n          index--;\n        }\n      }\n      return index;\n    };\n    _proto.findItemIndexAtTime = function findItemIndexAtTime(timelinePos, timelineType) {\n      var items = this.items;\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          var timeRange = items[i];\n          if (timelineType && timelineType !== 'primary') {\n            timeRange = timeRange[timelineType];\n          }\n          if (timelinePos === timeRange.start || timelinePos > timeRange.start && timelinePos < timeRange.end) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    _proto.findJumpRestrictedIndex = function findJumpRestrictedIndex(startIndex, endIndex) {\n      var items = this.items;\n      if (items) {\n        for (var i = startIndex; i <= endIndex; i++) {\n          if (!items[i]) {\n            break;\n          }\n          var event = items[i].event;\n          if (event != null && event.restrictions.jump && !event.appendInPlace) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    _proto.findEventIndex = function findEventIndex(identifier) {\n      var items = this.items;\n      if (items) {\n        for (var i = items.length; i--;) {\n          var _items$i$event;\n          if (((_items$i$event = items[i].event) == null ? void 0 : _items$i$event.identifier) === identifier) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    _proto.findAssetIndex = function findAssetIndex(event, timelinePos) {\n      var assetList = event.assetList;\n      var length = assetList.length;\n      if (length > 1) {\n        for (var i = 0; i < length; i++) {\n          var asset = assetList[i];\n          if (!asset.error) {\n            var timelineStart = asset.timelineStart;\n            if (timelinePos === timelineStart || timelinePos > timelineStart && (timelinePos < timelineStart + (asset.duration || 0) || i === length - 1)) {\n              return i;\n            }\n          }\n        }\n      }\n      return 0;\n    };\n    _proto.parseInterstitialDateRanges = function parseInterstitialDateRanges(mediaSelection, enableAppendInPlace) {\n      var _this2 = this;\n      var details = mediaSelection.main.details;\n      var dateRanges = details.dateRanges;\n      var previousInterstitialEvents = this.events;\n      var interstitialEvents = this.parseDateRanges(dateRanges, {\n        url: details.url\n      }, enableAppendInPlace);\n      var ids = Object.keys(dateRanges);\n      var removedInterstitials = previousInterstitialEvents ? previousInterstitialEvents.filter(function (event) {\n        return !ids.includes(event.identifier);\n      }) : [];\n      if (interstitialEvents.length) {\n        // pre-rolls, post-rolls, and events with the same start time are played in playlist tag order\n        // all other events are ordered by start time\n        interstitialEvents.sort(function (a, b) {\n          var aPre = a.cue.pre;\n          var aPost = a.cue.post;\n          var bPre = b.cue.pre;\n          var bPost = b.cue.post;\n          if (aPre && !bPre) {\n            return -1;\n          }\n          if (bPre && !aPre) {\n            return 1;\n          }\n          if (aPost && !bPost) {\n            return 1;\n          }\n          if (bPost && !aPost) {\n            return -1;\n          }\n          if (!aPre && !bPre && !aPost && !bPost) {\n            var startA = a.startTime;\n            var startB = b.startTime;\n            if (startA !== startB) {\n              return startA - startB;\n            }\n          }\n          return a.dateRange.tagOrder - b.dateRange.tagOrder;\n        });\n      }\n      this.events = interstitialEvents;\n\n      // Clear removed DateRanges from buffered list (kills playback of active Interstitials)\n      removedInterstitials.forEach(function (interstitial) {\n        _this2.removeEvent(interstitial);\n      });\n      this.updateSchedule(mediaSelection, removedInterstitials);\n    };\n    _proto.updateSchedule = function updateSchedule(mediaSelection, removedInterstitials, forceUpdate) {\n      if (removedInterstitials === void 0) {\n        removedInterstitials = [];\n      }\n      if (forceUpdate === void 0) {\n        forceUpdate = false;\n      }\n      var events = this.events || [];\n      if (events.length || removedInterstitials.length || this.length < 2) {\n        var currentItems = this.items;\n        var updatedItems = this.parseSchedule(events, mediaSelection);\n        var updated = forceUpdate || removedInterstitials.length || (currentItems == null ? void 0 : currentItems.length) !== updatedItems.length || updatedItems.some(function (item, i) {\n          return Math.abs(item.playout.start - currentItems[i].playout.start) > 0.005 || Math.abs(item.playout.end - currentItems[i].playout.end) > 0.005;\n        });\n        if (updated) {\n          this.items = updatedItems;\n          // call interstitials-controller onScheduleUpdated()\n          this.onScheduleUpdate(removedInterstitials, currentItems);\n        }\n      }\n    };\n    _proto.parseDateRanges = function parseDateRanges(dateRanges, baseData, enableAppendInPlace) {\n      var interstitialEvents = [];\n      var ids = Object.keys(dateRanges);\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var dateRange = dateRanges[id];\n        if (dateRange.isInterstitial) {\n          var interstitial = this.eventMap[id];\n          if (interstitial) {\n            // Update InterstitialEvent already parsed and mapped\n            // This retains already loaded duration and loaded asset list info\n            interstitial.setDateRange(dateRange);\n          } else {\n            interstitial = new InterstitialEvent(dateRange, baseData);\n            this.eventMap[id] = interstitial;\n            if (enableAppendInPlace === false) {\n              interstitial.appendInPlace = enableAppendInPlace;\n            }\n          }\n          interstitialEvents.push(interstitial);\n        }\n      }\n      return interstitialEvents;\n    };\n    _proto.parseSchedule = function parseSchedule(interstitialEvents, mediaSelection) {\n      var schedule = [];\n      var details = mediaSelection.main.details;\n      var primaryDuration = details.live ? Infinity : details.edge;\n      var playoutDuration = 0;\n\n      // Filter events that have errored from the schedule (Primary fallback)\n      interstitialEvents = interstitialEvents.filter(function (event) {\n        return !event.error && !(event.cue.once && event.hasPlayed);\n      });\n      if (interstitialEvents.length) {\n        // Update Schedule\n        this.resolveOffsets(interstitialEvents, mediaSelection);\n\n        // Populate Schedule with Interstitial Event and Primary Segment Items\n        var primaryPosition = 0;\n        var integratedTime = 0;\n        interstitialEvents.forEach(function (interstitial, i) {\n          var preroll = interstitial.cue.pre;\n          var postroll = interstitial.cue.post;\n          var previousEvent = interstitialEvents[i - 1] || null;\n          var appendInPlace = interstitial.appendInPlace;\n          var eventStart = postroll ? primaryDuration : interstitial.startOffset;\n          var interstitialDuration = interstitial.duration;\n          var timelineDuration = interstitial.timelineOccupancy === TimelineOccupancy.Range ? interstitialDuration : 0;\n          var resumptionOffset = interstitial.resumptionOffset;\n          var inSameStartTimeSequence = (previousEvent == null ? void 0 : previousEvent.startTime) === eventStart;\n          var start = eventStart + interstitial.cumulativeDuration;\n          var end = appendInPlace ? start + interstitialDuration : eventStart + resumptionOffset;\n          if (preroll || !postroll && eventStart <= 0) {\n            // preroll or in-progress midroll\n            var integratedStart = integratedTime;\n            integratedTime += timelineDuration;\n            interstitial.timelineStart = start;\n            var playoutStart = playoutDuration;\n            playoutDuration += interstitialDuration;\n            schedule.push({\n              event: interstitial,\n              start: start,\n              end: end,\n              playout: {\n                start: playoutStart,\n                end: playoutDuration\n              },\n              integrated: {\n                start: integratedStart,\n                end: integratedTime\n              }\n            });\n          } else if (eventStart <= primaryDuration) {\n            if (!inSameStartTimeSequence) {\n              var segmentDuration = eventStart - primaryPosition;\n              // Do not schedule a primary segment if interstitials are abutting by less than ABUTTING_THRESHOLD_SECONDS\n              if (segmentDuration > ABUTTING_THRESHOLD_SECONDS) {\n                // primary segment\n                var timelineStart = primaryPosition;\n                var _integratedStart = integratedTime;\n                integratedTime += segmentDuration;\n                var _playoutStart = playoutDuration;\n                playoutDuration += segmentDuration;\n                var primarySegment = {\n                  previousEvent: interstitialEvents[i - 1] || null,\n                  nextEvent: interstitial,\n                  start: timelineStart,\n                  end: timelineStart + segmentDuration,\n                  playout: {\n                    start: _playoutStart,\n                    end: playoutDuration\n                  },\n                  integrated: {\n                    start: _integratedStart,\n                    end: integratedTime\n                  }\n                };\n                schedule.push(primarySegment);\n              } else if (segmentDuration > 0 && previousEvent) {\n                // Add previous event `resumeTime` (based on duration or resumeOffset) so that it ends aligned with this one\n                previousEvent.cumulativeDuration += segmentDuration;\n                schedule[schedule.length - 1].end = eventStart;\n              }\n            }\n            // midroll / postroll\n            if (postroll) {\n              end = start;\n            }\n            interstitial.timelineStart = start;\n            var _integratedStart2 = integratedTime;\n            integratedTime += timelineDuration;\n            var _playoutStart2 = playoutDuration;\n            playoutDuration += interstitialDuration;\n            schedule.push({\n              event: interstitial,\n              start: start,\n              end: end,\n              playout: {\n                start: _playoutStart2,\n                end: playoutDuration\n              },\n              integrated: {\n                start: _integratedStart2,\n                end: integratedTime\n              }\n            });\n          } else {\n            // Interstitial starts after end of primary VOD - not included in schedule\n            return;\n          }\n          var resumeTime = interstitial.resumeTime;\n          if (postroll || resumeTime > primaryDuration) {\n            primaryPosition = primaryDuration;\n          } else {\n            primaryPosition = resumeTime;\n          }\n        });\n        if (primaryPosition < primaryDuration) {\n          var _schedule;\n          // last primary segment\n          var timelineStart = primaryPosition;\n          var integratedStart = integratedTime;\n          var segmentDuration = primaryDuration - primaryPosition;\n          integratedTime += segmentDuration;\n          var playoutStart = playoutDuration;\n          playoutDuration += segmentDuration;\n          schedule.push({\n            previousEvent: ((_schedule = schedule[schedule.length - 1]) == null ? void 0 : _schedule.event) || null,\n            nextEvent: null,\n            start: primaryPosition,\n            end: timelineStart + segmentDuration,\n            playout: {\n              start: playoutStart,\n              end: playoutDuration\n            },\n            integrated: {\n              start: integratedStart,\n              end: integratedTime\n            }\n          });\n        }\n        this.setDurations(primaryDuration, playoutDuration, integratedTime);\n      } else {\n        // no interstials - schedule is one primary segment\n        var start = 0;\n        schedule.push({\n          previousEvent: null,\n          nextEvent: null,\n          start: start,\n          end: primaryDuration,\n          playout: {\n            start: start,\n            end: primaryDuration\n          },\n          integrated: {\n            start: start,\n            end: primaryDuration\n          }\n        });\n        this.setDurations(primaryDuration, primaryDuration, primaryDuration);\n      }\n      return schedule;\n    };\n    _proto.setDurations = function setDurations(primary, playout, integrated) {\n      this.durations = {\n        primary: primary,\n        playout: playout,\n        integrated: integrated\n      };\n    };\n    _proto.resolveOffsets = function resolveOffsets(interstitialEvents, mediaSelection) {\n      var _this3 = this;\n      var details = mediaSelection.main.details;\n      var primaryDuration = details.live ? Infinity : details.edge;\n\n      // First resolve cumulative resumption offsets for Interstitials that start at the same DateTime\n      var cumulativeDuration = 0;\n      var lastScheduledStart = -1;\n      interstitialEvents.forEach(function (interstitial, i) {\n        var preroll = interstitial.cue.pre;\n        var postroll = interstitial.cue.post;\n        var eventStart = preroll ? 0 : postroll ? primaryDuration : interstitial.startTime;\n        _this3.updateAssetDurations(interstitial);\n\n        // X-RESUME-OFFSET values of interstitials scheduled at the same time are cumulative\n        var inSameStartTimeSequence = lastScheduledStart === eventStart;\n        if (inSameStartTimeSequence) {\n          interstitial.cumulativeDuration = cumulativeDuration;\n        } else {\n          cumulativeDuration = 0;\n          lastScheduledStart = eventStart;\n        }\n        if (!postroll && interstitial.snapOptions.in) {\n          // FIXME: Include audio playlist in snapping\n          interstitial.resumeAnchor = findFragmentByPTS(null, details.fragments, interstitial.startOffset + interstitial.resumptionOffset, 0, 0) || undefined;\n        }\n        // Check if primary fragments align with resumption offset and disable appendInPlace if they do not\n        if (interstitial.appendInPlace && !interstitial.appendInPlaceStarted) {\n          var alignedSegmentStart = _this3.primaryCanResumeInPlaceAt(interstitial, mediaSelection);\n          if (!alignedSegmentStart) {\n            interstitial.appendInPlace = false;\n          }\n        }\n        if (!interstitial.appendInPlace && i + 1 < interstitialEvents.length) {\n          // abutting Interstitials must use the same MediaSource strategy, this applies to all whether or not they are back to back:\n          var timeBetween = interstitialEvents[i + 1].startTime - interstitialEvents[i].resumeTime;\n          if (timeBetween < ABUTTING_THRESHOLD_SECONDS) {\n            interstitialEvents[i + 1].appendInPlace = false;\n            if (interstitialEvents[i + 1].appendInPlace) {\n              _this3.warn(\"Could not change append strategy for abutting event \" + interstitial);\n            }\n          }\n        }\n        // Update cumulativeDuration for next abutting interstitial with the same start date\n        var resumeOffset = isFiniteNumber(interstitial.resumeOffset) ? interstitial.resumeOffset : interstitial.duration;\n        cumulativeDuration += resumeOffset;\n      });\n    };\n    _proto.primaryCanResumeInPlaceAt = function primaryCanResumeInPlaceAt(interstitial, mediaSelection) {\n      var _this4 = this;\n      var resumeTime = interstitial.resumeTime;\n      var resumesInPlaceAt = interstitial.startTime + interstitial.resumptionOffset;\n      if (Math.abs(resumeTime - resumesInPlaceAt) > ALIGNED_END_THRESHOLD_SECONDS) {\n        this.log(\"\\\"\" + interstitial.identifier + \"\\\" resumption \" + resumeTime + \" not aligned with estimated timeline end \" + resumesInPlaceAt);\n        return false;\n      }\n      var playlists = Object.keys(mediaSelection);\n      return !playlists.some(function (playlistType) {\n        var details = mediaSelection[playlistType].details;\n        var playlistEnd = details.edge;\n        if (resumeTime >= playlistEnd) {\n          // Live playback - resumption segments are not yet available\n          _this4.log(\"\\\"\" + interstitial.identifier + \"\\\" resumption \" + resumeTime + \" past \" + playlistType + \" playlist end \" + playlistEnd);\n          // Assume alignment is possible (or reset can take place)\n          return false;\n        }\n        var startFragment = findFragmentByPTS(null, details.fragments, resumeTime);\n        if (!startFragment) {\n          _this4.log(\"\\\"\" + interstitial.identifier + \"\\\" resumption \" + resumeTime + \" does not align with any fragments in \" + playlistType + \" playlist (\" + details.fragStart + \"-\" + details.fragmentEnd + \")\");\n          return true;\n        }\n        var allowance = playlistType === 'audio' ? 0.175 : 0;\n        var alignedWithSegment = Math.abs(startFragment.start - resumeTime) < ALIGNED_END_THRESHOLD_SECONDS + allowance || Math.abs(startFragment.end - resumeTime) < ALIGNED_END_THRESHOLD_SECONDS + allowance;\n        if (!alignedWithSegment) {\n          _this4.log(\"\\\"\" + interstitial.identifier + \"\\\" resumption \" + resumeTime + \" not aligned with \" + playlistType + \" fragment bounds (\" + startFragment.start + \"-\" + startFragment.end + \" sn: \" + startFragment.sn + \" cc: \" + startFragment.cc + \")\");\n          return true;\n        }\n        return false;\n      });\n    };\n    _proto.updateAssetDurations = function updateAssetDurations(interstitial) {\n      if (!interstitial.assetListLoaded) {\n        return;\n      }\n      var eventStart = interstitial.timelineStart;\n      var sumDuration = 0;\n      var hasUnknownDuration = false;\n      var hasErrors = false;\n      for (var i = 0; i < interstitial.assetList.length; i++) {\n        var asset = interstitial.assetList[i];\n        var timelineStart = eventStart + sumDuration;\n        asset.startOffset = sumDuration;\n        asset.timelineStart = timelineStart;\n        hasUnknownDuration || (hasUnknownDuration = asset.duration === null);\n        hasErrors || (hasErrors = !!asset.error);\n        var duration = asset.error ? 0 : asset.duration || 0;\n        sumDuration += duration;\n      }\n      // Use the sum of known durations when it is greater than the stated duration\n      if (hasUnknownDuration && !hasErrors) {\n        interstitial.duration = Math.max(sumDuration, interstitial.duration);\n      } else {\n        interstitial.duration = sumDuration;\n      }\n    };\n    _proto.removeEvent = function removeEvent(interstitial) {\n      interstitial.reset();\n      delete this.eventMap[interstitial.identifier];\n    };\n    return _createClass(InterstitialsSchedule, [{\n      key: \"duration\",\n      get: function get() {\n        var items = this.items;\n        return items ? items[items.length - 1].end : 0;\n      }\n    }, {\n      key: \"length\",\n      get: function get() {\n        return this.items ? this.items.length : 0;\n      }\n    }, {\n      key: \"assetIdAtEnd\",\n      get: function get() {\n        var _this$items;\n        var interstitialAtEnd = (_this$items = this.items) == null || (_this$items = _this$items[this.length - 1]) == null ? void 0 : _this$items.event;\n        if (interstitialAtEnd) {\n          var assetList = interstitialAtEnd.assetList;\n          var assetAtEnd = assetList[assetList.length - 1];\n          if (assetAtEnd) {\n            return assetAtEnd.identifier;\n          }\n        }\n        return null;\n      }\n    }]);\n  }(Logger);\n  function segmentToString(segment) {\n    return \"[\" + (segment.event ? '\"' + segment.event.identifier + '\"' : 'primary') + \": \" + segment.start.toFixed(2) + \"-\" + segment.end.toFixed(2) + \"]\";\n  }\n\n  var AssetListLoader = /*#__PURE__*/function () {\n    function AssetListLoader(hls) {\n      this.hls = void 0;\n      this.hls = hls;\n    }\n    var _proto = AssetListLoader.prototype;\n    _proto.destroy = function destroy() {\n      // @ts-ignore\n      this.hls = null;\n    };\n    _proto.loadAssetList = function loadAssetList(interstitial, hlsStartOffset) {\n      var _this = this;\n      var assetListUrl = interstitial.assetListUrl;\n      var url;\n      try {\n        url = getInterstitialUrl(assetListUrl, this.hls.sessionId, interstitial.baseUrl);\n      } catch (error) {\n        var errorData = this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_ERROR, error, assetListUrl);\n        this.hls.trigger(Events.ERROR, errorData);\n        return;\n      }\n      if (hlsStartOffset && url.protocol !== 'data:') {\n        url.searchParams.set('_HLS_start_offset', '' + hlsStartOffset);\n      }\n      var config = this.hls.config;\n      var Loader = config.loader;\n      var loader = new Loader(config);\n      var context = {\n        responseType: 'json',\n        url: url.href\n      };\n      var loadPolicy = config.interstitialAssetListLoadPolicy.default;\n      var loaderConfig = {\n        loadPolicy: loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      var callbacks = {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          var assetListResponse = response.data;\n          var assets = assetListResponse == null ? void 0 : assetListResponse.ASSETS;\n          if (!Array.isArray(assets)) {\n            var _errorData = _this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_PARSING_ERROR, new Error(\"Invalid interstitial asset list\"), context.url, stats, networkDetails);\n            _this.hls.trigger(Events.ERROR, _errorData);\n            return;\n          }\n          interstitial.assetListResponse = assetListResponse;\n          _this.hls.trigger(Events.ASSET_LIST_LOADED, {\n            event: interstitial,\n            assetListResponse: assetListResponse,\n            networkDetails: networkDetails\n          });\n        },\n        onError: function onError(error, context, networkDetails, stats) {\n          var errorData = _this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_ERROR, new Error(\"Error loading X-ASSET-LIST: HTTP status \" + error.code + \" \" + error.text + \" (\" + context.url + \")\"), context.url, stats, networkDetails);\n          _this.hls.trigger(Events.ERROR, errorData);\n        },\n        onTimeout: function onTimeout(stats, context, networkDetails) {\n          var errorData = _this.assignAssetListError(interstitial, ErrorDetails.ASSET_LIST_LOAD_TIMEOUT, new Error(\"Timeout loading X-ASSET-LIST (\" + context.url + \")\"), context.url, stats, networkDetails);\n          _this.hls.trigger(Events.ERROR, errorData);\n        }\n      };\n      loader.load(context, loaderConfig, callbacks);\n      this.hls.trigger(Events.ASSET_LIST_LOADING, {\n        event: interstitial\n      });\n      return loader;\n    };\n    _proto.assignAssetListError = function assignAssetListError(interstitial, details, error, url, stats, networkDetails) {\n      interstitial.error = error;\n      return {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: details,\n        fatal: false,\n        interstitial: interstitial,\n        url: url,\n        error: error,\n        networkDetails: networkDetails,\n        stats: stats\n      };\n    };\n    return AssetListLoader;\n  }();\n\n  function playWithCatch(media) {\n    var _media$play;\n    media == null || (_media$play = media.play()) == null || _media$play.catch(function () {\n      /* no-op */\n    });\n  }\n  function timelineMessage(label, time) {\n    return \"[\" + label + \"] Advancing timeline position to \" + time;\n  }\n  var InterstitialsController = /*#__PURE__*/function (_Logger) {\n    function InterstitialsController(hls, HlsPlayerClass) {\n      var _this;\n      _this = _Logger.call(this, 'interstitials', hls.logger) || this;\n      _this.HlsPlayerClass = void 0;\n      _this.hls = void 0;\n      _this.assetListLoader = void 0;\n      // Last updated LevelDetails\n      _this.mediaSelection = null;\n      _this.altSelection = null;\n      // Media and MediaSource/SourceBuffers\n      _this.media = null;\n      _this.detachedData = null;\n      _this.requiredTracks = null;\n      // Public Interface for Interstitial playback state and control\n      _this.manager = null;\n      // Interstitial Asset Players\n      _this.playerQueue = [];\n      // Timeline position tracking\n      _this.bufferedPos = -1;\n      _this.timelinePos = -1;\n      // Schedule\n      _this.schedule = void 0;\n      // Schedule playback and buffering state\n      _this.playingItem = null;\n      _this.bufferingItem = null;\n      _this.waitingItem = null;\n      _this.endedItem = null;\n      _this.playingAsset = null;\n      _this.endedAsset = null;\n      _this.bufferingAsset = null;\n      _this.shouldPlay = false;\n      _this.onPlay = function () {\n        _this.shouldPlay = true;\n      };\n      _this.onPause = function () {\n        _this.shouldPlay = false;\n      };\n      _this.onSeeking = function () {\n        var currentTime = _this.currentTime;\n        if (currentTime === undefined || _this.playbackDisabled || !_this.schedule) {\n          return;\n        }\n        var diff = currentTime - _this.timelinePos;\n        var roundingError = Math.abs(diff) < 1 / 705600000; // one flick\n        if (roundingError) {\n          return;\n        }\n        var backwardSeek = diff <= -0.01;\n        _this.timelinePos = currentTime;\n        _this.bufferedPos = currentTime;\n\n        // Check if seeking out of an item\n        var playingItem = _this.playingItem;\n        if (!playingItem) {\n          _this.checkBuffer();\n          return;\n        }\n        if (backwardSeek) {\n          var resetCount = _this.schedule.resetErrorsInRange(currentTime, currentTime - diff);\n          if (resetCount) {\n            _this.updateSchedule(true);\n          }\n        }\n        _this.checkBuffer();\n        if (backwardSeek && currentTime < playingItem.start || currentTime >= playingItem.end) {\n          var _this$media;\n          var playingIndex = _this.findItemIndex(playingItem);\n          var scheduleIndex = _this.schedule.findItemIndexAtTime(currentTime);\n          if (scheduleIndex === -1) {\n            scheduleIndex = playingIndex + (backwardSeek ? -1 : 1);\n            _this.log(\"seeked \" + (backwardSeek ? 'back ' : '') + \"to position not covered by schedule \" + currentTime + \" (resolving from \" + playingIndex + \" to \" + scheduleIndex + \")\");\n          }\n          if (!_this.isInterstitial(playingItem) && (_this$media = _this.media) != null && _this$media.paused) {\n            _this.shouldPlay = false;\n          }\n          if (!backwardSeek) {\n            // check if an Interstitial between the current item and target item has an X-RESTRICT JUMP restriction\n            if (scheduleIndex > playingIndex) {\n              var jumpIndex = _this.schedule.findJumpRestrictedIndex(playingIndex + 1, scheduleIndex);\n              if (jumpIndex > playingIndex) {\n                _this.setSchedulePosition(jumpIndex);\n                return;\n              }\n            }\n          }\n          _this.setSchedulePosition(scheduleIndex);\n          return;\n        }\n        // Check if seeking out of an asset (assumes same item following above check)\n        var playingAsset = _this.playingAsset;\n        if (!playingAsset) {\n          // restart Interstitial at end\n          if (_this.playingLastItem && _this.isInterstitial(playingItem)) {\n            var restartAsset = playingItem.event.assetList[0];\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (restartAsset) {\n              _this.endedItem = _this.playingItem;\n              _this.playingItem = null;\n              _this.setScheduleToAssetAtTime(currentTime, restartAsset);\n            }\n          }\n          return;\n        }\n        var start = playingAsset.timelineStart;\n        var duration = playingAsset.duration || 0;\n        if (backwardSeek && currentTime < start || currentTime >= start + duration) {\n          var _playingItem$event;\n          if ((_playingItem$event = playingItem.event) != null && _playingItem$event.appendInPlace) {\n            // Return SourceBuffer(s) to primary player and flush\n            _this.clearAssetPlayers(playingItem.event, playingItem);\n            _this.flushFrontBuffer(currentTime);\n          }\n          _this.setScheduleToAssetAtTime(currentTime, playingAsset);\n        }\n      };\n      _this.onTimeupdate = function () {\n        var currentTime = _this.currentTime;\n        if (currentTime === undefined || _this.playbackDisabled) {\n          return;\n        }\n\n        // Only allow timeupdate to advance primary position, seeking is used for jumping back\n        // this prevents primaryPos from being reset to 0 after re-attach\n        if (currentTime > _this.timelinePos) {\n          _this.timelinePos = currentTime;\n          if (currentTime > _this.bufferedPos) {\n            _this.checkBuffer();\n          }\n        } else {\n          return;\n        }\n\n        // Check if playback has entered the next item\n        var playingItem = _this.playingItem;\n        if (!playingItem || _this.playingLastItem) {\n          return;\n        }\n        if (currentTime >= playingItem.end) {\n          _this.timelinePos = playingItem.end;\n          var playingIndex = _this.findItemIndex(playingItem);\n          _this.setSchedulePosition(playingIndex + 1);\n        }\n        // Check if playback has entered the next asset\n        var playingAsset = _this.playingAsset;\n        if (!playingAsset) {\n          return;\n        }\n        var end = playingAsset.timelineStart + (playingAsset.duration || 0);\n        if (currentTime >= end) {\n          _this.setScheduleToAssetAtTime(currentTime, playingAsset);\n        }\n      };\n      // Schedule update callback\n      _this.onScheduleUpdate = function (removedInterstitials, previousItems) {\n        var schedule = _this.schedule;\n        if (!schedule) {\n          return;\n        }\n        var playingItem = _this.playingItem;\n        var interstitialEvents = schedule.events || [];\n        var scheduleItems = schedule.items || [];\n        var durations = schedule.durations;\n        var removedIds = removedInterstitials.map(function (interstitial) {\n          return interstitial.identifier;\n        });\n        var interstitialsUpdated = !!(interstitialEvents.length || removedIds.length);\n        if (interstitialsUpdated || previousItems) {\n          _this.log(\"INTERSTITIALS_UPDATED (\" + interstitialEvents.length + \"): \" + interstitialEvents + \"\\nSchedule: \" + scheduleItems.map(function (seg) {\n            return segmentToString(seg);\n          }) + \" pos: \" + _this.timelinePos);\n        }\n        if (removedIds.length) {\n          _this.log(\"Removed events \" + removedIds);\n        }\n\n        // Update schedule item references\n        // Do not replace Interstitial playingItem without a match - used for INTERSTITIAL_ASSET_ENDED and INTERSTITIAL_ENDED\n        var updatedPlayingItem = null;\n        var updatedBufferingItem = null;\n        if (playingItem) {\n          updatedPlayingItem = _this.updateItem(playingItem, _this.timelinePos);\n          if (_this.itemsMatch(playingItem, updatedPlayingItem)) {\n            _this.playingItem = updatedPlayingItem;\n          } else {\n            _this.waitingItem = _this.endedItem = null;\n          }\n        }\n        // Clear waitingItem if it has been removed from the schedule\n        _this.waitingItem = _this.updateItem(_this.waitingItem);\n        _this.endedItem = _this.updateItem(_this.endedItem);\n        // Do not replace Interstitial bufferingItem without a match - used for transfering media element or source\n        var bufferingItem = _this.bufferingItem;\n        if (bufferingItem) {\n          updatedBufferingItem = _this.updateItem(bufferingItem, _this.bufferedPos);\n          if (_this.itemsMatch(bufferingItem, updatedBufferingItem)) {\n            _this.bufferingItem = updatedBufferingItem;\n          } else if (bufferingItem.event) {\n            // Interstitial removed from schedule (Live -> VOD or other scenario where Start Date is outside the range of VOD Playlist)\n            _this.bufferingItem = _this.playingItem;\n            _this.clearInterstitial(bufferingItem.event, null);\n          }\n        }\n        removedInterstitials.forEach(function (interstitial) {\n          interstitial.assetList.forEach(function (asset) {\n            _this.clearAssetPlayer(asset.identifier, null);\n          });\n        });\n        _this.playerQueue.forEach(function (player) {\n          if (player.interstitial.appendInPlace) {\n            var timelineStart = player.assetItem.timelineStart;\n            var diff = player.timelineOffset - timelineStart;\n            if (diff) {\n              try {\n                player.timelineOffset = timelineStart;\n              } catch (e) {\n                if (Math.abs(diff) > ALIGNED_END_THRESHOLD_SECONDS) {\n                  _this.warn(e + \" (\\\"\" + player.assetId + \"\\\" \" + player.timelineOffset + \"->\" + timelineStart + \")\");\n                }\n              }\n            }\n          }\n        });\n        if (interstitialsUpdated || previousItems) {\n          _this.hls.trigger(Events.INTERSTITIALS_UPDATED, {\n            events: interstitialEvents.slice(0),\n            schedule: scheduleItems.slice(0),\n            durations: durations,\n            removedIds: removedIds\n          });\n          if (_this.isInterstitial(playingItem) && removedIds.includes(playingItem.event.identifier)) {\n            _this.warn(\"Interstitial \\\"\" + playingItem.event.identifier + \"\\\" removed while playing\");\n            _this.primaryFallback(playingItem.event);\n            return;\n          }\n          if (playingItem) {\n            _this.trimInPlace(updatedPlayingItem, playingItem);\n          }\n          if (bufferingItem && updatedBufferingItem !== updatedPlayingItem) {\n            _this.trimInPlace(updatedBufferingItem, bufferingItem);\n          }\n\n          // Check if buffered to new Interstitial event boundary\n          // (Live update publishes Interstitial with new segment)\n          _this.checkBuffer();\n        }\n      };\n      _this.hls = hls;\n      _this.HlsPlayerClass = HlsPlayerClass;\n      _this.assetListLoader = new AssetListLoader(hls);\n      _this.schedule = new InterstitialsSchedule(_this.onScheduleUpdate, hls.logger);\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(InterstitialsController, _Logger);\n    var _proto = InterstitialsController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (hls) {\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.on(Events.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this);\n        hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n        hls.on(Events.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this);\n        hls.on(Events.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this);\n        hls.on(Events.ASSET_LIST_LOADED, this.onAssetListLoaded, this);\n        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.on(Events.BUFFERED_TO_END, this.onBufferedToEnd, this);\n        hls.on(Events.MEDIA_ENDED, this.onMediaEnded, this);\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.DESTROYING, this.onDestroying, this);\n      }\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (hls) {\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.off(Events.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this);\n        hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n        hls.off(Events.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this);\n        hls.off(Events.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this);\n        hls.off(Events.ASSET_LIST_LOADED, this.onAssetListLoaded, this);\n        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.off(Events.BUFFERED_TO_END, this.onBufferedToEnd, this);\n        hls.off(Events.MEDIA_ENDED, this.onMediaEnded, this);\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.DESTROYING, this.onDestroying, this);\n      }\n    };\n    _proto.startLoad = function startLoad() {\n      // TODO: startLoad - check for waitingItem and retry by resetting schedule\n      this.resumeBuffering();\n    };\n    _proto.stopLoad = function stopLoad() {\n      // TODO: stopLoad - stop all scheule.events[].assetListLoader?.abort() then delete the loaders\n      this.pauseBuffering();\n    };\n    _proto.resumeBuffering = function resumeBuffering() {\n      var _this$getBufferingPla;\n      (_this$getBufferingPla = this.getBufferingPlayer()) == null || _this$getBufferingPla.resumeBuffering();\n    };\n    _proto.pauseBuffering = function pauseBuffering() {\n      var _this$getBufferingPla2;\n      (_this$getBufferingPla2 = this.getBufferingPlayer()) == null || _this$getBufferingPla2.pauseBuffering();\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.stopLoad();\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (this.assetListLoader) {\n        this.assetListLoader.destroy();\n      }\n      this.emptyPlayerQueue();\n      this.clearScheduleState();\n      if (this.schedule) {\n        this.schedule.destroy();\n      }\n      this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.schedule = this.manager = null;\n      // @ts-ignore\n      this.hls = this.HlsPlayerClass = this.log = null;\n      // @ts-ignore\n      this.assetListLoader = null;\n      // @ts-ignore\n      this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null;\n      // @ts-ignore\n      this.onScheduleUpdate = null;\n    };\n    _proto.onDestroying = function onDestroying() {\n      var media = this.primaryMedia || this.media;\n      if (media) {\n        this.removeMediaListeners(media);\n      }\n    };\n    _proto.removeMediaListeners = function removeMediaListeners(media) {\n      removeEventListener(media, 'play', this.onPlay);\n      removeEventListener(media, 'pause', this.onPause);\n      removeEventListener(media, 'seeking', this.onSeeking);\n      removeEventListener(media, 'timeupdate', this.onTimeupdate);\n    };\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      var media = this.media = data.media;\n      addEventListener(media, 'seeking', this.onSeeking);\n      addEventListener(media, 'timeupdate', this.onTimeupdate);\n      addEventListener(media, 'play', this.onPlay);\n      addEventListener(media, 'pause', this.onPause);\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      var playingItem = this.effectivePlayingItem;\n      var detachedMedia = this.detachedData;\n      this.detachedData = null;\n      if (playingItem === null) {\n        this.checkStart();\n      } else if (!detachedMedia) {\n        // Resume schedule after detached externally\n        this.clearScheduleState();\n        var playingIndex = this.findItemIndex(playingItem);\n        this.setSchedulePosition(playingIndex);\n      }\n    };\n    _proto.clearScheduleState = function clearScheduleState() {\n      this.log(\"clear schedule state\");\n      this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      var transferringMedia = !!data.transferMedia;\n      var media = this.media;\n      this.media = null;\n      if (transferringMedia) {\n        return;\n      }\n      if (media) {\n        this.removeMediaListeners(media);\n      }\n      // If detachMedia is called while in an Interstitial, detach the asset player as well and reset the schedule position\n      if (this.detachedData) {\n        var player = this.getBufferingPlayer();\n        if (player) {\n          this.log(\"Removing schedule state for detachedData and \" + player);\n          this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null;\n          player.detachMedia();\n        }\n        this.shouldPlay = false;\n      }\n    };\n    _proto.isInterstitial = function isInterstitial(item) {\n      return !!(item != null && item.event);\n    };\n    _proto.retreiveMediaSource = function retreiveMediaSource(assetId, toSegment) {\n      var player = this.getAssetPlayer(assetId);\n      if (player) {\n        this.transferMediaFromPlayer(player, toSegment);\n      }\n    };\n    _proto.transferMediaFromPlayer = function transferMediaFromPlayer(player, toSegment) {\n      var appendInPlace = player.interstitial.appendInPlace;\n      var playerMedia = player.media;\n      if (appendInPlace && playerMedia === this.primaryMedia) {\n        this.bufferingAsset = null;\n        if (!toSegment || this.isInterstitial(toSegment) && !toSegment.event.appendInPlace) {\n          // MediaSource cannot be transfered back to an Interstitial that requires a source reset\n          // no-op when toSegment is undefined\n          if (toSegment && playerMedia) {\n            this.detachedData = {\n              media: playerMedia\n            };\n            return;\n          }\n        }\n        var attachMediaSourceData = player.transferMedia();\n        this.log(\"transfer MediaSource from \" + player + \" \" + stringify(attachMediaSourceData));\n        this.detachedData = attachMediaSourceData;\n      } else if (toSegment && playerMedia) {\n        this.shouldPlay || (this.shouldPlay = !playerMedia.paused);\n      }\n    };\n    _proto.transferMediaTo = function transferMediaTo(player, media) {\n      var _this$detachedData,\n        _this2 = this,\n        _attachMediaSourceDat;\n      if (player.media === media) {\n        return;\n      }\n      var attachMediaSourceData = null;\n      var primaryPlayer = this.hls;\n      var isAssetPlayer = player !== primaryPlayer;\n      var appendInPlace = isAssetPlayer && player.interstitial.appendInPlace;\n      var detachedMediaSource = (_this$detachedData = this.detachedData) == null ? void 0 : _this$detachedData.mediaSource;\n      var logFromSource;\n      if (primaryPlayer.media) {\n        if (appendInPlace) {\n          attachMediaSourceData = primaryPlayer.transferMedia();\n          this.detachedData = attachMediaSourceData;\n        }\n        logFromSource = \"Primary\";\n      } else if (detachedMediaSource) {\n        var bufferingPlayer = this.getBufferingPlayer();\n        if (bufferingPlayer) {\n          attachMediaSourceData = bufferingPlayer.transferMedia();\n          logFromSource = \"\" + bufferingPlayer;\n        } else {\n          logFromSource = \"detached MediaSource\";\n        }\n      } else {\n        logFromSource = \"detached media\";\n      }\n      if (!attachMediaSourceData) {\n        if (detachedMediaSource) {\n          attachMediaSourceData = this.detachedData;\n          this.log(\"using detachedData: MediaSource \" + stringify(attachMediaSourceData));\n        } else if (!this.detachedData || primaryPlayer.media === media) {\n          // Keep interstitial media transition consistent\n          var playerQueue = this.playerQueue;\n          if (playerQueue.length > 1) {\n            playerQueue.forEach(function (queuedPlayer) {\n              if (isAssetPlayer && queuedPlayer.interstitial.appendInPlace !== appendInPlace) {\n                var interstitial = queuedPlayer.interstitial;\n                _this2.clearInterstitial(queuedPlayer.interstitial, null);\n                interstitial.appendInPlace = false; // setter may be a no-op;\n                // `appendInPlace` getter may still return `true` after insterstitial streaming has begun in that mode.\n                if (interstitial.appendInPlace) {\n                  _this2.warn(\"Could not change append strategy for queued assets \" + interstitial);\n                }\n              }\n            });\n          }\n          this.hls.detachMedia();\n          this.detachedData = {\n            media: media\n          };\n        }\n      }\n      var transferring = attachMediaSourceData && 'mediaSource' in attachMediaSourceData && ((_attachMediaSourceDat = attachMediaSourceData.mediaSource) == null ? void 0 : _attachMediaSourceDat.readyState) !== 'closed';\n      var dataToAttach = transferring && attachMediaSourceData ? attachMediaSourceData : media;\n      this.log((transferring ? 'transfering MediaSource' : 'attaching media') + \" to \" + (isAssetPlayer ? player : 'Primary') + \" from \" + logFromSource + \" (media.currentTime: \" + media.currentTime + \")\");\n      var schedule = this.schedule;\n      if (dataToAttach === attachMediaSourceData && schedule) {\n        var isAssetAtEndOfSchedule = isAssetPlayer && player.assetId === schedule.assetIdAtEnd;\n        // Prevent asset players from marking EoS on transferred MediaSource\n        dataToAttach.overrides = {\n          duration: schedule.duration,\n          endOfStream: !isAssetPlayer || isAssetAtEndOfSchedule,\n          cueRemoval: !isAssetPlayer\n        };\n      }\n      player.attachMedia(dataToAttach);\n    };\n    _proto.onInterstitialCueEnter = function onInterstitialCueEnter() {\n      this.onTimeupdate();\n    };\n    // Scheduling methods\n    _proto.checkStart = function checkStart() {\n      var schedule = this.schedule;\n      var interstitialEvents = schedule == null ? void 0 : schedule.events;\n      if (!interstitialEvents || this.playbackDisabled || !this.media) {\n        return;\n      }\n      // Check buffered to pre-roll\n      if (this.bufferedPos === -1) {\n        this.bufferedPos = 0;\n      }\n      // Start stepping through schedule when playback begins for the first time and we have a pre-roll\n      var timelinePos = this.timelinePos;\n      var effectivePlayingItem = this.effectivePlayingItem;\n      if (timelinePos === -1) {\n        var startPosition = this.hls.startPosition;\n        this.log(timelineMessage('checkStart', startPosition));\n        this.timelinePos = startPosition;\n        if (interstitialEvents.length && interstitialEvents[0].cue.pre) {\n          var index = schedule.findEventIndex(interstitialEvents[0].identifier);\n          this.setSchedulePosition(index);\n        } else if (startPosition >= 0 || !this.primaryLive) {\n          var start = this.timelinePos = startPosition > 0 ? startPosition : 0;\n          var _index = schedule.findItemIndexAtTime(start);\n          this.setSchedulePosition(_index);\n        }\n      } else if (effectivePlayingItem && !this.playingItem) {\n        var _index2 = schedule.findItemIndex(effectivePlayingItem);\n        this.setSchedulePosition(_index2);\n      }\n    };\n    _proto.advanceAssetBuffering = function advanceAssetBuffering(item, assetItem) {\n      var interstitial = item.event;\n      var assetListIndex = interstitial.findAssetIndex(assetItem);\n      var nextAssetIndex = getNextAssetIndex(interstitial, assetListIndex);\n      if (!interstitial.isAssetPastPlayoutLimit(nextAssetIndex)) {\n        this.bufferedToEvent(item, nextAssetIndex);\n      } else if (this.schedule) {\n        var _this$schedule$items;\n        var nextItem = (_this$schedule$items = this.schedule.items) == null ? void 0 : _this$schedule$items[this.findItemIndex(item) + 1];\n        if (nextItem) {\n          this.bufferedToItem(nextItem);\n        }\n      }\n    };\n    _proto.advanceAfterAssetEnded = function advanceAfterAssetEnded(interstitial, index, assetListIndex) {\n      var nextAssetIndex = getNextAssetIndex(interstitial, assetListIndex);\n      if (!interstitial.isAssetPastPlayoutLimit(nextAssetIndex)) {\n        // Advance to next asset list item\n        if (interstitial.appendInPlace) {\n          var assetItem = interstitial.assetList[nextAssetIndex];\n          if (assetItem) {\n            this.advanceInPlace(assetItem.timelineStart);\n          }\n        }\n        this.setSchedulePosition(index, nextAssetIndex);\n      } else if (this.schedule) {\n        // Advance to next schedule segment\n        // check if we've reached the end of the program\n        var scheduleItems = this.schedule.items;\n        if (scheduleItems) {\n          var nextIndex = index + 1;\n          var scheduleLength = scheduleItems.length;\n          if (nextIndex >= scheduleLength) {\n            this.setSchedulePosition(-1);\n            return;\n          }\n          var resumptionTime = interstitial.resumeTime;\n          if (this.timelinePos < resumptionTime) {\n            this.log(timelineMessage('advanceAfterAssetEnded', resumptionTime));\n            this.timelinePos = resumptionTime;\n            if (interstitial.appendInPlace) {\n              this.advanceInPlace(resumptionTime);\n            }\n            this.checkBuffer(this.bufferedPos < resumptionTime);\n          }\n          this.setSchedulePosition(nextIndex);\n        }\n      }\n    };\n    _proto.setScheduleToAssetAtTime = function setScheduleToAssetAtTime(time, playingAsset) {\n      var schedule = this.schedule;\n      if (!schedule) {\n        return;\n      }\n      var parentIdentifier = playingAsset.parentIdentifier;\n      var interstitial = schedule.getEvent(parentIdentifier);\n      if (interstitial) {\n        var itemIndex = schedule.findEventIndex(parentIdentifier);\n        var assetListIndex = schedule.findAssetIndex(interstitial, time);\n        this.advanceAfterAssetEnded(interstitial, itemIndex, assetListIndex - 1);\n      }\n    };\n    _proto.setSchedulePosition = function setSchedulePosition(index, assetListIndex) {\n      var _this$schedule;\n      var scheduleItems = (_this$schedule = this.schedule) == null ? void 0 : _this$schedule.items;\n      if (!scheduleItems || this.playbackDisabled) {\n        return;\n      }\n      var scheduledItem = index >= 0 ? scheduleItems[index] : null;\n      this.log(\"setSchedulePosition \" + index + \", \" + assetListIndex + \" (\" + (scheduledItem ? segmentToString(scheduledItem) : scheduledItem) + \") pos: \" + this.timelinePos);\n      // Cleanup current item / asset\n      var currentItem = this.waitingItem || this.playingItem;\n      var playingLastItem = this.playingLastItem;\n      if (this.isInterstitial(currentItem)) {\n        var interstitial = currentItem.event;\n        var playingAsset = this.playingAsset;\n        var assetId = playingAsset == null ? void 0 : playingAsset.identifier;\n        var player = assetId ? this.getAssetPlayer(assetId) : null;\n        if (player && assetId && (!this.eventItemsMatch(currentItem, scheduledItem) || assetListIndex !== undefined && assetId !== interstitial.assetList[assetListIndex].identifier)) {\n          var _this$detachedData2;\n          var playingAssetListIndex = interstitial.findAssetIndex(playingAsset);\n          this.log(\"INTERSTITIAL_ASSET_ENDED \" + (playingAssetListIndex + 1) + \"/\" + interstitial.assetList.length + \" \" + eventAssetToString(playingAsset));\n          this.endedAsset = playingAsset;\n          this.playingAsset = null;\n          this.hls.trigger(Events.INTERSTITIAL_ASSET_ENDED, {\n            asset: playingAsset,\n            assetListIndex: playingAssetListIndex,\n            event: interstitial,\n            schedule: scheduleItems.slice(0),\n            scheduleIndex: index,\n            player: player\n          });\n          if (currentItem !== this.playingItem) {\n            // Schedule change occured on INTERSTITIAL_ASSET_ENDED\n            if (this.itemsMatch(currentItem, this.playingItem) &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            !this.playingAsset // INTERSTITIAL_ASSET_ENDED side-effect\n            ) {\n              this.advanceAfterAssetEnded(interstitial, this.findItemIndex(this.playingItem), playingAssetListIndex);\n            }\n            // Navigation occured on INTERSTITIAL_ASSET_ENDED\n            return;\n          }\n          this.retreiveMediaSource(assetId, scheduledItem);\n          if (player.media && !((_this$detachedData2 = this.detachedData) != null && _this$detachedData2.mediaSource)) {\n            player.detachMedia();\n          }\n        }\n        if (!this.eventItemsMatch(currentItem, scheduledItem)) {\n          this.endedItem = currentItem;\n          this.playingItem = null;\n          this.log(\"INTERSTITIAL_ENDED \" + interstitial + \" \" + segmentToString(currentItem));\n          interstitial.hasPlayed = true;\n          this.hls.trigger(Events.INTERSTITIAL_ENDED, {\n            event: interstitial,\n            schedule: scheduleItems.slice(0),\n            scheduleIndex: index\n          });\n          // Exiting an Interstitial\n          if (interstitial.cue.once) {\n            var _this$schedule2;\n            // Remove interstitial with CUE attribute value of ONCE after it has played\n            this.updateSchedule();\n            var updatedScheduleItems = (_this$schedule2 = this.schedule) == null ? void 0 : _this$schedule2.items;\n            if (scheduledItem && updatedScheduleItems) {\n              var updatedIndex = this.findItemIndex(scheduledItem);\n              this.advanceSchedule(updatedIndex, updatedScheduleItems, assetListIndex, currentItem, playingLastItem);\n            }\n            return;\n          }\n        }\n      }\n      this.advanceSchedule(index, scheduleItems, assetListIndex, currentItem, playingLastItem);\n    };\n    _proto.advanceSchedule = function advanceSchedule(index, scheduleItems, assetListIndex, currentItem, playedLastItem) {\n      var _this3 = this;\n      var schedule = this.schedule;\n      if (!schedule) {\n        return;\n      }\n      var scheduledItem = scheduleItems[index] || null;\n      var media = this.primaryMedia;\n      // Cleanup out of range Interstitials\n      var playerQueue = this.playerQueue;\n      if (playerQueue.length) {\n        playerQueue.forEach(function (player) {\n          var interstitial = player.interstitial;\n          var queuedIndex = schedule.findEventIndex(interstitial.identifier);\n          if (queuedIndex < index || queuedIndex > index + 1) {\n            _this3.clearInterstitial(interstitial, scheduledItem);\n          }\n        });\n      }\n      // Setup scheduled item\n      if (this.isInterstitial(scheduledItem)) {\n        this.timelinePos = Math.min(Math.max(this.timelinePos, scheduledItem.start), scheduledItem.end);\n        // Handle Interstitial\n        var interstitial = scheduledItem.event;\n        // find asset index\n        if (assetListIndex === undefined) {\n          assetListIndex = schedule.findAssetIndex(interstitial, this.timelinePos);\n          var assetIndexCandidate = getNextAssetIndex(interstitial, assetListIndex - 1);\n          if (interstitial.isAssetPastPlayoutLimit(assetIndexCandidate) || interstitial.appendInPlace && this.timelinePos === scheduledItem.end) {\n            this.advanceAfterAssetEnded(interstitial, index, assetListIndex);\n            return;\n          }\n          assetListIndex = assetIndexCandidate;\n        }\n        // Ensure Interstitial is enqueued\n        var waitingItem = this.waitingItem;\n        if (!this.assetsBuffered(scheduledItem, media)) {\n          this.setBufferingItem(scheduledItem);\n        }\n        var player = this.preloadAssets(interstitial, assetListIndex);\n        if (!this.eventItemsMatch(scheduledItem, waitingItem || currentItem)) {\n          this.waitingItem = scheduledItem;\n          this.log(\"INTERSTITIAL_STARTED \" + segmentToString(scheduledItem) + \" \" + (interstitial.appendInPlace ? 'append in place' : ''));\n          this.hls.trigger(Events.INTERSTITIAL_STARTED, {\n            event: interstitial,\n            schedule: scheduleItems.slice(0),\n            scheduleIndex: index\n          });\n        }\n        if (!interstitial.assetListLoaded) {\n          // Waiting at end of primary content segment\n          // Expect setSchedulePosition to be called again once ASSET-LIST is loaded\n          this.log(\"Waiting for ASSET-LIST to complete loading \" + interstitial);\n          return;\n        }\n        if (interstitial.assetListLoader) {\n          interstitial.assetListLoader.destroy();\n          interstitial.assetListLoader = undefined;\n        }\n        if (!media) {\n          this.log(\"Waiting for attachMedia to start Interstitial \" + interstitial);\n          return;\n        }\n        // Update schedule and asset list position now that it can start\n        this.waitingItem = this.endedItem = null;\n        this.playingItem = scheduledItem;\n\n        // If asset-list is empty or missing asset index, advance to next item\n        var assetItem = interstitial.assetList[assetListIndex];\n        if (!assetItem) {\n          this.advanceAfterAssetEnded(interstitial, index, assetListIndex || 0);\n          return;\n        }\n\n        // Start Interstitial Playback\n        if (!player) {\n          player = this.getAssetPlayer(assetItem.identifier);\n        }\n        if (player === null || player.destroyed) {\n          var assetListLength = interstitial.assetList.length;\n          this.warn(\"asset \" + (assetListIndex + 1) + \"/\" + assetListLength + \" player destroyed \" + interstitial);\n          player = this.createAssetPlayer(interstitial, assetItem, assetListIndex);\n          player.loadSource();\n        }\n        if (!this.eventItemsMatch(scheduledItem, this.bufferingItem)) {\n          if (interstitial.appendInPlace && this.isAssetBuffered(assetItem)) {\n            return;\n          }\n        }\n        this.startAssetPlayer(player, assetListIndex, scheduleItems, index, media);\n        if (this.shouldPlay) {\n          playWithCatch(player.media);\n        }\n      } else if (scheduledItem) {\n        this.resumePrimary(scheduledItem, index, currentItem);\n        if (this.shouldPlay) {\n          playWithCatch(this.hls.media);\n        }\n      } else if (playedLastItem && this.isInterstitial(currentItem)) {\n        // Maintain playingItem state at end of schedule (setSchedulePosition(-1) called to end program)\n        // this allows onSeeking handler to update schedule position\n        this.endedItem = null;\n        this.playingItem = currentItem;\n        if (!currentItem.event.appendInPlace) {\n          // Media must be re-attached to resume primary schedule if not sharing source\n          this.attachPrimary(schedule.durations.primary, null);\n        }\n      }\n    };\n    _proto.resumePrimary = function resumePrimary(scheduledItem, index, fromItem) {\n      var _this$detachedData3, _this$schedule3;\n      this.playingItem = scheduledItem;\n      this.playingAsset = this.endedAsset = null;\n      this.waitingItem = this.endedItem = null;\n      this.bufferedToItem(scheduledItem);\n      this.log(\"resuming \" + segmentToString(scheduledItem));\n      if (!((_this$detachedData3 = this.detachedData) != null && _this$detachedData3.mediaSource)) {\n        var timelinePos = this.timelinePos;\n        if (timelinePos < scheduledItem.start || timelinePos >= scheduledItem.end) {\n          timelinePos = this.getPrimaryResumption(scheduledItem, index);\n          this.log(timelineMessage('resumePrimary', timelinePos));\n          this.timelinePos = timelinePos;\n        }\n        this.attachPrimary(timelinePos, scheduledItem);\n      }\n      if (!fromItem) {\n        return;\n      }\n      var scheduleItems = (_this$schedule3 = this.schedule) == null ? void 0 : _this$schedule3.items;\n      if (!scheduleItems) {\n        return;\n      }\n      this.log(\"INTERSTITIALS_PRIMARY_RESUMED \" + segmentToString(scheduledItem));\n      this.hls.trigger(Events.INTERSTITIALS_PRIMARY_RESUMED, {\n        schedule: scheduleItems.slice(0),\n        scheduleIndex: index\n      });\n      this.checkBuffer();\n    };\n    _proto.getPrimaryResumption = function getPrimaryResumption(scheduledItem, index) {\n      var itemStart = scheduledItem.start;\n      if (this.primaryLive) {\n        var details = this.primaryDetails;\n        if (index === 0) {\n          return this.hls.startPosition;\n        } else if (details && (itemStart < details.fragmentStart || itemStart > details.edge)) {\n          return this.hls.liveSyncPosition || -1;\n        }\n      }\n      return itemStart;\n    };\n    _proto.isAssetBuffered = function isAssetBuffered(asset) {\n      var player = this.getAssetPlayer(asset.identifier);\n      if (player != null && player.hls) {\n        return player.hls.bufferedToEnd;\n      }\n      var bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, this.timelinePos, 0);\n      return bufferInfo.end + 1 >= asset.timelineStart + (asset.duration || 0);\n    };\n    _proto.attachPrimary = function attachPrimary(timelinePos, item, skipSeekToStartPosition) {\n      if (item) {\n        this.setBufferingItem(item);\n      } else {\n        this.bufferingItem = this.playingItem;\n      }\n      this.bufferingAsset = null;\n      var media = this.primaryMedia;\n      if (!media) {\n        return;\n      }\n      var hls = this.hls;\n      if (hls.media) {\n        this.checkBuffer();\n      } else {\n        this.transferMediaTo(hls, media);\n        if (skipSeekToStartPosition) {\n          this.startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition);\n        }\n      }\n      if (!skipSeekToStartPosition) {\n        // Set primary position to resume time\n        this.log(timelineMessage('attachPrimary', timelinePos));\n        this.timelinePos = timelinePos;\n        this.startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition);\n      }\n    };\n    _proto.startLoadingPrimaryAt = function startLoadingPrimaryAt(timelinePos, skipSeekToStartPosition) {\n      var _hls$mainForwardBuffe;\n      var hls = this.hls;\n      if (!hls.loadingEnabled || !hls.media || Math.abs((((_hls$mainForwardBuffe = hls.mainForwardBufferInfo) == null ? void 0 : _hls$mainForwardBuffe.start) || hls.media.currentTime) - timelinePos) > 0.5) {\n        hls.startLoad(timelinePos, skipSeekToStartPosition);\n      } else if (!hls.bufferingEnabled) {\n        hls.resumeBuffering();\n      }\n    }\n\n    // HLS.js event callbacks\n    ;\n    _proto.onManifestLoading = function onManifestLoading() {\n      var _this$schedule4;\n      this.stopLoad();\n      (_this$schedule4 = this.schedule) == null || _this$schedule4.reset();\n      this.emptyPlayerQueue();\n      this.clearScheduleState();\n      this.shouldPlay = false;\n      this.bufferedPos = this.timelinePos = -1;\n      this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null;\n      // BUFFER_CODECS listener added here for buffer-controller to handle it first where it adds tracks\n      this.hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n      this.hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    };\n    _proto.onLevelUpdated = function onLevelUpdated(event, data) {\n      if (data.level === -1 || !this.schedule) {\n        // level was removed\n        return;\n      }\n      var main = this.hls.levels[data.level];\n      if (!main.details) {\n        return;\n      }\n      var currentSelection = _objectSpread2(_objectSpread2({}, this.mediaSelection || this.altSelection), {}, {\n        main: main\n      });\n      this.mediaSelection = currentSelection;\n      this.schedule.parseInterstitialDateRanges(currentSelection, this.hls.config.interstitialAppendInPlace);\n      if (!this.effectivePlayingItem && this.schedule.items) {\n        this.checkStart();\n      }\n    };\n    _proto.onAudioTrackUpdated = function onAudioTrackUpdated(event, data) {\n      var audio = this.hls.audioTracks[data.id];\n      var previousSelection = this.mediaSelection;\n      if (!previousSelection) {\n        this.altSelection = _objectSpread2(_objectSpread2({}, this.altSelection), {}, {\n          audio: audio\n        });\n        return;\n      }\n      var currentSelection = _objectSpread2(_objectSpread2({}, previousSelection), {}, {\n        audio: audio\n      });\n      this.mediaSelection = currentSelection;\n    };\n    _proto.onSubtitleTrackUpdated = function onSubtitleTrackUpdated(event, data) {\n      var subtitles = this.hls.subtitleTracks[data.id];\n      var previousSelection = this.mediaSelection;\n      if (!previousSelection) {\n        this.altSelection = _objectSpread2(_objectSpread2({}, this.altSelection), {}, {\n          subtitles: subtitles\n        });\n        return;\n      }\n      var currentSelection = _objectSpread2(_objectSpread2({}, previousSelection), {}, {\n        subtitles: subtitles\n      });\n      this.mediaSelection = currentSelection;\n    };\n    _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n      var audioOption = getBasicSelectionOption(data);\n      this.playerQueue.forEach(function (_ref) {\n        var hls = _ref.hls;\n        return hls && (hls.setAudioOption(data) || hls.setAudioOption(audioOption));\n      });\n    };\n    _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {\n      var subtitleOption = getBasicSelectionOption(data);\n      this.playerQueue.forEach(function (_ref2) {\n        var hls = _ref2.hls;\n        return hls && (hls.setSubtitleOption(data) || data.id !== -1 && hls.setSubtitleOption(subtitleOption));\n      });\n    };\n    _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n      var requiredTracks = data.tracks;\n      if (requiredTracks) {\n        this.requiredTracks = requiredTracks;\n      }\n    };\n    _proto.onBufferAppended = function onBufferAppended(event, data) {\n      this.checkBuffer();\n    };\n    _proto.onBufferFlushed = function onBufferFlushed(event, data) {\n      var playingItem = this.playingItem;\n      if (playingItem && !this.itemsMatch(playingItem, this.bufferingItem) && !this.isInterstitial(playingItem)) {\n        var timelinePos = this.timelinePos;\n        this.bufferedPos = timelinePos;\n        this.checkBuffer();\n      }\n    };\n    _proto.onBufferedToEnd = function onBufferedToEnd(event) {\n      if (!this.schedule) {\n        return;\n      }\n      // Buffered to post-roll\n      var interstitialEvents = this.schedule.events;\n      if (this.bufferedPos < Number.MAX_VALUE && interstitialEvents) {\n        for (var i = 0; i < interstitialEvents.length; i++) {\n          var interstitial = interstitialEvents[i];\n          if (interstitial.cue.post) {\n            var _this$schedule$items2;\n            var scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n            var item = (_this$schedule$items2 = this.schedule.items) == null ? void 0 : _this$schedule$items2[scheduleIndex];\n            if (this.isInterstitial(item) && this.eventItemsMatch(item, this.bufferingItem)) {\n              this.bufferedToItem(item, 0);\n            }\n            break;\n          }\n        }\n        this.bufferedPos = Number.MAX_VALUE;\n      }\n    };\n    _proto.onMediaEnded = function onMediaEnded(event) {\n      var playingItem = this.playingItem;\n      if (!this.playingLastItem && playingItem) {\n        var playingIndex = this.findItemIndex(playingItem);\n        this.setSchedulePosition(playingIndex + 1);\n      } else {\n        this.shouldPlay = false;\n      }\n    };\n    _proto.updateItem = function updateItem(previousItem, time) {\n      var _this$schedule5;\n      // find item in this.schedule.items;\n      var items = (_this$schedule5 = this.schedule) == null ? void 0 : _this$schedule5.items;\n      if (previousItem && items) {\n        var index = this.findItemIndex(previousItem, time);\n        return items[index] || null;\n      }\n      return null;\n    };\n    _proto.trimInPlace = function trimInPlace(updatedItem, itemBeforeUpdate) {\n      var _this4 = this;\n      if (this.isInterstitial(updatedItem) && updatedItem.event.appendInPlace && itemBeforeUpdate.end - updatedItem.end > 0.25) {\n        updatedItem.event.assetList.forEach(function (asset, index) {\n          if (updatedItem.event.isAssetPastPlayoutLimit(index)) {\n            _this4.clearAssetPlayer(asset.identifier, null);\n          }\n        });\n        var flushStart = updatedItem.end + 0.25;\n        var bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, flushStart, 0);\n        if (bufferInfo.end > flushStart || (bufferInfo.nextStart || 0) > flushStart) {\n          this.log(\"trim buffered interstitial \" + segmentToString(updatedItem) + \" (was \" + segmentToString(itemBeforeUpdate) + \")\");\n          var skipSeekToStartPosition = true;\n          this.attachPrimary(flushStart, null, skipSeekToStartPosition);\n          this.flushFrontBuffer(flushStart);\n        }\n      }\n    };\n    _proto.itemsMatch = function itemsMatch(a, b) {\n      return !!b && (a === b || a.event && b.event && this.eventItemsMatch(a, b) || !a.event && !b.event && this.findItemIndex(a) === this.findItemIndex(b));\n    };\n    _proto.eventItemsMatch = function eventItemsMatch(a, b) {\n      var _b$event;\n      return !!b && (a === b || a.event.identifier === ((_b$event = b.event) == null ? void 0 : _b$event.identifier));\n    };\n    _proto.findItemIndex = function findItemIndex(item, time) {\n      return item && this.schedule ? this.schedule.findItemIndex(item, time) : -1;\n    };\n    _proto.updateSchedule = function updateSchedule(forceUpdate) {\n      var _this$schedule6;\n      if (forceUpdate === void 0) {\n        forceUpdate = false;\n      }\n      var mediaSelection = this.mediaSelection;\n      if (!mediaSelection) {\n        return;\n      }\n      (_this$schedule6 = this.schedule) == null || _this$schedule6.updateSchedule(mediaSelection, [], forceUpdate);\n    }\n\n    // Schedule buffer control\n    ;\n    _proto.checkBuffer = function checkBuffer(starved) {\n      var _this$schedule7;\n      var items = (_this$schedule7 = this.schedule) == null ? void 0 : _this$schedule7.items;\n      if (!items) {\n        return;\n      }\n      // Find when combined forward buffer change reaches next schedule segment\n      var bufferInfo = BufferHelper.bufferInfo(this.primaryMedia, this.timelinePos, 0);\n      if (starved) {\n        this.bufferedPos = this.timelinePos;\n      }\n      starved || (starved = bufferInfo.len < 1);\n      this.updateBufferedPos(bufferInfo.end, items, starved);\n    };\n    _proto.updateBufferedPos = function updateBufferedPos(bufferEnd, items, bufferIsEmpty) {\n      var schedule = this.schedule;\n      var bufferingItem = this.bufferingItem;\n      if (this.bufferedPos > bufferEnd || !schedule) {\n        return;\n      }\n      if (items.length === 1 && this.itemsMatch(items[0], bufferingItem)) {\n        this.bufferedPos = bufferEnd;\n        return;\n      }\n      var playingItem = this.playingItem;\n      var playingIndex = this.findItemIndex(playingItem);\n      var bufferEndIndex = schedule.findItemIndexAtTime(bufferEnd);\n      if (this.bufferedPos < bufferEnd) {\n        var _nextItemToBuffer$eve;\n        var bufferingIndex = this.findItemIndex(bufferingItem);\n        var nextToBufferIndex = Math.min(bufferingIndex + 1, items.length - 1);\n        var nextItemToBuffer = items[nextToBufferIndex];\n        if (bufferEndIndex === -1 && bufferingItem && bufferEnd >= bufferingItem.end || (_nextItemToBuffer$eve = nextItemToBuffer.event) != null && _nextItemToBuffer$eve.appendInPlace && bufferEnd + 0.01 >= nextItemToBuffer.start) {\n          bufferEndIndex = nextToBufferIndex;\n        }\n        if (this.isInterstitial(bufferingItem)) {\n          var interstitial = bufferingItem.event;\n          if (nextToBufferIndex - playingIndex > 1 && interstitial.appendInPlace === false) {\n            // do not advance buffering item past Interstitial that requires source reset\n            return;\n          }\n          if (interstitial.assetList.length === 0 && interstitial.assetListLoader) {\n            // do not advance buffering item past Interstitial loading asset-list\n            return;\n          }\n        }\n        this.bufferedPos = bufferEnd;\n        if (bufferEndIndex > bufferingIndex && bufferEndIndex > playingIndex) {\n          this.bufferedToItem(nextItemToBuffer);\n        } else {\n          // allow more time than distance from edge for assets to load\n          var details = this.primaryDetails;\n          if (this.primaryLive && details && bufferEnd > details.edge - details.targetduration && nextItemToBuffer.start < details.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(nextItemToBuffer)) {\n            this.preloadAssets(nextItemToBuffer.event, 0);\n          }\n        }\n      } else if (bufferIsEmpty && playingItem && !this.itemsMatch(playingItem, bufferingItem)) {\n        if (bufferEndIndex === playingIndex) {\n          this.bufferedToItem(playingItem);\n        } else if (bufferEndIndex === playingIndex + 1) {\n          this.bufferedToItem(items[bufferEndIndex]);\n        }\n      }\n    };\n    _proto.assetsBuffered = function assetsBuffered(item, media) {\n      var _this5 = this;\n      var assetList = item.event.assetList;\n      if (assetList.length === 0) {\n        return false;\n      }\n      return !item.event.assetList.some(function (asset) {\n        var player = _this5.getAssetPlayer(asset.identifier);\n        return !(player != null && player.bufferedInPlaceToEnd(media));\n      });\n    };\n    _proto.setBufferingItem = function setBufferingItem(item) {\n      var _this6 = this;\n      var bufferingLast = this.bufferingItem;\n      var schedule = this.schedule;\n      if (!this.itemsMatch(item, bufferingLast) && schedule) {\n        var items = schedule.items,\n          events = schedule.events;\n        if (!items || !events) {\n          return bufferingLast;\n        }\n        var isInterstitial = this.isInterstitial(item);\n        var bufferingPlayer = this.getBufferingPlayer();\n        this.bufferingItem = item;\n        this.bufferedPos = Math.max(item.start, Math.min(item.end, this.timelinePos));\n        var timeRemaining = bufferingPlayer ? bufferingPlayer.remaining : bufferingLast ? bufferingLast.end - this.timelinePos : 0;\n        this.log(\"INTERSTITIALS_BUFFERED_TO_BOUNDARY \" + segmentToString(item) + (bufferingLast ? \" (\" + timeRemaining.toFixed(2) + \" remaining)\" : ''));\n        if (!this.playbackDisabled) {\n          if (isInterstitial) {\n            var bufferIndex = schedule.findAssetIndex(item.event, this.bufferedPos);\n            // primary fragment loading will exit early in base-stream-controller while `bufferingItem` is set to an Interstitial block\n            item.event.assetList.forEach(function (asset, i) {\n              var player = _this6.getAssetPlayer(asset.identifier);\n              if (player) {\n                if (i === bufferIndex) {\n                  player.loadSource();\n                }\n                player.resumeBuffering();\n              }\n            });\n          } else {\n            this.hls.resumeBuffering();\n            this.playerQueue.forEach(function (player) {\n              return player.pauseBuffering();\n            });\n          }\n        }\n        this.hls.trigger(Events.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {\n          events: events.slice(0),\n          schedule: items.slice(0),\n          bufferingIndex: this.findItemIndex(item),\n          playingIndex: this.findItemIndex(this.playingItem)\n        });\n      } else if (this.bufferingItem !== item) {\n        this.bufferingItem = item;\n      }\n      return bufferingLast;\n    };\n    _proto.bufferedToItem = function bufferedToItem(item, assetListIndex) {\n      if (assetListIndex === void 0) {\n        assetListIndex = 0;\n      }\n      var bufferingLast = this.setBufferingItem(item);\n      if (this.playbackDisabled) {\n        return;\n      }\n      if (this.isInterstitial(item)) {\n        // Ensure asset list is loaded\n        this.bufferedToEvent(item, assetListIndex);\n      } else if (bufferingLast !== null) {\n        // If primary player is detached, it is also stopped, restart loading at primary position\n        this.bufferingAsset = null;\n        var detachedData = this.detachedData;\n        if (detachedData) {\n          if (detachedData.mediaSource) {\n            var skipSeekToStartPosition = true;\n            this.attachPrimary(item.start, item, skipSeekToStartPosition);\n          } else {\n            this.preloadPrimary(item);\n          }\n        } else {\n          // If not detached seek to resumption point\n          this.preloadPrimary(item);\n        }\n      }\n    };\n    _proto.preloadPrimary = function preloadPrimary(item) {\n      var index = this.findItemIndex(item);\n      var timelinePos = this.getPrimaryResumption(item, index);\n      this.startLoadingPrimaryAt(timelinePos);\n    };\n    _proto.bufferedToEvent = function bufferedToEvent(item, assetListIndex) {\n      var interstitial = item.event;\n      var neverLoaded = interstitial.assetList.length === 0 && !interstitial.assetListLoader;\n      var playOnce = interstitial.cue.once;\n      if (neverLoaded || !playOnce) {\n        // Buffered to Interstitial boundary\n        var player = this.preloadAssets(interstitial, assetListIndex);\n        if (player != null && player.interstitial.appendInPlace) {\n          var media = this.primaryMedia;\n          if (media) {\n            this.bufferAssetPlayer(player, media);\n          }\n        }\n      }\n    };\n    _proto.preloadAssets = function preloadAssets(interstitial, assetListIndex) {\n      var uri = interstitial.assetUrl;\n      var assetListLength = interstitial.assetList.length;\n      var neverLoaded = assetListLength === 0 && !interstitial.assetListLoader;\n      var playOnce = interstitial.cue.once;\n      if (neverLoaded) {\n        var timelineStart = interstitial.timelineStart;\n        if (interstitial.appendInPlace) {\n          var _playingItem$nextEven;\n          var playingItem = this.playingItem;\n          if (!this.isInterstitial(playingItem) && (playingItem == null || (_playingItem$nextEven = playingItem.nextEvent) == null ? void 0 : _playingItem$nextEven.identifier) === interstitial.identifier) {\n            this.flushFrontBuffer(timelineStart + 0.25);\n          }\n        }\n        var hlsStartOffset;\n        var liveStartPosition = 0;\n        if (!this.playingItem && this.primaryLive) {\n          liveStartPosition = this.hls.startPosition;\n          if (liveStartPosition === -1) {\n            liveStartPosition = this.hls.liveSyncPosition || 0;\n          }\n        }\n        if (liveStartPosition && !(interstitial.cue.pre || interstitial.cue.post)) {\n          var startOffset = liveStartPosition - timelineStart;\n          if (startOffset > 0) {\n            hlsStartOffset = Math.round(startOffset * 1000) / 1000;\n          }\n        }\n        this.log(\"Load interstitial asset \" + (assetListIndex + 1) + \"/\" + (uri ? 1 : assetListLength) + \" \" + interstitial + (hlsStartOffset ? \" live-start: \" + liveStartPosition + \" start-offset: \" + hlsStartOffset : ''));\n        if (uri) {\n          return this.createAsset(interstitial, 0, 0, timelineStart, interstitial.duration, uri);\n        }\n        var assetListLoader = this.assetListLoader.loadAssetList(interstitial, hlsStartOffset);\n        if (assetListLoader) {\n          interstitial.assetListLoader = assetListLoader;\n        }\n      } else if (!playOnce && assetListLength) {\n        // Re-buffered to Interstitial boundary, re-create asset player(s)\n        for (var i = assetListIndex; i < assetListLength; i++) {\n          var _asset = interstitial.assetList[i];\n          var playerIndex = this.getAssetPlayerQueueIndex(_asset.identifier);\n          if ((playerIndex === -1 || this.playerQueue[playerIndex].destroyed) && !_asset.error) {\n            this.createAssetPlayer(interstitial, _asset, i);\n          }\n        }\n        var asset = interstitial.assetList[assetListIndex];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (asset) {\n          var player = this.getAssetPlayer(asset.identifier);\n          if (player) {\n            player.loadSource();\n          }\n          return player;\n        }\n      }\n      return null;\n    };\n    _proto.flushFrontBuffer = function flushFrontBuffer(startOffset) {\n      var _this7 = this;\n      // Force queued flushing of all buffers\n      var requiredTracks = this.requiredTracks;\n      if (!requiredTracks) {\n        return;\n      }\n      this.log(\"Removing front buffer starting at \" + startOffset);\n      var sourceBufferNames = Object.keys(requiredTracks);\n      sourceBufferNames.forEach(function (type) {\n        _this7.hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: startOffset,\n          endOffset: Infinity,\n          type: type\n        });\n      });\n    }\n\n    // Interstitial Asset Player control\n    ;\n    _proto.getAssetPlayerQueueIndex = function getAssetPlayerQueueIndex(assetId) {\n      var playerQueue = this.playerQueue;\n      for (var i = 0; i < playerQueue.length; i++) {\n        if (assetId === playerQueue[i].assetId) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    _proto.getAssetPlayer = function getAssetPlayer(assetId) {\n      var index = this.getAssetPlayerQueueIndex(assetId);\n      return this.playerQueue[index] || null;\n    };\n    _proto.getBufferingPlayer = function getBufferingPlayer() {\n      var playerQueue = this.playerQueue,\n        primaryMedia = this.primaryMedia;\n      if (primaryMedia) {\n        for (var i = 0; i < playerQueue.length; i++) {\n          if (playerQueue[i].media === primaryMedia) {\n            return playerQueue[i];\n          }\n        }\n      }\n      return null;\n    };\n    _proto.createAsset = function createAsset(interstitial, assetListIndex, startOffset, timelineStart, duration, uri) {\n      var assetItem = {\n        parentIdentifier: interstitial.identifier,\n        identifier: generateAssetIdentifier(interstitial, uri, assetListIndex),\n        duration: duration,\n        startOffset: startOffset,\n        timelineStart: timelineStart,\n        uri: uri\n      };\n      return this.createAssetPlayer(interstitial, assetItem, assetListIndex);\n    };\n    _proto.createAssetPlayer = function createAssetPlayer(interstitial, assetItem, assetListIndex) {\n      var _this8 = this;\n      var primary = this.hls;\n      var userConfig = primary.userConfig;\n      var videoPreference = userConfig.videoPreference;\n      var currentLevel = primary.loadLevelObj || primary.levels[primary.currentLevel];\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (videoPreference || currentLevel) {\n        videoPreference = _extends({}, videoPreference);\n        if (currentLevel.videoCodec) {\n          videoPreference.videoCodec = currentLevel.videoCodec;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (currentLevel.videoRange) {\n          videoPreference.allowedVideoRanges = [currentLevel.videoRange];\n        }\n      }\n      var selectedAudio = primary.audioTracks[primary.audioTrack];\n      var selectedSubtitle = primary.subtitleTracks[primary.subtitleTrack];\n      var startPosition = 0;\n      if (this.primaryLive || interstitial.appendInPlace) {\n        var timePastStart = this.timelinePos - assetItem.timelineStart;\n        if (timePastStart > 1) {\n          var duration = assetItem.duration;\n          if (duration && timePastStart < duration) {\n            startPosition = timePastStart;\n          }\n        }\n      }\n      var assetId = assetItem.identifier;\n      var playerConfig = _objectSpread2(_objectSpread2({}, userConfig), {}, {\n        maxMaxBufferLength: Math.min(180, primary.config.maxMaxBufferLength),\n        autoStartLoad: true,\n        startFragPrefetch: true,\n        primarySessionId: primary.sessionId,\n        assetPlayerId: assetId,\n        abrEwmaDefaultEstimate: primary.bandwidthEstimate,\n        interstitialsController: undefined,\n        startPosition: startPosition,\n        liveDurationInfinity: false,\n        testBandwidth: false,\n        videoPreference: videoPreference,\n        audioPreference: selectedAudio || userConfig.audioPreference,\n        subtitlePreference: selectedSubtitle || userConfig.subtitlePreference\n      });\n      // TODO: limit maxMaxBufferLength in asset players to prevent QEE\n      if (interstitial.appendInPlace) {\n        interstitial.appendInPlaceStarted = true;\n        if (assetItem.timelineStart) {\n          playerConfig.timelineOffset = assetItem.timelineStart;\n        }\n      }\n      var cmcd = playerConfig.cmcd;\n      if (cmcd != null && cmcd.sessionId && cmcd.contentId) {\n        playerConfig.cmcd = _extends({}, cmcd, {\n          contentId: hash(assetItem.uri)\n        });\n      }\n      if (this.getAssetPlayer(assetId)) {\n        this.warn(\"Duplicate date range identifier \" + interstitial + \" and asset \" + assetId);\n      }\n      var player = new HlsAssetPlayer(this.HlsPlayerClass, playerConfig, interstitial, assetItem);\n      this.playerQueue.push(player);\n      interstitial.assetList[assetListIndex] = assetItem;\n      // Listen for LevelDetails and PTS change to update duration\n      var initialDuration = true;\n      var updateAssetPlayerDetails = function updateAssetPlayerDetails(details) {\n        if (details.live) {\n          var _this8$schedule;\n          var error = new Error(\"Interstitials MUST be VOD assets \" + interstitial);\n          var errorData = {\n            fatal: true,\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,\n            error: error\n          };\n          var scheduleIndex = ((_this8$schedule = _this8.schedule) == null ? void 0 : _this8$schedule.findEventIndex(interstitial.identifier)) || -1;\n          _this8.handleAssetItemError(errorData, interstitial, scheduleIndex, assetListIndex, error.message);\n          return;\n        }\n        // Get time at end of last fragment\n        var duration = details.edge - details.fragmentStart;\n        var currentAssetDuration = assetItem.duration;\n        if (initialDuration || currentAssetDuration === null || duration > currentAssetDuration) {\n          initialDuration = false;\n          _this8.log(\"Interstitial asset \\\"\" + assetId + \"\\\" duration change \" + currentAssetDuration + \" > \" + duration);\n          assetItem.duration = duration;\n          // Update schedule with new event and asset duration\n          _this8.updateSchedule();\n        }\n      };\n      player.on(Events.LEVEL_UPDATED, function (event, _ref3) {\n        var details = _ref3.details;\n        return updateAssetPlayerDetails(details);\n      });\n      player.on(Events.LEVEL_PTS_UPDATED, function (event, _ref4) {\n        var details = _ref4.details;\n        return updateAssetPlayerDetails(details);\n      });\n      player.on(Events.EVENT_CUE_ENTER, function () {\n        return _this8.onInterstitialCueEnter();\n      });\n      var _onBufferCodecs = function onBufferCodecs(event, data) {\n        var inQueuPlayer = _this8.getAssetPlayer(assetId);\n        if (inQueuPlayer && data.tracks) {\n          inQueuPlayer.off(Events.BUFFER_CODECS, _onBufferCodecs);\n          inQueuPlayer.tracks = data.tracks;\n          var media = _this8.primaryMedia;\n          if (_this8.bufferingAsset === inQueuPlayer.assetItem && media && !inQueuPlayer.media) {\n            _this8.bufferAssetPlayer(inQueuPlayer, media);\n          }\n        }\n      };\n      player.on(Events.BUFFER_CODECS, _onBufferCodecs);\n      var bufferedToEnd = function bufferedToEnd() {\n        var _this8$schedule$items;\n        var inQueuPlayer = _this8.getAssetPlayer(assetId);\n        _this8.log(\"buffered to end of asset \" + inQueuPlayer);\n        if (!inQueuPlayer || !_this8.schedule) {\n          return;\n        }\n        // Preload at end of asset\n        var scheduleIndex = _this8.schedule.findEventIndex(interstitial.identifier);\n        var item = (_this8$schedule$items = _this8.schedule.items) == null ? void 0 : _this8$schedule$items[scheduleIndex];\n        if (_this8.isInterstitial(item)) {\n          _this8.advanceAssetBuffering(item, assetItem);\n        }\n      };\n      player.on(Events.BUFFERED_TO_END, bufferedToEnd);\n      var endedWithAssetIndex = function endedWithAssetIndex(assetIndex) {\n        return function () {\n          var inQueuPlayer = _this8.getAssetPlayer(assetId);\n          if (!inQueuPlayer || !_this8.schedule) {\n            return;\n          }\n          _this8.shouldPlay = true;\n          var scheduleIndex = _this8.schedule.findEventIndex(interstitial.identifier);\n          _this8.advanceAfterAssetEnded(interstitial, scheduleIndex, assetIndex);\n        };\n      };\n      player.once(Events.MEDIA_ENDED, endedWithAssetIndex(assetListIndex));\n      player.once(Events.PLAYOUT_LIMIT_REACHED, endedWithAssetIndex(Infinity));\n      player.on(Events.ERROR, function (event, data) {\n        if (!_this8.schedule) {\n          return;\n        }\n        var inQueuPlayer = _this8.getAssetPlayer(assetId);\n        if (data.details === ErrorDetails.BUFFER_STALLED_ERROR) {\n          if (inQueuPlayer != null && inQueuPlayer.appendInPlace) {\n            _this8.handleInPlaceStall(interstitial);\n            return;\n          }\n          _this8.onTimeupdate();\n          _this8.checkBuffer(true);\n          return;\n        }\n        _this8.handleAssetItemError(data, interstitial, _this8.schedule.findEventIndex(interstitial.identifier), assetListIndex, \"Asset player error \" + data.error + \" \" + interstitial);\n      });\n      player.on(Events.DESTROYING, function () {\n        var inQueuPlayer = _this8.getAssetPlayer(assetId);\n        if (!inQueuPlayer || !_this8.schedule) {\n          return;\n        }\n        var error = new Error(\"Asset player destroyed unexpectedly \" + assetId);\n        var errorData = {\n          fatal: true,\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,\n          error: error\n        };\n        _this8.handleAssetItemError(errorData, interstitial, _this8.schedule.findEventIndex(interstitial.identifier), assetListIndex, error.message);\n      });\n      this.log(\"INTERSTITIAL_ASSET_PLAYER_CREATED \" + eventAssetToString(assetItem));\n      this.hls.trigger(Events.INTERSTITIAL_ASSET_PLAYER_CREATED, {\n        asset: assetItem,\n        assetListIndex: assetListIndex,\n        event: interstitial,\n        player: player\n      });\n      return player;\n    };\n    _proto.clearInterstitial = function clearInterstitial(interstitial, toSegment) {\n      this.clearAssetPlayers(interstitial, toSegment);\n      // Remove asset list and resolved duration\n      interstitial.reset();\n    };\n    _proto.clearAssetPlayers = function clearAssetPlayers(interstitial, toSegment) {\n      var _this9 = this;\n      interstitial.assetList.forEach(function (asset) {\n        _this9.clearAssetPlayer(asset.identifier, toSegment);\n      });\n    };\n    _proto.resetAssetPlayer = function resetAssetPlayer(assetId) {\n      // Reset asset player so that it's timeline can be adjusted without reloading the MVP\n      var playerIndex = this.getAssetPlayerQueueIndex(assetId);\n      if (playerIndex !== -1) {\n        this.log(\"reset asset player \\\"\" + assetId + \"\\\" after error\");\n        var player = this.playerQueue[playerIndex];\n        this.transferMediaFromPlayer(player, null);\n        player.resetDetails();\n      }\n    };\n    _proto.clearAssetPlayer = function clearAssetPlayer(assetId, toSegment) {\n      var playerIndex = this.getAssetPlayerQueueIndex(assetId);\n      if (playerIndex !== -1) {\n        var player = this.playerQueue[playerIndex];\n        this.log(\"clear \" + player + \" toSegment: \" + (toSegment ? segmentToString(toSegment) : toSegment));\n        this.transferMediaFromPlayer(player, toSegment);\n        this.playerQueue.splice(playerIndex, 1);\n        player.destroy();\n      }\n    };\n    _proto.emptyPlayerQueue = function emptyPlayerQueue() {\n      var player;\n      while (player = this.playerQueue.pop()) {\n        player.destroy();\n      }\n      this.playerQueue = [];\n    };\n    _proto.startAssetPlayer = function startAssetPlayer(player, assetListIndex, scheduleItems, scheduleIndex, media) {\n      var interstitial = player.interstitial,\n        assetItem = player.assetItem,\n        assetId = player.assetId;\n      var assetListLength = interstitial.assetList.length;\n      var playingAsset = this.playingAsset;\n      this.endedAsset = null;\n      this.playingAsset = assetItem;\n      if (!playingAsset || playingAsset.identifier !== assetId) {\n        if (playingAsset) {\n          // Exiting another Interstitial asset\n          this.clearAssetPlayer(playingAsset.identifier, scheduleItems[scheduleIndex]);\n          delete playingAsset.error;\n        }\n        this.log(\"INTERSTITIAL_ASSET_STARTED \" + (assetListIndex + 1) + \"/\" + assetListLength + \" \" + eventAssetToString(assetItem));\n        this.hls.trigger(Events.INTERSTITIAL_ASSET_STARTED, {\n          asset: assetItem,\n          assetListIndex: assetListIndex,\n          event: interstitial,\n          schedule: scheduleItems.slice(0),\n          scheduleIndex: scheduleIndex,\n          player: player\n        });\n      }\n\n      // detach media and attach to interstitial player if it does not have another element attached\n      this.bufferAssetPlayer(player, media);\n    };\n    _proto.bufferAssetPlayer = function bufferAssetPlayer(player, media) {\n      var _this$schedule$items3, _this$detachedData4;\n      if (!this.schedule) {\n        return;\n      }\n      var interstitial = player.interstitial,\n        assetItem = player.assetItem;\n      var scheduleIndex = this.schedule.findEventIndex(interstitial.identifier);\n      var item = (_this$schedule$items3 = this.schedule.items) == null ? void 0 : _this$schedule$items3[scheduleIndex];\n      if (!item) {\n        return;\n      }\n      player.loadSource();\n      this.setBufferingItem(item);\n      this.bufferingAsset = assetItem;\n      var bufferingPlayer = this.getBufferingPlayer();\n      if (bufferingPlayer === player) {\n        return;\n      }\n      var appendInPlaceNext = interstitial.appendInPlace;\n      if (appendInPlaceNext && (bufferingPlayer == null ? void 0 : bufferingPlayer.interstitial.appendInPlace) === false) {\n        // Media is detached and not available to append in place\n        return;\n      }\n      var activeTracks = (bufferingPlayer == null ? void 0 : bufferingPlayer.tracks) || ((_this$detachedData4 = this.detachedData) == null ? void 0 : _this$detachedData4.tracks) || this.requiredTracks;\n      if (appendInPlaceNext && assetItem !== this.playingAsset) {\n        // Do not buffer another item if tracks are unknown or incompatible\n        if (!player.tracks) {\n          this.log(\"Waiting for track info before buffering \" + player);\n          return;\n        }\n        if (activeTracks && !isCompatibleTrackChange(activeTracks, player.tracks)) {\n          var error = new Error(\"Asset \" + eventAssetToString(assetItem) + \" SourceBuffer tracks ('\" + Object.keys(player.tracks) + \"') are not compatible with primary content tracks ('\" + Object.keys(activeTracks) + \"')\");\n          var errorData = {\n            fatal: true,\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.INTERSTITIAL_ASSET_ITEM_ERROR,\n            error: error\n          };\n          var assetListIndex = interstitial.findAssetIndex(assetItem);\n          this.handleAssetItemError(errorData, interstitial, scheduleIndex, assetListIndex, error.message);\n          return;\n        }\n      }\n      this.transferMediaTo(player, media);\n    };\n    _proto.handleInPlaceStall = function handleInPlaceStall(interstitial) {\n      var schedule = this.schedule;\n      var media = this.primaryMedia;\n      if (!schedule || !media) {\n        return;\n      }\n      var currentTime = media.currentTime;\n      var foundAssetIndex = schedule.findAssetIndex(interstitial, currentTime);\n      var stallingAsset = interstitial.assetList[foundAssetIndex];\n      if (stallingAsset) {\n        var player = this.getAssetPlayer(stallingAsset.identifier);\n        if (player) {\n          var assetCurrentTime = player.currentTime || currentTime - stallingAsset.timelineStart;\n          var distanceFromEnd = player.duration - assetCurrentTime;\n          this.warn(\"Stalled at \" + assetCurrentTime + \" of \" + (assetCurrentTime + distanceFromEnd) + \" in \" + player + \" \" + interstitial + \" (media.currentTime: \" + currentTime + \")\");\n          if (assetCurrentTime && (distanceFromEnd / media.playbackRate < 0.5 || player.bufferedInPlaceToEnd(media)) && player.hls) {\n            var scheduleIndex = schedule.findEventIndex(interstitial.identifier);\n            this.advanceAfterAssetEnded(interstitial, scheduleIndex, foundAssetIndex);\n          }\n        }\n      }\n    };\n    _proto.advanceInPlace = function advanceInPlace(time) {\n      var media = this.primaryMedia;\n      if (media && media.currentTime < time) {\n        media.currentTime = time;\n      }\n    };\n    _proto.handleAssetItemError = function handleAssetItemError(data, interstitial, scheduleIndex, assetListIndex, errorMessage) {\n      if (data.details === ErrorDetails.BUFFER_STALLED_ERROR) {\n        return;\n      }\n      var assetItem = interstitial.assetList[assetListIndex] || null;\n      this.warn(\"INTERSTITIAL_ASSET_ERROR \" + (assetItem ? eventAssetToString(assetItem) : assetItem) + \" \" + data.error);\n      if (!this.schedule) {\n        return;\n      }\n      var assetId = (assetItem == null ? void 0 : assetItem.identifier) || '';\n      var playerIndex = this.getAssetPlayerQueueIndex(assetId);\n      var player = this.playerQueue[playerIndex] || null;\n      var items = this.schedule.items;\n      var interstitialAssetError = _extends({}, data, {\n        fatal: false,\n        errorAction: createDoNothingErrorAction(true),\n        asset: assetItem,\n        assetListIndex: assetListIndex,\n        event: interstitial,\n        schedule: items,\n        scheduleIndex: scheduleIndex,\n        player: player\n      });\n      this.hls.trigger(Events.INTERSTITIAL_ASSET_ERROR, interstitialAssetError);\n      if (!data.fatal) {\n        return;\n      }\n      var playingAsset = this.playingAsset;\n      var bufferingAsset = this.bufferingAsset;\n      var error = new Error(errorMessage);\n      if (assetItem) {\n        this.clearAssetPlayer(assetId, null);\n        assetItem.error = error;\n      }\n\n      // If all assets in interstitial fail, mark the interstitial with an error\n      if (!interstitial.assetList.some(function (asset) {\n        return !asset.error;\n      })) {\n        interstitial.error = error;\n      } else {\n        // Reset level details and reload/parse media playlists to align with updated schedule\n        for (var i = assetListIndex; i < interstitial.assetList.length; i++) {\n          this.resetAssetPlayer(interstitial.assetList[i].identifier);\n        }\n      }\n      this.updateSchedule(true);\n      if (interstitial.error) {\n        this.primaryFallback(interstitial);\n      } else if (playingAsset && playingAsset.identifier === assetId) {\n        this.advanceAfterAssetEnded(interstitial, scheduleIndex, assetListIndex);\n      } else if (bufferingAsset && bufferingAsset.identifier === assetId && this.isInterstitial(this.bufferingItem)) {\n        this.advanceAssetBuffering(this.bufferingItem, bufferingAsset);\n      }\n    };\n    _proto.primaryFallback = function primaryFallback(interstitial) {\n      // Fallback to Primary by on current or future events by updating schedule to skip errored interstitials/assets\n      var flushStart = interstitial.timelineStart;\n      var playingItem = this.effectivePlayingItem;\n      var timelinePos = this.timelinePos;\n      // Update schedule now that interstitial/assets are flagged with `error` for fallback\n      if (playingItem) {\n        this.log(\"Fallback to primary from event \\\"\" + interstitial.identifier + \"\\\" start: \" + flushStart + \" pos: \" + timelinePos + \" playing: \" + segmentToString(playingItem) + \" error: \" + interstitial.error);\n        if (timelinePos === -1) {\n          timelinePos = this.hls.startPosition;\n        }\n        var newPlayingItem = this.updateItem(playingItem, timelinePos);\n        if (this.itemsMatch(playingItem, newPlayingItem)) {\n          this.clearInterstitial(interstitial, null);\n        }\n        if (interstitial.appendInPlace) {\n          this.attachPrimary(flushStart, null);\n          this.flushFrontBuffer(flushStart);\n        }\n      } else if (timelinePos === -1) {\n        this.checkStart();\n        return;\n      }\n      if (!this.schedule) {\n        return;\n      }\n      var scheduleIndex = this.schedule.findItemIndexAtTime(timelinePos);\n      this.setSchedulePosition(scheduleIndex);\n    }\n\n    // Asset List loading\n    ;\n    _proto.onAssetListLoaded = function onAssetListLoaded(event, data) {\n      var _this$schedule8,\n        _this0 = this,\n        _this$bufferingItem;\n      var interstitial = data.event;\n      var interstitialId = interstitial.identifier;\n      var assets = data.assetListResponse.ASSETS;\n      if (!((_this$schedule8 = this.schedule) != null && _this$schedule8.hasEvent(interstitialId))) {\n        // Interstitial with id was removed\n        return;\n      }\n      var eventStart = interstitial.timelineStart;\n      var previousDuration = interstitial.duration;\n      var sumDuration = 0;\n      assets.forEach(function (asset, assetListIndex) {\n        var duration = parseFloat(asset.DURATION);\n        _this0.createAsset(interstitial, assetListIndex, sumDuration, eventStart + sumDuration, duration, asset.URI);\n        sumDuration += duration;\n      });\n      interstitial.duration = sumDuration;\n      this.log(\"Loaded asset-list with duration: \" + sumDuration + \" (was: \" + previousDuration + \") \" + interstitial);\n      var waitingItem = this.waitingItem;\n      var waitingForItem = (waitingItem == null ? void 0 : waitingItem.event.identifier) === interstitialId;\n\n      // Update schedule now that asset.DURATION(s) are parsed\n      this.updateSchedule();\n      var bufferingEvent = (_this$bufferingItem = this.bufferingItem) == null ? void 0 : _this$bufferingItem.event;\n\n      // If buffer reached Interstitial, start buffering first asset\n      if (waitingForItem) {\n        var _this$schedule$items4;\n        // Advance schedule when waiting for asset list data to play\n        var scheduleIndex = this.schedule.findEventIndex(interstitialId);\n        var item = (_this$schedule$items4 = this.schedule.items) == null ? void 0 : _this$schedule$items4[scheduleIndex];\n        if (item) {\n          if (!this.playingItem && this.timelinePos > item.end) {\n            // Abandon if new duration is reduced enough to land playback in primary start\n            var index = this.schedule.findItemIndexAtTime(this.timelinePos);\n            if (index !== scheduleIndex) {\n              interstitial.error = new Error(\"Interstitial \" + (assets.length ? 'no longer within playback range' : 'asset-list is empty') + \" \" + this.timelinePos + \" \" + interstitial);\n              this.log(interstitial.error.message);\n              this.updateSchedule(true);\n              this.primaryFallback(interstitial);\n              return;\n            }\n          }\n          this.setBufferingItem(item);\n        }\n        this.setSchedulePosition(scheduleIndex);\n      } else if ((bufferingEvent == null ? void 0 : bufferingEvent.identifier) === interstitialId) {\n        var assetItem = interstitial.assetList[0];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (assetItem) {\n          var player = this.getAssetPlayer(assetItem.identifier);\n          if (bufferingEvent.appendInPlace) {\n            // If buffering (but not playback) has reached this item transfer media-source\n            var media = this.primaryMedia;\n            if (player && media) {\n              this.bufferAssetPlayer(player, media);\n            }\n          } else if (player) {\n            player.loadSource();\n          }\n        }\n      }\n    };\n    _proto.onError = function onError(event, data) {\n      if (!this.schedule) {\n        return;\n      }\n      switch (data.details) {\n        case ErrorDetails.ASSET_LIST_PARSING_ERROR:\n        case ErrorDetails.ASSET_LIST_LOAD_ERROR:\n        case ErrorDetails.ASSET_LIST_LOAD_TIMEOUT:\n          {\n            var interstitial = data.interstitial;\n            if (interstitial) {\n              this.updateSchedule(true);\n              this.primaryFallback(interstitial);\n            }\n            break;\n          }\n        case ErrorDetails.BUFFER_STALLED_ERROR:\n          {\n            var stallingItem = this.endedItem || this.waitingItem || this.playingItem;\n            if (this.isInterstitial(stallingItem) && stallingItem.event.appendInPlace) {\n              this.handleInPlaceStall(stallingItem.event);\n              return;\n            }\n            this.log(\"Primary player stall @\" + this.timelinePos + \" bufferedPos: \" + this.bufferedPos);\n            this.onTimeupdate();\n            this.checkBuffer(true);\n            break;\n          }\n      }\n    };\n    return _createClass(InterstitialsController, [{\n      key: \"interstitialsManager\",\n      get: function get() {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!this.hls) {\n          return null;\n        }\n        if (this.manager) {\n          return this.manager;\n        }\n        var c = this;\n        var effectiveBufferingItem = function effectiveBufferingItem() {\n          return c.bufferingItem || c.waitingItem;\n        };\n        var getAssetPlayer = function getAssetPlayer(asset) {\n          return asset ? c.getAssetPlayer(asset.identifier) : asset;\n        };\n        var getMappedTime = function getMappedTime(item, timelineType, asset, controllerField, assetPlayerField) {\n          if (item) {\n            var time = item[timelineType].start;\n            var interstitial = item.event;\n            if (interstitial) {\n              if (timelineType === 'playout' || interstitial.timelineOccupancy !== TimelineOccupancy.Point) {\n                var assetPlayer = getAssetPlayer(asset);\n                if ((assetPlayer == null ? void 0 : assetPlayer.interstitial) === interstitial) {\n                  time += assetPlayer.assetItem.startOffset + assetPlayer[assetPlayerField];\n                }\n              }\n            } else {\n              var value = controllerField === 'bufferedPos' ? getBufferedEnd() : c[controllerField];\n              time += value - item.start;\n            }\n            return time;\n          }\n          return 0;\n        };\n        var findMappedTime = function findMappedTime(primaryTime, timelineType) {\n          var _c$schedule;\n          if (primaryTime !== 0 && timelineType !== 'primary' && (_c$schedule = c.schedule) != null && _c$schedule.length) {\n            var _c$schedule$items;\n            var index = c.schedule.findItemIndexAtTime(primaryTime);\n            var item = (_c$schedule$items = c.schedule.items) == null ? void 0 : _c$schedule$items[index];\n            if (item) {\n              var diff = item[timelineType].start - item.start;\n              return primaryTime + diff;\n            }\n          }\n          return primaryTime;\n        };\n        var getBufferedEnd = function getBufferedEnd() {\n          var value = c.bufferedPos;\n          if (value === Number.MAX_VALUE) {\n            return getMappedDuration('primary');\n          }\n          return Math.max(value, 0);\n        };\n        var getMappedDuration = function getMappedDuration(timelineType) {\n          var _c$primaryDetails, _c$schedule2;\n          if ((_c$primaryDetails = c.primaryDetails) != null && _c$primaryDetails.live) {\n            // return end of last event item or playlist\n            return c.primaryDetails.edge;\n          }\n          return ((_c$schedule2 = c.schedule) == null ? void 0 : _c$schedule2.durations[timelineType]) || 0;\n        };\n        var seekTo = function seekTo(time, timelineType) {\n          var _item$event, _c$schedule$items2;\n          var item = c.effectivePlayingItem;\n          if (item != null && (_item$event = item.event) != null && _item$event.restrictions.skip || !c.schedule) {\n            return;\n          }\n          c.log(\"seek to \" + time + \" \\\"\" + timelineType + \"\\\"\");\n          var playingItem = c.effectivePlayingItem;\n          var targetIndex = c.schedule.findItemIndexAtTime(time, timelineType);\n          var targetItem = (_c$schedule$items2 = c.schedule.items) == null ? void 0 : _c$schedule$items2[targetIndex];\n          var bufferingPlayer = c.getBufferingPlayer();\n          var bufferingInterstitial = bufferingPlayer == null ? void 0 : bufferingPlayer.interstitial;\n          var appendInPlace = bufferingInterstitial == null ? void 0 : bufferingInterstitial.appendInPlace;\n          var seekInItem = playingItem && c.itemsMatch(playingItem, targetItem);\n          if (playingItem && (appendInPlace || seekInItem)) {\n            // seek in asset player or primary media (appendInPlace)\n            var assetPlayer = getAssetPlayer(c.playingAsset);\n            var media = (assetPlayer == null ? void 0 : assetPlayer.media) || c.primaryMedia;\n            if (media) {\n              var currentTime = timelineType === 'primary' ? media.currentTime : getMappedTime(playingItem, timelineType, c.playingAsset, 'timelinePos', 'currentTime');\n              var diff = time - currentTime;\n              var seekToTime = (appendInPlace ? currentTime : media.currentTime) + diff;\n              if (seekToTime >= 0 && (!assetPlayer || appendInPlace || seekToTime <= assetPlayer.duration)) {\n                media.currentTime = seekToTime;\n                return;\n              }\n            }\n          }\n          // seek out of item or asset\n          if (targetItem) {\n            var _seekToTime = time;\n            if (timelineType !== 'primary') {\n              var primarySegmentStart = targetItem[timelineType].start;\n              var _diff = time - primarySegmentStart;\n              _seekToTime = targetItem.start + _diff;\n            }\n            var targetIsPrimary = !c.isInterstitial(targetItem);\n            if ((!c.isInterstitial(playingItem) || playingItem.event.appendInPlace) && (targetIsPrimary || targetItem.event.appendInPlace)) {\n              var _media = c.media || (appendInPlace ? bufferingPlayer == null ? void 0 : bufferingPlayer.media : null);\n              if (_media) {\n                _media.currentTime = _seekToTime;\n              }\n            } else if (playingItem) {\n              // check if an Interstitial between the current item and target item has an X-RESTRICT JUMP restriction\n              var playingIndex = c.findItemIndex(playingItem);\n              if (targetIndex > playingIndex) {\n                var jumpIndex = c.schedule.findJumpRestrictedIndex(playingIndex + 1, targetIndex);\n                if (jumpIndex > playingIndex) {\n                  c.setSchedulePosition(jumpIndex);\n                  return;\n                }\n              }\n              var assetIndex = 0;\n              if (targetIsPrimary) {\n                c.timelinePos = _seekToTime;\n                c.checkBuffer();\n              } else {\n                var assetList = targetItem.event.assetList;\n                var eventTime = time - (targetItem[timelineType] || targetItem).start;\n                for (var i = assetList.length; i--;) {\n                  var asset = assetList[i];\n                  if (asset.duration && eventTime >= asset.startOffset && eventTime < asset.startOffset + asset.duration) {\n                    assetIndex = i;\n                    break;\n                  }\n                }\n              }\n              c.setSchedulePosition(targetIndex, assetIndex);\n            }\n          }\n        };\n        var getActiveInterstitial = function getActiveInterstitial() {\n          var playingItem = c.effectivePlayingItem;\n          if (c.isInterstitial(playingItem)) {\n            return playingItem;\n          }\n          var bufferingItem = effectiveBufferingItem();\n          if (c.isInterstitial(bufferingItem)) {\n            return bufferingItem;\n          }\n          return null;\n        };\n        var interstitialPlayer = {\n          get bufferedEnd() {\n            var interstitialItem = effectiveBufferingItem();\n            var bufferingItem = c.bufferingItem;\n            if (bufferingItem && bufferingItem === interstitialItem) {\n              var _c$bufferingAsset;\n              return getMappedTime(bufferingItem, 'playout', c.bufferingAsset, 'bufferedPos', 'bufferedEnd') - bufferingItem.playout.start || ((_c$bufferingAsset = c.bufferingAsset) == null ? void 0 : _c$bufferingAsset.startOffset) || 0;\n            }\n            return 0;\n          },\n          get currentTime() {\n            var interstitialItem = getActiveInterstitial();\n            var playingItem = c.effectivePlayingItem;\n            if (playingItem && playingItem === interstitialItem) {\n              return getMappedTime(playingItem, 'playout', c.effectivePlayingAsset, 'timelinePos', 'currentTime') - playingItem.playout.start;\n            }\n            return 0;\n          },\n          set currentTime(time) {\n            var interstitialItem = getActiveInterstitial();\n            var playingItem = c.effectivePlayingItem;\n            if (playingItem && playingItem === interstitialItem) {\n              seekTo(time + playingItem.playout.start, 'playout');\n            }\n          },\n          get duration() {\n            var interstitialItem = getActiveInterstitial();\n            if (interstitialItem) {\n              return interstitialItem.playout.end - interstitialItem.playout.start;\n            }\n            return 0;\n          },\n          get assetPlayers() {\n            var _getActiveInterstitia;\n            var assetList = (_getActiveInterstitia = getActiveInterstitial()) == null ? void 0 : _getActiveInterstitia.event.assetList;\n            if (assetList) {\n              return assetList.map(function (asset) {\n                return c.getAssetPlayer(asset.identifier);\n              });\n            }\n            return [];\n          },\n          get playingIndex() {\n            var _getActiveInterstitia2;\n            var interstitial = (_getActiveInterstitia2 = getActiveInterstitial()) == null ? void 0 : _getActiveInterstitia2.event;\n            if (interstitial && c.effectivePlayingAsset) {\n              return interstitial.findAssetIndex(c.effectivePlayingAsset);\n            }\n            return -1;\n          },\n          get scheduleItem() {\n            return getActiveInterstitial();\n          }\n        };\n        return this.manager = {\n          get events() {\n            var _c$schedule3;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            return ((_c$schedule3 = c.schedule) == null || (_c$schedule3 = _c$schedule3.events) == null ? void 0 : _c$schedule3.slice(0)) || [];\n          },\n          get schedule() {\n            var _c$schedule4;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            return ((_c$schedule4 = c.schedule) == null || (_c$schedule4 = _c$schedule4.items) == null ? void 0 : _c$schedule4.slice(0)) || [];\n          },\n          get interstitialPlayer() {\n            if (getActiveInterstitial()) {\n              return interstitialPlayer;\n            }\n            return null;\n          },\n          get playerQueue() {\n            return c.playerQueue.slice(0);\n          },\n          get bufferingAsset() {\n            return c.bufferingAsset;\n          },\n          get bufferingItem() {\n            return effectiveBufferingItem();\n          },\n          get bufferingIndex() {\n            var item = effectiveBufferingItem();\n            return c.findItemIndex(item);\n          },\n          get playingAsset() {\n            return c.effectivePlayingAsset;\n          },\n          get playingItem() {\n            return c.effectivePlayingItem;\n          },\n          get playingIndex() {\n            var item = c.effectivePlayingItem;\n            return c.findItemIndex(item);\n          },\n          primary: {\n            get bufferedEnd() {\n              return getBufferedEnd();\n            },\n            get currentTime() {\n              var timelinePos = c.timelinePos;\n              return timelinePos > 0 ? timelinePos : 0;\n            },\n            set currentTime(time) {\n              seekTo(time, 'primary');\n            },\n            get duration() {\n              return getMappedDuration('primary');\n            },\n            get seekableStart() {\n              var _c$primaryDetails2;\n              return ((_c$primaryDetails2 = c.primaryDetails) == null ? void 0 : _c$primaryDetails2.fragmentStart) || 0;\n            }\n          },\n          integrated: {\n            get bufferedEnd() {\n              return getMappedTime(effectiveBufferingItem(), 'integrated', c.bufferingAsset, 'bufferedPos', 'bufferedEnd');\n            },\n            get currentTime() {\n              return getMappedTime(c.effectivePlayingItem, 'integrated', c.effectivePlayingAsset, 'timelinePos', 'currentTime');\n            },\n            set currentTime(time) {\n              seekTo(time, 'integrated');\n            },\n            get duration() {\n              return getMappedDuration('integrated');\n            },\n            get seekableStart() {\n              var _c$primaryDetails3;\n              return findMappedTime(((_c$primaryDetails3 = c.primaryDetails) == null ? void 0 : _c$primaryDetails3.fragmentStart) || 0, 'integrated');\n            }\n          },\n          skip: function skip() {\n            var item = c.effectivePlayingItem;\n            var event = item == null ? void 0 : item.event;\n            if (event && !event.restrictions.skip) {\n              var index = c.findItemIndex(item);\n              if (event.appendInPlace) {\n                var time = item.playout.start + item.event.duration;\n                seekTo(time + 0.001, 'playout');\n              } else {\n                c.advanceAfterAssetEnded(event, index, Infinity);\n              }\n            }\n          }\n        };\n      }\n\n      // Schedule getters\n    }, {\n      key: \"effectivePlayingItem\",\n      get: function get() {\n        return this.waitingItem || this.playingItem || this.endedItem;\n      }\n    }, {\n      key: \"effectivePlayingAsset\",\n      get: function get() {\n        return this.playingAsset || this.endedAsset;\n      }\n    }, {\n      key: \"playingLastItem\",\n      get: function get() {\n        var _this$schedule9;\n        var playingItem = this.playingItem;\n        var items = (_this$schedule9 = this.schedule) == null ? void 0 : _this$schedule9.items;\n        if (!this.playbackStarted || !playingItem || !items) {\n          return false;\n        }\n        return this.findItemIndex(playingItem) === items.length - 1;\n      }\n    }, {\n      key: \"playbackStarted\",\n      get: function get() {\n        return this.effectivePlayingItem !== null;\n      }\n\n      // Media getters and event callbacks\n    }, {\n      key: \"currentTime\",\n      get: function get() {\n        var _this$bufferingItem2, _media2;\n        if (this.mediaSelection === null) {\n          // Do not advance before schedule is known\n          return undefined;\n        }\n        // Ignore currentTime when detached for Interstitial playback with source reset\n        var queuedForPlayback = this.waitingItem || this.playingItem;\n        if (this.isInterstitial(queuedForPlayback) && !queuedForPlayback.event.appendInPlace) {\n          return undefined;\n        }\n        var media = this.media;\n        if (!media && (_this$bufferingItem2 = this.bufferingItem) != null && (_this$bufferingItem2 = _this$bufferingItem2.event) != null && _this$bufferingItem2.appendInPlace) {\n          // Observe detached media currentTime when appending in place\n          media = this.primaryMedia;\n        }\n        var currentTime = (_media2 = media) == null ? void 0 : _media2.currentTime;\n        if (currentTime === undefined || !isFiniteNumber(currentTime)) {\n          return undefined;\n        }\n        return currentTime;\n      }\n    }, {\n      key: \"primaryMedia\",\n      get: function get() {\n        var _this$detachedData5;\n        return this.media || ((_this$detachedData5 = this.detachedData) == null ? void 0 : _this$detachedData5.media) || null;\n      }\n    }, {\n      key: \"playbackDisabled\",\n      get: function get() {\n        return this.hls.config.enableInterstitialPlayback === false;\n      }\n    }, {\n      key: \"primaryDetails\",\n      get: function get() {\n        var _this$mediaSelection;\n        return (_this$mediaSelection = this.mediaSelection) == null ? void 0 : _this$mediaSelection.main.details;\n      }\n    }, {\n      key: \"primaryLive\",\n      get: function get() {\n        var _this$primaryDetails;\n        return !!((_this$primaryDetails = this.primaryDetails) != null && _this$primaryDetails.live);\n      }\n    }]);\n  }(Logger);\n\n  var TICK_INTERVAL$2 = 500; // how often to tick in ms\n\n  var SubtitleStreamController = /*#__PURE__*/function (_BaseStreamController) {\n    function SubtitleStreamController(hls, fragmentTracker, keyLoader) {\n      var _this;\n      _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, 'subtitle-stream-controller', PlaylistLevelType.SUBTITLE) || this;\n      _this.currentTrackId = -1;\n      _this.tracksBuffered = [];\n      _this.mainDetails = null;\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(SubtitleStreamController, _BaseStreamController);\n    var _proto = SubtitleStreamController.prototype;\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      this.unregisterListeners();\n      _BaseStreamController.prototype.onHandlerDestroying.call(this);\n      this.mainDetails = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      _BaseStreamController.prototype.registerListeners.call(this);\n      var hls = this.hls;\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n      hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n      hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n      hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      _BaseStreamController.prototype.unregisterListeners.call(this);\n      var hls = this.hls;\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n      hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n      hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n      hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    };\n    _proto.startLoad = function startLoad(startPosition, skipSeekToStartPosition) {\n      this.stopLoad();\n      this.state = State.IDLE;\n      this.setInterval(TICK_INTERVAL$2);\n      this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;\n      this.startPosition = skipSeekToStartPosition ? -1 : startPosition;\n      this.tick();\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      _BaseStreamController.prototype.onManifestLoading.call(this);\n      this.mainDetails = null;\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      this.tracksBuffered = [];\n      _BaseStreamController.prototype.onMediaDetaching.call(this, event, data);\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      this.mainDetails = data.details;\n    };\n    _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {\n      var frag = data.frag,\n        success = data.success;\n      if (!this.fragContextChanged(frag)) {\n        if (isMediaFragment(frag)) {\n          this.fragPrevious = frag;\n        }\n        this.state = State.IDLE;\n      }\n      if (!success) {\n        return;\n      }\n      var buffered = this.tracksBuffered[this.currentTrackId];\n      if (!buffered) {\n        return;\n      }\n\n      // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n      // so we can re-use the logic used to detect how much has been buffered\n      var timeRange;\n      var fragStart = frag.start;\n      for (var i = 0; i < buffered.length; i++) {\n        if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n          timeRange = buffered[i];\n          break;\n        }\n      }\n      var fragEnd = frag.start + frag.duration;\n      if (timeRange) {\n        timeRange.end = fragEnd;\n      } else {\n        timeRange = {\n          start: fragStart,\n          end: fragEnd\n        };\n        buffered.push(timeRange);\n      }\n      this.fragmentTracker.fragBuffered(frag);\n      this.fragBufferedComplete(frag, null);\n      if (this.media) {\n        this.tick();\n      }\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n      var startOffset = data.startOffset,\n        endOffset = data.endOffset;\n      if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n        var endOffsetSubtitles = endOffset - 1;\n        if (endOffsetSubtitles <= 0) {\n          return;\n        }\n        data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n        this.tracksBuffered.forEach(function (buffered) {\n          for (var i = 0; i < buffered.length;) {\n            if (buffered[i].end <= endOffsetSubtitles) {\n              buffered.shift();\n              continue;\n            } else if (buffered[i].start < endOffsetSubtitles) {\n              buffered[i].start = endOffsetSubtitles;\n            } else {\n              break;\n            }\n            i++;\n          }\n        });\n        this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);\n      }\n    }\n\n    // If something goes wrong, proceed to next frag, if we were processing one.\n    ;\n    _proto.onError = function onError(event, data) {\n      var frag = data.frag;\n      if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {\n        if (data.details === ErrorDetails.FRAG_GAP) {\n          this.fragmentTracker.fragBuffered(frag, true);\n        }\n        if (this.fragCurrent) {\n          this.fragCurrent.abortRequests();\n        }\n        if (this.state !== State.STOPPED) {\n          this.state = State.IDLE;\n        }\n      }\n    }\n\n    // Got all new subtitle levels.\n    ;\n    _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref) {\n      var _this2 = this;\n      var subtitleTracks = _ref.subtitleTracks;\n      if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {\n        this.levels = subtitleTracks.map(function (mediaPlaylist) {\n          return new Level(mediaPlaylist);\n        });\n        return;\n      }\n      this.tracksBuffered = [];\n      this.levels = subtitleTracks.map(function (mediaPlaylist) {\n        var level = new Level(mediaPlaylist);\n        _this2.tracksBuffered[level.id] = [];\n        return level;\n      });\n      this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);\n      this.fragPrevious = null;\n      this.mediaBuffer = null;\n    };\n    _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {\n      var _this$levels;\n      this.currentTrackId = data.id;\n      if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {\n        this.clearInterval();\n        return;\n      }\n\n      // Check if track has the necessary details to load fragments\n      var currentTrack = this.levels[this.currentTrackId];\n      if (currentTrack != null && currentTrack.details) {\n        this.mediaBuffer = this.mediaBufferTimeRanges;\n      } else {\n        this.mediaBuffer = null;\n      }\n      if (currentTrack && this.state !== State.STOPPED) {\n        this.setInterval(TICK_INTERVAL$2);\n      }\n    }\n\n    // Got a new set of subtitle fragments.\n    ;\n    _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n      var _track$details;\n      var currentTrackId = this.currentTrackId,\n        levels = this.levels;\n      var newDetails = data.details,\n        trackId = data.id;\n      if (!levels) {\n        this.warn(\"Subtitle tracks were reset while loading level \" + trackId);\n        return;\n      }\n      var track = levels[trackId];\n      if (trackId >= levels.length || !track) {\n        return;\n      }\n      this.log(\"Subtitle track \" + trackId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"]\" + (newDetails.lastPartSn ? \"[part-\" + newDetails.lastPartSn + \"-\" + newDetails.lastPartIndex + \"]\" : '') + \",duration:\" + newDetails.totalduration);\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n      var sliding = 0;\n      if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n        if (newDetails.deltaUpdateFailed) {\n          return;\n        }\n        var mainDetails = this.mainDetails;\n        if (!mainDetails) {\n          this.startFragRequested = false;\n          return;\n        }\n        var mainSlidingStartFragment = mainDetails.fragments[0];\n        if (!track.details) {\n          if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n            alignMediaPlaylistByPDT(newDetails, mainDetails);\n            sliding = newDetails.fragmentStart;\n          } else if (mainSlidingStartFragment) {\n            // line up live playlist with main so that fragments in range are loaded\n            sliding = mainSlidingStartFragment.start;\n            addSliding(newDetails, sliding);\n          }\n        } else {\n          var _this$levelLastLoaded;\n          sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n          if (sliding === 0 && mainSlidingStartFragment) {\n            // realign with main when there is no overlap with last refresh\n            sliding = mainSlidingStartFragment.start;\n            addSliding(newDetails, sliding);\n          }\n        }\n        // compute start position if we are aligned with the main playlist\n        if (mainDetails && !this.startFragRequested) {\n          this.setStartPosition(mainDetails, sliding);\n        }\n      }\n      track.details = newDetails;\n      this.levelLastLoaded = track;\n      if (trackId !== currentTrackId) {\n        return;\n      }\n      this.hls.trigger(Events.SUBTITLE_TRACK_UPDATED, {\n        details: newDetails,\n        id: trackId,\n        groupId: data.groupId\n      });\n\n      // trigger handler right now\n      this.tick();\n\n      // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n      if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {\n        var foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);\n        if (!foundFrag) {\n          this.warn('Subtitle playlist not aligned with playback');\n          track.details = undefined;\n        }\n      }\n    };\n    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n      var _this3 = this;\n      var frag = fragLoadedData.frag,\n        payload = fragLoadedData.payload;\n      var decryptData = frag.decryptdata;\n      var hls = this.hls;\n      if (this.fragContextChanged(frag)) {\n        return;\n      }\n      // check to see if the payload needs to be decrypted\n      if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && isFullSegmentEncryption(decryptData.method)) {\n        var startTime = performance.now();\n        // decrypt the subtitles\n        this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer, getAesModeFromFullSegmentMethod(decryptData.method)).catch(function (err) {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_DECRYPT_ERROR,\n            fatal: false,\n            error: err,\n            reason: err.message,\n            frag: frag\n          });\n          throw err;\n        }).then(function (decryptedData) {\n          var endTime = performance.now();\n          hls.trigger(Events.FRAG_DECRYPTED, {\n            frag: frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n        }).catch(function (err) {\n          _this3.warn(err.name + \": \" + err.message);\n          _this3.state = State.IDLE;\n        });\n      }\n    };\n    _proto.doTick = function doTick() {\n      if (!this.media) {\n        this.state = State.IDLE;\n        return;\n      }\n      if (this.state === State.IDLE) {\n        var currentTrackId = this.currentTrackId,\n          levels = this.levels;\n        var track = levels == null ? void 0 : levels[currentTrackId];\n        if (!track || !levels.length || !track.details) {\n          return;\n        }\n        if (this.waitForLive(track)) {\n          return;\n        }\n        var config = this.config;\n        var currentTime = this.getLoadPosition();\n        var bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);\n        var targetBufferTime = bufferedInfo.end,\n          bufferLen = bufferedInfo.len;\n        var trackDetails = track.details;\n        var maxBufLen = this.hls.maxBufferLength + trackDetails.levelTargetDuration;\n        if (bufferLen > maxBufLen) {\n          return;\n        }\n        var fragments = trackDetails.fragments;\n        var fragLen = fragments.length;\n        var end = trackDetails.edge;\n        var foundFrag = null;\n        var fragPrevious = this.fragPrevious;\n        if (targetBufferTime < end) {\n          var tolerance = config.maxFragLookUpTolerance;\n          var lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;\n          foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);\n          if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n            foundFrag = fragments[0];\n          }\n        } else {\n          foundFrag = fragments[fragLen - 1];\n        }\n        foundFrag = this.filterReplacedPrimary(foundFrag, track.details);\n        if (!foundFrag) {\n          return;\n        }\n        // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment\n        var curSNIdx = foundFrag.sn - trackDetails.startSN;\n        var prevFrag = fragments[curSNIdx - 1];\n        if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {\n          foundFrag = prevFrag;\n        }\n        if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {\n          // only load if fragment is not loaded\n          var fragToLoad = this.mapToInitFragWhenRequired(foundFrag);\n          if (fragToLoad) {\n            this.loadFragment(fragToLoad, track, targetBufferTime);\n          }\n        }\n      }\n    };\n    _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n      if (!isMediaFragment(frag)) {\n        this._loadInitSegment(frag, level);\n      } else {\n        _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);\n      }\n    };\n    return _createClass(SubtitleStreamController, [{\n      key: \"mediaBufferTimeRanges\",\n      get: function get() {\n        return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n      }\n    }]);\n  }(BaseStreamController);\n  var BufferableInstance = function BufferableInstance(timeranges) {\n    this.buffered = void 0;\n    var getRange = function getRange(name, index, length) {\n      index = index >>> 0;\n      if (index > length - 1) {\n        throw new DOMException(\"Failed to execute '\" + name + \"' on 'TimeRanges': The index provided (\" + index + \") is greater than the maximum bound (\" + length + \")\");\n      }\n      return timeranges[index][name];\n    };\n    this.buffered = {\n      get length() {\n        return timeranges.length;\n      },\n      end: function end(index) {\n        return getRange('end', index, timeranges.length);\n      },\n      start: function start(index) {\n        return getRange('start', index, timeranges.length);\n      }\n    };\n  };\n\n  function sendAddTrackEvent(track, videoEl) {\n    var event;\n    try {\n      event = new Event('addtrack');\n    } catch (err) {\n      // for IE11\n      event = document.createEvent('Event');\n      event.initEvent('addtrack', false, false);\n    }\n    event.track = track;\n    videoEl.dispatchEvent(event);\n  }\n  function addCueToTrack(track, cue) {\n    // Sometimes there are cue overlaps on segmented vtts so the same\n    // cue can appear more than once in different vtt files.\n    // This avoid showing duplicated cues with same timecode and text.\n    var mode = track.mode;\n    if (mode === 'disabled') {\n      track.mode = 'hidden';\n    }\n    if (track.cues && !track.cues.getCueById(cue.id)) {\n      try {\n        track.addCue(cue);\n        if (!track.cues.getCueById(cue.id)) {\n          throw new Error(\"addCue is failed for: \" + cue);\n        }\n      } catch (err) {\n        logger.debug(\"[texttrack-utils]: \" + err);\n        try {\n          var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n          textTrackCue.id = cue.id;\n          track.addCue(textTrackCue);\n        } catch (err2) {\n          logger.debug(\"[texttrack-utils]: Legacy TextTrackCue fallback failed: \" + err2);\n        }\n      }\n    }\n    if (mode === 'disabled') {\n      track.mode = mode;\n    }\n  }\n  function clearCurrentCues(track, enterHandler) {\n    // When track.mode is disabled, track.cues will be null.\n    // To guarantee the removal of cues, we need to temporarily\n    // change the mode to hidden\n    var mode = track.mode;\n    if (mode === 'disabled') {\n      track.mode = 'hidden';\n    }\n    if (track.cues) {\n      for (var i = track.cues.length; i--;) {\n        if (enterHandler) {\n          track.cues[i].removeEventListener('enter', enterHandler);\n        }\n        track.removeCue(track.cues[i]);\n      }\n    }\n    if (mode === 'disabled') {\n      track.mode = mode;\n    }\n  }\n  function removeCuesInRange(track, start, end, predicate) {\n    var mode = track.mode;\n    if (mode === 'disabled') {\n      track.mode = 'hidden';\n    }\n    if (track.cues && track.cues.length > 0) {\n      var cues = getCuesInRange(track.cues, start, end);\n      for (var i = 0; i < cues.length; i++) {\n        if (!predicate || predicate(cues[i])) {\n          track.removeCue(cues[i]);\n        }\n      }\n    }\n    if (mode === 'disabled') {\n      track.mode = mode;\n    }\n  }\n\n  // Find first cue starting at or after given time.\n  // Modified version of binary search O(log(n)).\n  function getFirstCueIndexFromTime(cues, time) {\n    // If first cue starts at or after time, start there\n    if (time <= cues[0].startTime) {\n      return 0;\n    }\n    // If the last cue ends before time there is no overlap\n    var len = cues.length - 1;\n    if (time > cues[len].endTime) {\n      return -1;\n    }\n    var left = 0;\n    var right = len;\n    var mid;\n    while (left <= right) {\n      mid = Math.floor((right + left) / 2);\n      if (time < cues[mid].startTime) {\n        right = mid - 1;\n      } else if (time > cues[mid].startTime && left < len) {\n        left = mid + 1;\n      } else {\n        // If it's not lower or higher, it must be equal.\n        return mid;\n      }\n    }\n    // At this point, left and right have swapped.\n    // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n    return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n  }\n  function getCuesInRange(cues, start, end) {\n    var cuesFound = [];\n    var firstCueInRange = getFirstCueIndexFromTime(cues, start);\n    if (firstCueInRange > -1) {\n      for (var i = firstCueInRange, len = cues.length; i < len; i++) {\n        var cue = cues[i];\n        if (cue.startTime >= start && cue.endTime <= end) {\n          cuesFound.push(cue);\n        } else if (cue.startTime > end) {\n          return cuesFound;\n        }\n      }\n    }\n    return cuesFound;\n  }\n  function filterSubtitleTracks(textTrackList) {\n    var tracks = [];\n    for (var i = 0; i < textTrackList.length; i++) {\n      var track = textTrackList[i];\n      // Edge adds a track without a label; we don't want to use it\n      if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {\n        tracks.push(textTrackList[i]);\n      }\n    }\n    return tracks;\n  }\n\n  var SubtitleTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n    function SubtitleTrackController(hls) {\n      var _this;\n      _this = _BasePlaylistControll.call(this, hls, 'subtitle-track-controller') || this;\n      _this.media = null;\n      _this.tracks = [];\n      _this.groupIds = null;\n      _this.tracksInGroup = [];\n      _this.trackId = -1;\n      _this.currentTrack = null;\n      _this.selectDefaultTrack = true;\n      _this.queuedDefaultTrack = -1;\n      _this.useTextTrackPolling = false;\n      _this.subtitlePollingInterval = -1;\n      _this._subtitleDisplay = true;\n      _this.asyncPollTrackChange = function () {\n        return _this.pollTrackChange(0);\n      };\n      _this.onTextTracksChanged = function () {\n        if (!_this.useTextTrackPolling) {\n          self.clearInterval(_this.subtitlePollingInterval);\n        }\n        // Media is undefined when switching streams via loadSource()\n        if (!_this.media || !_this.hls.config.renderTextTracksNatively) {\n          return;\n        }\n        var textTrack = null;\n        var tracks = filterSubtitleTracks(_this.media.textTracks);\n        for (var i = 0; i < tracks.length; i++) {\n          if (tracks[i].mode === 'hidden') {\n            // Do not break in case there is a following track with showing.\n            textTrack = tracks[i];\n          } else if (tracks[i].mode === 'showing') {\n            textTrack = tracks[i];\n            break;\n          }\n        }\n\n        // Find internal track index for TextTrack\n        var trackId = _this.findTrackForTextTrack(textTrack);\n        if (_this.subtitleTrack !== trackId) {\n          _this.setSubtitleTrack(trackId);\n        }\n      };\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(SubtitleTrackController, _BasePlaylistControll);\n    var _proto = SubtitleTrackController.prototype;\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.tracks.length = 0;\n      this.tracksInGroup.length = 0;\n      this.currentTrack = null;\n      // @ts-ignore\n      this.onTextTracksChanged = this.asyncPollTrackChange = null;\n      _BasePlaylistControll.prototype.destroy.call(this);\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n      hls.off(Events.ERROR, this.onError, this);\n    }\n\n    // Listen for subtitle track change, then extract the current track ID.\n    ;\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      this.media = data.media;\n      if (!this.media) {\n        return;\n      }\n      if (this.queuedDefaultTrack > -1) {\n        this.subtitleTrack = this.queuedDefaultTrack;\n        this.queuedDefaultTrack = -1;\n      }\n      this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n      if (this.useTextTrackPolling) {\n        this.pollTrackChange(500);\n      } else {\n        this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n      }\n    };\n    _proto.pollTrackChange = function pollTrackChange(timeout) {\n      self.clearInterval(this.subtitlePollingInterval);\n      this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      var transferringMedia = !!data.transferMedia;\n      self.clearInterval(this.subtitlePollingInterval);\n      if (!this.useTextTrackPolling) {\n        media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n      }\n      if (this.trackId > -1) {\n        this.queuedDefaultTrack = this.trackId;\n      }\n\n      // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n      this.subtitleTrack = -1;\n      this.media = null;\n      if (transferringMedia) {\n        return;\n      }\n      var textTracks = filterSubtitleTracks(media.textTracks);\n      // Clear loaded cues on media detachment from tracks\n      textTracks.forEach(function (track) {\n        clearCurrentCues(track);\n      });\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.tracks = [];\n      this.groupIds = null;\n      this.tracksInGroup = [];\n      this.trackId = -1;\n      this.currentTrack = null;\n      this.selectDefaultTrack = true;\n    }\n\n    // Fired whenever a new manifest is loaded.\n    ;\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      this.tracks = data.subtitleTracks;\n    };\n    _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n      var id = data.id,\n        groupId = data.groupId,\n        details = data.details;\n      var trackInActiveGroup = this.tracksInGroup[id];\n      if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n        this.warn(\"Subtitle track with id:\" + id + \" and group:\" + groupId + \" not found in active group \" + (trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId));\n        return;\n      }\n      var curDetails = trackInActiveGroup.details;\n      trackInActiveGroup.details = data.details;\n      this.log(\"Subtitle track \" + id + \" \\\"\" + trackInActiveGroup.name + \"\\\" lang:\" + trackInActiveGroup.lang + \" group:\" + groupId + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n      if (id === this.trackId) {\n        this.playlistLoaded(id, data, curDetails);\n      }\n    };\n    _proto.onLevelLoading = function onLevelLoading(event, data) {\n      this.switchLevel(data.level);\n    };\n    _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n      this.switchLevel(data.level);\n    };\n    _proto.switchLevel = function switchLevel(levelIndex) {\n      var levelInfo = this.hls.levels[levelIndex];\n      if (!levelInfo) {\n        return;\n      }\n      var subtitleGroups = levelInfo.subtitleGroups || null;\n      var currentGroups = this.groupIds;\n      var currentTrack = this.currentTrack;\n      if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some(function (groupId) {\n        return (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1;\n      })) {\n        this.groupIds = subtitleGroups;\n        this.trackId = -1;\n        this.currentTrack = null;\n        var subtitleTracks = this.tracks.filter(function (track) {\n          return !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1;\n        });\n        if (subtitleTracks.length) {\n          // Disable selectDefaultTrack if there are no default tracks\n          if (this.selectDefaultTrack && !subtitleTracks.some(function (track) {\n            return track.default;\n          })) {\n            this.selectDefaultTrack = false;\n          }\n          // track.id should match hls.audioTracks index\n          subtitleTracks.forEach(function (track, i) {\n            track.id = i;\n          });\n        } else if (!currentTrack && !this.tracksInGroup.length) {\n          // Do not dispatch SUBTITLE_TRACKS_UPDATED when there were and are no tracks\n          return;\n        }\n        this.tracksInGroup = subtitleTracks;\n\n        // Find preferred track\n        var subtitlePreference = this.hls.config.subtitlePreference;\n        if (!currentTrack && subtitlePreference) {\n          this.selectDefaultTrack = false;\n          var groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);\n          if (groupIndex > -1) {\n            currentTrack = subtitleTracks[groupIndex];\n          } else {\n            var allIndex = findMatchingOption(subtitlePreference, this.tracks);\n            currentTrack = this.tracks[allIndex];\n          }\n        }\n\n        // Select initial track\n        var trackId = this.findTrackId(currentTrack);\n        if (trackId === -1 && currentTrack) {\n          trackId = this.findTrackId(null);\n        }\n\n        // Dispatch events and load track if needed\n        var subtitleTracksUpdated = {\n          subtitleTracks: subtitleTracks\n        };\n        this.log(\"Updating subtitle tracks, \" + subtitleTracks.length + \" track(s) found in \\\"\" + (subtitleGroups == null ? void 0 : subtitleGroups.join(',')) + \"\\\" group-id\");\n        this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n        if (trackId !== -1 && this.trackId === -1) {\n          this.setSubtitleTrack(trackId);\n        }\n      }\n    };\n    _proto.findTrackId = function findTrackId(currentTrack) {\n      var tracks = this.tracksInGroup;\n      var selectDefault = this.selectDefaultTrack;\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n        if (selectDefault && !track.default || !selectDefault && !currentTrack) {\n          continue;\n        }\n        if (!currentTrack || matchesOption(track, currentTrack)) {\n          return i;\n        }\n      }\n      if (currentTrack) {\n        for (var _i = 0; _i < tracks.length; _i++) {\n          var _track = tracks[_i];\n          if (mediaAttributesIdentical(currentTrack.attrs, _track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n            return _i;\n          }\n        }\n        for (var _i2 = 0; _i2 < tracks.length; _i2++) {\n          var _track2 = tracks[_i2];\n          if (mediaAttributesIdentical(currentTrack.attrs, _track2.attrs, ['LANGUAGE'])) {\n            return _i2;\n          }\n        }\n      }\n      return -1;\n    };\n    _proto.findTrackForTextTrack = function findTrackForTextTrack(textTrack) {\n      if (textTrack) {\n        var tracks = this.tracksInGroup;\n        for (var i = 0; i < tracks.length; i++) {\n          var track = tracks[i];\n          if (subtitleTrackMatchesTextTrack(track, textTrack)) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    _proto.onError = function onError(event, data) {\n      if (data.fatal || !data.context) {\n        return;\n      }\n      if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n        this.checkRetry(data);\n      }\n    };\n    _proto.setSubtitleOption = function setSubtitleOption(subtitleOption) {\n      this.hls.config.subtitlePreference = subtitleOption;\n      if (subtitleOption) {\n        if (subtitleOption.id === -1) {\n          this.setSubtitleTrack(-1);\n          return null;\n        }\n        var allSubtitleTracks = this.allSubtitleTracks;\n        this.selectDefaultTrack = false;\n        if (allSubtitleTracks.length) {\n          // First see if current option matches (no switch op)\n          var currentTrack = this.currentTrack;\n          if (currentTrack && matchesOption(subtitleOption, currentTrack)) {\n            return currentTrack;\n          }\n          // Find option in current group\n          var groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);\n          if (groupIndex > -1) {\n            var track = this.tracksInGroup[groupIndex];\n            this.setSubtitleTrack(groupIndex);\n            return track;\n          } else if (currentTrack) {\n            // If this is not the initial selection return null\n            // option should have matched one in active group\n            return null;\n          } else {\n            // Find the option in all tracks for initial selection\n            var allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);\n            if (allIndex > -1) {\n              return allSubtitleTracks[allIndex];\n            }\n          }\n        }\n      }\n      return null;\n    };\n    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n      _BasePlaylistControll.prototype.loadPlaylist.call(this);\n      if (this.shouldLoadPlaylist(this.currentTrack)) {\n        this.scheduleLoading(this.currentTrack, hlsUrlParameters);\n      }\n    };\n    _proto.loadingPlaylist = function loadingPlaylist(currentTrack, hlsUrlParameters) {\n      _BasePlaylistControll.prototype.loadingPlaylist.call(this, currentTrack, hlsUrlParameters);\n      var id = currentTrack.id;\n      var groupId = currentTrack.groupId;\n      var url = this.getUrlWithDirectives(currentTrack.url, hlsUrlParameters);\n      var details = currentTrack.details;\n      var age = details == null ? void 0 : details.age;\n      this.log(\"Loading subtitle \" + id + \" \\\"\" + currentTrack.name + \"\\\" lang:\" + currentTrack.lang + \" group:\" + groupId + ((hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + (age && details.live ? ' age ' + age.toFixed(1) + (details.type ? ' ' + details.type || 0 : '') : '') + \" \" + url);\n      this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {\n        url: url,\n        id: id,\n        groupId: groupId,\n        deliveryDirectives: hlsUrlParameters || null,\n        track: currentTrack\n      });\n    }\n\n    /**\n     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n     * This operates on the DOM textTracks.\n     * A value of -1 will disable all subtitle tracks.\n     */;\n    _proto.toggleTrackModes = function toggleTrackModes() {\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      var textTracks = filterSubtitleTracks(media.textTracks);\n      var currentTrack = this.currentTrack;\n      var nextTrack;\n      if (currentTrack) {\n        nextTrack = textTracks.filter(function (textTrack) {\n          return subtitleTrackMatchesTextTrack(currentTrack, textTrack);\n        })[0];\n        if (!nextTrack) {\n          this.warn(\"Unable to find subtitle TextTrack with name \\\"\" + currentTrack.name + \"\\\" and language \\\"\" + currentTrack.lang + \"\\\"\");\n        }\n      }\n      [].slice.call(textTracks).forEach(function (track) {\n        if (track.mode !== 'disabled' && track !== nextTrack) {\n          track.mode = 'disabled';\n        }\n      });\n      if (nextTrack) {\n        var mode = this.subtitleDisplay ? 'showing' : 'hidden';\n        if (nextTrack.mode !== mode) {\n          nextTrack.mode = mode;\n        }\n      }\n    }\n\n    /**\n     * This method is responsible for validating the subtitle index and periodically reloading if live.\n     * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n     */;\n    _proto.setSubtitleTrack = function setSubtitleTrack(newId) {\n      var tracks = this.tracksInGroup;\n\n      // setting this.subtitleTrack will trigger internal logic\n      // if media has not been attached yet, it will fail\n      // we keep a reference to the default track id\n      // and we'll set subtitleTrack when onMediaAttached is triggered\n      if (!this.media) {\n        this.queuedDefaultTrack = newId;\n        return;\n      }\n\n      // exit if track id as already set or invalid\n      if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {\n        this.warn(\"Invalid subtitle track id: \" + newId);\n        return;\n      }\n      this.selectDefaultTrack = false;\n      var lastTrack = this.currentTrack;\n      var track = tracks[newId] || null;\n      this.trackId = newId;\n      this.currentTrack = track;\n      this.toggleTrackModes();\n      if (!track) {\n        // switch to -1\n        this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n          id: newId\n        });\n        return;\n      }\n      var trackLoaded = !!track.details && !track.details.live;\n      if (newId === this.trackId && track === lastTrack && trackLoaded) {\n        return;\n      }\n      this.log(\"Switching to subtitle-track \" + newId + (track ? \" \\\"\" + track.name + \"\\\" lang:\" + track.lang + \" group:\" + track.groupId : ''));\n      var id = track.id,\n        _track$groupId = track.groupId,\n        groupId = _track$groupId === void 0 ? '' : _track$groupId,\n        name = track.name,\n        type = track.type,\n        url = track.url;\n      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id: id,\n        groupId: groupId,\n        name: name,\n        type: type,\n        url: url\n      });\n      var hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n      this.loadPlaylist(hlsUrlParameters);\n    };\n    return _createClass(SubtitleTrackController, [{\n      key: \"subtitleDisplay\",\n      get: function get() {\n        return this._subtitleDisplay;\n      },\n      set: function set(value) {\n        this._subtitleDisplay = value;\n        if (this.trackId > -1) {\n          this.toggleTrackModes();\n        }\n      }\n    }, {\n      key: \"allSubtitleTracks\",\n      get: function get() {\n        return this.tracks;\n      }\n\n      /** get alternate subtitle tracks list from playlist **/\n    }, {\n      key: \"subtitleTracks\",\n      get: function get() {\n        return this.tracksInGroup;\n      }\n\n      /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n    }, {\n      key: \"subtitleTrack\",\n      get: function get() {\n        return this.trackId;\n      },\n      set: function set(newId) {\n        this.selectDefaultTrack = false;\n        this.setSubtitleTrack(newId);\n      }\n    }]);\n  }(BasePlaylistController);\n\n  /**\n   *\n   * This code was ported from the dash.js project at:\n   *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n   *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n   *\n   * The original copyright appears below:\n   *\n   * The copyright in this software is being made available under the BSD License,\n   * included below. This software may be subject to other third party and contributor\n   * rights, including patent rights, and no such rights are granted under this license.\n   *\n   * Copyright (c) 2015-2016, DASH Industry Forum.\n   * All rights reserved.\n   *\n   * Redistribution and use in source and binary forms, with or without modification,\n   * are permitted provided that the following conditions are met:\n   *  1. Redistributions of source code must retain the above copyright notice, this\n   *  list of conditions and the following disclaimer.\n   *  * Redistributions in binary form must reproduce the above copyright notice,\n   *  this list of conditions and the following disclaimer in the documentation and/or\n   *  other materials provided with the distribution.\n   *  2. Neither the name of Dash Industry Forum nor the names of its\n   *  contributors may be used to endorse or promote products derived from this software\n   *  without specific prior written permission.\n   *\n   *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n   *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n   *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n   *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n   *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n   *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n   *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n   *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n   *  POSSIBILITY OF SUCH DAMAGE.\n   */\n  /**\n   *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n   */\n\n  var specialCea608CharsCodes = {\n    0x2a: 0xe1,\n    // lowercase a, acute accent\n    0x5c: 0xe9,\n    // lowercase e, acute accent\n    0x5e: 0xed,\n    // lowercase i, acute accent\n    0x5f: 0xf3,\n    // lowercase o, acute accent\n    0x60: 0xfa,\n    // lowercase u, acute accent\n    0x7b: 0xe7,\n    // lowercase c with cedilla\n    0x7c: 0xf7,\n    // division symbol\n    0x7d: 0xd1,\n    // uppercase N tilde\n    0x7e: 0xf1,\n    // lowercase n tilde\n    0x7f: 0x2588,\n    // Full block\n    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n    // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n    0x80: 0xae,\n    // Registered symbol (R)\n    0x81: 0xb0,\n    // degree sign\n    0x82: 0xbd,\n    // 1/2 symbol\n    0x83: 0xbf,\n    // Inverted (open) question mark\n    0x84: 0x2122,\n    // Trademark symbol (TM)\n    0x85: 0xa2,\n    // Cents symbol\n    0x86: 0xa3,\n    // Pounds sterling\n    0x87: 0x266a,\n    // Music 8'th note\n    0x88: 0xe0,\n    // lowercase a, grave accent\n    0x89: 0x20,\n    // transparent space (regular)\n    0x8a: 0xe8,\n    // lowercase e, grave accent\n    0x8b: 0xe2,\n    // lowercase a, circumflex accent\n    0x8c: 0xea,\n    // lowercase e, circumflex accent\n    0x8d: 0xee,\n    // lowercase i, circumflex accent\n    0x8e: 0xf4,\n    // lowercase o, circumflex accent\n    0x8f: 0xfb,\n    // lowercase u, circumflex accent\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n    0x90: 0xc1,\n    // capital letter A with acute\n    0x91: 0xc9,\n    // capital letter E with acute\n    0x92: 0xd3,\n    // capital letter O with acute\n    0x93: 0xda,\n    // capital letter U with acute\n    0x94: 0xdc,\n    // capital letter U with diaresis\n    0x95: 0xfc,\n    // lowercase letter U with diaeresis\n    0x96: 0x2018,\n    // opening single quote\n    0x97: 0xa1,\n    // inverted exclamation mark\n    0x98: 0x2a,\n    // asterisk\n    0x99: 0x2019,\n    // closing single quote\n    0x9a: 0x2501,\n    // box drawings heavy horizontal\n    0x9b: 0xa9,\n    // copyright sign\n    0x9c: 0x2120,\n    // Service mark\n    0x9d: 0x2022,\n    // (round) bullet\n    0x9e: 0x201c,\n    // Left double quotation mark\n    0x9f: 0x201d,\n    // Right double quotation mark\n    0xa0: 0xc0,\n    // uppercase A, grave accent\n    0xa1: 0xc2,\n    // uppercase A, circumflex\n    0xa2: 0xc7,\n    // uppercase C with cedilla\n    0xa3: 0xc8,\n    // uppercase E, grave accent\n    0xa4: 0xca,\n    // uppercase E, circumflex\n    0xa5: 0xcb,\n    // capital letter E with diaresis\n    0xa6: 0xeb,\n    // lowercase letter e with diaresis\n    0xa7: 0xce,\n    // uppercase I, circumflex\n    0xa8: 0xcf,\n    // uppercase I, with diaresis\n    0xa9: 0xef,\n    // lowercase i, with diaresis\n    0xaa: 0xd4,\n    // uppercase O, circumflex\n    0xab: 0xd9,\n    // uppercase U, grave accent\n    0xac: 0xf9,\n    // lowercase u, grave accent\n    0xad: 0xdb,\n    // uppercase U, circumflex\n    0xae: 0xab,\n    // left-pointing double angle quotation mark\n    0xaf: 0xbb,\n    // right-pointing double angle quotation mark\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n    0xb0: 0xc3,\n    // Uppercase A, tilde\n    0xb1: 0xe3,\n    // Lowercase a, tilde\n    0xb2: 0xcd,\n    // Uppercase I, acute accent\n    0xb3: 0xcc,\n    // Uppercase I, grave accent\n    0xb4: 0xec,\n    // Lowercase i, grave accent\n    0xb5: 0xd2,\n    // Uppercase O, grave accent\n    0xb6: 0xf2,\n    // Lowercase o, grave accent\n    0xb7: 0xd5,\n    // Uppercase O, tilde\n    0xb8: 0xf5,\n    // Lowercase o, tilde\n    0xb9: 0x7b,\n    // Open curly brace\n    0xba: 0x7d,\n    // Closing curly brace\n    0xbb: 0x5c,\n    // Backslash\n    0xbc: 0x5e,\n    // Caret\n    0xbd: 0x5f,\n    // Underscore\n    0xbe: 0x7c,\n    // Pipe (vertical line)\n    0xbf: 0x223c,\n    // Tilde operator\n    0xc0: 0xc4,\n    // Uppercase A, umlaut\n    0xc1: 0xe4,\n    // Lowercase A, umlaut\n    0xc2: 0xd6,\n    // Uppercase O, umlaut\n    0xc3: 0xf6,\n    // Lowercase o, umlaut\n    0xc4: 0xdf,\n    // Esszett (sharp S)\n    0xc5: 0xa5,\n    // Yen symbol\n    0xc6: 0xa4,\n    // Generic currency sign\n    0xc7: 0x2503,\n    // Box drawings heavy vertical\n    0xc8: 0xc5,\n    // Uppercase A, ring\n    0xc9: 0xe5,\n    // Lowercase A, ring\n    0xca: 0xd8,\n    // Uppercase O, stroke\n    0xcb: 0xf8,\n    // Lowercase o, strok\n    0xcc: 0x250f,\n    // Box drawings heavy down and right\n    0xcd: 0x2513,\n    // Box drawings heavy down and left\n    0xce: 0x2517,\n    // Box drawings heavy up and right\n    0xcf: 0x251b // Box drawings heavy up and left\n  };\n\n  /**\n   * Utils\n   */\n  var getCharForByte = function getCharForByte(_byte) {\n    return String.fromCharCode(specialCea608CharsCodes[_byte] || _byte);\n  };\n  var NR_ROWS = 15;\n  var NR_COLS = 100;\n  // Tables to look up row from PAC data\n  var rowsLowCh1 = {\n    0x11: 1,\n    0x12: 3,\n    0x15: 5,\n    0x16: 7,\n    0x17: 9,\n    0x10: 11,\n    0x13: 12,\n    0x14: 14\n  };\n  var rowsHighCh1 = {\n    0x11: 2,\n    0x12: 4,\n    0x15: 6,\n    0x16: 8,\n    0x17: 10,\n    0x13: 13,\n    0x14: 15\n  };\n  var rowsLowCh2 = {\n    0x19: 1,\n    0x1a: 3,\n    0x1d: 5,\n    0x1e: 7,\n    0x1f: 9,\n    0x18: 11,\n    0x1b: 12,\n    0x1c: 14\n  };\n  var rowsHighCh2 = {\n    0x19: 2,\n    0x1a: 4,\n    0x1d: 6,\n    0x1e: 8,\n    0x1f: 10,\n    0x1b: 13,\n    0x1c: 15\n  };\n  var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\n  var CaptionsLogger = /*#__PURE__*/function () {\n    function CaptionsLogger() {\n      this.time = null;\n      this.verboseLevel = 0;\n    }\n    var _proto = CaptionsLogger.prototype;\n    _proto.log = function log(severity, msg) {\n      if (this.verboseLevel >= severity) {\n        var m = typeof msg === 'function' ? msg() : msg;\n        logger.log(this.time + \" [\" + severity + \"] \" + m);\n      }\n    };\n    return CaptionsLogger;\n  }();\n  var numArrayToHexArray = function numArrayToHexArray(numArray) {\n    var hexArray = [];\n    for (var j = 0; j < numArray.length; j++) {\n      hexArray.push(numArray[j].toString(16));\n    }\n    return hexArray;\n  };\n  var PenState = /*#__PURE__*/function () {\n    function PenState() {\n      this.foreground = 'white';\n      this.underline = false;\n      this.italics = false;\n      this.background = 'black';\n      this.flash = false;\n    }\n    var _proto2 = PenState.prototype;\n    _proto2.reset = function reset() {\n      this.foreground = 'white';\n      this.underline = false;\n      this.italics = false;\n      this.background = 'black';\n      this.flash = false;\n    };\n    _proto2.setStyles = function setStyles(styles) {\n      var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n      for (var i = 0; i < attribs.length; i++) {\n        var style = attribs[i];\n        if (styles.hasOwnProperty(style)) {\n          this[style] = styles[style];\n        }\n      }\n    };\n    _proto2.isDefault = function isDefault() {\n      return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n    };\n    _proto2.equals = function equals(other) {\n      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n    };\n    _proto2.copy = function copy(newPenState) {\n      this.foreground = newPenState.foreground;\n      this.underline = newPenState.underline;\n      this.italics = newPenState.italics;\n      this.background = newPenState.background;\n      this.flash = newPenState.flash;\n    };\n    _proto2.toString = function toString() {\n      return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n    };\n    return PenState;\n  }();\n  /**\n   * Unicode character with styling and background.\n   * @constructor\n   */\n  var StyledUnicodeChar = /*#__PURE__*/function () {\n    function StyledUnicodeChar() {\n      this.uchar = ' ';\n      this.penState = new PenState();\n    }\n    var _proto3 = StyledUnicodeChar.prototype;\n    _proto3.reset = function reset() {\n      this.uchar = ' ';\n      this.penState.reset();\n    };\n    _proto3.setChar = function setChar(uchar, newPenState) {\n      this.uchar = uchar;\n      this.penState.copy(newPenState);\n    };\n    _proto3.setPenState = function setPenState(newPenState) {\n      this.penState.copy(newPenState);\n    };\n    _proto3.equals = function equals(other) {\n      return this.uchar === other.uchar && this.penState.equals(other.penState);\n    };\n    _proto3.copy = function copy(newChar) {\n      this.uchar = newChar.uchar;\n      this.penState.copy(newChar.penState);\n    };\n    _proto3.isEmpty = function isEmpty() {\n      return this.uchar === ' ' && this.penState.isDefault();\n    };\n    return StyledUnicodeChar;\n  }();\n  /**\n   * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n   * @constructor\n   */\n  var Row = /*#__PURE__*/function () {\n    function Row(logger) {\n      this.chars = [];\n      this.pos = 0;\n      this.currPenState = new PenState();\n      this.cueStartTime = null;\n      this.logger = void 0;\n      for (var i = 0; i < NR_COLS; i++) {\n        this.chars.push(new StyledUnicodeChar());\n      }\n      this.logger = logger;\n    }\n    var _proto4 = Row.prototype;\n    _proto4.equals = function equals(other) {\n      for (var i = 0; i < NR_COLS; i++) {\n        if (!this.chars[i].equals(other.chars[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n    _proto4.copy = function copy(other) {\n      for (var i = 0; i < NR_COLS; i++) {\n        this.chars[i].copy(other.chars[i]);\n      }\n    };\n    _proto4.isEmpty = function isEmpty() {\n      var empty = true;\n      for (var i = 0; i < NR_COLS; i++) {\n        if (!this.chars[i].isEmpty()) {\n          empty = false;\n          break;\n        }\n      }\n      return empty;\n    }\n\n    /**\n     *  Set the cursor to a valid column.\n     */;\n    _proto4.setCursor = function setCursor(absPos) {\n      if (this.pos !== absPos) {\n        this.pos = absPos;\n      }\n      if (this.pos < 0) {\n        this.logger.log(3, 'Negative cursor position ' + this.pos);\n        this.pos = 0;\n      } else if (this.pos > NR_COLS) {\n        this.logger.log(3, 'Too large cursor position ' + this.pos);\n        this.pos = NR_COLS;\n      }\n    }\n\n    /**\n     * Move the cursor relative to current position.\n     */;\n    _proto4.moveCursor = function moveCursor(relPos) {\n      var newPos = this.pos + relPos;\n      if (relPos > 1) {\n        for (var i = this.pos + 1; i < newPos + 1; i++) {\n          this.chars[i].setPenState(this.currPenState);\n        }\n      }\n      this.setCursor(newPos);\n    }\n\n    /**\n     * Backspace, move one step back and clear character.\n     */;\n    _proto4.backSpace = function backSpace() {\n      this.moveCursor(-1);\n      this.chars[this.pos].setChar(' ', this.currPenState);\n    };\n    _proto4.insertChar = function insertChar(_byte2) {\n      var _this = this;\n      if (_byte2 >= 0x90) {\n        // Extended char\n        this.backSpace();\n      }\n      var _char = getCharForByte(_byte2);\n      if (this.pos >= NR_COLS) {\n        this.logger.log(0, function () {\n          return 'Cannot insert ' + _byte2.toString(16) + ' (' + _char + ') at position ' + _this.pos + '. Skipping it!';\n        });\n        return;\n      }\n      this.chars[this.pos].setChar(_char, this.currPenState);\n      this.moveCursor(1);\n    };\n    _proto4.clearFromPos = function clearFromPos(startPos) {\n      var i;\n      for (i = startPos; i < NR_COLS; i++) {\n        this.chars[i].reset();\n      }\n    };\n    _proto4.clear = function clear() {\n      this.clearFromPos(0);\n      this.pos = 0;\n      this.currPenState.reset();\n    };\n    _proto4.clearToEndOfRow = function clearToEndOfRow() {\n      this.clearFromPos(this.pos);\n    };\n    _proto4.getTextString = function getTextString() {\n      var chars = [];\n      var empty = true;\n      for (var i = 0; i < NR_COLS; i++) {\n        var _char2 = this.chars[i].uchar;\n        if (_char2 !== ' ') {\n          empty = false;\n        }\n        chars.push(_char2);\n      }\n      if (empty) {\n        return '';\n      } else {\n        return chars.join('');\n      }\n    };\n    _proto4.setPenStyles = function setPenStyles(styles) {\n      this.currPenState.setStyles(styles);\n      var currChar = this.chars[this.pos];\n      currChar.setPenState(this.currPenState);\n    };\n    return Row;\n  }();\n\n  /**\n   * Keep a CEA-608 screen of 32x15 styled characters\n   * @constructor\n   */\n  var CaptionScreen = /*#__PURE__*/function () {\n    function CaptionScreen(logger) {\n      this.rows = [];\n      this.currRow = NR_ROWS - 1;\n      this.nrRollUpRows = null;\n      this.lastOutputScreen = null;\n      this.logger = void 0;\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows.push(new Row(logger));\n      }\n      this.logger = logger;\n    }\n    var _proto5 = CaptionScreen.prototype;\n    _proto5.reset = function reset() {\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n      this.currRow = NR_ROWS - 1;\n    };\n    _proto5.equals = function equals(other) {\n      var equal = true;\n      for (var i = 0; i < NR_ROWS; i++) {\n        if (!this.rows[i].equals(other.rows[i])) {\n          equal = false;\n          break;\n        }\n      }\n      return equal;\n    };\n    _proto5.copy = function copy(other) {\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].copy(other.rows[i]);\n      }\n    };\n    _proto5.isEmpty = function isEmpty() {\n      var empty = true;\n      for (var i = 0; i < NR_ROWS; i++) {\n        if (!this.rows[i].isEmpty()) {\n          empty = false;\n          break;\n        }\n      }\n      return empty;\n    };\n    _proto5.backSpace = function backSpace() {\n      var row = this.rows[this.currRow];\n      row.backSpace();\n    };\n    _proto5.clearToEndOfRow = function clearToEndOfRow() {\n      var row = this.rows[this.currRow];\n      row.clearToEndOfRow();\n    }\n\n    /**\n     * Insert a character (without styling) in the current row.\n     */;\n    _proto5.insertChar = function insertChar(_char3) {\n      var row = this.rows[this.currRow];\n      row.insertChar(_char3);\n    };\n    _proto5.setPen = function setPen(styles) {\n      var row = this.rows[this.currRow];\n      row.setPenStyles(styles);\n    };\n    _proto5.moveCursor = function moveCursor(relPos) {\n      var row = this.rows[this.currRow];\n      row.moveCursor(relPos);\n    };\n    _proto5.setCursor = function setCursor(absPos) {\n      this.logger.log(2, 'setCursor: ' + absPos);\n      var row = this.rows[this.currRow];\n      row.setCursor(absPos);\n    };\n    _proto5.setPAC = function setPAC(pacData) {\n      this.logger.log(2, function () {\n        return 'pacData = ' + stringify(pacData);\n      });\n      var newRow = pacData.row - 1;\n      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n        newRow = this.nrRollUpRows - 1;\n      }\n\n      // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n      if (this.nrRollUpRows && this.currRow !== newRow) {\n        // clear all rows first\n        for (var i = 0; i < NR_ROWS; i++) {\n          this.rows[i].clear();\n        }\n\n        // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n        // topRowIndex - the start of rows to copy (inclusive index)\n        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n        // We only copy if the last position was already shown.\n        // We use the cueStartTime value to check this.\n        var lastOutputScreen = this.lastOutputScreen;\n        if (lastOutputScreen) {\n          var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n          var time = this.logger.time;\n          if (prevLineTime !== null && time !== null && prevLineTime < time) {\n            for (var _i = 0; _i < this.nrRollUpRows; _i++) {\n              this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);\n            }\n          }\n        }\n      }\n      this.currRow = newRow;\n      var row = this.rows[this.currRow];\n      if (pacData.indent !== null) {\n        var indent = pacData.indent;\n        var prevPos = Math.max(indent - 1, 0);\n        row.setCursor(pacData.indent);\n        pacData.color = row.chars[prevPos].penState.foreground;\n      }\n      var styles = {\n        foreground: pacData.color,\n        underline: pacData.underline,\n        italics: pacData.italics,\n        background: 'black',\n        flash: false\n      };\n      this.setPen(styles);\n    }\n\n    /**\n     * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n     */;\n    _proto5.setBkgData = function setBkgData(bkgData) {\n      this.logger.log(2, function () {\n        return 'bkgData = ' + stringify(bkgData);\n      });\n      this.backSpace();\n      this.setPen(bkgData);\n      this.insertChar(0x20); // Space\n    };\n    _proto5.setRollUpRows = function setRollUpRows(nrRows) {\n      this.nrRollUpRows = nrRows;\n    };\n    _proto5.rollUp = function rollUp() {\n      var _this2 = this;\n      if (this.nrRollUpRows === null) {\n        this.logger.log(3, 'roll_up but nrRollUpRows not set yet');\n        return; // Not properly setup\n      }\n      this.logger.log(1, function () {\n        return _this2.getDisplayText();\n      });\n      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      var topRow = this.rows.splice(topRowIndex, 1)[0];\n      topRow.clear();\n      this.rows.splice(this.currRow, 0, topRow);\n      this.logger.log(2, 'Rolling up');\n      // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n    }\n\n    /**\n     * Get all non-empty rows with as unicode text.\n     */;\n    _proto5.getDisplayText = function getDisplayText(asOneRow) {\n      asOneRow = asOneRow || false;\n      var displayText = [];\n      var text = '';\n      var rowNr = -1;\n      for (var i = 0; i < NR_ROWS; i++) {\n        var rowText = this.rows[i].getTextString();\n        if (rowText) {\n          rowNr = i + 1;\n          if (asOneRow) {\n            displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n          } else {\n            displayText.push(rowText.trim());\n          }\n        }\n      }\n      if (displayText.length > 0) {\n        if (asOneRow) {\n          text = '[' + displayText.join(' | ') + ']';\n        } else {\n          text = displayText.join('\\n');\n        }\n      }\n      return text;\n    };\n    _proto5.getTextAndFormat = function getTextAndFormat() {\n      return this.rows;\n    };\n    return CaptionScreen;\n  }();\n\n  // var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n  var Cea608Channel = /*#__PURE__*/function () {\n    function Cea608Channel(channelNumber, outputFilter, logger) {\n      this.chNr = void 0;\n      this.outputFilter = void 0;\n      this.mode = void 0;\n      this.verbose = void 0;\n      this.displayedMemory = void 0;\n      this.nonDisplayedMemory = void 0;\n      this.lastOutputScreen = void 0;\n      this.currRollUpRow = void 0;\n      this.writeScreen = void 0;\n      this.cueStartTime = void 0;\n      this.logger = void 0;\n      this.chNr = channelNumber;\n      this.outputFilter = outputFilter;\n      this.mode = null;\n      this.verbose = 0;\n      this.displayedMemory = new CaptionScreen(logger);\n      this.nonDisplayedMemory = new CaptionScreen(logger);\n      this.lastOutputScreen = new CaptionScreen(logger);\n      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n      this.writeScreen = this.displayedMemory;\n      this.mode = null;\n      this.cueStartTime = null; // Keeps track of where a cue started.\n      this.logger = logger;\n    }\n    var _proto6 = Cea608Channel.prototype;\n    _proto6.reset = function reset() {\n      this.mode = null;\n      this.displayedMemory.reset();\n      this.nonDisplayedMemory.reset();\n      this.lastOutputScreen.reset();\n      this.outputFilter.reset();\n      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n      this.writeScreen = this.displayedMemory;\n      this.mode = null;\n      this.cueStartTime = null;\n    };\n    _proto6.getHandler = function getHandler() {\n      return this.outputFilter;\n    };\n    _proto6.setHandler = function setHandler(newHandler) {\n      this.outputFilter = newHandler;\n    };\n    _proto6.setPAC = function setPAC(pacData) {\n      this.writeScreen.setPAC(pacData);\n    };\n    _proto6.setBkgData = function setBkgData(bkgData) {\n      this.writeScreen.setBkgData(bkgData);\n    };\n    _proto6.setMode = function setMode(newMode) {\n      if (newMode === this.mode) {\n        return;\n      }\n      this.mode = newMode;\n      this.logger.log(2, function () {\n        return 'MODE=' + newMode;\n      });\n      if (this.mode === 'MODE_POP-ON') {\n        this.writeScreen = this.nonDisplayedMemory;\n      } else {\n        this.writeScreen = this.displayedMemory;\n        this.writeScreen.reset();\n      }\n      if (this.mode !== 'MODE_ROLL-UP') {\n        this.displayedMemory.nrRollUpRows = null;\n        this.nonDisplayedMemory.nrRollUpRows = null;\n      }\n      this.mode = newMode;\n    };\n    _proto6.insertChars = function insertChars(chars) {\n      var _this3 = this;\n      for (var i = 0; i < chars.length; i++) {\n        this.writeScreen.insertChar(chars[i]);\n      }\n      var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n      this.logger.log(2, function () {\n        return screen + ': ' + _this3.writeScreen.getDisplayText(true);\n      });\n      if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n        this.logger.log(1, function () {\n          return 'DISPLAYED: ' + _this3.displayedMemory.getDisplayText(true);\n        });\n        this.outputDataUpdate();\n      }\n    };\n    _proto6.ccRCL = function ccRCL() {\n      // Resume Caption Loading (switch mode to Pop On)\n      this.logger.log(2, 'RCL - Resume Caption Loading');\n      this.setMode('MODE_POP-ON');\n    };\n    _proto6.ccBS = function ccBS() {\n      // BackSpace\n      this.logger.log(2, 'BS - BackSpace');\n      if (this.mode === 'MODE_TEXT') {\n        return;\n      }\n      this.writeScreen.backSpace();\n      if (this.writeScreen === this.displayedMemory) {\n        this.outputDataUpdate();\n      }\n    };\n    _proto6.ccAOF = function ccAOF() {\n      // Reserved (formerly Alarm Off)\n    };\n    _proto6.ccAON = function ccAON() {\n      // Reserved (formerly Alarm On)\n    };\n    _proto6.ccDER = function ccDER() {\n      // Delete to End of Row\n      this.logger.log(2, 'DER- Delete to End of Row');\n      this.writeScreen.clearToEndOfRow();\n      this.outputDataUpdate();\n    };\n    _proto6.ccRU = function ccRU(nrRows) {\n      // Roll-Up Captions-2,3,or 4 Rows\n      this.logger.log(2, 'RU(' + nrRows + ') - Roll Up');\n      this.writeScreen = this.displayedMemory;\n      this.setMode('MODE_ROLL-UP');\n      this.writeScreen.setRollUpRows(nrRows);\n    };\n    _proto6.ccFON = function ccFON() {\n      // Flash On\n      this.logger.log(2, 'FON - Flash On');\n      this.writeScreen.setPen({\n        flash: true\n      });\n    };\n    _proto6.ccRDC = function ccRDC() {\n      // Resume Direct Captioning (switch mode to PaintOn)\n      this.logger.log(2, 'RDC - Resume Direct Captioning');\n      this.setMode('MODE_PAINT-ON');\n    };\n    _proto6.ccTR = function ccTR() {\n      // Text Restart in text mode (not supported, however)\n      this.logger.log(2, 'TR');\n      this.setMode('MODE_TEXT');\n    };\n    _proto6.ccRTD = function ccRTD() {\n      // Resume Text Display in Text mode (not supported, however)\n      this.logger.log(2, 'RTD');\n      this.setMode('MODE_TEXT');\n    };\n    _proto6.ccEDM = function ccEDM() {\n      // Erase Displayed Memory\n      this.logger.log(2, 'EDM - Erase Displayed Memory');\n      this.displayedMemory.reset();\n      this.outputDataUpdate(true);\n    };\n    _proto6.ccCR = function ccCR() {\n      // Carriage Return\n      this.logger.log(2, 'CR - Carriage Return');\n      this.writeScreen.rollUp();\n      this.outputDataUpdate(true);\n    };\n    _proto6.ccENM = function ccENM() {\n      // Erase Non-Displayed Memory\n      this.logger.log(2, 'ENM - Erase Non-displayed Memory');\n      this.nonDisplayedMemory.reset();\n    };\n    _proto6.ccEOC = function ccEOC() {\n      var _this4 = this;\n      // End of Caption (Flip Memories)\n      this.logger.log(2, 'EOC - End Of Caption');\n      if (this.mode === 'MODE_POP-ON') {\n        var tmp = this.displayedMemory;\n        this.displayedMemory = this.nonDisplayedMemory;\n        this.nonDisplayedMemory = tmp;\n        this.writeScreen = this.nonDisplayedMemory;\n        this.logger.log(1, function () {\n          return 'DISP: ' + _this4.displayedMemory.getDisplayText();\n        });\n      }\n      this.outputDataUpdate(true);\n    };\n    _proto6.ccTO = function ccTO(nrCols) {\n      // Tab Offset 1,2, or 3 columns\n      this.logger.log(2, 'TO(' + nrCols + ') - Tab Offset');\n      this.writeScreen.moveCursor(nrCols);\n    };\n    _proto6.ccMIDROW = function ccMIDROW(secondByte) {\n      // Parse MIDROW command\n      var styles = {\n        flash: false\n      };\n      styles.underline = secondByte % 2 === 1;\n      styles.italics = secondByte >= 0x2e;\n      if (!styles.italics) {\n        var colorIndex = Math.floor(secondByte / 2) - 0x10;\n        var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n        styles.foreground = colors[colorIndex];\n      } else {\n        styles.foreground = 'white';\n      }\n      this.logger.log(2, 'MIDROW: ' + stringify(styles));\n      this.writeScreen.setPen(styles);\n    };\n    _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {\n      if (dispatch === void 0) {\n        dispatch = false;\n      }\n      var time = this.logger.time;\n      if (time === null) {\n        return;\n      }\n      if (this.outputFilter) {\n        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n          // Start of a new cue\n          this.cueStartTime = time;\n        } else {\n          if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n            this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n            if (dispatch && this.outputFilter.dispatchCue) {\n              this.outputFilter.dispatchCue();\n            }\n            this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n          }\n        }\n        this.lastOutputScreen.copy(this.displayedMemory);\n      }\n    };\n    _proto6.cueSplitAtTime = function cueSplitAtTime(t) {\n      if (this.outputFilter) {\n        if (!this.displayedMemory.isEmpty()) {\n          if (this.outputFilter.newCue) {\n            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n          }\n          this.cueStartTime = t;\n        }\n      }\n    };\n    return Cea608Channel;\n  }(); // Will be 1 or 2 when parsing captions\n  var Cea608Parser = /*#__PURE__*/function () {\n    function Cea608Parser(field, out1, out2) {\n      this.channels = void 0;\n      this.currentChannel = 0;\n      this.cmdHistory = createCmdHistory();\n      this.logger = void 0;\n      var logger = this.logger = new CaptionsLogger();\n      this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n    }\n    var _proto7 = Cea608Parser.prototype;\n    _proto7.getHandler = function getHandler(channel) {\n      return this.channels[channel].getHandler();\n    };\n    _proto7.setHandler = function setHandler(channel, newHandler) {\n      this.channels[channel].setHandler(newHandler);\n    }\n\n    /**\n     * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n     */;\n    _proto7.addData = function addData(time, byteList) {\n      var _this5 = this;\n      this.logger.time = time;\n      var _loop = function _loop(i) {\n          var a = byteList[i] & 0x7f;\n          var b = byteList[i + 1] & 0x7f;\n          var cmdFound = false;\n          var charsFound = null;\n          if (a === 0 && b === 0) {\n            return 0; // continue\n          } else {\n            _this5.logger.log(3, function () {\n              return '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')';\n            });\n          }\n          var cmdHistory = _this5.cmdHistory;\n          var isControlCode = a >= 0x10 && a <= 0x1f;\n          if (isControlCode) {\n            // Skip redundant control codes\n            if (hasCmdRepeated(a, b, cmdHistory)) {\n              setLastCmd(null, null, cmdHistory);\n              _this5.logger.log(3, function () {\n                return 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped';\n              });\n              return 0; // continue\n            }\n            setLastCmd(a, b, _this5.cmdHistory);\n            cmdFound = _this5.parseCmd(a, b);\n            if (!cmdFound) {\n              cmdFound = _this5.parseMidrow(a, b);\n            }\n            if (!cmdFound) {\n              cmdFound = _this5.parsePAC(a, b);\n            }\n            if (!cmdFound) {\n              cmdFound = _this5.parseBackgroundAttributes(a, b);\n            }\n          } else {\n            setLastCmd(null, null, cmdHistory);\n          }\n          if (!cmdFound) {\n            charsFound = _this5.parseChars(a, b);\n            if (charsFound) {\n              var currChNr = _this5.currentChannel;\n              if (currChNr && currChNr > 0) {\n                var channel = _this5.channels[currChNr];\n                channel.insertChars(charsFound);\n              } else {\n                _this5.logger.log(2, 'No channel found yet. TEXT-MODE?');\n              }\n            }\n          }\n          if (!cmdFound && !charsFound) {\n            _this5.logger.log(2, function () {\n              return \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]);\n            });\n          }\n        },\n        _ret;\n      for (var i = 0; i < byteList.length; i += 2) {\n        _ret = _loop(i);\n        if (_ret === 0) continue;\n      }\n    }\n\n    /**\n     * Parse Command.\n     * @returns True if a command was found\n     */;\n    _proto7.parseCmd = function parseCmd(a, b) {\n      var cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n      var cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n      if (!(cond1 || cond2)) {\n        return false;\n      }\n      var chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n      var channel = this.channels[chNr];\n      if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n        if (b === 0x20) {\n          channel.ccRCL();\n        } else if (b === 0x21) {\n          channel.ccBS();\n        } else if (b === 0x22) {\n          channel.ccAOF();\n        } else if (b === 0x23) {\n          channel.ccAON();\n        } else if (b === 0x24) {\n          channel.ccDER();\n        } else if (b === 0x25) {\n          channel.ccRU(2);\n        } else if (b === 0x26) {\n          channel.ccRU(3);\n        } else if (b === 0x27) {\n          channel.ccRU(4);\n        } else if (b === 0x28) {\n          channel.ccFON();\n        } else if (b === 0x29) {\n          channel.ccRDC();\n        } else if (b === 0x2a) {\n          channel.ccTR();\n        } else if (b === 0x2b) {\n          channel.ccRTD();\n        } else if (b === 0x2c) {\n          channel.ccEDM();\n        } else if (b === 0x2d) {\n          channel.ccCR();\n        } else if (b === 0x2e) {\n          channel.ccENM();\n        } else if (b === 0x2f) {\n          channel.ccEOC();\n        }\n      } else {\n        // a == 0x17 || a == 0x1F\n        channel.ccTO(b - 0x20);\n      }\n      this.currentChannel = chNr;\n      return true;\n    }\n\n    /**\n     * Parse midrow styling command\n     */;\n    _proto7.parseMidrow = function parseMidrow(a, b) {\n      var chNr = 0;\n      if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n        if (a === 0x11) {\n          chNr = 1;\n        } else {\n          chNr = 2;\n        }\n        if (chNr !== this.currentChannel) {\n          this.logger.log(0, 'Mismatch channel in midrow parsing');\n          return false;\n        }\n        var channel = this.channels[chNr];\n        if (!channel) {\n          return false;\n        }\n        channel.ccMIDROW(b);\n        this.logger.log(3, function () {\n          return 'MIDROW (' + numArrayToHexArray([a, b]) + ')';\n        });\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Parse Preable Access Codes (Table 53).\n     * @returns {Boolean} Tells if PAC found\n     */;\n    _proto7.parsePAC = function parsePAC(a, b) {\n      var row;\n      var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n      var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n      if (!(case1 || case2)) {\n        return false;\n      }\n      var chNr = a <= 0x17 ? 1 : 2;\n      if (b >= 0x40 && b <= 0x5f) {\n        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n      } else {\n        // 0x60 <= b <= 0x7F\n        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n      }\n      var channel = this.channels[chNr];\n      if (!channel) {\n        return false;\n      }\n      channel.setPAC(this.interpretPAC(row, b));\n      this.currentChannel = chNr;\n      return true;\n    }\n\n    /**\n     * Interpret the second byte of the pac, and return the information.\n     * @returns pacData with style parameters\n     */;\n    _proto7.interpretPAC = function interpretPAC(row, _byte3) {\n      var pacIndex;\n      var pacData = {\n        color: null,\n        italics: false,\n        indent: null,\n        underline: false,\n        row: row\n      };\n      if (_byte3 > 0x5f) {\n        pacIndex = _byte3 - 0x60;\n      } else {\n        pacIndex = _byte3 - 0x40;\n      }\n      pacData.underline = (pacIndex & 1) === 1;\n      if (pacIndex <= 0xd) {\n        pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n      } else if (pacIndex <= 0xf) {\n        pacData.italics = true;\n        pacData.color = 'white';\n      } else {\n        pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n      }\n      return pacData; // Note that row has zero offset. The spec uses 1.\n    }\n\n    /**\n     * Parse characters.\n     * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n     */;\n    _proto7.parseChars = function parseChars(a, b) {\n      var channelNr;\n      var charCodes = null;\n      var charCode1 = null;\n      if (a >= 0x19) {\n        channelNr = 2;\n        charCode1 = a - 8;\n      } else {\n        channelNr = 1;\n        charCode1 = a;\n      }\n      if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n        // Special character\n        var oneCode;\n        if (charCode1 === 0x11) {\n          oneCode = b + 0x50;\n        } else if (charCode1 === 0x12) {\n          oneCode = b + 0x70;\n        } else {\n          oneCode = b + 0x90;\n        }\n        this.logger.log(2, function () {\n          return \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr;\n        });\n        charCodes = [oneCode];\n      } else if (a >= 0x20 && a <= 0x7f) {\n        charCodes = b === 0 ? [a] : [a, b];\n      }\n      if (charCodes) {\n        this.logger.log(3, function () {\n          return 'Char codes =  ' + numArrayToHexArray(charCodes).join(',');\n        });\n      }\n      return charCodes;\n    }\n\n    /**\n     * Parse extended background attributes as well as new foreground color black.\n     * @returns True if background attributes are found\n     */;\n    _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {\n      var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n      var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n      if (!(case1 || case2)) {\n        return false;\n      }\n      var index;\n      var bkgData = {};\n      if (a === 0x10 || a === 0x18) {\n        index = Math.floor((b - 0x20) / 2);\n        bkgData.background = backgroundColors[index];\n        if (b % 2 === 1) {\n          bkgData.background = bkgData.background + '_semi';\n        }\n      } else if (b === 0x2d) {\n        bkgData.background = 'transparent';\n      } else {\n        bkgData.foreground = 'black';\n        if (b === 0x2f) {\n          bkgData.underline = true;\n        }\n      }\n      var chNr = a <= 0x17 ? 1 : 2;\n      var channel = this.channels[chNr];\n      channel.setBkgData(bkgData);\n      return true;\n    }\n\n    /**\n     * Reset state of parser and its channels.\n     */;\n    _proto7.reset = function reset() {\n      for (var i = 0; i < Object.keys(this.channels).length; i++) {\n        var channel = this.channels[i];\n        if (channel) {\n          channel.reset();\n        }\n      }\n      setLastCmd(null, null, this.cmdHistory);\n    }\n\n    /**\n     * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n     */;\n    _proto7.cueSplitAtTime = function cueSplitAtTime(t) {\n      for (var i = 0; i < this.channels.length; i++) {\n        var channel = this.channels[i];\n        if (channel) {\n          channel.cueSplitAtTime(t);\n        }\n      }\n    };\n    return Cea608Parser;\n  }();\n  function setLastCmd(a, b, cmdHistory) {\n    cmdHistory.a = a;\n    cmdHistory.b = b;\n  }\n  function hasCmdRepeated(a, b, cmdHistory) {\n    return cmdHistory.a === a && cmdHistory.b === b;\n  }\n  function createCmdHistory() {\n    return {\n      a: null,\n      b: null\n    };\n  }\n\n  /**\n   * Copyright 2013 vtt.js Contributors\n   *\n   * Licensed under the Apache License, Version 2.0 (the 'License');\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an 'AS IS' BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var VTTCue = (function () {\n    if (optionalSelf != null && optionalSelf.VTTCue) {\n      return self.VTTCue;\n    }\n    var AllowedDirections = ['', 'lr', 'rl'];\n    var AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n    function isAllowedValue(allowed, value) {\n      if (typeof value !== 'string') {\n        return false;\n      }\n      // necessary for assuring the generic conforms to the Array interface\n      if (!Array.isArray(allowed)) {\n        return false;\n      }\n      // reset the type so that the next narrowing works well\n      var lcValue = value.toLowerCase();\n      // use the allow list to narrow the type to a specific subset of strings\n      if (~allowed.indexOf(lcValue)) {\n        return lcValue;\n      }\n      return false;\n    }\n    function findDirectionSetting(value) {\n      return isAllowedValue(AllowedDirections, value);\n    }\n    function findAlignSetting(value) {\n      return isAllowedValue(AllowedAlignments, value);\n    }\n    function extend(obj) {\n      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        rest[_key - 1] = arguments[_key];\n      }\n      var i = 1;\n      for (; i < arguments.length; i++) {\n        var cobj = arguments[i];\n        for (var p in cobj) {\n          obj[p] = cobj[p];\n        }\n      }\n      return obj;\n    }\n    function VTTCue(startTime, endTime, text) {\n      var cue = this;\n      var baseObj = {\n        enumerable: true\n      };\n      /**\n       * Shim implementation specific properties. These properties are not in\n       * the spec.\n       */\n\n      // Lets us know when the VTTCue's data has changed in such a way that we need\n      // to recompute its display state. This lets us compute its display state\n      // lazily.\n      cue.hasBeenReset = false;\n\n      /**\n       * VTTCue and TextTrackCue properties\n       * http://dev.w3.org/html5/webvtt/#vttcue-interface\n       */\n\n      var _id = '';\n      var _pauseOnExit = false;\n      var _startTime = startTime;\n      var _endTime = endTime;\n      var _text = text;\n      var _region = null;\n      var _vertical = '';\n      var _snapToLines = true;\n      var _line = 'auto';\n      var _lineAlign = 'start';\n      var _position = 50;\n      var _positionAlign = 'middle';\n      var _size = 50;\n      var _align = 'middle';\n      Object.defineProperty(cue, 'id', extend({}, baseObj, {\n        get: function get() {\n          return _id;\n        },\n        set: function set(value) {\n          _id = '' + value;\n        }\n      }));\n      Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n        get: function get() {\n          return _pauseOnExit;\n        },\n        set: function set(value) {\n          _pauseOnExit = !!value;\n        }\n      }));\n      Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n        get: function get() {\n          return _startTime;\n        },\n        set: function set(value) {\n          if (typeof value !== 'number') {\n            throw new TypeError('Start time must be set to a number.');\n          }\n          _startTime = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n        get: function get() {\n          return _endTime;\n        },\n        set: function set(value) {\n          if (typeof value !== 'number') {\n            throw new TypeError('End time must be set to a number.');\n          }\n          _endTime = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'text', extend({}, baseObj, {\n        get: function get() {\n          return _text;\n        },\n        set: function set(value) {\n          _text = '' + value;\n          this.hasBeenReset = true;\n        }\n      }));\n\n      // todo: implement VTTRegion polyfill?\n      Object.defineProperty(cue, 'region', extend({}, baseObj, {\n        get: function get() {\n          return _region;\n        },\n        set: function set(value) {\n          _region = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n        get: function get() {\n          return _vertical;\n        },\n        set: function set(value) {\n          var setting = findDirectionSetting(value);\n          // Have to check for false because the setting an be an empty string.\n          if (setting === false) {\n            throw new SyntaxError('An invalid or illegal string was specified.');\n          }\n          _vertical = setting;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n        get: function get() {\n          return _snapToLines;\n        },\n        set: function set(value) {\n          _snapToLines = !!value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'line', extend({}, baseObj, {\n        get: function get() {\n          return _line;\n        },\n        set: function set(value) {\n          if (typeof value !== 'number' && value !== 'auto') {\n            throw new SyntaxError('An invalid number or illegal string was specified.');\n          }\n          _line = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n        get: function get() {\n          return _lineAlign;\n        },\n        set: function set(value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            throw new SyntaxError('An invalid or illegal string was specified.');\n          }\n          _lineAlign = setting;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'position', extend({}, baseObj, {\n        get: function get() {\n          return _position;\n        },\n        set: function set(value) {\n          if (value < 0 || value > 100) {\n            throw new Error('Position must be between 0 and 100.');\n          }\n          _position = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n        get: function get() {\n          return _positionAlign;\n        },\n        set: function set(value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            throw new SyntaxError('An invalid or illegal string was specified.');\n          }\n          _positionAlign = setting;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'size', extend({}, baseObj, {\n        get: function get() {\n          return _size;\n        },\n        set: function set(value) {\n          if (value < 0 || value > 100) {\n            throw new Error('Size must be between 0 and 100.');\n          }\n          _size = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'align', extend({}, baseObj, {\n        get: function get() {\n          return _align;\n        },\n        set: function set(value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            throw new SyntaxError('An invalid or illegal string was specified.');\n          }\n          _align = setting;\n          this.hasBeenReset = true;\n        }\n      }));\n\n      /**\n       * Other <track> spec defined properties\n       */\n\n      // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n      cue.displayState = undefined;\n    }\n\n    /**\n     * VTTCue methods\n     */\n\n    VTTCue.prototype.getCueAsHTML = function () {\n      // Assume WebVTT.convertCueToDOMTree is on the global.\n      var WebVTT = self.WebVTT;\n      return WebVTT.convertCueToDOMTree(self, this.text);\n    };\n    // this is a polyfill hack\n    return VTTCue;\n  })();\n\n  /*\n   * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n   */\n\n  var StringDecoder = /*#__PURE__*/function () {\n    function StringDecoder() {}\n    var _proto = StringDecoder.prototype;\n    _proto.decode = function decode(data, options) {\n      if (!data) {\n        return '';\n      }\n      if (typeof data !== 'string') {\n        throw new Error('Error - expected string data.');\n      }\n      return decodeURIComponent(encodeURIComponent(data));\n    };\n    return StringDecoder;\n  }(); // Try to parse input as a time stamp.\n  function parseTimeStamp(input) {\n    function computeSeconds(h, m, s, f) {\n      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n    }\n    var m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n    if (!m) {\n      return null;\n    }\n    if (parseFloat(m[2]) > 59) {\n      // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n      // First position is hours as it's over 59.\n      return computeSeconds(m[2], m[3], 0, m[4]);\n    }\n    // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3], m[4]);\n  }\n\n  // A settings object holds key/value pairs and will ignore anything but the first\n  // assignment to a specific key.\n  var Settings = /*#__PURE__*/function () {\n    function Settings() {\n      this.values = Object.create(null);\n    }\n    var _proto2 = Settings.prototype;\n    // Only accept the first assignment to any key.\n    _proto2.set = function set(k, v) {\n      if (!this.get(k) && v !== '') {\n        this.values[k] = v;\n      }\n    }\n    // Return the value for a key, or a default value.\n    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n    // a number of possible default values as properties where 'defaultKey' is\n    // the key of the property that will be chosen; otherwise it's assumed to be\n    // a single value.\n    ;\n    _proto2.get = function get(k, dflt, defaultKey) {\n      if (defaultKey) {\n        return this.has(k) ? this.values[k] : dflt[defaultKey];\n      }\n      return this.has(k) ? this.values[k] : dflt;\n    }\n    // Check whether we have a value for a key.\n    ;\n    _proto2.has = function has(k) {\n      return k in this.values;\n    }\n    // Accept a setting if its one of the given alternatives.\n    ;\n    _proto2.alt = function alt(k, v, a) {\n      for (var n = 0; n < a.length; ++n) {\n        if (v === a[n]) {\n          this.set(k, v);\n          break;\n        }\n      }\n    }\n    // Accept a setting if its a valid (signed) integer.\n    ;\n    _proto2.integer = function integer(k, v) {\n      if (/^-?\\d+$/.test(v)) {\n        // integer\n        this.set(k, parseInt(v, 10));\n      }\n    }\n    // Accept a setting if its a valid percentage.\n    ;\n    _proto2.percent = function percent(k, v) {\n      if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n        var _percent = parseFloat(v);\n        if (_percent >= 0 && _percent <= 100) {\n          this.set(k, _percent);\n          return true;\n        }\n      }\n      return false;\n    };\n    return Settings;\n  }(); // Helper function to parse input into groups separated by 'groupDelim', and\n  // interpret each group as a key/value pair separated by 'keyValueDelim'.\n  function parseOptions(input, callback, keyValueDelim, groupDelim) {\n    var groups = groupDelim ? input.split(groupDelim) : [input];\n    for (var i in groups) {\n      if (typeof groups[i] !== 'string') {\n        continue;\n      }\n      var kv = groups[i].split(keyValueDelim);\n      if (kv.length !== 2) {\n        continue;\n      }\n      var k = kv[0];\n      var v = kv[1];\n      callback(k, v);\n    }\n  }\n  var defaults = new VTTCue(0, 0, '');\n  // 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n  //  Safari doesn't yet support this change, but FF and Chrome do.\n  var center = defaults.align === 'middle' ? 'middle' : 'center';\n  function parseCue(input, cue, regionList) {\n    // Remember the original input if we need to throw an error.\n    var oInput = input;\n    // 4.1 WebVTT timestamp\n    function consumeTimeStamp() {\n      var ts = parseTimeStamp(input);\n      if (ts === null) {\n        throw new Error('Malformed timestamp: ' + oInput);\n      }\n\n      // Remove time stamp from input.\n      input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n      return ts;\n    }\n\n    // 4.4.2 WebVTT cue settings\n    function consumeCueSettings(input, cue) {\n      var settings = new Settings();\n      parseOptions(input, function (k, v) {\n        var vals;\n        switch (k) {\n          case 'region':\n            // Find the last region we parsed with the same region id.\n            for (var i = regionList.length - 1; i >= 0; i--) {\n              if (regionList[i].id === v) {\n                settings.set(k, regionList[i].region);\n                break;\n              }\n            }\n            break;\n          case 'vertical':\n            settings.alt(k, v, ['rl', 'lr']);\n            break;\n          case 'line':\n            vals = v.split(',');\n            settings.integer(k, vals[0]);\n            if (settings.percent(k, vals[0])) {\n              settings.set('snapToLines', false);\n            }\n            settings.alt(k, vals[0], ['auto']);\n            if (vals.length === 2) {\n              settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n            }\n            break;\n          case 'position':\n            vals = v.split(',');\n            settings.percent(k, vals[0]);\n            if (vals.length === 2) {\n              settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n            }\n            break;\n          case 'size':\n            settings.percent(k, v);\n            break;\n          case 'align':\n            settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n            break;\n        }\n      }, /:/, /\\s/);\n\n      // Apply default values for any missing fields.\n      cue.region = settings.get('region', null);\n      cue.vertical = settings.get('vertical', '');\n      var line = settings.get('line', 'auto');\n      if (line === 'auto' && defaults.line === -1) {\n        // set numeric line number for Safari\n        line = -1;\n      }\n      cue.line = line;\n      cue.lineAlign = settings.get('lineAlign', 'start');\n      cue.snapToLines = settings.get('snapToLines', true);\n      cue.size = settings.get('size', 100);\n      cue.align = settings.get('align', center);\n      var position = settings.get('position', 'auto');\n      if (position === 'auto' && defaults.position === 50) {\n        // set numeric position for Safari\n        position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n      }\n      cue.position = position;\n    }\n    function skipWhitespace() {\n      input = input.replace(/^\\s+/, '');\n    }\n\n    // 4.1 WebVTT cue timings.\n    skipWhitespace();\n    cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n    skipWhitespace();\n    if (input.slice(0, 3) !== '-->') {\n      // (3) next characters must match '-->'\n      throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n    }\n    input = input.slice(3);\n    skipWhitespace();\n    cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n    // 4.1 WebVTT cue settings list.\n    skipWhitespace();\n    consumeCueSettings(input, cue);\n  }\n  function fixLineBreaks(input) {\n    return input.replace(/<br(?: \\/)?>/gi, '\\n');\n  }\n  var VTTParser = /*#__PURE__*/function () {\n    function VTTParser() {\n      this.state = 'INITIAL';\n      this.buffer = '';\n      this.decoder = new StringDecoder();\n      this.regionList = [];\n      this.cue = null;\n      this.oncue = void 0;\n      this.onparsingerror = void 0;\n      this.onflush = void 0;\n    }\n    var _proto3 = VTTParser.prototype;\n    _proto3.parse = function parse(data) {\n      var _this = this;\n\n      // If there is no data then we won't decode it, but will just try to parse\n      // whatever is in buffer already. This may occur in circumstances, for\n      // example when flush() is called.\n      if (data) {\n        // Try to decode the data that we received.\n        _this.buffer += _this.decoder.decode(data, {\n          stream: true\n        });\n      }\n      function collectNextLine() {\n        var buffer = _this.buffer;\n        var pos = 0;\n        buffer = fixLineBreaks(buffer);\n        while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n          ++pos;\n        }\n        var line = buffer.slice(0, pos);\n        // Advance the buffer early in case we fail below.\n        if (buffer[pos] === '\\r') {\n          ++pos;\n        }\n        if (buffer[pos] === '\\n') {\n          ++pos;\n        }\n        _this.buffer = buffer.slice(pos);\n        return line;\n      }\n\n      // 3.2 WebVTT metadata header syntax\n      function parseHeader(input) {\n        parseOptions(input, function (k, v) {\n          // switch (k) {\n          // case 'region':\n          // 3.3 WebVTT region metadata header syntax\n          // console.log('parse region', v);\n          // parseRegion(v);\n          // break;\n          // }\n        }, /:/);\n      }\n\n      // 5.1 WebVTT file parsing.\n      try {\n        var line = '';\n        if (_this.state === 'INITIAL') {\n          // We can't start parsing until we have the first line.\n          if (!/\\r\\n|\\n/.test(_this.buffer)) {\n            return this;\n          }\n          line = collectNextLine();\n          // strip of UTF-8 BOM if any\n          // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n          var m = line.match(/^()?WEBVTT([ \\t].*)?$/);\n          if (!(m != null && m[0])) {\n            throw new Error('Malformed WebVTT signature.');\n          }\n          _this.state = 'HEADER';\n        }\n        var alreadyCollectedLine = false;\n        while (_this.buffer) {\n          // We can't parse a line until we have the full line.\n          if (!/\\r\\n|\\n/.test(_this.buffer)) {\n            return this;\n          }\n          if (!alreadyCollectedLine) {\n            line = collectNextLine();\n          } else {\n            alreadyCollectedLine = false;\n          }\n          switch (_this.state) {\n            case 'HEADER':\n              // 13-18 - Allow a header (metadata) under the WEBVTT line.\n              if (/:/.test(line)) {\n                parseHeader(line);\n              } else if (!line) {\n                // An empty line terminates the header and starts the body (cues).\n                _this.state = 'ID';\n              }\n              continue;\n            case 'NOTE':\n              // Ignore NOTE blocks.\n              if (!line) {\n                _this.state = 'ID';\n              }\n              continue;\n            case 'ID':\n              // Check for the start of NOTE blocks.\n              if (/^NOTE($|[ \\t])/.test(line)) {\n                _this.state = 'NOTE';\n                break;\n              }\n              // 19-29 - Allow any number of line terminators, then initialize new cue values.\n              if (!line) {\n                continue;\n              }\n              _this.cue = new VTTCue(0, 0, '');\n              _this.state = 'CUE';\n              // 30-39 - Check if self line contains an optional identifier or timing data.\n              if (line.indexOf('-->') === -1) {\n                _this.cue.id = line;\n                continue;\n              }\n            // Process line as start of a cue.\n            /* falls through */\n            case 'CUE':\n              // 40 - Collect cue timings and settings.\n              if (!_this.cue) {\n                _this.state = 'BADCUE';\n                continue;\n              }\n              try {\n                parseCue(line, _this.cue, _this.regionList);\n              } catch (e) {\n                // In case of an error ignore rest of the cue.\n                _this.cue = null;\n                _this.state = 'BADCUE';\n                continue;\n              }\n              _this.state = 'CUETEXT';\n              continue;\n            case 'CUETEXT':\n              {\n                var hasSubstring = line.indexOf('-->') !== -1;\n                // 34 - If we have an empty line then report the cue.\n                // 35 - If we have the special substring '-->' then report the cue,\n                // but do not collect the line as we need to process the current\n                // one as a new cue.\n                if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                  // We are done parsing self cue.\n                  if (_this.oncue && _this.cue) {\n                    _this.oncue(_this.cue);\n                  }\n                  _this.cue = null;\n                  _this.state = 'ID';\n                  continue;\n                }\n                if (_this.cue === null) {\n                  continue;\n                }\n                if (_this.cue.text) {\n                  _this.cue.text += '\\n';\n                }\n                _this.cue.text += line;\n              }\n              continue;\n            case 'BADCUE':\n              // 54-62 - Collect and discard the remaining cue.\n              if (!line) {\n                _this.state = 'ID';\n              }\n          }\n        }\n      } catch (e) {\n        // If we are currently parsing a cue, report what we have.\n        if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n          _this.oncue(_this.cue);\n        }\n        _this.cue = null;\n        // Enter BADWEBVTT state if header was not parsed correctly otherwise\n        // another exception occurred so enter BADCUE state.\n        _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n      }\n      return this;\n    };\n    _proto3.flush = function flush() {\n      var _this = this;\n      try {\n        // Finish decoding the stream.\n        // _this.buffer += _this.decoder.decode();\n        // Synthesize the end of the current cue or region.\n        if (_this.cue || _this.state === 'HEADER') {\n          _this.buffer += '\\n\\n';\n          _this.parse();\n        }\n        // If we've flushed, parsed, and we're still on the INITIAL state then\n        // that means we don't have enough of the stream to parse the first\n        // line.\n        if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n          throw new Error('Malformed WebVTT signature.');\n        }\n      } catch (e) {\n        if (_this.onparsingerror) {\n          _this.onparsingerror(e);\n        }\n      }\n      if (_this.onflush) {\n        _this.onflush();\n      }\n      return this;\n    };\n    return VTTParser;\n  }();\n\n  var LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n\n  // String.prototype.startsWith is not supported in IE11\n  var startsWith = function startsWith(inputString, searchString, position) {\n    if (position === void 0) {\n      position = 0;\n    }\n    return inputString.slice(position, position + searchString.length) === searchString;\n  };\n  var cueString2millis = function cueString2millis(timeString) {\n    var ts = parseInt(timeString.slice(-3));\n    var secs = parseInt(timeString.slice(-6, -4));\n    var mins = parseInt(timeString.slice(-9, -7));\n    var hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;\n    if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {\n      throw Error(\"Malformed X-TIMESTAMP-MAP: Local:\" + timeString);\n    }\n    ts += 1000 * secs;\n    ts += 60 * 1000 * mins;\n    ts += 60 * 60 * 1000 * hours;\n    return ts;\n  };\n\n  // Create a unique hash id for a cue based on start/end times and text.\n  // This helps timeline-controller to avoid showing repeated captions.\n  function generateCueId(startTime, endTime, text) {\n    return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n  }\n  var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n    var currCC = vttCCs[cc];\n    var prevCC = vttCCs[currCC.prevCC];\n\n    // This is the first discontinuity or cues have been processed since the last discontinuity\n    // Offset = current discontinuity time\n    if (!prevCC || !prevCC.new && currCC.new) {\n      vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n      currCC.new = false;\n      return;\n    }\n\n    // There have been discontinuities since cues were last parsed.\n    // Offset = time elapsed\n    while ((_prevCC = prevCC) != null && _prevCC.new) {\n      var _prevCC;\n      vttCCs.ccOffset += currCC.start - prevCC.start;\n      currCC.new = false;\n      currCC = prevCC;\n      prevCC = vttCCs[currCC.prevCC];\n    }\n    vttCCs.presentationOffset = presentationTime;\n  };\n  function parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n    var parser = new VTTParser();\n    // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n    // Uint8Array.prototype.reduce is not implemented in IE11\n    var vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n    var cues = [];\n    var init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;\n    var cueTime = '00:00.000';\n    var timestampMapMPEGTS = 0;\n    var timestampMapLOCAL = 0;\n    var parsingError;\n    var inHeader = true;\n    parser.oncue = function (cue) {\n      // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n      var currCC = vttCCs[cc];\n      var cueOffset = vttCCs.ccOffset;\n\n      // Calculate subtitle PTS offset\n      var webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;\n\n      // Update offsets for new discontinuities\n      if (currCC != null && currCC.new) {\n        if (timestampMapLOCAL !== undefined) {\n          // When local time is provided, offset = discontinuity start time - local time\n          cueOffset = vttCCs.ccOffset = currCC.start;\n        } else {\n          calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n        }\n      }\n      if (webVttMpegTsMapOffset) {\n        if (!initPTS) {\n          parsingError = new Error('Missing initPTS for VTT MPEGTS');\n          return;\n        }\n        // If we have MPEGTS, offset = presentation time + discontinuity offset\n        cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n      }\n      var duration = cue.endTime - cue.startTime;\n      var startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n      cue.startTime = Math.max(startTime, 0);\n      cue.endTime = Math.max(startTime + duration, 0);\n\n      //trim trailing webvtt block whitespaces\n      var text = cue.text.trim();\n\n      // Fix encoding of special characters\n      cue.text = decodeURIComponent(encodeURIComponent(text));\n\n      // If the cue was not assigned an id from the VTT file (line above the content), create one.\n      if (!cue.id) {\n        cue.id = generateCueId(cue.startTime, cue.endTime, text);\n      }\n      if (cue.endTime > 0) {\n        cues.push(cue);\n      }\n    };\n    parser.onparsingerror = function (error) {\n      parsingError = error;\n    };\n    parser.onflush = function () {\n      if (parsingError) {\n        errorCallBack(parsingError);\n        return;\n      }\n      callBack(cues);\n    };\n\n    // Go through contents line by line.\n    vttLines.forEach(function (line) {\n      if (inHeader) {\n        // Look for X-TIMESTAMP-MAP in header.\n        if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n          // Once found, no more are allowed anyway, so stop searching.\n          inHeader = false;\n          // Extract LOCAL and MPEGTS.\n          line.slice(16).split(',').forEach(function (timestamp) {\n            if (startsWith(timestamp, 'LOCAL:')) {\n              cueTime = timestamp.slice(6);\n            } else if (startsWith(timestamp, 'MPEGTS:')) {\n              timestampMapMPEGTS = parseInt(timestamp.slice(7));\n            }\n          });\n          try {\n            // Convert cue time to seconds\n            timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n          } catch (error) {\n            parsingError = error;\n          }\n          // Return without parsing X-TIMESTAMP-MAP line.\n          return;\n        } else if (line === '') {\n          inHeader = false;\n        }\n      }\n      // Parse line by default.\n      parser.parse(line + '\\n');\n    });\n    parser.flush();\n  }\n\n  var IMSC1_CODEC = 'stpp.ttml.im1t';\n\n  // Time format: h:m:s:frames(.subframes)\n  var HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n  // Time format: hours, minutes, seconds, milliseconds, frames, ticks\n  var TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\n  var textAlignToLineAlign = {\n    left: 'start',\n    center: 'center',\n    right: 'end',\n    start: 'start',\n    end: 'end'\n  };\n  function parseIMSC1(payload, initPTS, callBack, errorCallBack) {\n    var results = findBox(new Uint8Array(payload), ['mdat']);\n    if (results.length === 0) {\n      errorCallBack(new Error('Could not parse IMSC1 mdat'));\n      return;\n    }\n    var ttmlList = results.map(function (mdat) {\n      return utf8ArrayToStr(mdat);\n    });\n    var syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);\n    try {\n      ttmlList.forEach(function (ttml) {\n        return callBack(parseTTML(ttml, syncTime));\n      });\n    } catch (error) {\n      errorCallBack(error);\n    }\n  }\n  function parseTTML(ttml, syncTime) {\n    var parser = new DOMParser();\n    var xmlDoc = parser.parseFromString(ttml, 'text/xml');\n    var tt = xmlDoc.getElementsByTagName('tt')[0];\n    if (!tt) {\n      throw new Error('Invalid ttml');\n    }\n    var defaultRateInfo = {\n      frameRate: 30,\n      subFrameRate: 1,\n      frameRateMultiplier: 0,\n      tickRate: 0\n    };\n    var rateInfo = Object.keys(defaultRateInfo).reduce(function (result, key) {\n      result[key] = tt.getAttribute(\"ttp:\" + key) || defaultRateInfo[key];\n      return result;\n    }, {});\n    var trim = tt.getAttribute('xml:space') !== 'preserve';\n    var styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n    var regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n    var cueElements = getElementCollection(tt, 'body', '[begin]');\n    return [].map.call(cueElements, function (cueElement) {\n      var cueText = getTextContent(cueElement, trim);\n      if (!cueText || !cueElement.hasAttribute('begin')) {\n        return null;\n      }\n      var startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n      var duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n      var endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n      if (startTime === null) {\n        throw timestampParsingError(cueElement);\n      }\n      if (endTime === null) {\n        if (duration === null) {\n          throw timestampParsingError(cueElement);\n        }\n        endTime = startTime + duration;\n      }\n      var cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);\n      cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);\n      var region = regionElements[cueElement.getAttribute('region')];\n      var style = styleElements[cueElement.getAttribute('style')];\n\n      // Apply styles to cue\n      var styles = getTtmlStyles(region, style, styleElements);\n      var textAlign = styles.textAlign;\n      if (textAlign) {\n        // cue.positionAlign not settable in FF~2016\n        var lineAlign = textAlignToLineAlign[textAlign];\n        if (lineAlign) {\n          cue.lineAlign = lineAlign;\n        }\n        cue.align = textAlign;\n      }\n      _extends(cue, styles);\n      return cue;\n    }).filter(function (cue) {\n      return cue !== null;\n    });\n  }\n  function getElementCollection(fromElement, parentName, childName) {\n    var parent = fromElement.getElementsByTagName(parentName)[0];\n    if (parent) {\n      return [].slice.call(parent.querySelectorAll(childName));\n    }\n    return [];\n  }\n  function collectionToDictionary(elementsWithId) {\n    return elementsWithId.reduce(function (dict, element) {\n      var id = element.getAttribute('xml:id');\n      if (id) {\n        dict[id] = element;\n      }\n      return dict;\n    }, {});\n  }\n  function getTextContent(element, trim) {\n    return [].slice.call(element.childNodes).reduce(function (str, node, i) {\n      var _node$childNodes;\n      if (node.nodeName === 'br' && i) {\n        return str + '\\n';\n      }\n      if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {\n        return getTextContent(node, trim);\n      } else if (trim) {\n        return str + node.textContent.trim().replace(/\\s+/g, ' ');\n      }\n      return str + node.textContent;\n    }, '');\n  }\n  function getTtmlStyles(region, style, styleElements) {\n    var ttsNs = 'http://www.w3.org/ns/ttml#styling';\n    var regionStyle = null;\n    var styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'\n    // 'fontWeight',\n    // 'lineHeight',\n    // 'wrapOption',\n    // 'fontStyle',\n    // 'direction',\n    // 'writingMode'\n    ];\n    var regionStyleName = region != null && region.hasAttribute('style') ? region.getAttribute('style') : null;\n    if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n      regionStyle = styleElements[regionStyleName];\n    }\n    return styleAttributes.reduce(function (styles, name) {\n      var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n      if (value) {\n        styles[name] = value;\n      }\n      return styles;\n    }, {});\n  }\n  function getAttributeNS(element, ns, name) {\n    if (!element) {\n      return null;\n    }\n    return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n  }\n  function timestampParsingError(node) {\n    return new Error(\"Could not parse ttml timestamp \" + node);\n  }\n  function parseTtmlTime(timeAttributeValue, rateInfo) {\n    if (!timeAttributeValue) {\n      return null;\n    }\n    var seconds = parseTimeStamp(timeAttributeValue);\n    if (seconds === null) {\n      if (HMSF_REGEX.test(timeAttributeValue)) {\n        seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n      } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n        seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n      }\n    }\n    return seconds;\n  }\n  function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n    var m = HMSF_REGEX.exec(timeAttributeValue);\n    var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n    return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n  }\n  function parseTimeUnits(timeAttributeValue, rateInfo) {\n    var m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n    var value = Number(m[1]);\n    var unit = m[2];\n    switch (unit) {\n      case 'h':\n        return value * 3600;\n      case 'm':\n        return value * 60;\n      case 'ms':\n        return value * 1000;\n      case 'f':\n        return value / rateInfo.frameRate;\n      case 't':\n        return value / rateInfo.tickRate;\n    }\n    return value;\n  }\n\n  var OutputFilter = /*#__PURE__*/function () {\n    function OutputFilter(timelineController, trackName) {\n      this.timelineController = void 0;\n      this.cueRanges = [];\n      this.trackName = void 0;\n      this.startTime = null;\n      this.endTime = null;\n      this.screen = null;\n      this.timelineController = timelineController;\n      this.trackName = trackName;\n    }\n    var _proto = OutputFilter.prototype;\n    _proto.dispatchCue = function dispatchCue() {\n      if (this.startTime === null) {\n        return;\n      }\n      this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n      this.startTime = null;\n    };\n    _proto.newCue = function newCue(startTime, endTime, screen) {\n      if (this.startTime === null || this.startTime > startTime) {\n        this.startTime = startTime;\n      }\n      this.endTime = endTime;\n      this.screen = screen;\n      this.timelineController.createCaptionsTrack(this.trackName);\n    };\n    _proto.reset = function reset() {\n      this.cueRanges = [];\n      this.startTime = null;\n    };\n    return OutputFilter;\n  }();\n\n  var TimelineController = /*#__PURE__*/function () {\n    function TimelineController(hls) {\n      this.hls = void 0;\n      this.media = null;\n      this.config = void 0;\n      this.enabled = true;\n      this.Cues = void 0;\n      this.textTracks = [];\n      this.tracks = [];\n      this.initPTS = [];\n      this.unparsedVttFrags = [];\n      this.captionsTracks = {};\n      this.nonNativeCaptionsTracks = {};\n      this.cea608Parser1 = void 0;\n      this.cea608Parser2 = void 0;\n      this.lastCc = -1;\n      // Last video (CEA-608) fragment CC\n      this.lastSn = -1;\n      // Last video (CEA-608) fragment MSN\n      this.lastPartIndex = -1;\n      // Last video (CEA-608) fragment Part Index\n      this.prevCC = -1;\n      // Last subtitle fragment CC\n      this.vttCCs = newVTTCCs();\n      this.captionsProperties = void 0;\n      this.hls = hls;\n      this.config = hls.config;\n      this.Cues = hls.config.cueHandler;\n      this.captionsProperties = {\n        textTrack1: {\n          label: this.config.captionsTextTrack1Label,\n          languageCode: this.config.captionsTextTrack1LanguageCode\n        },\n        textTrack2: {\n          label: this.config.captionsTextTrack2Label,\n          languageCode: this.config.captionsTextTrack2LanguageCode\n        },\n        textTrack3: {\n          label: this.config.captionsTextTrack3Label,\n          languageCode: this.config.captionsTextTrack3LanguageCode\n        },\n        textTrack4: {\n          label: this.config.captionsTextTrack4Label,\n          languageCode: this.config.captionsTextTrack4LanguageCode\n        }\n      };\n      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n      hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n      hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n      hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n      hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    }\n    var _proto = TimelineController.prototype;\n    _proto.destroy = function destroy() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n      hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n      hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n      hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n      hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      // @ts-ignore\n      this.hls = this.config = this.media = null;\n      this.cea608Parser1 = this.cea608Parser2 = undefined;\n    };\n    _proto.initCea608Parsers = function initCea608Parsers() {\n      var channel1 = new OutputFilter(this, 'textTrack1');\n      var channel2 = new OutputFilter(this, 'textTrack2');\n      var channel3 = new OutputFilter(this, 'textTrack3');\n      var channel4 = new OutputFilter(this, 'textTrack4');\n      this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);\n      this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);\n    };\n    _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {\n      // skip cues which overlap more than 50% with previously parsed time ranges\n      var merged = false;\n      for (var i = cueRanges.length; i--;) {\n        var cueRange = cueRanges[i];\n        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n        if (overlap >= 0) {\n          cueRange[0] = Math.min(cueRange[0], startTime);\n          cueRange[1] = Math.max(cueRange[1], endTime);\n          merged = true;\n          if (overlap / (endTime - startTime) > 0.5) {\n            return;\n          }\n        }\n      }\n      if (!merged) {\n        cueRanges.push([startTime, endTime]);\n      }\n      if (this.config.renderTextTracksNatively) {\n        var track = this.captionsTracks[trackName];\n        this.Cues.newCue(track, startTime, endTime, screen);\n      } else {\n        var cues = this.Cues.newCue(null, startTime, endTime, screen);\n        this.hls.trigger(Events.CUES_PARSED, {\n          type: 'captions',\n          cues: cues,\n          track: trackName\n        });\n      }\n    }\n\n    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n    ;\n    _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n      var _this = this;\n      var frag = _ref.frag,\n        id = _ref.id,\n        initPTS = _ref.initPTS,\n        timescale = _ref.timescale,\n        trackId = _ref.trackId;\n      var unparsedVttFrags = this.unparsedVttFrags;\n      if (id === PlaylistLevelType.MAIN) {\n        this.initPTS[frag.cc] = {\n          baseTime: initPTS,\n          timescale: timescale,\n          trackId: trackId\n        };\n      }\n\n      // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n      // Parse any unparsed fragments upon receiving the initial PTS.\n      if (unparsedVttFrags.length) {\n        this.unparsedVttFrags = [];\n        unparsedVttFrags.forEach(function (data) {\n          if (_this.initPTS[data.frag.cc]) {\n            _this.onFragLoaded(Events.FRAG_LOADED, data);\n          } else {\n            _this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n              success: false,\n              frag: data.frag,\n              error: new Error('Subtitle discontinuity domain does not match main')\n            });\n          }\n        });\n      }\n    };\n    _proto.getExistingTrack = function getExistingTrack(label, language) {\n      var media = this.media;\n      if (media) {\n        for (var i = 0; i < media.textTracks.length; i++) {\n          var textTrack = media.textTracks[i];\n          if (canReuseVttTextTrack(textTrack, {\n            name: label,\n            lang: language,\n            characteristics: 'transcribes-spoken-dialog,describes-music-and-sound'})) {\n            return textTrack;\n          }\n        }\n      }\n      return null;\n    };\n    _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {\n      if (this.config.renderTextTracksNatively) {\n        this.createNativeTrack(trackName);\n      } else {\n        this.createNonNativeTrack(trackName);\n      }\n    };\n    _proto.createNativeTrack = function createNativeTrack(trackName) {\n      if (this.captionsTracks[trackName]) {\n        return;\n      }\n      var captionsProperties = this.captionsProperties,\n        captionsTracks = this.captionsTracks,\n        media = this.media;\n      var _captionsProperties$t = captionsProperties[trackName],\n        label = _captionsProperties$t.label,\n        languageCode = _captionsProperties$t.languageCode;\n      // Enable reuse of existing text track.\n      var existingTrack = this.getExistingTrack(label, languageCode);\n      if (!existingTrack) {\n        var textTrack = this.createTextTrack('captions', label, languageCode);\n        if (textTrack) {\n          // Set a special property on the track so we know it's managed by Hls.js\n          textTrack[trackName] = true;\n          captionsTracks[trackName] = textTrack;\n        }\n      } else {\n        captionsTracks[trackName] = existingTrack;\n        clearCurrentCues(captionsTracks[trackName]);\n        sendAddTrackEvent(captionsTracks[trackName], media);\n      }\n    };\n    _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {\n      if (this.nonNativeCaptionsTracks[trackName]) {\n        return;\n      }\n      // Create a list of a single track for the provider to consume\n      var trackProperties = this.captionsProperties[trackName];\n      if (!trackProperties) {\n        return;\n      }\n      var label = trackProperties.label;\n      var track = {\n        _id: trackName,\n        label: label,\n        kind: 'captions',\n        default: trackProperties.media ? !!trackProperties.media.default : false,\n        closedCaptions: trackProperties.media\n      };\n      this.nonNativeCaptionsTracks[trackName] = track;\n      this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n        tracks: [track]\n      });\n    };\n    _proto.createTextTrack = function createTextTrack(kind, label, lang) {\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      return media.addTextTrack(kind, label, lang);\n    };\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      this.media = data.media;\n      if (!data.mediaSource) {\n        this._cleanTracks();\n      }\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      var transferringMedia = !!data.transferMedia;\n      this.media = null;\n      if (transferringMedia) {\n        return;\n      }\n      var captionsTracks = this.captionsTracks;\n      Object.keys(captionsTracks).forEach(function (trackName) {\n        clearCurrentCues(captionsTracks[trackName]);\n        delete captionsTracks[trackName];\n      });\n      this.nonNativeCaptionsTracks = {};\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      // Detect discontinuity in video fragment (CEA-608) parsing\n      this.lastCc = -1;\n      this.lastSn = -1;\n      this.lastPartIndex = -1;\n      // Detect discontinuity in subtitle manifests\n      this.prevCC = -1;\n      this.vttCCs = newVTTCCs();\n      // Reset tracks\n      this._cleanTracks();\n      this.tracks = [];\n      this.captionsTracks = {};\n      this.nonNativeCaptionsTracks = {};\n      this.textTracks = [];\n      this.unparsedVttFrags = [];\n      this.initPTS = [];\n      if (this.cea608Parser1 && this.cea608Parser2) {\n        this.cea608Parser1.reset();\n        this.cea608Parser2.reset();\n      }\n    };\n    _proto._cleanTracks = function _cleanTracks() {\n      // clear outdated subtitles\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      var textTracks = media.textTracks;\n      if (textTracks) {\n        for (var i = 0; i < textTracks.length; i++) {\n          clearCurrentCues(textTracks[i]);\n        }\n      }\n    };\n    _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {\n      var _this2 = this;\n      var tracks = data.subtitleTracks || [];\n      var hasIMSC1 = tracks.some(function (track) {\n        return track.textCodec === IMSC1_CODEC;\n      });\n      if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n        var listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);\n        if (listIsIdentical) {\n          this.tracks = tracks;\n          return;\n        }\n        this.textTracks = [];\n        this.tracks = tracks;\n        if (this.config.renderTextTracksNatively) {\n          var media = this.media;\n          var inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;\n          this.tracks.forEach(function (track, index) {\n            // Reuse tracks with the same label and lang, but do not reuse 608/708 tracks\n            var textTrack;\n            if (inUseTracks) {\n              var inUseTrack = null;\n              for (var i = 0; i < inUseTracks.length; i++) {\n                if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {\n                  inUseTrack = inUseTracks[i];\n                  inUseTracks[i] = null;\n                  break;\n                }\n              }\n              if (inUseTrack) {\n                textTrack = inUseTrack;\n              }\n            }\n            if (textTrack) {\n              clearCurrentCues(textTrack);\n            } else {\n              var textTrackKind = captionsOrSubtitlesFromCharacteristics(track);\n              textTrack = _this2.createTextTrack(textTrackKind, track.name, track.lang);\n              if (textTrack) {\n                textTrack.mode = 'disabled';\n              }\n            }\n            if (textTrack) {\n              _this2.textTracks.push(textTrack);\n            }\n          });\n          // Warn when video element has captions or subtitle TextTracks carried over from another source\n          if (inUseTracks != null && inUseTracks.length) {\n            var unusedTextTracks = inUseTracks.filter(function (t) {\n              return t !== null;\n            }).map(function (t) {\n              return t.label;\n            });\n            if (unusedTextTracks.length) {\n              this.hls.logger.warn(\"Media element contains unused subtitle tracks: \" + unusedTextTracks.join(', ') + \". Replace media element for each source to clear TextTracks and captions menu.\");\n            }\n          }\n        } else if (this.tracks.length) {\n          // Create a list of tracks for the provider to consume\n          var tracksList = this.tracks.map(function (track) {\n            return {\n              label: track.name,\n              kind: track.type.toLowerCase(),\n              default: track.default,\n              subtitleTrack: track\n            };\n          });\n          this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n            tracks: tracksList\n          });\n        }\n      }\n    };\n    _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n      var _this3 = this;\n      if (this.config.enableCEA708Captions && data.captions) {\n        data.captions.forEach(function (captionsTrack) {\n          var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n          if (!instreamIdMatch) {\n            return;\n          }\n          var trackName = \"textTrack\" + instreamIdMatch[1];\n          var trackProperties = _this3.captionsProperties[trackName];\n          if (!trackProperties) {\n            return;\n          }\n          trackProperties.label = captionsTrack.name;\n          if (captionsTrack.lang) {\n            // optional attribute\n            trackProperties.languageCode = captionsTrack.lang;\n          }\n          trackProperties.media = captionsTrack;\n        });\n      }\n    };\n    _proto.closedCaptionsForLevel = function closedCaptionsForLevel(frag) {\n      var level = this.hls.levels[frag.level];\n      return level == null ? void 0 : level.attrs['CLOSED-CAPTIONS'];\n    };\n    _proto.onFragLoading = function onFragLoading(event, data) {\n      // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n      if (this.enabled && data.frag.type === PlaylistLevelType.MAIN) {\n        var _data$part$index, _data$part;\n        var cea608Parser1 = this.cea608Parser1,\n          cea608Parser2 = this.cea608Parser2,\n          lastSn = this.lastSn;\n        var _data$frag = data.frag,\n          cc = _data$frag.cc,\n          sn = _data$frag.sn;\n        var partIndex = (_data$part$index = (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n        if (cea608Parser1 && cea608Parser2) {\n          if (sn !== lastSn + 1 || sn === lastSn && partIndex !== this.lastPartIndex + 1 || cc !== this.lastCc) {\n            cea608Parser1.reset();\n            cea608Parser2.reset();\n          }\n        }\n        this.lastCc = cc;\n        this.lastSn = sn;\n        this.lastPartIndex = partIndex;\n      }\n    };\n    _proto.onFragLoaded = function onFragLoaded(event, data) {\n      var frag = data.frag,\n        payload = data.payload;\n      if (frag.type === PlaylistLevelType.SUBTITLE) {\n        // If fragment is subtitle type, parse as WebVTT.\n        if (payload.byteLength) {\n          var decryptData = frag.decryptdata;\n          // fragment after decryption has a stats object\n          var decrypted = 'stats' in data;\n          // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n          if (decryptData == null || !decryptData.encrypted || decrypted) {\n            var trackPlaylistMedia = this.tracks[frag.level];\n            var vttCCs = this.vttCCs;\n            if (!vttCCs[frag.cc]) {\n              vttCCs[frag.cc] = {\n                start: frag.start,\n                prevCC: this.prevCC,\n                new: true\n              };\n              this.prevCC = frag.cc;\n            }\n            if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {\n              this._parseIMSC1(frag, payload);\n            } else {\n              this._parseVTTs(data);\n            }\n          }\n        } else {\n          // In case there is no payload, finish unsuccessfully.\n          this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n            success: false,\n            frag: frag,\n            error: new Error('Empty subtitle payload')\n          });\n        }\n      }\n    };\n    _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {\n      var _this4 = this;\n      var hls = this.hls;\n      parseIMSC1(payload, this.initPTS[frag.cc], function (cues) {\n        _this4._appendCues(cues, frag.level);\n        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: true,\n          frag: frag\n        });\n      }, function (error) {\n        hls.logger.log(\"Failed to parse IMSC1: \" + error);\n        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag: frag,\n          error: error\n        });\n      });\n    };\n    _proto._parseVTTs = function _parseVTTs(data) {\n      var _frag$initSegment,\n        _this5 = this;\n      var frag = data.frag,\n        payload = data.payload;\n      // We need an initial synchronisation PTS. Store fragments as long as none has arrived\n      var initPTS = this.initPTS,\n        unparsedVttFrags = this.unparsedVttFrags;\n      var maxAvCC = initPTS.length - 1;\n      if (!initPTS[frag.cc] && maxAvCC === -1) {\n        unparsedVttFrags.push(data);\n        return;\n      }\n      var hls = this.hls;\n      // Parse the WebVTT file contents.\n      var payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)).buffer : payload;\n      parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, function (cues) {\n        _this5._appendCues(cues, frag.level);\n        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: true,\n          frag: frag\n        });\n      }, function (error) {\n        var missingInitPTS = error.message === 'Missing initPTS for VTT MPEGTS';\n        if (missingInitPTS) {\n          unparsedVttFrags.push(data);\n        } else {\n          _this5._fallbackToIMSC1(frag, payload);\n        }\n        // Something went wrong while parsing. Trigger event with success false.\n        hls.logger.log(\"Failed to parse VTT cue: \" + error);\n        if (missingInitPTS && maxAvCC > frag.cc) {\n          return;\n        }\n        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag: frag,\n          error: error\n        });\n      });\n    };\n    _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {\n      var _this6 = this;\n      // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n      var trackPlaylistMedia = this.tracks[frag.level];\n      if (!trackPlaylistMedia.textCodec) {\n        parseIMSC1(payload, this.initPTS[frag.cc], function () {\n          trackPlaylistMedia.textCodec = IMSC1_CODEC;\n          _this6._parseIMSC1(frag, payload);\n        }, function () {\n          trackPlaylistMedia.textCodec = 'wvtt';\n        });\n      }\n    };\n    _proto._appendCues = function _appendCues(cues, fragLevel) {\n      var hls = this.hls;\n      if (this.config.renderTextTracksNatively) {\n        var textTrack = this.textTracks[fragLevel];\n        // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n        // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n        // and trying to access getCueById method of cues will throw an exception\n        // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n        if (!textTrack || textTrack.mode === 'disabled') {\n          return;\n        }\n        cues.forEach(function (cue) {\n          return addCueToTrack(textTrack, cue);\n        });\n      } else {\n        var currentTrack = this.tracks[fragLevel];\n        if (!currentTrack) {\n          return;\n        }\n        var track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n        hls.trigger(Events.CUES_PARSED, {\n          type: 'subtitles',\n          cues: cues,\n          track: track\n        });\n      }\n    };\n    _proto.onFragDecrypted = function onFragDecrypted(event, data) {\n      var frag = data.frag;\n      if (frag.type === PlaylistLevelType.SUBTITLE) {\n        this.onFragLoaded(Events.FRAG_LOADED, data);\n      }\n    };\n    _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {\n      this.tracks = [];\n      this.captionsTracks = {};\n    };\n    _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {\n      if (!this.enabled || !this.config.enableCEA708Captions) {\n        return;\n      }\n      var frag = data.frag,\n        samples = data.samples;\n      if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === 'NONE') {\n        return;\n      }\n      // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n      // It will create the proper timestamps based on the PTS value\n      for (var i = 0; i < samples.length; i++) {\n        var ccBytes = samples[i].bytes;\n        if (ccBytes) {\n          if (!this.cea608Parser1) {\n            this.initCea608Parsers();\n          }\n          var ccdatas = this.extractCea608Data(ccBytes);\n          this.cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n          this.cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n        }\n      }\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, _ref2) {\n      var startOffset = _ref2.startOffset,\n        endOffset = _ref2.endOffset,\n        endOffsetSubtitles = _ref2.endOffsetSubtitles,\n        type = _ref2.type;\n      var media = this.media;\n      if (!media || media.currentTime < endOffset) {\n        return;\n      }\n      // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n      // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n      if (!type || type === 'video') {\n        var captionsTracks = this.captionsTracks;\n        Object.keys(captionsTracks).forEach(function (trackName) {\n          return removeCuesInRange(captionsTracks[trackName], startOffset, endOffset);\n        });\n      }\n      if (this.config.renderTextTracksNatively) {\n        // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n        if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n          var textTracks = this.textTracks;\n          Object.keys(textTracks).forEach(function (trackName) {\n            return removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles);\n          });\n        }\n      }\n    };\n    _proto.extractCea608Data = function extractCea608Data(byteArray) {\n      var actualCCBytes = [[], []];\n      var count = byteArray[0] & 0x1f;\n      var position = 2;\n      for (var j = 0; j < count; j++) {\n        var tmpByte = byteArray[position++];\n        var ccbyte1 = 0x7f & byteArray[position++];\n        var ccbyte2 = 0x7f & byteArray[position++];\n        if (ccbyte1 === 0 && ccbyte2 === 0) {\n          continue;\n        }\n        var ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n        if (ccValid) {\n          var ccType = 0x03 & tmpByte;\n          if (0x00 /* CEA608 field1*/ === ccType || 0x01 /* CEA608 field2*/ === ccType) {\n            // Exclude CEA708 CC data.\n            actualCCBytes[ccType].push(ccbyte1);\n            actualCCBytes[ccType].push(ccbyte2);\n          }\n        }\n      }\n      return actualCCBytes;\n    };\n    return TimelineController;\n  }();\n  function captionsOrSubtitlesFromCharacteristics(track) {\n    if (track.characteristics) {\n      if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {\n        return 'captions';\n      }\n    }\n    return 'subtitles';\n  }\n  function canReuseVttTextTrack(inUseTrack, manifestTrack) {\n    return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);\n  }\n  function intersection(x1, x2, y1, y2) {\n    return Math.min(x2, y2) - Math.max(x1, y1);\n  }\n  function newVTTCCs() {\n    return {\n      ccOffset: 0,\n      presentationOffset: 0,\n      0: {\n        start: 0,\n        prevCC: -1,\n        new: true\n      }\n    };\n  }\n\n  var WHITESPACE_CHAR = /\\s/;\n  var Cues = {\n    newCue: function newCue(track, startTime, endTime, captionScreen) {\n      var result = [];\n      var row;\n      // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n      var cue;\n      var indenting;\n      var indent;\n      var text;\n      var Cue = self.VTTCue || self.TextTrackCue;\n      for (var r = 0; r < captionScreen.rows.length; r++) {\n        row = captionScreen.rows[r];\n        indenting = true;\n        indent = 0;\n        text = '';\n        if (!row.isEmpty()) {\n          var _track$cues;\n          for (var c = 0; c < row.chars.length; c++) {\n            if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n              indent++;\n            } else {\n              text += row.chars[c].uchar;\n              indenting = false;\n            }\n          }\n          // To be used for cleaning-up orphaned roll-up captions\n          row.cueStartTime = startTime;\n\n          // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n          if (startTime === endTime) {\n            endTime += 0.0001;\n          }\n          if (indent >= 16) {\n            indent--;\n          } else {\n            indent++;\n          }\n          var cueText = fixLineBreaks(text.trim());\n          var id = generateCueId(startTime, endTime, cueText);\n\n          // If this cue already exists in the track do not push it\n          if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {\n            cue = new Cue(startTime, endTime, cueText);\n            cue.id = id;\n            cue.line = r + 1;\n            cue.align = 'left';\n            // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n            // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n            // Firefox throws an exception and captions break with out of bounds 0-100 values\n            cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n            result.push(cue);\n          }\n        }\n      }\n      if (track && result.length) {\n        // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n        result.sort(function (cueA, cueB) {\n          if (cueA.line === 'auto' || cueB.line === 'auto') {\n            return 0;\n          }\n          if (cueA.line > 8 && cueB.line > 8) {\n            return cueB.line - cueA.line;\n          }\n          return cueA.line - cueB.line;\n        });\n        result.forEach(function (cue) {\n          return addCueToTrack(track, cue);\n        });\n      }\n      return result;\n    }\n  };\n\n  function fetchSupported() {\n    if (\n    // @ts-ignore\n    self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n      try {\n        new self.ReadableStream({}); // eslint-disable-line no-new\n        return true;\n      } catch (e) {\n        /* noop */\n      }\n    }\n    return false;\n  }\n  var BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\n  var FetchLoader = /*#__PURE__*/function () {\n    function FetchLoader(config) {\n      this.fetchSetup = void 0;\n      this.requestTimeout = void 0;\n      this.request = null;\n      this.response = null;\n      this.controller = void 0;\n      this.context = null;\n      this.config = null;\n      this.callbacks = null;\n      this.stats = void 0;\n      this.loader = null;\n      this.fetchSetup = config.fetchSetup || getRequest;\n      this.controller = new self.AbortController();\n      this.stats = new LoadStats();\n    }\n    var _proto = FetchLoader.prototype;\n    _proto.destroy = function destroy() {\n      this.loader = this.callbacks = this.context = this.config = this.request = null;\n      this.abortInternal();\n      this.response = null;\n      // @ts-ignore\n      this.fetchSetup = this.controller = this.stats = null;\n    };\n    _proto.abortInternal = function abortInternal() {\n      if (this.controller && !this.stats.loading.end) {\n        this.stats.aborted = true;\n        this.controller.abort();\n      }\n    };\n    _proto.abort = function abort() {\n      var _this$callbacks;\n      this.abortInternal();\n      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n        this.callbacks.onAbort(this.stats, this.context, this.response);\n      }\n    };\n    _proto.load = function load(context, config, callbacks) {\n      var _this = this;\n      var stats = this.stats;\n      if (stats.loading.start) {\n        throw new Error('Loader can only be used once.');\n      }\n      stats.loading.start = self.performance.now();\n      var initParams = getRequestParameters(context, this.controller.signal);\n      var isArrayBuffer = context.responseType === 'arraybuffer';\n      var LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n      var _config$loadPolicy = config.loadPolicy,\n        maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs,\n        maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;\n      this.context = context;\n      this.config = config;\n      this.callbacks = callbacks;\n      this.request = this.fetchSetup(context, initParams);\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(function () {\n        if (_this.callbacks) {\n          _this.abortInternal();\n          _this.callbacks.onTimeout(stats, context, _this.response);\n        }\n      }, config.timeout);\n      var fetchPromise = isPromise(this.request) ? this.request.then(self.fetch) : self.fetch(this.request);\n      fetchPromise.then(function (response) {\n        var _this$callbacks2;\n        _this.response = _this.loader = response;\n        var first = Math.max(self.performance.now(), stats.loading.start);\n        self.clearTimeout(_this.requestTimeout);\n        config.timeout = maxLoadTimeMs;\n        _this.requestTimeout = self.setTimeout(function () {\n          if (_this.callbacks) {\n            _this.abortInternal();\n            _this.callbacks.onTimeout(stats, context, _this.response);\n          }\n        }, maxLoadTimeMs - (first - stats.loading.start));\n        if (!response.ok) {\n          var status = response.status,\n            statusText = response.statusText;\n          throw new FetchError(statusText || 'fetch, bad network response', status, response);\n        }\n        stats.loading.first = first;\n        stats.total = getContentLength(response.headers) || stats.total;\n        var onProgress = (_this$callbacks2 = _this.callbacks) == null ? void 0 : _this$callbacks2.onProgress;\n        if (onProgress && isFiniteNumber(config.highWaterMark)) {\n          return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n        }\n        if (isArrayBuffer) {\n          return response.arrayBuffer();\n        }\n        if (context.responseType === 'json') {\n          return response.json();\n        }\n        return response.text();\n      }).then(function (responseData) {\n        var _this$callbacks3, _this$callbacks4;\n        var response = _this.response;\n        if (!response) {\n          throw new Error('loader destroyed');\n        }\n        self.clearTimeout(_this.requestTimeout);\n        stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n        var total = responseData[LENGTH];\n        if (total) {\n          stats.loaded = stats.total = total;\n        }\n        var loaderResponse = {\n          url: response.url,\n          data: responseData,\n          code: response.status\n        };\n        var onProgress = (_this$callbacks3 = _this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;\n        if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n          onProgress(stats, context, responseData, response);\n        }\n        (_this$callbacks4 = _this.callbacks) == null || _this$callbacks4.onSuccess(loaderResponse, stats, context, response);\n      }).catch(function (error) {\n        var _this$callbacks5;\n        self.clearTimeout(_this.requestTimeout);\n        if (stats.aborted) {\n          return;\n        }\n        // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n        // when destroying, 'error' itself can be undefined\n        var code = !error ? 0 : error.code || 0;\n        var text = !error ? null : error.message;\n        (_this$callbacks5 = _this.callbacks) == null || _this$callbacks5.onError({\n          code: code,\n          text: text\n        }, context, error ? error.details : null, stats);\n      });\n    };\n    _proto.getCacheAge = function getCacheAge() {\n      var result = null;\n      if (this.response) {\n        var ageHeader = this.response.headers.get('age');\n        result = ageHeader ? parseFloat(ageHeader) : null;\n      }\n      return result;\n    };\n    _proto.getResponseHeader = function getResponseHeader(name) {\n      return this.response ? this.response.headers.get(name) : null;\n    };\n    _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {\n      if (highWaterMark === void 0) {\n        highWaterMark = 0;\n      }\n      var chunkCache = new ChunkCache();\n      var reader = response.body.getReader();\n      var _pump = function pump() {\n        return reader.read().then(function (data) {\n          if (data.done) {\n            if (chunkCache.dataLength) {\n              onProgress(stats, context, chunkCache.flush().buffer, response);\n            }\n            return Promise.resolve(new ArrayBuffer(0));\n          }\n          var chunk = data.value;\n          var len = chunk.length;\n          stats.loaded += len;\n          if (len < highWaterMark || chunkCache.dataLength) {\n            // The current chunk is too small to to be emitted or the cache already has data\n            // Push it to the cache\n            chunkCache.push(chunk);\n            if (chunkCache.dataLength >= highWaterMark) {\n              // flush in order to join the typed arrays\n              onProgress(stats, context, chunkCache.flush().buffer, response);\n            }\n          } else {\n            // If there's nothing cached already, and the chache is large enough\n            // just emit the progress event\n            onProgress(stats, context, chunk.buffer, response);\n          }\n          return _pump();\n        }).catch(function () {\n          /* aborted */\n          return Promise.reject();\n        });\n      };\n      return _pump();\n    };\n    return FetchLoader;\n  }();\n  function getRequestParameters(context, signal) {\n    var initParams = {\n      method: 'GET',\n      mode: 'cors',\n      credentials: 'same-origin',\n      signal: signal,\n      headers: new self.Headers(_extends({}, context.headers))\n    };\n    if (context.rangeEnd) {\n      initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n    }\n    return initParams;\n  }\n  function getByteRangeLength(byteRangeHeader) {\n    var result = BYTERANGE.exec(byteRangeHeader);\n    if (result) {\n      return parseInt(result[2]) - parseInt(result[1]) + 1;\n    }\n  }\n  function getContentLength(headers) {\n    var contentRange = headers.get('Content-Range');\n    if (contentRange) {\n      var byteRangeLength = getByteRangeLength(contentRange);\n      if (isFiniteNumber(byteRangeLength)) {\n        return byteRangeLength;\n      }\n    }\n    var contentLength = headers.get('Content-Length');\n    if (contentLength) {\n      return parseInt(contentLength);\n    }\n  }\n  function getRequest(context, initParams) {\n    return new self.Request(context.url, initParams);\n  }\n  var FetchError = /*#__PURE__*/function (_Error) {\n    function FetchError(message, code, details) {\n      var _this2;\n      _this2 = _Error.call(this, message) || this;\n      _this2.code = void 0;\n      _this2.details = void 0;\n      _this2.code = code;\n      _this2.details = details;\n      return _this2;\n    }\n    _inheritsLoose(FetchError, _Error);\n    return FetchError;\n  }(/*#__PURE__*/_wrapNativeSuper(Error));\n\n  var AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\n  var XhrLoader = /*#__PURE__*/function () {\n    function XhrLoader(config) {\n      this.xhrSetup = void 0;\n      this.requestTimeout = void 0;\n      this.retryTimeout = void 0;\n      this.retryDelay = void 0;\n      this.config = null;\n      this.callbacks = null;\n      this.context = null;\n      this.loader = null;\n      this.stats = void 0;\n      this.xhrSetup = config ? config.xhrSetup || null : null;\n      this.stats = new LoadStats();\n      this.retryDelay = 0;\n    }\n    var _proto = XhrLoader.prototype;\n    _proto.destroy = function destroy() {\n      this.callbacks = null;\n      this.abortInternal();\n      this.loader = null;\n      this.config = null;\n      this.context = null;\n      this.xhrSetup = null;\n    };\n    _proto.abortInternal = function abortInternal() {\n      var loader = this.loader;\n      self.clearTimeout(this.requestTimeout);\n      self.clearTimeout(this.retryTimeout);\n      if (loader) {\n        loader.onreadystatechange = null;\n        loader.onprogress = null;\n        if (loader.readyState !== 4) {\n          this.stats.aborted = true;\n          loader.abort();\n        }\n      }\n    };\n    _proto.abort = function abort() {\n      var _this$callbacks;\n      this.abortInternal();\n      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n        this.callbacks.onAbort(this.stats, this.context, this.loader);\n      }\n    };\n    _proto.load = function load(context, config, callbacks) {\n      if (this.stats.loading.start) {\n        throw new Error('Loader can only be used once.');\n      }\n      this.stats.loading.start = self.performance.now();\n      this.context = context;\n      this.config = config;\n      this.callbacks = callbacks;\n      this.loadInternal();\n    };\n    _proto.loadInternal = function loadInternal() {\n      var _this = this;\n      var config = this.config,\n        context = this.context;\n      if (!config || !context) {\n        return;\n      }\n      var xhr = this.loader = new self.XMLHttpRequest();\n      var stats = this.stats;\n      stats.loading.first = 0;\n      stats.loaded = 0;\n      stats.aborted = false;\n      var xhrSetup = this.xhrSetup;\n      if (xhrSetup) {\n        Promise.resolve().then(function () {\n          if (_this.loader !== xhr || _this.stats.aborted) return;\n          return xhrSetup(xhr, context.url);\n        }).catch(function (error) {\n          if (_this.loader !== xhr || _this.stats.aborted) return;\n          xhr.open('GET', context.url, true);\n          return xhrSetup(xhr, context.url);\n        }).then(function () {\n          if (_this.loader !== xhr || _this.stats.aborted) return;\n          _this.openAndSendXhr(xhr, context, config);\n        }).catch(function (error) {\n          var _this$callbacks2;\n          // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n          (_this$callbacks2 = _this.callbacks) == null || _this$callbacks2.onError({\n            code: xhr.status,\n            text: error.message\n          }, context, xhr, stats);\n          return;\n        });\n      } else {\n        this.openAndSendXhr(xhr, context, config);\n      }\n    };\n    _proto.openAndSendXhr = function openAndSendXhr(xhr, context, config) {\n      if (!xhr.readyState) {\n        xhr.open('GET', context.url, true);\n      }\n      var headers = context.headers;\n      var _config$loadPolicy = config.loadPolicy,\n        maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs,\n        maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;\n      if (headers) {\n        for (var header in headers) {\n          xhr.setRequestHeader(header, headers[header]);\n        }\n      }\n      if (context.rangeEnd) {\n        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n      }\n      xhr.onreadystatechange = this.readystatechange.bind(this);\n      xhr.onprogress = this.loadprogress.bind(this);\n      xhr.responseType = context.responseType;\n      // setup timeout before we perform request\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n      xhr.send();\n    };\n    _proto.readystatechange = function readystatechange() {\n      var context = this.context,\n        xhr = this.loader,\n        stats = this.stats;\n      if (!context || !xhr) {\n        return;\n      }\n      var readyState = xhr.readyState;\n      var config = this.config;\n\n      // don't proceed if xhr has been aborted\n      if (stats.aborted) {\n        return;\n      }\n\n      // >= HEADERS_RECEIVED\n      if (readyState >= 2) {\n        if (stats.loading.first === 0) {\n          stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n          if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n            self.clearTimeout(this.requestTimeout);\n            config.timeout = config.loadPolicy.maxLoadTimeMs;\n            this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n          }\n        }\n        if (readyState === 4) {\n          self.clearTimeout(this.requestTimeout);\n          xhr.onreadystatechange = null;\n          xhr.onprogress = null;\n          var _status = xhr.status;\n          // http status between 200 to 299 are all successful\n          var useResponseText = xhr.responseType === 'text' ? xhr.responseText : null;\n          if (_status >= 200 && _status < 300) {\n            var data = useResponseText != null ? useResponseText : xhr.response;\n            if (data != null) {\n              var _this$callbacks3, _this$callbacks4;\n              stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n              var len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n              stats.loaded = stats.total = len;\n              stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n              var onProgress = (_this$callbacks3 = this.callbacks) == null ? void 0 : _this$callbacks3.onProgress;\n              if (onProgress) {\n                onProgress(stats, context, data, xhr);\n              }\n              var _response = {\n                url: xhr.responseURL,\n                data: data,\n                code: _status\n              };\n              (_this$callbacks4 = this.callbacks) == null || _this$callbacks4.onSuccess(_response, stats, context, xhr);\n              return;\n            }\n          }\n\n          // Handle bad status or nullish response\n          var retryConfig = config.loadPolicy.errorRetry;\n          var retryCount = stats.retry;\n          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n          var response = {\n            url: context.url,\n            data: undefined,\n            code: _status\n          };\n          if (shouldRetry(retryConfig, retryCount, false, response)) {\n            this.retry(retryConfig);\n          } else {\n            var _this$callbacks5;\n            logger.error(_status + \" while loading \" + context.url);\n            (_this$callbacks5 = this.callbacks) == null || _this$callbacks5.onError({\n              code: _status,\n              text: xhr.statusText\n            }, context, xhr, stats);\n          }\n        }\n      }\n    };\n    _proto.loadtimeout = function loadtimeout() {\n      if (!this.config) return;\n      var retryConfig = this.config.loadPolicy.timeoutRetry;\n      var retryCount = this.stats.retry;\n      if (shouldRetry(retryConfig, retryCount, true)) {\n        this.retry(retryConfig);\n      } else {\n        var _this$context;\n        logger.warn(\"timeout while loading \" + ((_this$context = this.context) == null ? void 0 : _this$context.url));\n        var callbacks = this.callbacks;\n        if (callbacks) {\n          this.abortInternal();\n          callbacks.onTimeout(this.stats, this.context, this.loader);\n        }\n      }\n    };\n    _proto.retry = function retry(retryConfig) {\n      var context = this.context,\n        stats = this.stats;\n      this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n      stats.retry++;\n      logger.warn((status ? 'HTTP Status ' + status : 'Timeout') + \" while loading \" + (context == null ? void 0 : context.url) + \", retrying \" + stats.retry + \"/\" + retryConfig.maxNumRetry + \" in \" + this.retryDelay + \"ms\");\n      // abort and reset internal state\n      this.abortInternal();\n      this.loader = null;\n      // schedule retry\n      self.clearTimeout(this.retryTimeout);\n      this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n    };\n    _proto.loadprogress = function loadprogress(event) {\n      var stats = this.stats;\n      stats.loaded = event.loaded;\n      if (event.lengthComputable) {\n        stats.total = event.total;\n      }\n    };\n    _proto.getCacheAge = function getCacheAge() {\n      var result = null;\n      if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n        var ageHeader = this.loader.getResponseHeader('age');\n        result = ageHeader ? parseFloat(ageHeader) : null;\n      }\n      return result;\n    };\n    _proto.getResponseHeader = function getResponseHeader(name) {\n      if (this.loader && new RegExp(\"^\" + name + \":\\\\s*[\\\\d.]+\\\\s*$\", 'im').test(this.loader.getAllResponseHeaders())) {\n        return this.loader.getResponseHeader(name);\n      }\n      return null;\n    };\n    return XhrLoader;\n  }();\n\n  /**\n   * @deprecated use fragLoadPolicy.default\n   */\n\n  /**\n   * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n   */\n\n  var defaultLoadPolicy = {\n    maxTimeToFirstByteMs: 8000,\n    maxLoadTimeMs: 20000,\n    timeoutRetry: null,\n    errorRetry: null\n  };\n\n  /**\n   * @ignore\n   * If possible, keep hlsDefaultConfig shallow\n   * It is cloned whenever a new Hls instance is created, by keeping the config\n   * shallow the properties are cloned, and we don't end up manipulating the default\n   */\n  var hlsDefaultConfig = _objectSpread2(_objectSpread2({\n    autoStartLoad: true,\n    // used by stream-controller\n    startPosition: -1,\n    // used by stream-controller\n    defaultAudioCodec: undefined,\n    // used by stream-controller\n    debug: false,\n    // used by logger\n    capLevelOnFPSDrop: false,\n    // used by fps-controller\n    capLevelToPlayerSize: false,\n    // used by cap-level-controller\n    ignoreDevicePixelRatio: false,\n    // used by cap-level-controller\n    maxDevicePixelRatio: Number.POSITIVE_INFINITY,\n    // used by cap-level-controller\n    preferManagedMediaSource: true,\n    initialLiveManifestSize: 1,\n    // used by stream-controller\n    maxBufferLength: 30,\n    // used by stream-controller\n    backBufferLength: Infinity,\n    // used by buffer-controller\n    frontBufferFlushThreshold: Infinity,\n    startOnSegmentBoundary: false,\n    // used by stream-controller\n    maxBufferSize: 60 * 1000 * 1000,\n    // used by stream-controller\n    maxFragLookUpTolerance: 0.25,\n    // used by stream-controller\n    maxBufferHole: 0.1,\n    // used by stream-controller and gap-controller\n    detectStallWithCurrentTimeMs: 1250,\n    // used by gap-controller\n    highBufferWatchdogPeriod: 2,\n    // used by gap-controller\n    nudgeOffset: 0.1,\n    // used by gap-controller\n    nudgeMaxRetry: 3,\n    // used by gap-controller\n    nudgeOnVideoHole: true,\n    // used by gap-controller\n    liveSyncMode: 'edge',\n    // used by stream-controller\n    liveSyncDurationCount: 3,\n    // used by latency-controller\n    liveSyncOnStallIncrease: 1,\n    // used by latency-controller\n    liveMaxLatencyDurationCount: Infinity,\n    // used by latency-controller\n    liveSyncDuration: undefined,\n    // used by latency-controller\n    liveMaxLatencyDuration: undefined,\n    // used by latency-controller\n    maxLiveSyncPlaybackRate: 1,\n    // used by latency-controller\n    liveDurationInfinity: false,\n    // used by buffer-controller\n    /**\n     * @deprecated use backBufferLength\n     */\n    liveBackBufferLength: null,\n    // used by buffer-controller\n    maxMaxBufferLength: 600,\n    // used by stream-controller\n    enableWorker: true,\n    // used by transmuxer\n    workerPath: null,\n    // used by transmuxer\n    enableSoftwareAES: true,\n    // used by decrypter\n    startLevel: undefined,\n    // used by level-controller\n    startFragPrefetch: false,\n    // used by stream-controller\n    fpsDroppedMonitoringPeriod: 5000,\n    // used by fps-controller\n    fpsDroppedMonitoringThreshold: 0.2,\n    // used by fps-controller\n    appendErrorMaxRetry: 3,\n    // used by buffer-controller\n    ignorePlaylistParsingErrors: false,\n    loader: XhrLoader,\n    // loader: FetchLoader,\n    fLoader: undefined,\n    // used by fragment-loader\n    pLoader: undefined,\n    // used by playlist-loader\n    xhrSetup: undefined,\n    // used by xhr-loader\n    licenseXhrSetup: undefined,\n    // used by eme-controller\n    licenseResponseCallback: undefined,\n    // used by eme-controller\n    abrController: AbrController,\n    bufferController: BufferController,\n    capLevelController: CapLevelController,\n    errorController: ErrorController,\n    fpsController: FPSController,\n    stretchShortVideoTrack: false,\n    // used by mp4-remuxer\n    maxAudioFramesDrift: 1,\n    // used by mp4-remuxer\n    forceKeyFrameOnDiscontinuity: true,\n    // used by ts-demuxer\n    abrEwmaFastLive: 3,\n    // used by abr-controller\n    abrEwmaSlowLive: 9,\n    // used by abr-controller\n    abrEwmaFastVoD: 3,\n    // used by abr-controller\n    abrEwmaSlowVoD: 9,\n    // used by abr-controller\n    abrEwmaDefaultEstimate: 5e5,\n    // 500 kbps  // used by abr-controller\n    abrEwmaDefaultEstimateMax: 5e6,\n    // 5 mbps\n    abrBandWidthFactor: 0.95,\n    // used by abr-controller\n    abrBandWidthUpFactor: 0.7,\n    // used by abr-controller\n    abrMaxWithRealBitrate: false,\n    // used by abr-controller\n    maxStarvationDelay: 4,\n    // used by abr-controller\n    maxLoadingDelay: 4,\n    // used by abr-controller\n    minAutoBitrate: 0,\n    // used by hls\n    emeEnabled: false,\n    // used by eme-controller\n    widevineLicenseUrl: undefined,\n    // used by eme-controller\n    drmSystems: {},\n    // used by eme-controller\n    drmSystemOptions: {},\n    // used by eme-controller\n    requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess ,\n    // used by eme-controller\n    requireKeySystemAccessOnStart: false,\n    // used by eme-controller\n    testBandwidth: true,\n    progressive: false,\n    lowLatencyMode: true,\n    cmcd: undefined,\n    enableDateRangeMetadataCues: true,\n    enableEmsgMetadataCues: true,\n    enableEmsgKLVMetadata: false,\n    enableID3MetadataCues: true,\n    enableInterstitialPlayback: true,\n    interstitialAppendInPlace: true,\n    interstitialLiveLookAhead: 10,\n    useMediaCapabilities: true,\n    preserveManualLevelOnError: false,\n    certLoadPolicy: {\n      default: defaultLoadPolicy\n    },\n    keyLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: 8000,\n        maxLoadTimeMs: 20000,\n        timeoutRetry: {\n          maxNumRetry: 1,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 20000,\n          backoff: 'linear'\n        },\n        errorRetry: {\n          maxNumRetry: 8,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 20000,\n          backoff: 'linear'\n        }\n      }\n    },\n    manifestLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: Infinity,\n        maxLoadTimeMs: 20000,\n        timeoutRetry: {\n          maxNumRetry: 2,\n          retryDelayMs: 0,\n          maxRetryDelayMs: 0\n        },\n        errorRetry: {\n          maxNumRetry: 1,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 8000\n        }\n      }\n    },\n    playlistLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: 10000,\n        maxLoadTimeMs: 20000,\n        timeoutRetry: {\n          maxNumRetry: 2,\n          retryDelayMs: 0,\n          maxRetryDelayMs: 0\n        },\n        errorRetry: {\n          maxNumRetry: 2,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 8000\n        }\n      }\n    },\n    fragLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: 10000,\n        maxLoadTimeMs: 120000,\n        timeoutRetry: {\n          maxNumRetry: 4,\n          retryDelayMs: 0,\n          maxRetryDelayMs: 0\n        },\n        errorRetry: {\n          maxNumRetry: 6,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 8000\n        }\n      }\n    },\n    steeringManifestLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: 10000,\n        maxLoadTimeMs: 20000,\n        timeoutRetry: {\n          maxNumRetry: 2,\n          retryDelayMs: 0,\n          maxRetryDelayMs: 0\n        },\n        errorRetry: {\n          maxNumRetry: 1,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 8000\n        }\n      } \n    },\n    interstitialAssetListLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: 10000,\n        maxLoadTimeMs: 30000,\n        timeoutRetry: {\n          maxNumRetry: 0,\n          retryDelayMs: 0,\n          maxRetryDelayMs: 0\n        },\n        errorRetry: {\n          maxNumRetry: 0,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 8000\n        }\n      } \n    },\n    // These default settings are deprecated in favor of the above policies\n    // and are maintained for backwards compatibility\n    manifestLoadingTimeOut: 10000,\n    manifestLoadingMaxRetry: 1,\n    manifestLoadingRetryDelay: 1000,\n    manifestLoadingMaxRetryTimeout: 64000,\n    levelLoadingTimeOut: 10000,\n    levelLoadingMaxRetry: 4,\n    levelLoadingRetryDelay: 1000,\n    levelLoadingMaxRetryTimeout: 64000,\n    fragLoadingTimeOut: 20000,\n    fragLoadingMaxRetry: 6,\n    fragLoadingRetryDelay: 1000,\n    fragLoadingMaxRetryTimeout: 64000\n  }, timelineConfig()), {}, {\n    subtitleStreamController: SubtitleStreamController ,\n    subtitleTrackController: SubtitleTrackController ,\n    timelineController: TimelineController ,\n    audioStreamController: AudioStreamController ,\n    audioTrackController: AudioTrackController ,\n    emeController: EMEController ,\n    cmcdController: CMCDController ,\n    contentSteeringController: ContentSteeringController ,\n    interstitialsController: InterstitialsController \n  });\n  function timelineConfig() {\n    return {\n      cueHandler: Cues,\n      // used by timeline-controller\n      enableWebVTT: true,\n      // used by timeline-controller\n      enableIMSC1: true,\n      // used by timeline-controller\n      enableCEA708Captions: true,\n      // used by timeline-controller\n      captionsTextTrack1Label: 'English',\n      // used by timeline-controller\n      captionsTextTrack1LanguageCode: 'en',\n      // used by timeline-controller\n      captionsTextTrack2Label: 'Spanish',\n      // used by timeline-controller\n      captionsTextTrack2LanguageCode: 'es',\n      // used by timeline-controller\n      captionsTextTrack3Label: 'Unknown CC',\n      // used by timeline-controller\n      captionsTextTrack3LanguageCode: '',\n      // used by timeline-controller\n      captionsTextTrack4Label: 'Unknown CC',\n      // used by timeline-controller\n      captionsTextTrack4LanguageCode: '',\n      // used by timeline-controller\n      renderTextTracksNatively: true\n    };\n  }\n\n  /**\n   * @ignore\n   */\n  function mergeConfig(defaultConfig, userConfig, logger) {\n    if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n      throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n    }\n    if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n      throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n    }\n    if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n      throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n    }\n    var defaultsCopy = deepCpy(defaultConfig);\n\n    // Backwards compatibility with deprecated config values\n    var deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n    var deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n    deprecatedSettingTypes.forEach(function (type) {\n      var policyName = (type === 'level' ? 'playlist' : type) + \"LoadPolicy\";\n      var policyNotSet = userConfig[policyName] === undefined;\n      var report = [];\n      deprecatedSettings.forEach(function (setting) {\n        var deprecatedSetting = type + \"Loading\" + setting;\n        var value = userConfig[deprecatedSetting];\n        if (value !== undefined && policyNotSet) {\n          report.push(deprecatedSetting);\n          var settings = defaultsCopy[policyName].default;\n          userConfig[policyName] = {\n            default: settings\n          };\n          switch (setting) {\n            case 'TimeOut':\n              settings.maxLoadTimeMs = value;\n              settings.maxTimeToFirstByteMs = value;\n              break;\n            case 'MaxRetry':\n              settings.errorRetry.maxNumRetry = value;\n              settings.timeoutRetry.maxNumRetry = value;\n              break;\n            case 'RetryDelay':\n              settings.errorRetry.retryDelayMs = value;\n              settings.timeoutRetry.retryDelayMs = value;\n              break;\n            case 'MaxRetryTimeout':\n              settings.errorRetry.maxRetryDelayMs = value;\n              settings.timeoutRetry.maxRetryDelayMs = value;\n              break;\n          }\n        }\n      });\n      if (report.length) {\n        logger.warn(\"hls.js config: \\\"\" + report.join('\", \"') + \"\\\" setting(s) are deprecated, use \\\"\" + policyName + \"\\\": \" + stringify(userConfig[policyName]));\n      }\n    });\n    return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n  }\n  function deepCpy(obj) {\n    if (obj && typeof obj === 'object') {\n      if (Array.isArray(obj)) {\n        return obj.map(deepCpy);\n      }\n      return Object.keys(obj).reduce(function (result, key) {\n        result[key] = deepCpy(obj[key]);\n        return result;\n      }, {});\n    }\n    return obj;\n  }\n\n  /**\n   * @ignore\n   */\n  function enableStreamingMode(config, logger) {\n    var currentLoader = config.loader;\n    if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n      // If a developer has configured their own loader, respect that choice\n      logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n      config.progressive = false;\n    } else {\n      var canStreamProgressively = fetchSupported();\n      if (canStreamProgressively) {\n        config.loader = FetchLoader;\n        config.progressive = true;\n        config.enableSoftwareAES = true;\n        logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n      }\n    }\n  }\n\n  var MAX_START_GAP_JUMP = 2.0;\n  var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\n  var SKIP_BUFFER_RANGE_START = 0.05;\n  var TICK_INTERVAL$1 = 100;\n  var GapController = /*#__PURE__*/function (_TaskLoop) {\n    function GapController(hls, fragmentTracker) {\n      var _this;\n      _this = _TaskLoop.call(this, 'gap-controller', hls.logger) || this;\n      _this.hls = void 0;\n      _this.fragmentTracker = void 0;\n      _this.media = null;\n      _this.mediaSource = void 0;\n      _this.nudgeRetry = 0;\n      _this.stallReported = false;\n      _this.stalled = null;\n      _this.moved = false;\n      _this.seeking = false;\n      _this.buffered = {};\n      _this.lastCurrentTime = 0;\n      _this.ended = 0;\n      _this.waiting = 0;\n      _this.onMediaPlaying = function () {\n        _this.ended = 0;\n        _this.waiting = 0;\n      };\n      _this.onMediaWaiting = function () {\n        var _this$media;\n        if ((_this$media = _this.media) != null && _this$media.seeking) {\n          return;\n        }\n        _this.waiting = self.performance.now();\n        _this.tick();\n      };\n      _this.onMediaEnded = function () {\n        if (_this.hls) {\n          var _this$media2;\n          // ended is set when triggering MEDIA_ENDED so that we do not trigger it again on stall or on tick with media.ended\n          _this.ended = ((_this$media2 = _this.media) == null ? void 0 : _this$media2.currentTime) || 1;\n          _this.hls.trigger(Events.MEDIA_ENDED, {\n            stalled: false\n          });\n        }\n      };\n      _this.hls = hls;\n      _this.fragmentTracker = fragmentTracker;\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(GapController, _TaskLoop);\n    var _proto = GapController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      if (hls) {\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n      }\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      if (hls) {\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n      }\n    };\n    _proto.destroy = function destroy() {\n      _TaskLoop.prototype.destroy.call(this);\n      this.unregisterListeners();\n      this.media = this.hls = this.fragmentTracker = null;\n      this.mediaSource = undefined;\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      this.setInterval(TICK_INTERVAL$1);\n      this.mediaSource = data.mediaSource;\n      var media = this.media = data.media;\n      addEventListener(media, 'playing', this.onMediaPlaying);\n      addEventListener(media, 'waiting', this.onMediaWaiting);\n      addEventListener(media, 'ended', this.onMediaEnded);\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      this.clearInterval();\n      var media = this.media;\n      if (media) {\n        removeEventListener(media, 'playing', this.onMediaPlaying);\n        removeEventListener(media, 'waiting', this.onMediaWaiting);\n        removeEventListener(media, 'ended', this.onMediaEnded);\n        this.media = null;\n      }\n      this.mediaSource = undefined;\n    };\n    _proto.onBufferAppended = function onBufferAppended(event, data) {\n      this.buffered = data.timeRanges;\n    };\n    _proto.tick = function tick() {\n      var _this$media3;\n      if (!((_this$media3 = this.media) != null && _this$media3.readyState) || !this.hasBuffered) {\n        return;\n      }\n      var currentTime = this.media.currentTime;\n      this.poll(currentTime, this.lastCurrentTime);\n      this.lastCurrentTime = currentTime;\n    }\n\n    /**\n     * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n     * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n     *\n     * @param lastCurrentTime - Previously read playhead position\n     */;\n    _proto.poll = function poll(currentTime, lastCurrentTime) {\n      var _this$hls, _this$hls2;\n      var config = (_this$hls = this.hls) == null ? void 0 : _this$hls.config;\n      if (!config) {\n        return;\n      }\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      var seeking = media.seeking;\n      var seeked = this.seeking && !seeking;\n      var beginSeek = !this.seeking && seeking;\n      var pausedEndedOrHalted = media.paused && !seeking || media.ended || media.playbackRate === 0;\n      this.seeking = seeking;\n\n      // The playhead is moving, no-op\n      if (currentTime !== lastCurrentTime) {\n        if (lastCurrentTime) {\n          this.ended = 0;\n        }\n        this.moved = true;\n        if (!seeking) {\n          this.nudgeRetry = 0;\n          // When crossing between buffered video time ranges, but not audio, flush pipeline with seek (Chrome)\n          if (config.nudgeOnVideoHole && !pausedEndedOrHalted && currentTime > lastCurrentTime) {\n            this.nudgeOnVideoHole(currentTime, lastCurrentTime);\n          }\n        }\n        if (this.waiting === 0) {\n          this.stallResolved(currentTime);\n        }\n        return;\n      }\n\n      // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n      if (beginSeek || seeked) {\n        if (seeked) {\n          this.stallResolved(currentTime);\n        }\n        return;\n      }\n\n      // The playhead should not be moving\n      if (pausedEndedOrHalted) {\n        this.nudgeRetry = 0;\n        this.stallResolved(currentTime);\n        // Fire MEDIA_ENDED to workaround event not being dispatched by browser\n        if (!this.ended && media.ended && this.hls) {\n          this.ended = currentTime || 1;\n          this.hls.trigger(Events.MEDIA_ENDED, {\n            stalled: false\n          });\n        }\n        return;\n      }\n      if (!BufferHelper.getBuffered(media).length) {\n        this.nudgeRetry = 0;\n        return;\n      }\n\n      // Resolve stalls at buffer holes using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n      var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n      var nextStart = bufferInfo.nextStart || 0;\n      var fragmentTracker = this.fragmentTracker;\n      if (seeking && fragmentTracker && this.hls) {\n        // Is there a fragment loading/parsing/appending before currentTime?\n        var inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, currentTime);\n\n        // Waiting for seeking in a buffered range to complete\n        var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n        // Next buffered range is too far ahead to jump to while still seeking\n        var noBufferHole = !nextStart || inFlightDependency || nextStart - currentTime > MAX_START_GAP_JUMP && !fragmentTracker.getPartialFragment(currentTime);\n        if (hasEnoughBuffer || noBufferHole) {\n          return;\n        }\n        // Reset moved state when seeking to a point in or before a gap/hole\n        this.moved = false;\n      }\n\n      // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n      // The addition poll gives the browser a chance to jump the gap for us\n      var levelDetails = (_this$hls2 = this.hls) == null ? void 0 : _this$hls2.latestLevelDetails;\n      if (!this.moved && this.stalled !== null && fragmentTracker) {\n        // There is no playable buffer (seeked, waiting for buffer)\n        var isBuffered = bufferInfo.len > 0;\n        if (!isBuffered && !nextStart) {\n          return;\n        }\n        // Jump start gaps within jump threshold\n        var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n        // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n        // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n        // that begins over 1 target duration after the video start position.\n        var isLive = !!(levelDetails != null && levelDetails.live);\n        var maxStartGapJump = isLive ? levelDetails.targetduration * 2 : MAX_START_GAP_JUMP;\n        var appended = appendedFragAtPosition(currentTime, fragmentTracker);\n        if (startJump > 0 && (startJump <= maxStartGapJump || appended)) {\n          if (!media.paused) {\n            this._trySkipBufferHole(appended);\n          }\n          return;\n        }\n      }\n\n      // Start tracking stall time\n      var detectStallWithCurrentTimeMs = config.detectStallWithCurrentTimeMs;\n      var tnow = self.performance.now();\n      var tWaiting = this.waiting;\n      var stalled = this.stalled;\n      if (stalled === null) {\n        // Use time of recent \"waiting\" event\n        if (tWaiting > 0 && tnow - tWaiting < detectStallWithCurrentTimeMs) {\n          stalled = this.stalled = tWaiting;\n        } else {\n          this.stalled = tnow;\n          return;\n        }\n      }\n      var stalledDuration = tnow - stalled;\n      if (!seeking && (stalledDuration >= detectStallWithCurrentTimeMs || tWaiting) && this.hls) {\n        var _this$mediaSource;\n        // Dispatch MEDIA_ENDED when media.ended/ended event is not signalled at end of stream\n        if (((_this$mediaSource = this.mediaSource) == null ? void 0 : _this$mediaSource.readyState) === 'ended' && !(levelDetails != null && levelDetails.live) && Math.abs(currentTime - ((levelDetails == null ? void 0 : levelDetails.edge) || 0)) < 1) {\n          if (this.ended) {\n            return;\n          }\n          this.ended = currentTime || 1;\n          this.hls.trigger(Events.MEDIA_ENDED, {\n            stalled: true\n          });\n          return;\n        }\n        // Report stalling after trying to fix\n        this._reportStall(bufferInfo);\n        if (!this.media || !this.hls) {\n          return;\n        }\n      }\n      var bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n      this._tryFixBufferStall(bufferedWithHoles, stalledDuration, currentTime);\n    };\n    _proto.stallResolved = function stallResolved(currentTime) {\n      var stalled = this.stalled;\n      if (stalled && this.hls) {\n        this.stalled = null;\n        // The playhead is now moving, but was previously stalled\n        if (this.stallReported) {\n          var stalledDuration = self.performance.now() - stalled;\n          this.log(\"playback not stuck anymore @\" + currentTime + \", after \" + Math.round(stalledDuration) + \"ms\");\n          this.stallReported = false;\n          this.waiting = 0;\n          this.hls.trigger(Events.STALL_RESOLVED, {});\n        }\n      }\n    };\n    _proto.nudgeOnVideoHole = function nudgeOnVideoHole(currentTime, lastCurrentTime) {\n      var _this$buffered$audio;\n      // Chrome will play one second past a hole in video buffered time ranges without rendering any video from the subsequent range and then stall as long as audio is buffered:\n      // https://github.com/video-dev/hls.js/issues/5631\n      // https://issues.chromium.org/issues/40280613#comment10\n      // Detect the potential for this situation and proactively seek to flush the video pipeline once the playhead passes the start of the video hole.\n      // When there are audio and video buffers and currentTime is past the end of the first video buffered range...\n      var videoSourceBuffered = this.buffered.video;\n      if (this.hls && this.media && this.fragmentTracker && (_this$buffered$audio = this.buffered.audio) != null && _this$buffered$audio.length && videoSourceBuffered && videoSourceBuffered.length > 1 && currentTime > videoSourceBuffered.end(0)) {\n        // and audio is buffered at the playhead\n        var audioBufferInfo = BufferHelper.bufferedInfo(BufferHelper.timeRangesToArray(this.buffered.audio), currentTime, 0);\n        if (audioBufferInfo.len > 1 && lastCurrentTime >= audioBufferInfo.start) {\n          var videoTimes = BufferHelper.timeRangesToArray(videoSourceBuffered);\n          var lastBufferedIndex = BufferHelper.bufferedInfo(videoTimes, lastCurrentTime, 0).bufferedIndex;\n          // nudge when crossing into another video buffered range (hole).\n          if (lastBufferedIndex > -1 && lastBufferedIndex < videoTimes.length - 1) {\n            var bufferedIndex = BufferHelper.bufferedInfo(videoTimes, currentTime, 0).bufferedIndex;\n            var holeStart = videoTimes[lastBufferedIndex].end;\n            var holeEnd = videoTimes[lastBufferedIndex + 1].start;\n            if ((bufferedIndex === -1 || bufferedIndex > lastBufferedIndex) && holeEnd - holeStart < 1 &&\n            // `maxBufferHole` may be too small and setting it to 0 should not disable this feature\n            currentTime - holeStart < 2) {\n              var error = new Error(\"nudging playhead to flush pipeline after video hole. currentTime: \" + currentTime + \" hole: \" + holeStart + \" -> \" + holeEnd + \" buffered index: \" + bufferedIndex);\n              this.warn(error.message);\n              // Magic number to flush the pipeline without interuption to audio playback:\n              this.media.currentTime += 0.000001;\n              var frag = appendedFragAtPosition(currentTime, this.fragmentTracker);\n              if (frag && 'fragment' in frag) {\n                frag = frag.fragment;\n              } else if (!frag) {\n                frag = undefined;\n              }\n              var bufferInfo = BufferHelper.bufferInfo(this.media, currentTime, 0);\n              this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n                fatal: false,\n                error: error,\n                reason: error.message,\n                frag: frag,\n                buffer: bufferInfo.len,\n                bufferInfo: bufferInfo\n              });\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Detects and attempts to fix known buffer stalling issues.\n     * @param bufferInfo - The properties of the current buffer.\n     * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n     * @private\n     */;\n    _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs, currentTime) {\n      var _this$hls3, _this$hls4;\n      var fragmentTracker = this.fragmentTracker,\n        media = this.media;\n      var config = (_this$hls3 = this.hls) == null ? void 0 : _this$hls3.config;\n      if (!media || !fragmentTracker || !config) {\n        return;\n      }\n      var levelDetails = (_this$hls4 = this.hls) == null ? void 0 : _this$hls4.latestLevelDetails;\n      var appended = appendedFragAtPosition(currentTime, fragmentTracker);\n      if (appended || levelDetails != null && levelDetails.live && currentTime < levelDetails.fragmentStart) {\n        // Try to skip over the buffer hole caused by a partial fragment\n        // This method isn't limited by the size of the gap between buffered ranges\n        var targetTime = this._trySkipBufferHole(appended);\n        // we return here in this case, meaning\n        // the branch below only executes when we haven't seeked to a new position\n        if (targetTime || !this.media) {\n          return;\n        }\n      }\n\n      // if we haven't had to skip over a buffer hole of a partial fragment\n      // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n      // needs to cross some sort of threshold covering all source-buffers content\n      // to start playing properly.\n      var bufferedRanges = bufferInfo.buffered;\n      var adjacentTraversal = this.adjacentTraversal(bufferInfo, currentTime);\n      if ((bufferedRanges && bufferedRanges.length > 1 && bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && (bufferInfo.nextStart - currentTime < config.maxBufferHole || adjacentTraversal)) && (stalledDurationMs > config.highBufferWatchdogPeriod * 1000 || this.waiting)) {\n        this.warn('Trying to nudge playhead over buffer-hole');\n        // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n        // We only try to jump the hole if it's under the configured size\n        this._tryNudgeBuffer(bufferInfo);\n      }\n    };\n    _proto.adjacentTraversal = function adjacentTraversal(bufferInfo, currentTime) {\n      var fragmentTracker = this.fragmentTracker;\n      var nextStart = bufferInfo.nextStart;\n      if (fragmentTracker && nextStart) {\n        var current = fragmentTracker.getFragAtPos(currentTime, PlaylistLevelType.MAIN);\n        var next = fragmentTracker.getFragAtPos(nextStart, PlaylistLevelType.MAIN);\n        if (current && next) {\n          return next.sn - current.sn < 2;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n     * @param bufferLen - The playhead distance from the end of the current buffer segment.\n     * @private\n     */;\n    _proto._reportStall = function _reportStall(bufferInfo) {\n      var hls = this.hls,\n        media = this.media,\n        stallReported = this.stallReported,\n        stalled = this.stalled;\n      if (!stallReported && stalled !== null && media && hls) {\n        // Report stalled error once\n        this.stallReported = true;\n        var error = new Error(\"Playback stalling at @\" + media.currentTime + \" due to low buffer (\" + stringify(bufferInfo) + \")\");\n        this.warn(error.message);\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_STALLED_ERROR,\n          fatal: false,\n          error: error,\n          buffer: bufferInfo.len,\n          bufferInfo: bufferInfo,\n          stalled: {\n            start: stalled\n          }\n        });\n      }\n    }\n\n    /**\n     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n     * @param appended - The fragment or part found at the current time (where playback is stalling).\n     * @private\n     */;\n    _proto._trySkipBufferHole = function _trySkipBufferHole(appended) {\n      var _this$hls5;\n      var fragmentTracker = this.fragmentTracker,\n        media = this.media;\n      var config = (_this$hls5 = this.hls) == null ? void 0 : _this$hls5.config;\n      if (!media || !fragmentTracker || !config) {\n        return 0;\n      }\n\n      // Check if currentTime is between unbuffered regions of partial fragments\n      var currentTime = media.currentTime;\n      var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n      var startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n      if (startTime && this.hls) {\n        var bufferStarved = bufferInfo.len <= config.maxBufferHole;\n        var waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n        var gapLength = startTime - currentTime;\n        if (gapLength > 0 && (bufferStarved || waiting)) {\n          // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n          if (gapLength > config.maxBufferHole) {\n            var startGap = false;\n            if (currentTime === 0) {\n              var startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n              if (startFrag && startTime < startFrag.end) {\n                startGap = true;\n              }\n            }\n            if (!startGap && appended) {\n              var _this$hls$loadLevelOb;\n              // Do not seek when selected variant playlist is unloaded\n              if (!((_this$hls$loadLevelOb = this.hls.loadLevelObj) != null && _this$hls$loadLevelOb.details)) {\n                return 0;\n              }\n              // Do not seek when required fragments are inflight or appending\n              var inFlightDependency = getInFlightDependency(this.hls.inFlightFragments, startTime);\n              if (inFlightDependency) {\n                return 0;\n              }\n              // Do not seek if we can't walk tracked fragments to end of gap\n              var moreToLoad = false;\n              var pos = appended.end;\n              while (pos < startTime) {\n                var provisioned = appendedFragAtPosition(pos, fragmentTracker);\n                if (provisioned) {\n                  pos += provisioned.duration;\n                } else {\n                  moreToLoad = true;\n                  break;\n                }\n              }\n              if (moreToLoad) {\n                return 0;\n              }\n            }\n          }\n          var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n          this.warn(\"skipping hole, adjusting currentTime from \" + currentTime + \" to \" + targetTime);\n          this.moved = true;\n          media.currentTime = targetTime;\n          if (!(appended != null && appended.gap)) {\n            var error = new Error(\"fragment loaded with buffer holes, seeking from \" + currentTime + \" to \" + targetTime);\n            var errorData = {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n              fatal: false,\n              error: error,\n              reason: error.message,\n              buffer: bufferInfo.len,\n              bufferInfo: bufferInfo\n            };\n            if (appended) {\n              if ('fragment' in appended) {\n                errorData.part = appended;\n              } else {\n                errorData.frag = appended;\n              }\n            }\n            this.hls.trigger(Events.ERROR, errorData);\n          }\n          return targetTime;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n     * @private\n     */;\n    _proto._tryNudgeBuffer = function _tryNudgeBuffer(bufferInfo) {\n      var hls = this.hls,\n        media = this.media,\n        nudgeRetry = this.nudgeRetry;\n      var config = hls == null ? void 0 : hls.config;\n      if (!media || !config) {\n        return 0;\n      }\n      var currentTime = media.currentTime;\n      this.nudgeRetry++;\n      if (nudgeRetry < config.nudgeMaxRetry) {\n        var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n        // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n        var error = new Error(\"Nudging 'currentTime' from \" + currentTime + \" to \" + targetTime);\n        this.warn(error.message);\n        media.currentTime = targetTime;\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n          error: error,\n          fatal: false,\n          buffer: bufferInfo.len,\n          bufferInfo: bufferInfo\n        });\n      } else {\n        var _error = new Error(\"Playhead still not moving while enough data buffered @\" + currentTime + \" after \" + config.nudgeMaxRetry + \" nudges\");\n        this.error(_error.message);\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_STALLED_ERROR,\n          error: _error,\n          fatal: true,\n          buffer: bufferInfo.len,\n          bufferInfo: bufferInfo\n        });\n      }\n    };\n    return _createClass(GapController, [{\n      key: \"hasBuffered\",\n      get: function get() {\n        return Object.keys(this.buffered).length > 0;\n      }\n    }]);\n  }(TaskLoop);\n  function getInFlightDependency(inFlightFragments, currentTime) {\n    var main = inFlight(inFlightFragments.main);\n    if (main && main.start <= currentTime) {\n      return main;\n    }\n    var audio = inFlight(inFlightFragments.audio);\n    if (audio && audio.start <= currentTime) {\n      return audio;\n    }\n    return null;\n  }\n  function inFlight(inFlightData) {\n    if (!inFlightData) {\n      return null;\n    }\n    switch (inFlightData.state) {\n      case State.IDLE:\n      case State.STOPPED:\n      case State.ENDED:\n      case State.ERROR:\n        return null;\n    }\n    return inFlightData.frag;\n  }\n  function appendedFragAtPosition(pos, fragmentTracker) {\n    return fragmentTracker.getAppendedFrag(pos, PlaylistLevelType.MAIN) || fragmentTracker.getPartialFragment(pos);\n  }\n\n  var MIN_CUE_DURATION = 0.25;\n  function getCueClass() {\n    if (typeof self === 'undefined') return undefined;\n    return self.VTTCue || self.TextTrackCue;\n  }\n  function createCueWithDataFields(Cue, startTime, endTime, data, type) {\n    var cue = new Cue(startTime, endTime, '');\n    try {\n      cue.value = data;\n      if (type) {\n        cue.type = type;\n      }\n    } catch (e) {\n      cue = new Cue(startTime, endTime, stringify(type ? _objectSpread2({\n        type: type\n      }, data) : data));\n    }\n    return cue;\n  }\n\n  // VTTCue latest draft allows an infinite duration, fallback\n  // to MAX_VALUE if necessary\n  var MAX_CUE_ENDTIME = function () {\n    var Cue = getCueClass();\n    try {\n      Cue && new Cue(0, Number.POSITIVE_INFINITY, '');\n    } catch (e) {\n      return Number.MAX_VALUE;\n    }\n    return Number.POSITIVE_INFINITY;\n  }();\n  var ID3TrackController = /*#__PURE__*/function () {\n    function ID3TrackController(hls) {\n      var _this = this;\n      this.hls = void 0;\n      this.id3Track = null;\n      this.media = null;\n      this.dateRangeCuesAppended = {};\n      this.removeCues = true;\n      this.assetCue = void 0;\n      this.onEventCueEnter = function () {\n        if (!_this.hls) {\n          return;\n        }\n        _this.hls.trigger(Events.EVENT_CUE_ENTER, {});\n      };\n      this.hls = hls;\n      this._registerListeners();\n    }\n    var _proto = ID3TrackController.prototype;\n    _proto.destroy = function destroy() {\n      this._unregisterListeners();\n      this.id3Track = null;\n      this.media = null;\n      this.dateRangeCuesAppended = {};\n      // @ts-ignore\n      this.hls = this.onEventCueEnter = null;\n    };\n    _proto._registerListeners = function _registerListeners() {\n      var hls = this.hls;\n      if (hls) {\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.on(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);\n      }\n    };\n    _proto._unregisterListeners = function _unregisterListeners() {\n      var hls = this.hls;\n      if (hls) {\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.off(Events.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);\n      }\n    };\n    // Add ID3 metatadata text track.\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      var _data$overrides;\n      this.media = data.media;\n      if (((_data$overrides = data.overrides) == null ? void 0 : _data$overrides.cueRemoval) === false) {\n        this.removeCues = false;\n      }\n    };\n    _proto.onMediaAttached = function onMediaAttached() {\n      var _this$hls;\n      var details = (_this$hls = this.hls) == null ? void 0 : _this$hls.latestLevelDetails;\n      if (details) {\n        this.updateDateRangeCues(details);\n      }\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      this.media = null;\n      var transferringMedia = !!data.transferMedia;\n      if (transferringMedia) {\n        return;\n      }\n      if (this.id3Track) {\n        if (this.removeCues) {\n          clearCurrentCues(this.id3Track, this.onEventCueEnter);\n        }\n        this.id3Track = null;\n      }\n      this.dateRangeCuesAppended = {};\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.dateRangeCuesAppended = {};\n    };\n    _proto.createTrack = function createTrack(media) {\n      var track = this.getID3Track(media.textTracks);\n      track.mode = 'hidden';\n      return track;\n    };\n    _proto.getID3Track = function getID3Track(textTracks) {\n      if (!this.media) {\n        return;\n      }\n      for (var i = 0; i < textTracks.length; i++) {\n        var textTrack = textTracks[i];\n        if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n          // send 'addtrack' when reusing the textTrack for metadata,\n          // same as what we do for captions\n          sendAddTrackEvent(textTrack, this.media);\n          return textTrack;\n        }\n      }\n      return this.media.addTextTrack('metadata', 'id3');\n    };\n    _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {\n      if (!this.media || !this.hls) {\n        return;\n      }\n      var _this$hls$config = this.hls.config,\n        enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues,\n        enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;\n      if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n        return;\n      }\n      var samples = data.samples;\n\n      // create track dynamically\n      if (!this.id3Track) {\n        this.id3Track = this.createTrack(this.media);\n      }\n      var Cue = getCueClass();\n      if (!Cue) {\n        return;\n      }\n      for (var i = 0; i < samples.length; i++) {\n        var type = samples[i].type;\n        if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n          continue;\n        }\n        var frames = getId3Frames(samples[i].data);\n        var startTime = samples[i].pts;\n        var endTime = startTime + samples[i].duration;\n        if (endTime > MAX_CUE_ENDTIME) {\n          endTime = MAX_CUE_ENDTIME;\n        }\n        var timeDiff = endTime - startTime;\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n        for (var j = 0; j < frames.length; j++) {\n          var frame = frames[j];\n          // Safari doesn't put the timestamp frame in the TextTrack\n          if (!isId3TimestampFrame(frame)) {\n            // add a bounds to any unbounded cues\n            this.updateId3CueEnds(startTime, type);\n            var cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);\n            if (cue) {\n              this.id3Track.addCue(cue);\n            }\n          }\n        }\n      }\n    };\n    _proto.updateId3CueEnds = function updateId3CueEnds(startTime, type) {\n      var _this$id3Track;\n      var cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n      if (cues) {\n        for (var i = cues.length; i--;) {\n          var cue = cues[i];\n          if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n            cue.endTime = startTime;\n          }\n        }\n      }\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {\n      var startOffset = _ref.startOffset,\n        endOffset = _ref.endOffset,\n        type = _ref.type;\n      var id3Track = this.id3Track,\n        hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      var _hls$config = hls.config,\n        enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues,\n        enableID3MetadataCues = _hls$config.enableID3MetadataCues;\n      if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n        var predicate;\n        if (type === 'audio') {\n          predicate = function predicate(cue) {\n            return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n          };\n        } else if (type === 'video') {\n          predicate = function predicate(cue) {\n            return cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n          };\n        } else {\n          predicate = function predicate(cue) {\n            return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n          };\n        }\n        removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n      }\n    };\n    _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {\n      var details = _ref2.details;\n      this.updateDateRangeCues(details, true);\n    };\n    _proto.onLevelPtsUpdated = function onLevelPtsUpdated(event, data) {\n      if (Math.abs(data.drift) > 0.01) {\n        this.updateDateRangeCues(data.details);\n      }\n    };\n    _proto.updateDateRangeCues = function updateDateRangeCues(details, removeOldCues) {\n      var _this2 = this;\n      if (!this.hls || !this.media) {\n        return;\n      }\n      var _this$hls$config2 = this.hls.config,\n        assetPlayerId = _this$hls$config2.assetPlayerId,\n        timelineOffset = _this$hls$config2.timelineOffset,\n        enableDateRangeMetadataCues = _this$hls$config2.enableDateRangeMetadataCues,\n        interstitialsController = _this$hls$config2.interstitialsController;\n      if (!enableDateRangeMetadataCues) {\n        return;\n      }\n      var Cue = getCueClass();\n      if (assetPlayerId && timelineOffset && !interstitialsController) {\n        var fragmentStart = details.fragmentStart,\n          fragmentEnd = details.fragmentEnd;\n        var cue = this.assetCue;\n        if (cue) {\n          cue.startTime = fragmentStart;\n          cue.endTime = fragmentEnd;\n        } else if (Cue) {\n          cue = this.assetCue = createCueWithDataFields(Cue, fragmentStart, fragmentEnd, {\n            assetPlayerId: this.hls.config.assetPlayerId\n          }, 'hlsjs.interstitial.asset');\n          if (cue) {\n            cue.id = assetPlayerId;\n            this.id3Track || (this.id3Track = this.createTrack(this.media));\n            this.id3Track.addCue(cue);\n            cue.addEventListener('enter', this.onEventCueEnter);\n          }\n        }\n      }\n      if (!details.hasProgramDateTime) {\n        return;\n      }\n      var id3Track = this.id3Track;\n      var dateRanges = details.dateRanges;\n      var ids = Object.keys(dateRanges);\n      var dateRangeCuesAppended = this.dateRangeCuesAppended;\n      // Remove cues from track not found in details.dateRanges\n      if (id3Track && removeOldCues) {\n        var _id3Track$cues;\n        if ((_id3Track$cues = id3Track.cues) != null && _id3Track$cues.length) {\n          var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function (id) {\n            return !ids.includes(id);\n          });\n          var _loop = function _loop() {\n            var _dateRangeCuesAppende;\n            var id = idsToRemove[i];\n            var cues = (_dateRangeCuesAppende = dateRangeCuesAppended[id]) == null ? void 0 : _dateRangeCuesAppende.cues;\n            delete dateRangeCuesAppended[id];\n            if (cues) {\n              Object.keys(cues).forEach(function (key) {\n                var cue = cues[key];\n                if (cue) {\n                  cue.removeEventListener('enter', _this2.onEventCueEnter);\n                  try {\n                    id3Track.removeCue(cue);\n                  } catch (e) {\n                    /* no-op */\n                  }\n                }\n              });\n            }\n          };\n          for (var i = idsToRemove.length; i--;) {\n            _loop();\n          }\n        } else {\n          dateRangeCuesAppended = this.dateRangeCuesAppended = {};\n        }\n      }\n      // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n      var lastFragment = details.fragments[details.fragments.length - 1];\n      if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n        return;\n      }\n      this.id3Track || (this.id3Track = this.createTrack(this.media));\n      var _loop2 = function _loop2() {\n        var id = ids[_i];\n        var dateRange = dateRanges[id];\n        var startTime = dateRange.startTime;\n\n        // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)\n        var appendedDateRangeCues = dateRangeCuesAppended[id];\n        var cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n        var durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n        var endTime = MAX_CUE_ENDTIME;\n        var duration = dateRange.duration,\n          endDate = dateRange.endDate;\n        if (endDate && duration !== null) {\n          endTime = startTime + duration;\n          durationKnown = true;\n        } else if (dateRange.endOnNext && !durationKnown) {\n          var nextDateRangeWithSameClass = ids.reduce(function (candidateDateRange, id) {\n            if (id !== dateRange.id) {\n              var otherDateRange = dateRanges[id];\n              if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {\n                return otherDateRange;\n              }\n            }\n            return candidateDateRange;\n          }, null);\n          if (nextDateRangeWithSameClass) {\n            endTime = nextDateRangeWithSameClass.startTime;\n            durationKnown = true;\n          }\n        }\n\n        // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)\n        // This is to emulate Safari HLS playback handling of DateRange tags\n        var attributes = Object.keys(dateRange.attr);\n        for (var j = 0; j < attributes.length; j++) {\n          var key = attributes[j];\n          if (!isDateRangeCueAttribute(key)) {\n            continue;\n          }\n          var _cue = cues[key];\n          if (_cue) {\n            if (durationKnown && !(appendedDateRangeCues != null && appendedDateRangeCues.durationKnown)) {\n              _cue.endTime = endTime;\n            } else if (Math.abs(_cue.startTime - startTime) > 0.01) {\n              _cue.startTime = startTime;\n              _cue.endTime = endTime;\n            }\n          } else if (Cue) {\n            var data = dateRange.attr[key];\n            if (isSCTE35Attribute(key)) {\n              data = hexToArrayBuffer(data);\n            }\n            var payload = {\n              key: key,\n              data: data\n            };\n            var _cue2 = createCueWithDataFields(Cue, startTime, endTime, payload, MetadataSchema.dateRange);\n            if (_cue2) {\n              _cue2.id = id;\n              _this2.id3Track.addCue(_cue2);\n              cues[key] = _cue2;\n              if (interstitialsController) {\n                if (key === 'X-ASSET-LIST' || key === 'X-ASSET-URL') {\n                  _cue2.addEventListener('enter', _this2.onEventCueEnter);\n                }\n              }\n            }\n          }\n        }\n\n        // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes\n        dateRangeCuesAppended[id] = {\n          cues: cues,\n          dateRange: dateRange,\n          durationKnown: durationKnown\n        };\n      };\n      for (var _i = 0; _i < ids.length; _i++) {\n        _loop2();\n      }\n    };\n    return ID3TrackController;\n  }();\n\n  var LatencyController = /*#__PURE__*/function () {\n    function LatencyController(hls) {\n      var _this = this;\n      this.hls = void 0;\n      this.config = void 0;\n      this.media = null;\n      this.currentTime = 0;\n      this.stallCount = 0;\n      this._latency = null;\n      this._targetLatencyUpdated = false;\n      this.onTimeupdate = function () {\n        var media = _this.media;\n        var levelDetails = _this.levelDetails;\n        if (!media || !levelDetails) {\n          return;\n        }\n        _this.currentTime = media.currentTime;\n        var latency = _this.computeLatency();\n        if (latency === null) {\n          return;\n        }\n        _this._latency = latency;\n\n        // Adapt playbackRate to meet target latency in low-latency mode\n        var _this$config = _this.config,\n          lowLatencyMode = _this$config.lowLatencyMode,\n          maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;\n        if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {\n          return;\n        }\n        var targetLatency = _this.targetLatency;\n        if (targetLatency === null) {\n          return;\n        }\n        var distanceFromTarget = latency - targetLatency;\n        // Only adjust playbackRate when within one target duration of targetLatency\n        // and more than one second from under-buffering.\n        // Playback further than one target duration from target can be considered DVR playback.\n        var liveMinLatencyDuration = Math.min(_this.maxLatency, targetLatency + levelDetails.targetduration);\n        var inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n        if (inLiveRange && distanceFromTarget > 0.05 && _this.forwardBufferLength > 1) {\n          var max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n          var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - _this.edgeStalled)) * 20) / 20;\n          var playbackRate = Math.min(max, Math.max(1, rate));\n          _this.changeMediaPlaybackRate(media, playbackRate);\n        } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n          _this.changeMediaPlaybackRate(media, 1);\n        }\n      };\n      this.hls = hls;\n      this.config = hls.config;\n      this.registerListeners();\n    }\n    var _proto = LatencyController.prototype;\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.onMediaDetaching();\n      this.hls = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      this.media = data.media;\n      this.media.addEventListener('timeupdate', this.onTimeupdate);\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      if (this.media) {\n        this.media.removeEventListener('timeupdate', this.onTimeupdate);\n        this.media = null;\n      }\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this._latency = null;\n      this.stallCount = 0;\n    };\n    _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n      var details = _ref.details;\n      if (details.advanced) {\n        this.onTimeupdate();\n      }\n      if (!details.live && this.media) {\n        this.media.removeEventListener('timeupdate', this.onTimeupdate);\n      }\n    };\n    _proto.onError = function onError(event, data) {\n      var _this$levelDetails;\n      if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n        return;\n      }\n      this.stallCount++;\n      if (this.hls && (_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n        this.hls.logger.warn('[latency-controller]: Stall detected, adjusting target latency');\n      }\n    };\n    _proto.changeMediaPlaybackRate = function changeMediaPlaybackRate(media, playbackRate) {\n      var _this$hls, _this$targetLatency;\n      if (media.playbackRate === playbackRate) {\n        return;\n      }\n      (_this$hls = this.hls) == null || _this$hls.logger.debug(\"[latency-controller]: latency=\" + this.latency.toFixed(3) + \", targetLatency=\" + ((_this$targetLatency = this.targetLatency) == null ? void 0 : _this$targetLatency.toFixed(3)) + \", forwardBufferLength=\" + this.forwardBufferLength.toFixed(3) + \": adjusting playback rate from \" + media.playbackRate + \" to \" + playbackRate);\n      media.playbackRate = playbackRate;\n    };\n    _proto.estimateLiveEdge = function estimateLiveEdge() {\n      var levelDetails = this.levelDetails;\n      if (levelDetails === null) {\n        return null;\n      }\n      return levelDetails.edge + levelDetails.age;\n    };\n    _proto.computeLatency = function computeLatency() {\n      var liveEdge = this.estimateLiveEdge();\n      if (liveEdge === null) {\n        return null;\n      }\n      return liveEdge - this.currentTime;\n    };\n    return _createClass(LatencyController, [{\n      key: \"levelDetails\",\n      get: function get() {\n        var _this$hls2;\n        return ((_this$hls2 = this.hls) == null ? void 0 : _this$hls2.latestLevelDetails) || null;\n      }\n    }, {\n      key: \"latency\",\n      get: function get() {\n        return this._latency || 0;\n      }\n    }, {\n      key: \"maxLatency\",\n      get: function get() {\n        var config = this.config;\n        if (config.liveMaxLatencyDuration !== undefined) {\n          return config.liveMaxLatencyDuration;\n        }\n        var levelDetails = this.levelDetails;\n        return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n      }\n    }, {\n      key: \"targetLatency\",\n      get: function get() {\n        var levelDetails = this.levelDetails;\n        if (levelDetails === null || this.hls === null) {\n          return null;\n        }\n        var holdBack = levelDetails.holdBack,\n          partHoldBack = levelDetails.partHoldBack,\n          targetduration = levelDetails.targetduration;\n        var _this$config2 = this.config,\n          liveSyncDuration = _this$config2.liveSyncDuration,\n          liveSyncDurationCount = _this$config2.liveSyncDurationCount,\n          lowLatencyMode = _this$config2.lowLatencyMode;\n        var userConfig = this.hls.userConfig;\n        var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n        if (this._targetLatencyUpdated || userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n          targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n        }\n        var maxLiveSyncOnStallIncrease = targetduration;\n        return targetLatency + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n      },\n      set: function set(latency) {\n        this.stallCount = 0;\n        this.config.liveSyncDuration = latency;\n        this._targetLatencyUpdated = true;\n      }\n    }, {\n      key: \"liveSyncPosition\",\n      get: function get() {\n        var liveEdge = this.estimateLiveEdge();\n        var targetLatency = this.targetLatency;\n        if (liveEdge === null || targetLatency === null) {\n          return null;\n        }\n        var levelDetails = this.levelDetails;\n        if (levelDetails === null) {\n          return null;\n        }\n        var edge = levelDetails.edge;\n        var syncPosition = liveEdge - targetLatency - this.edgeStalled;\n        var min = edge - levelDetails.totalduration;\n        var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n        return Math.min(Math.max(min, syncPosition), max);\n      }\n    }, {\n      key: \"drift\",\n      get: function get() {\n        var levelDetails = this.levelDetails;\n        if (levelDetails === null) {\n          return 1;\n        }\n        return levelDetails.drift;\n      }\n    }, {\n      key: \"edgeStalled\",\n      get: function get() {\n        var levelDetails = this.levelDetails;\n        if (levelDetails === null) {\n          return 0;\n        }\n        var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n        return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n      }\n    }, {\n      key: \"forwardBufferLength\",\n      get: function get() {\n        var media = this.media;\n        var levelDetails = this.levelDetails;\n        if (!media || !levelDetails) {\n          return 0;\n        }\n        var bufferedRanges = media.buffered.length;\n        return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n      }\n    }]);\n  }();\n\n  var LevelController = /*#__PURE__*/function (_BasePlaylistControll) {\n    function LevelController(hls, contentSteeringController) {\n      var _this;\n      _this = _BasePlaylistControll.call(this, hls, 'level-controller') || this;\n      _this._levels = [];\n      _this._firstLevel = -1;\n      _this._maxAutoLevel = -1;\n      _this._startLevel = void 0;\n      _this.currentLevel = null;\n      _this.currentLevelIndex = -1;\n      _this.manualLevelIndex = -1;\n      _this.steering = void 0;\n      _this.onParsedComplete = void 0;\n      _this.steering = contentSteeringController;\n      _this._registerListeners();\n      return _this;\n    }\n    _inheritsLoose(LevelController, _BasePlaylistControll);\n    var _proto = LevelController.prototype;\n    _proto._registerListeners = function _registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto._unregisterListeners = function _unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.destroy = function destroy() {\n      this._unregisterListeners();\n      this.steering = null;\n      this.resetLevels();\n      _BasePlaylistControll.prototype.destroy.call(this);\n    };\n    _proto.stopLoad = function stopLoad() {\n      var levels = this._levels;\n\n      // clean up live level details to force reload them, and reset load errors\n      levels.forEach(function (level) {\n        level.loadError = 0;\n        level.fragmentError = 0;\n      });\n      _BasePlaylistControll.prototype.stopLoad.call(this);\n    };\n    _proto.resetLevels = function resetLevels() {\n      this._startLevel = undefined;\n      this.manualLevelIndex = -1;\n      this.currentLevelIndex = -1;\n      this.currentLevel = null;\n      this._levels = [];\n      this._maxAutoLevel = -1;\n    };\n    _proto.onManifestLoading = function onManifestLoading(event, data) {\n      this.resetLevels();\n    };\n    _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n      var _this2 = this;\n      var preferManagedMediaSource = this.hls.config.preferManagedMediaSource;\n      var levels = [];\n      var redundantSet = {};\n      var generatePathwaySet = {};\n      var resolutionFound = false;\n      var videoCodecFound = false;\n      var audioCodecFound = false;\n      data.levels.forEach(function (levelParsed) {\n        var attributes = levelParsed.attrs;\n        var audioCodec = levelParsed.audioCodec,\n          videoCodec = levelParsed.videoCodec;\n        if (audioCodec) {\n          // Returns empty and set to undefined for 'mp4a.40.34' with fallback to 'audio/mpeg' SourceBuffer\n          levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource) || undefined;\n        }\n        if (videoCodec) {\n          videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);\n        }\n\n        // only keep levels with supported audio/video codecs\n        var width = levelParsed.width,\n          height = levelParsed.height,\n          unknownCodecs = levelParsed.unknownCodecs;\n        var unknownUnsupportedCodecCount = (unknownCodecs == null ? void 0 : unknownCodecs.length) || 0;\n        resolutionFound || (resolutionFound = !!(width && height));\n        videoCodecFound || (videoCodecFound = !!videoCodec);\n        audioCodecFound || (audioCodecFound = !!audioCodec);\n        if (unknownUnsupportedCodecCount || audioCodec && !_this2.isAudioSupported(audioCodec) || videoCodec && !_this2.isVideoSupported(videoCodec)) {\n          _this2.log(\"Some or all CODECS not supported \\\"\" + attributes.CODECS + \"\\\"\");\n          return;\n        }\n        var CODECS = attributes.CODECS,\n          FRAMERATE = attributes['FRAME-RATE'],\n          HDCP = attributes['HDCP-LEVEL'],\n          PATHWAY = attributes['PATHWAY-ID'],\n          RESOLUTION = attributes.RESOLUTION,\n          VIDEO_RANGE = attributes['VIDEO-RANGE'];\n        var contentSteeringPrefix = (PATHWAY || '.') + \"-\";\n        var levelKey = \"\" + contentSteeringPrefix + levelParsed.bitrate + \"-\" + RESOLUTION + \"-\" + FRAMERATE + \"-\" + CODECS + \"-\" + VIDEO_RANGE + \"-\" + HDCP;\n        if (!redundantSet[levelKey]) {\n          var level = _this2.createLevel(levelParsed);\n          redundantSet[levelKey] = level;\n          generatePathwaySet[levelKey] = 1;\n          levels.push(level);\n        } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs['PATHWAY-ID']) {\n          // Assign Pathway IDs to Redundant Streams (default Pathways is \".\". Redundant Streams \"..\", \"...\", and so on.)\n          // Content Steering controller to handles Pathway fallback on error\n          var pathwayCount = generatePathwaySet[levelKey] += 1;\n          levelParsed.attrs['PATHWAY-ID'] = new Array(pathwayCount + 1).join('.');\n          var _level = _this2.createLevel(levelParsed);\n          redundantSet[levelKey] = _level;\n          levels.push(_level);\n        } else {\n          redundantSet[levelKey].addGroupId('audio', attributes.AUDIO);\n          redundantSet[levelKey].addGroupId('text', attributes.SUBTITLES);\n        }\n      });\n      this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);\n    };\n    _proto.createLevel = function createLevel(levelParsed) {\n      var level = new Level(levelParsed);\n      var supplemental = levelParsed.supplemental;\n      if (supplemental != null && supplemental.videoCodec && !this.isVideoSupported(supplemental.videoCodec)) {\n        var error = new Error(\"SUPPLEMENTAL-CODECS not supported \\\"\" + supplemental.videoCodec + \"\\\"\");\n        this.log(error.message);\n        level.supportedResult = getUnsupportedResult(error, []);\n      }\n      return level;\n    };\n    _proto.isAudioSupported = function isAudioSupported(codec) {\n      return areCodecsMediaSourceSupported(codec, 'audio', this.hls.config.preferManagedMediaSource);\n    };\n    _proto.isVideoSupported = function isVideoSupported(codec) {\n      return areCodecsMediaSourceSupported(codec, 'video', this.hls.config.preferManagedMediaSource);\n    };\n    _proto.filterAndSortMediaOptions = function filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {\n      var _data$stats,\n        _this3 = this;\n      var audioTracks = [];\n      var subtitleTracks = [];\n      var levels = filteredLevels;\n      var statsParsing = ((_data$stats = data.stats) == null ? void 0 : _data$stats.parsing) || {};\n\n      // remove audio-only and invalid video-range levels if we also have levels with video codecs or RESOLUTION signalled\n      if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n        levels = levels.filter(function (_ref) {\n          var videoCodec = _ref.videoCodec,\n            videoRange = _ref.videoRange,\n            width = _ref.width,\n            height = _ref.height;\n          return (!!videoCodec || !!(width && height)) && isVideoRange(videoRange);\n        });\n      }\n      if (levels.length === 0) {\n        // Dispatch error after MANIFEST_LOADED is done propagating\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.resolve().then(function () {\n          if (_this3.hls) {\n            var message = 'no level with compatible codecs found in manifest';\n            var reason = message;\n            if (data.levels.length) {\n              reason = \"one or more CODECS in variant not supported: \" + stringify(data.levels.map(function (level) {\n                return level.attrs.CODECS;\n              }).filter(function (value, index, array) {\n                return array.indexOf(value) === index;\n              }));\n              _this3.warn(reason);\n              message += \" (\" + reason + \")\";\n            }\n            var error = new Error(message);\n            _this3.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n              fatal: true,\n              url: data.url,\n              error: error,\n              reason: reason\n            });\n          }\n        });\n        statsParsing.end = performance.now();\n        return;\n      }\n      if (data.audioTracks) {\n        audioTracks = data.audioTracks.filter(function (track) {\n          return !track.audioCodec || _this3.isAudioSupported(track.audioCodec);\n        });\n        // Assign ids after filtering as array indices by group-id\n        assignTrackIdsByGroup(audioTracks);\n      }\n      if (data.subtitles) {\n        subtitleTracks = data.subtitles;\n        assignTrackIdsByGroup(subtitleTracks);\n      }\n      // start bitrate is the first bitrate of the manifest\n      var unsortedLevels = levels.slice(0);\n      // sort levels from lowest to highest\n      levels.sort(function (a, b) {\n        if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n          return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n        }\n        // sort on height before bitrate for cap-level-controller\n        if (resolutionFound && a.height !== b.height) {\n          return a.height - b.height;\n        }\n        if (a.frameRate !== b.frameRate) {\n          return a.frameRate - b.frameRate;\n        }\n        if (a.videoRange !== b.videoRange) {\n          return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);\n        }\n        if (a.videoCodec !== b.videoCodec) {\n          var valueA = videoCodecPreferenceValue(a.videoCodec);\n          var valueB = videoCodecPreferenceValue(b.videoCodec);\n          if (valueA !== valueB) {\n            return valueB - valueA;\n          }\n        }\n        if (a.uri === b.uri && a.codecSet !== b.codecSet) {\n          var _valueA = codecsSetSelectionPreferenceValue(a.codecSet);\n          var _valueB = codecsSetSelectionPreferenceValue(b.codecSet);\n          if (_valueA !== _valueB) {\n            return _valueB - _valueA;\n          }\n        }\n        if (a.averageBitrate !== b.averageBitrate) {\n          return a.averageBitrate - b.averageBitrate;\n        }\n        return 0;\n      });\n      var firstLevelInPlaylist = unsortedLevels[0];\n      if (this.steering) {\n        levels = this.steering.filterParsedLevels(levels);\n        if (levels.length !== unsortedLevels.length) {\n          for (var i = 0; i < unsortedLevels.length; i++) {\n            if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n              firstLevelInPlaylist = unsortedLevels[i];\n              break;\n            }\n          }\n        }\n      }\n      this._levels = levels;\n\n      // find index of first level in sorted levels\n      for (var _i = 0; _i < levels.length; _i++) {\n        if (levels[_i] === firstLevelInPlaylist) {\n          var _this$hls$userConfig;\n          this._firstLevel = _i;\n          var firstLevelBitrate = firstLevelInPlaylist.bitrate;\n          var bandwidthEstimate = this.hls.bandwidthEstimate;\n          this.log(\"manifest loaded, \" + levels.length + \" level(s) found, first bitrate: \" + firstLevelBitrate);\n          // Update default bwe to first variant bitrate as long it has not been configured or set\n          if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {\n            var startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);\n            if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === this.hls.abrEwmaDefaultEstimate) {\n              this.hls.bandwidthEstimate = startingBwEstimate;\n            }\n          }\n          break;\n        }\n      }\n\n      // Audio is only alternate if manifest include a URI along with the audio group tag,\n      // and this is not an audio-only stream where levels contain audio-only\n      var audioOnly = audioCodecFound && !videoCodecFound;\n      var config = this.hls.config;\n      var altAudioEnabled = !!(config.audioStreamController && config.audioTrackController);\n      var edata = {\n        levels: levels,\n        audioTracks: audioTracks,\n        subtitleTracks: subtitleTracks,\n        sessionData: data.sessionData,\n        sessionKeys: data.sessionKeys,\n        firstLevel: this._firstLevel,\n        stats: data.stats,\n        audio: audioCodecFound,\n        video: videoCodecFound,\n        altAudio: altAudioEnabled && !audioOnly && audioTracks.some(function (t) {\n          return !!t.url;\n        })\n      };\n      statsParsing.end = performance.now();\n      this.hls.trigger(Events.MANIFEST_PARSED, edata);\n    };\n    _proto.onError = function onError(event, data) {\n      if (data.fatal || !data.context) {\n        return;\n      }\n      if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n        this.checkRetry(data);\n      }\n    }\n\n    // reset errors on the successful load of a fragment\n    ;\n    _proto.onFragBuffered = function onFragBuffered(event, _ref2) {\n      var frag = _ref2.frag;\n      if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n        var el = frag.elementaryStreams;\n        if (!Object.keys(el).some(function (type) {\n          return !!el[type];\n        })) {\n          return;\n        }\n        var level = this._levels[frag.level];\n        if (level != null && level.loadError) {\n          this.log(\"Resetting level error count of \" + level.loadError + \" on frag buffered\");\n          level.loadError = 0;\n        }\n      }\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      var _data$deliveryDirecti2;\n      var level = data.level,\n        details = data.details;\n      var curLevel = data.levelInfo;\n      if (!curLevel) {\n        var _data$deliveryDirecti;\n        this.warn(\"Invalid level index \" + level);\n        if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n          details.deltaUpdateFailed = true;\n        }\n        return;\n      }\n\n      // only process level loaded events matching with expected level or prior to switch when media playlist is loaded directly\n      if (curLevel === this.currentLevel || data.withoutMultiVariant) {\n        // reset level load error counter on successful level loaded only if there is no issues with fragments\n        if (curLevel.fragmentError === 0) {\n          curLevel.loadError = 0;\n        }\n        // Ignore matching details populated by loading a Media Playlist directly\n        var previousDetails = curLevel.details;\n        if (previousDetails === data.details && previousDetails.advanced) {\n          previousDetails = undefined;\n        }\n        this.playlistLoaded(level, data, previousDetails);\n      } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n        // received a delta playlist update that cannot be merged\n        details.deltaUpdateFailed = true;\n      }\n    };\n    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n      _BasePlaylistControll.prototype.loadPlaylist.call(this);\n      if (this.shouldLoadPlaylist(this.currentLevel)) {\n        this.scheduleLoading(this.currentLevel, hlsUrlParameters);\n      }\n    };\n    _proto.loadingPlaylist = function loadingPlaylist(currentLevel, hlsUrlParameters) {\n      _BasePlaylistControll.prototype.loadingPlaylist.call(this, currentLevel, hlsUrlParameters);\n      var url = this.getUrlWithDirectives(currentLevel.uri, hlsUrlParameters);\n      var currentLevelIndex = this.currentLevelIndex;\n      var pathwayId = currentLevel.attrs['PATHWAY-ID'];\n      var details = currentLevel.details;\n      var age = details == null ? void 0 : details.age;\n      this.log(\"Loading level index \" + currentLevelIndex + ((hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + (pathwayId ? ' Pathway ' + pathwayId : '') + (age && details.live ? ' age ' + age.toFixed(1) + (details.type ? ' ' + details.type || 0 : '') : '') + \" \" + url);\n      this.hls.trigger(Events.LEVEL_LOADING, {\n        url: url,\n        level: currentLevelIndex,\n        levelInfo: currentLevel,\n        pathwayId: currentLevel.attrs['PATHWAY-ID'],\n        id: 0,\n        // Deprecated Level urlId\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    };\n    _proto.removeLevel = function removeLevel(levelIndex) {\n      var _this4 = this,\n        _this$currentLevel;\n      if (this._levels.length === 1) {\n        return;\n      }\n      var levels = this._levels.filter(function (level, index) {\n        if (index !== levelIndex) {\n          return true;\n        }\n        if (_this4.steering) {\n          _this4.steering.removeLevel(level);\n        }\n        if (level === _this4.currentLevel) {\n          _this4.currentLevel = null;\n          _this4.currentLevelIndex = -1;\n          if (level.details) {\n            level.details.fragments.forEach(function (f) {\n              return f.level = -1;\n            });\n          }\n        }\n        return false;\n      });\n      reassignFragmentLevelIndexes(levels);\n      this._levels = levels;\n      if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {\n        this.currentLevelIndex = this.currentLevel.details.fragments[0].level;\n      }\n      if (this.manualLevelIndex > -1) {\n        this.manualLevelIndex = this.currentLevelIndex;\n      }\n      var maxLevel = levels.length - 1;\n      this._firstLevel = Math.min(this._firstLevel, maxLevel);\n      if (this._startLevel) {\n        this._startLevel = Math.min(this._startLevel, maxLevel);\n      }\n      this.hls.trigger(Events.LEVELS_UPDATED, {\n        levels: levels\n      });\n    };\n    _proto.onLevelsUpdated = function onLevelsUpdated(event, _ref3) {\n      var levels = _ref3.levels;\n      this._levels = levels;\n    };\n    _proto.checkMaxAutoUpdated = function checkMaxAutoUpdated() {\n      var _this$hls = this.hls,\n        autoLevelCapping = _this$hls.autoLevelCapping,\n        maxAutoLevel = _this$hls.maxAutoLevel,\n        maxHdcpLevel = _this$hls.maxHdcpLevel;\n      if (this._maxAutoLevel !== maxAutoLevel) {\n        this._maxAutoLevel = maxAutoLevel;\n        this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {\n          autoLevelCapping: autoLevelCapping,\n          levels: this.levels,\n          maxAutoLevel: maxAutoLevel,\n          minAutoLevel: this.hls.minAutoLevel,\n          maxHdcpLevel: maxHdcpLevel\n        });\n      }\n    };\n    return _createClass(LevelController, [{\n      key: \"levels\",\n      get: function get() {\n        if (this._levels.length === 0) {\n          return null;\n        }\n        return this._levels;\n      }\n    }, {\n      key: \"loadLevelObj\",\n      get: function get() {\n        return this.currentLevel;\n      }\n    }, {\n      key: \"level\",\n      get: function get() {\n        return this.currentLevelIndex;\n      },\n      set: function set(newLevel) {\n        var levels = this._levels;\n        if (levels.length === 0) {\n          return;\n        }\n        // check if level idx is valid\n        if (newLevel < 0 || newLevel >= levels.length) {\n          // invalid level id given, trigger error\n          var error = new Error('invalid level idx');\n          var fatal = newLevel < 0;\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.LEVEL_SWITCH_ERROR,\n            level: newLevel,\n            fatal: fatal,\n            error: error,\n            reason: error.message\n          });\n          if (fatal) {\n            return;\n          }\n          newLevel = Math.min(newLevel, levels.length - 1);\n        }\n        var lastLevelIndex = this.currentLevelIndex;\n        var lastLevel = this.currentLevel;\n        var lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n        var level = levels[newLevel];\n        var pathwayId = level.attrs['PATHWAY-ID'];\n        this.currentLevelIndex = newLevel;\n        this.currentLevel = level;\n        if (lastLevelIndex === newLevel && lastLevel && lastPathwayId === pathwayId) {\n          return;\n        }\n        this.log(\"Switching to level \" + newLevel + \" (\" + (level.height ? level.height + 'p ' : '') + (level.videoRange ? level.videoRange + ' ' : '') + (level.codecSet ? level.codecSet + ' ' : '') + \"@\" + level.bitrate + \")\" + (pathwayId ? ' with Pathway ' + pathwayId : '') + \" from level \" + lastLevelIndex + (lastPathwayId ? ' with Pathway ' + lastPathwayId : ''));\n        var levelSwitchingData = {\n          level: newLevel,\n          attrs: level.attrs,\n          details: level.details,\n          bitrate: level.bitrate,\n          averageBitrate: level.averageBitrate,\n          maxBitrate: level.maxBitrate,\n          realBitrate: level.realBitrate,\n          width: level.width,\n          height: level.height,\n          codecSet: level.codecSet,\n          audioCodec: level.audioCodec,\n          videoCodec: level.videoCodec,\n          audioGroups: level.audioGroups,\n          subtitleGroups: level.subtitleGroups,\n          loaded: level.loaded,\n          loadError: level.loadError,\n          fragmentError: level.fragmentError,\n          name: level.name,\n          id: level.id,\n          uri: level.uri,\n          url: level.url,\n          urlId: 0,\n          audioGroupIds: level.audioGroupIds,\n          textGroupIds: level.textGroupIds\n        };\n        this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n        // check if we need to load playlist for this level\n        var levelDetails = level.details;\n        if (!levelDetails || levelDetails.live) {\n          // level not retrieved yet, or live playlist we need to (re)load it\n          var hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details, levelDetails);\n          this.loadPlaylist(hlsUrlParameters);\n        }\n      }\n    }, {\n      key: \"manualLevel\",\n      get: function get() {\n        return this.manualLevelIndex;\n      },\n      set: function set(newLevel) {\n        this.manualLevelIndex = newLevel;\n        if (this._startLevel === undefined) {\n          this._startLevel = newLevel;\n        }\n        if (newLevel !== -1) {\n          this.level = newLevel;\n        }\n      }\n    }, {\n      key: \"firstLevel\",\n      get: function get() {\n        return this._firstLevel;\n      },\n      set: function set(newLevel) {\n        this._firstLevel = newLevel;\n      }\n    }, {\n      key: \"startLevel\",\n      get: function get() {\n        // Setting hls.startLevel (this._startLevel) overrides config.startLevel\n        if (this._startLevel === undefined) {\n          var configStartLevel = this.hls.config.startLevel;\n          if (configStartLevel !== undefined) {\n            return configStartLevel;\n          }\n          return this.hls.firstAutoLevel;\n        }\n        return this._startLevel;\n      },\n      set: function set(newLevel) {\n        this._startLevel = newLevel;\n      }\n    }, {\n      key: \"pathways\",\n      get: function get() {\n        if (this.steering) {\n          return this.steering.pathways();\n        }\n        return [];\n      }\n    }, {\n      key: \"pathwayPriority\",\n      get: function get() {\n        if (this.steering) {\n          return this.steering.pathwayPriority;\n        }\n        return null;\n      },\n      set: function set(pathwayPriority) {\n        if (this.steering) {\n          var pathwaysList = this.steering.pathways();\n          var filteredPathwayPriority = pathwayPriority.filter(function (pathwayId) {\n            return pathwaysList.indexOf(pathwayId) !== -1;\n          });\n          if (pathwayPriority.length < 1) {\n            this.warn(\"pathwayPriority \" + pathwayPriority + \" should contain at least one pathway from list: \" + pathwaysList);\n            return;\n          }\n          this.steering.pathwayPriority = filteredPathwayPriority;\n        }\n      }\n    }, {\n      key: \"nextLoadLevel\",\n      get: function get() {\n        if (this.manualLevelIndex !== -1) {\n          return this.manualLevelIndex;\n        } else {\n          return this.hls.nextAutoLevel;\n        }\n      },\n      set: function set(nextLevel) {\n        this.level = nextLevel;\n        if (this.manualLevelIndex === -1) {\n          this.hls.nextAutoLevel = nextLevel;\n        }\n      }\n    }]);\n  }(BasePlaylistController);\n  function assignTrackIdsByGroup(tracks) {\n    var groups = {};\n    tracks.forEach(function (track) {\n      var groupId = track.groupId || '';\n      track.id = groups[groupId] = groups[groupId] || 0;\n      groups[groupId]++;\n    });\n  }\n\n  function getSourceBuffer() {\n    return self.SourceBuffer || self.WebKitSourceBuffer;\n  }\n  function isMSESupported() {\n    var mediaSource = getMediaSource();\n    if (!mediaSource) {\n      return false;\n    }\n\n    // if SourceBuffer is exposed ensure its API is valid\n    // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n    var sourceBuffer = getSourceBuffer();\n    return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n  }\n  function isSupported() {\n    if (!isMSESupported()) {\n      return false;\n    }\n    var mediaSource = getMediaSource();\n    return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === 'function' && (['avc1.42E01E,mp4a.40.2', 'av01.0.01M.08', 'vp09.00.50.08'].some(function (codecsForVideoContainer) {\n      return mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, 'video'));\n    }) || ['mp4a.40.2', 'fLaC'].some(function (codecForAudioContainer) {\n      return mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, 'audio'));\n    }));\n  }\n  function changeTypeSupported() {\n    var _sourceBuffer$prototy;\n    var sourceBuffer = getSourceBuffer();\n    return typeof (sourceBuffer == null || (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n  }\n\n  var TICK_INTERVAL = 100; // how often to tick in ms\n  var StreamController = /*#__PURE__*/function (_BaseStreamController) {\n    function StreamController(hls, fragmentTracker, keyLoader) {\n      var _this;\n      _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, 'stream-controller', PlaylistLevelType.MAIN) || this;\n      _this.audioCodecSwap = false;\n      _this.level = -1;\n      _this._forceStartLoad = false;\n      _this._hasEnoughToStart = false;\n      _this.altAudio = 0;\n      _this.audioOnly = false;\n      _this.fragPlaying = null;\n      _this.fragLastKbps = 0;\n      _this.couldBacktrack = false;\n      _this.backtrackFragment = null;\n      _this.audioCodecSwitch = false;\n      _this.videoBuffer = null;\n      _this.onMediaPlaying = function () {\n        // tick to speed up FRAG_CHANGED triggering\n        _this.tick();\n      };\n      _this.onMediaSeeked = function () {\n        var media = _this.media;\n        var currentTime = media ? media.currentTime : null;\n        if (currentTime === null || !isFiniteNumber(currentTime)) {\n          return;\n        }\n        _this.log(\"Media seeked to \" + currentTime.toFixed(3));\n\n        // If seeked was issued before buffer was appended do not tick immediately\n        if (!_this.getBufferedFrag(currentTime)) {\n          return;\n        }\n        var bufferInfo = _this.getFwdBufferInfoAtPos(media, currentTime, PlaylistLevelType.MAIN, 0);\n        if (bufferInfo === null || bufferInfo.len === 0) {\n          _this.warn(\"Main forward buffer length at \" + currentTime + \" on \\\"seeked\\\" event \" + (bufferInfo ? bufferInfo.len : 'empty') + \")\");\n          return;\n        }\n\n        // tick to speed up FRAG_CHANGED triggering\n        _this.tick();\n      };\n      _this.registerListeners();\n      return _this;\n    }\n    _inheritsLoose(StreamController, _BaseStreamController);\n    var _proto = StreamController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      _BaseStreamController.prototype.registerListeners.call(this);\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n      hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n      hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n      hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      _BaseStreamController.prototype.unregisterListeners.call(this);\n      var hls = this.hls;\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n      hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n      hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n      hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    };\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      // @ts-ignore\n      this.onMediaPlaying = this.onMediaSeeked = null;\n      this.unregisterListeners();\n      _BaseStreamController.prototype.onHandlerDestroying.call(this);\n    };\n    _proto.startLoad = function startLoad(startPosition, skipSeekToStartPosition) {\n      if (this.levels) {\n        var lastCurrentTime = this.lastCurrentTime,\n          hls = this.hls;\n        this.stopLoad();\n        this.setInterval(TICK_INTERVAL);\n        this.level = -1;\n        if (!this.startFragRequested) {\n          // determine load level\n          var startLevel = hls.startLevel;\n          if (startLevel === -1) {\n            if (hls.config.testBandwidth && this.levels.length > 1) {\n              // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n              startLevel = 0;\n              this.bitrateTest = true;\n            } else {\n              startLevel = hls.firstAutoLevel;\n            }\n          }\n          // set new level to playlist loader : this will trigger start level load\n          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n          hls.nextLoadLevel = startLevel;\n          this.level = hls.loadLevel;\n          this._hasEnoughToStart = !!skipSeekToStartPosition;\n        }\n        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n        if (lastCurrentTime > 0 && startPosition === -1 && !skipSeekToStartPosition) {\n          this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n          startPosition = lastCurrentTime;\n        }\n        this.state = State.IDLE;\n        this.nextLoadPosition = this.lastCurrentTime = startPosition + this.timelineOffset;\n        this.startPosition = skipSeekToStartPosition ? -1 : startPosition;\n        this.tick();\n      } else {\n        this._forceStartLoad = true;\n        this.state = State.STOPPED;\n      }\n    };\n    _proto.stopLoad = function stopLoad() {\n      this._forceStartLoad = false;\n      _BaseStreamController.prototype.stopLoad.call(this);\n    };\n    _proto.doTick = function doTick() {\n      switch (this.state) {\n        case State.WAITING_LEVEL:\n          {\n            var levels = this.levels,\n              level = this.level;\n            var currentLevel = levels == null ? void 0 : levels[level];\n            var details = currentLevel == null ? void 0 : currentLevel.details;\n            if (details && (!details.live || this.levelLastLoaded === currentLevel && !this.waitForLive(currentLevel))) {\n              if (this.waitForCdnTuneIn(details)) {\n                break;\n              }\n              this.state = State.IDLE;\n              break;\n            } else if (this.hls.nextLoadLevel !== this.level) {\n              this.state = State.IDLE;\n              break;\n            }\n            break;\n          }\n        case State.FRAG_LOADING_WAITING_RETRY:\n          this.checkRetryDate();\n          break;\n      }\n      if (this.state === State.IDLE) {\n        this.doTickIdle();\n      }\n      this.onTickEnd();\n    };\n    _proto.onTickEnd = function onTickEnd() {\n      var _this$media;\n      _BaseStreamController.prototype.onTickEnd.call(this);\n      if ((_this$media = this.media) != null && _this$media.readyState && this.media.seeking === false) {\n        this.lastCurrentTime = this.media.currentTime;\n      }\n      this.checkFragmentChanged();\n    };\n    _proto.doTickIdle = function doTickIdle() {\n      var hls = this.hls,\n        levelLastLoaded = this.levelLastLoaded,\n        levels = this.levels,\n        media = this.media;\n\n      // if start level not parsed yet OR\n      // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n      // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n      if (levelLastLoaded === null || !media && !this.primaryPrefetch && (this.startFragRequested || !hls.config.startFragPrefetch)) {\n        return;\n      }\n\n      // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n      if (this.altAudio && this.audioOnly) {\n        return;\n      }\n      var level = this.buffering ? hls.nextLoadLevel : hls.loadLevel;\n      if (!(levels != null && levels[level])) {\n        return;\n      }\n      var levelInfo = levels[level];\n\n      // if buffer length is less than maxBufLen try to load a new fragment\n\n      var bufferInfo = this.getMainFwdBufferInfo();\n      if (bufferInfo === null) {\n        return;\n      }\n      var lastDetails = this.getLevelDetails();\n      if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n        var data = {};\n        if (this.altAudio === 2) {\n          data.type = 'video';\n        }\n        this.hls.trigger(Events.BUFFER_EOS, data);\n        this.state = State.ENDED;\n        return;\n      }\n      if (!this.buffering) {\n        return;\n      }\n\n      // set next load level : this will trigger a playlist load if needed\n      if (hls.loadLevel !== level && hls.manualLevel === -1) {\n        this.log(\"Adapting to level \" + level + \" from level \" + this.level);\n      }\n      this.level = hls.nextLoadLevel = level;\n      var levelDetails = levelInfo.details;\n      // if level info not retrieved yet, switch state and wait for level retrieval\n      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n      if (!levelDetails || this.state === State.WAITING_LEVEL || this.waitForLive(levelInfo)) {\n        this.level = level;\n        this.state = State.WAITING_LEVEL;\n        this.startFragRequested = false;\n        return;\n      }\n      var bufferLen = bufferInfo.len;\n\n      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n      var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n      // Stay idle if we are still with buffer margins\n      if (bufferLen >= maxBufLen) {\n        return;\n      }\n      if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n        this.backtrackFragment = null;\n      }\n      var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n      var frag = this.getNextFragment(targetBufferTime, levelDetails);\n      // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n      if (this.couldBacktrack && !this.fragPrevious && frag && isMediaFragment(frag) && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n        var _this$backtrackFragme;\n        var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n        var fragIdx = backtrackSn - levelDetails.startSN;\n        var backtrackFrag = levelDetails.fragments[fragIdx - 1];\n        if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n          frag = backtrackFrag;\n          this.fragmentTracker.removeFragment(backtrackFrag);\n        }\n      } else if (this.backtrackFragment && bufferInfo.len) {\n        this.backtrackFragment = null;\n      }\n      // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n      if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n        var gapStart = frag.gap;\n        if (!gapStart) {\n          // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n          var type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n          var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n          if (mediaBuffer) {\n            this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n          }\n        }\n        frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n      }\n      if (!frag) {\n        return;\n      }\n      if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n        frag = frag.initSegment;\n      }\n      this.loadFragment(frag, levelInfo, targetBufferTime);\n    };\n    _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n      // Check if fragment is not loaded\n      var fragState = this.fragmentTracker.getState(frag);\n      if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n        if (!isMediaFragment(frag)) {\n          this._loadInitSegment(frag, level);\n        } else if (this.bitrateTest) {\n          this.log(\"Fragment \" + frag.sn + \" of level \" + frag.level + \" is being downloaded to test bitrate and will not be buffered\");\n          this._loadBitrateTestFrag(frag, level);\n        } else {\n          _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);\n        }\n      } else {\n        this.clearTrackerIfNeeded(frag);\n      }\n    };\n    _proto.getBufferedFrag = function getBufferedFrag(position) {\n      return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n    };\n    _proto.followingBufferedFrag = function followingBufferedFrag(frag) {\n      if (frag) {\n        // try to get range of next fragment (500ms after this range)\n        return this.getBufferedFrag(frag.end + 0.5);\n      }\n      return null;\n    }\n\n    /*\n      on immediate level switch :\n       - pause playback if playing\n       - cancel any pending load request\n       - and trigger a buffer flush\n    */;\n    _proto.immediateLevelSwitch = function immediateLevelSwitch() {\n      this.abortCurrentFrag();\n      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n    }\n\n    /**\n     * try to switch ASAP without breaking video playback:\n     * in order to ensure smooth but quick level switching,\n     * we need to find the next flushable buffer range\n     * we should take into account new segment fetch time\n     */;\n    _proto.nextLevelSwitch = function nextLevelSwitch() {\n      var levels = this.levels,\n        media = this.media;\n      // ensure that media is defined and that metadata are available (to retrieve currentTime)\n      if (media != null && media.readyState) {\n        var fetchdelay;\n        var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n        if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n          // flush buffer preceding current fragment (flush until current fragment start offset)\n          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n          this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n        }\n        var levelDetails = this.getLevelDetails();\n        if (levelDetails != null && levelDetails.live) {\n          var bufferInfo = this.getMainFwdBufferInfo();\n          // Do not flush in live stream with low buffer\n          if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n            return;\n          }\n        }\n        if (!media.paused && levels) {\n          // add a safety delay of 1s\n          var nextLevelId = this.hls.nextLoadLevel;\n          var nextLevel = levels[nextLevelId];\n          var fragLastKbps = this.fragLastKbps;\n          if (fragLastKbps && this.fragCurrent) {\n            fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n          } else {\n            fetchdelay = 0;\n          }\n        } else {\n          fetchdelay = 0;\n        }\n        // this.log('fetchdelay:'+fetchdelay);\n        // find buffer range that will be reached once new fragment will be fetched\n        var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n        if (bufferedFrag) {\n          // we can flush buffer range following this one without stalling playback\n          var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n          if (nextBufferedFrag) {\n            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n            this.abortCurrentFrag();\n            // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n            var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n            var fragDuration = nextBufferedFrag.duration;\n            var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));\n            this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n          }\n        }\n      }\n    };\n    _proto.abortCurrentFrag = function abortCurrentFrag() {\n      var fragCurrent = this.fragCurrent;\n      this.fragCurrent = null;\n      this.backtrackFragment = null;\n      if (fragCurrent) {\n        fragCurrent.abortRequests();\n        this.fragmentTracker.removeFragment(fragCurrent);\n      }\n      switch (this.state) {\n        case State.KEY_LOADING:\n        case State.FRAG_LOADING:\n        case State.FRAG_LOADING_WAITING_RETRY:\n        case State.PARSING:\n        case State.PARSED:\n          this.state = State.IDLE;\n          break;\n      }\n      this.nextLoadPosition = this.getLoadPosition();\n    };\n    _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {\n      _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio === 2 ? 'video' : null);\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      _BaseStreamController.prototype.onMediaAttached.call(this, event, data);\n      var media = data.media;\n      addEventListener(media, 'playing', this.onMediaPlaying);\n      addEventListener(media, 'seeked', this.onMediaSeeked);\n    };\n    _proto.onMediaDetaching = function onMediaDetaching(event, data) {\n      var media = this.media;\n      if (media) {\n        removeEventListener(media, 'playing', this.onMediaPlaying);\n        removeEventListener(media, 'seeked', this.onMediaSeeked);\n      }\n      this.videoBuffer = null;\n      this.fragPlaying = null;\n      _BaseStreamController.prototype.onMediaDetaching.call(this, event, data);\n      var transferringMedia = !!data.transferMedia;\n      if (transferringMedia) {\n        return;\n      }\n      this._hasEnoughToStart = false;\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      _BaseStreamController.prototype.onManifestLoading.call(this);\n      // reset buffer on manifest loading\n      this.log('Trigger BUFFER_RESET');\n      this.hls.trigger(Events.BUFFER_RESET, undefined);\n      this.couldBacktrack = false;\n      this.fragLastKbps = 0;\n      this.fragPlaying = this.backtrackFragment = null;\n      this.altAudio = 0;\n      this.audioOnly = false;\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      // detect if we have different kind of audio codecs used amongst playlists\n      var aac = false;\n      var heaac = false;\n      for (var i = 0; i < data.levels.length; i++) {\n        var codec = data.levels[i].audioCodec;\n        if (codec) {\n          aac = aac || codec.indexOf('mp4a.40.2') !== -1;\n          heaac = heaac || codec.indexOf('mp4a.40.5') !== -1;\n        }\n      }\n      this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n      if (this.audioCodecSwitch) {\n        this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n      }\n      this.levels = data.levels;\n      this.startFragRequested = false;\n    };\n    _proto.onLevelLoading = function onLevelLoading(event, data) {\n      var levels = this.levels;\n      if (!levels || this.state !== State.IDLE) {\n        return;\n      }\n      var level = data.levelInfo;\n      if (!level.details || level.details.live && (this.levelLastLoaded !== level || level.details.expired) || this.waitForCdnTuneIn(level.details)) {\n        this.state = State.WAITING_LEVEL;\n      }\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      var _curLevel$details;\n      var levels = this.levels,\n        startFragRequested = this.startFragRequested;\n      var newLevelId = data.level;\n      var newDetails = data.details;\n      var duration = newDetails.totalduration;\n      if (!levels) {\n        this.warn(\"Levels were reset while loading level \" + newLevelId);\n        return;\n      }\n      this.log(\"Level \" + newLevelId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"]\" + (newDetails.lastPartSn ? \"[part-\" + newDetails.lastPartSn + \"-\" + newDetails.lastPartIndex + \"]\" : '') + \", cc [\" + newDetails.startCC + \", \" + newDetails.endCC + \"] duration:\" + duration);\n      var curLevel = data.levelInfo;\n      var fragCurrent = this.fragCurrent;\n      if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n        if (fragCurrent.level !== data.level && fragCurrent.loader) {\n          this.abortCurrentFrag();\n        }\n      }\n      var sliding = 0;\n      if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n        var _this$levelLastLoaded;\n        this.checkLiveUpdate(newDetails);\n        if (newDetails.deltaUpdateFailed) {\n          return;\n        }\n        sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n      }\n      // override level info\n      curLevel.details = newDetails;\n      this.levelLastLoaded = curLevel;\n      if (!startFragRequested) {\n        this.setStartPosition(newDetails, sliding);\n      }\n      this.hls.trigger(Events.LEVEL_UPDATED, {\n        details: newDetails,\n        level: newLevelId\n      });\n\n      // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n      if (this.state === State.WAITING_LEVEL) {\n        if (this.waitForCdnTuneIn(newDetails)) {\n          // Wait for Low-Latency CDN Tune-in\n          return;\n        }\n        this.state = State.IDLE;\n      }\n      if (startFragRequested && newDetails.live) {\n        this.synchronizeToLiveEdge(newDetails);\n      }\n\n      // trigger handler right now\n      this.tick();\n    };\n    _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {\n      var config = this.config,\n        media = this.media;\n      if (!media) {\n        return;\n      }\n      var liveSyncPosition = this.hls.liveSyncPosition;\n      var currentTime = this.getLoadPosition();\n      var start = levelDetails.fragmentStart;\n      var end = levelDetails.edge;\n      var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n      // Continue if we can seek forward to sync position or if current time is outside of sliding window\n      if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n        // Continue if buffer is starving or if current time is behind max latency\n        var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n        if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n          if (!this._hasEnoughToStart) {\n            this.nextLoadPosition = liveSyncPosition;\n          }\n          // Only seek if ready and there is not a significant forward buffer available for playback\n          if (media.readyState) {\n            this.warn(\"Playback: \" + currentTime.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + end + \", reset currentTime to : \" + liveSyncPosition.toFixed(3));\n            if (this.config.liveSyncMode === 'buffered') {\n              var _bufferInfo$buffered;\n              var bufferInfo = BufferHelper.bufferInfo(media, liveSyncPosition, 0);\n              if (!((_bufferInfo$buffered = bufferInfo.buffered) != null && _bufferInfo$buffered.length)) {\n                media.currentTime = liveSyncPosition;\n                return;\n              }\n              var isLiveSyncInBuffer = bufferInfo.start <= currentTime;\n              if (isLiveSyncInBuffer) {\n                media.currentTime = liveSyncPosition;\n                return;\n              }\n              var _BufferHelper$buffere = BufferHelper.bufferedInfo(bufferInfo.buffered, currentTime, 0),\n                nextStart = _BufferHelper$buffere.nextStart;\n              if (nextStart) {\n                media.currentTime = nextStart;\n              }\n            } else {\n              media.currentTime = liveSyncPosition;\n            }\n          }\n        }\n      }\n    };\n    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n      var _frag$initSegment;\n      var frag = data.frag;\n      var part = data.part,\n        payload = data.payload;\n      var levels = this.levels;\n      if (!levels) {\n        this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n        return;\n      }\n      var currentLevel = levels[frag.level];\n      if (!currentLevel) {\n        this.warn(\"Level \" + frag.level + \" not found on progress\");\n        return;\n      }\n      var details = currentLevel.details;\n      if (!details) {\n        this.warn(\"Dropping fragment \" + frag.sn + \" of level \" + frag.level + \" after level details were reset\");\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      var videoCodec = currentLevel.videoCodec;\n\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      var accurateTimeOffset = details.PTSKnown || !details.live;\n      var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n      var audioCodec = this._getAudioCodec(currentLevel);\n\n      // transmux the MPEG-TS data to ISO-BMFF segments\n      // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n      var transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n      var partIndex = part ? part.index : -1;\n      var partial = partIndex !== -1;\n      var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      var initPTS = this.initPTS[frag.cc];\n      transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    };\n    _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n      var _this2 = this;\n      var hls = this.hls;\n      // if any URL found on new audio track, it is an alternate audio track\n      var fromAltAudio = this.altAudio !== 0;\n      var altAudio = useAlternateAudio(data.url, hls);\n      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n      // don't do anything if we switch to alt audio: audio stream controller is handling it.\n      // we will just have to change buffer scheduling on audioTrackSwitched\n      if (!altAudio) {\n        if (this.mediaBuffer !== this.media) {\n          this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n          this.mediaBuffer = this.media;\n          var fragCurrent = this.fragCurrent;\n          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n          if (fragCurrent) {\n            this.log('Switching to main audio track, cancel main fragment load');\n            fragCurrent.abortRequests();\n            this.fragmentTracker.removeFragment(fragCurrent);\n          }\n          // destroy transmuxer to force init segment generation (following audio switch)\n          this.resetTransmuxer();\n          // switch to IDLE state to load new fragment\n          this.resetLoadingState();\n        } else if (this.audioOnly) {\n          // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n          this.resetTransmuxer();\n        }\n        // If switching from alt to main audio, flush all audio and trigger track switched\n        if (fromAltAudio) {\n          this.altAudio = 0;\n          this.fragmentTracker.removeAllFragments();\n          hls.once(Events.BUFFER_FLUSHED, function () {\n            if (!_this2.hls) {\n              return;\n            }\n            _this2.hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n          });\n          hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: Number.POSITIVE_INFINITY,\n            type: null\n          });\n          return;\n        }\n        hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n      } else {\n        this.altAudio = 1;\n      }\n    };\n    _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n      var altAudio = useAlternateAudio(data.url, this.hls);\n      if (altAudio) {\n        var videoBuffer = this.videoBuffer;\n        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n        if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n          this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n          this.mediaBuffer = videoBuffer;\n        }\n      }\n      this.altAudio = altAudio ? 2 : 0;\n      this.tick();\n    };\n    _proto.onBufferCreated = function onBufferCreated(event, data) {\n      var tracks = data.tracks;\n      var mediaTrack;\n      var name;\n      var alternate = false;\n      for (var type in tracks) {\n        var track = tracks[type];\n        if (track.id === 'main') {\n          name = type;\n          mediaTrack = track;\n          // keep video source buffer reference\n          if (type === 'video') {\n            var videoTrack = tracks[type];\n            if (videoTrack) {\n              this.videoBuffer = videoTrack.buffer;\n            }\n          }\n        } else {\n          alternate = true;\n        }\n      }\n      if (alternate && mediaTrack) {\n        this.log(\"Alternate track found, use \" + name + \".buffered to schedule main fragment loading\");\n        this.mediaBuffer = mediaTrack.buffer;\n      } else {\n        this.mediaBuffer = this.media;\n      }\n    };\n    _proto.onFragBuffered = function onFragBuffered(event, data) {\n      var frag = data.frag,\n        part = data.part;\n      var bufferedMainFragment = frag.type === PlaylistLevelType.MAIN;\n      if (bufferedMainFragment) {\n        if (this.fragContextChanged(frag)) {\n          // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n          // Avoid setting state back to IDLE, since that will interfere with a level switch\n          this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state);\n          if (this.state === State.PARSED) {\n            this.state = State.IDLE;\n          }\n          return;\n        }\n        var stats = part ? part.stats : frag.stats;\n        this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n        if (isMediaFragment(frag)) {\n          this.fragPrevious = frag;\n        }\n        this.fragBufferedComplete(frag, part);\n      }\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      if (!this._hasEnoughToStart && BufferHelper.getBuffered(media).length) {\n        this._hasEnoughToStart = true;\n        this.seekToStartPos();\n      }\n      if (bufferedMainFragment) {\n        this.tick();\n      }\n    };\n    _proto.onError = function onError(event, data) {\n      var _data$context;\n      if (data.fatal) {\n        this.state = State.ERROR;\n        return;\n      }\n      switch (data.details) {\n        case ErrorDetails.FRAG_GAP:\n        case ErrorDetails.FRAG_PARSING_ERROR:\n        case ErrorDetails.FRAG_DECRYPT_ERROR:\n        case ErrorDetails.FRAG_LOAD_ERROR:\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_ERROR:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n          this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n          break;\n        case ErrorDetails.LEVEL_LOAD_ERROR:\n        case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        case ErrorDetails.LEVEL_PARSING_ERROR:\n          // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n          if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n            this.state = State.IDLE;\n          }\n          break;\n        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n        case ErrorDetails.BUFFER_APPEND_ERROR:\n          if (data.parent !== 'main') {\n            return;\n          }\n          if (this.reduceLengthAndFlushBuffer(data)) {\n            this.resetLoadingState();\n          }\n          break;\n        case ErrorDetails.BUFFER_FULL_ERROR:\n          if (data.parent !== 'main') {\n            return;\n          }\n          if (this.reduceLengthAndFlushBuffer(data)) {\n            var isAssetPlayer = !this.config.interstitialsController && this.config.assetPlayerId;\n            if (isAssetPlayer) {\n              // Use currentTime in buffer estimate to prevent loading more until playback advances\n              this._hasEnoughToStart = true;\n            } else {\n              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n            }\n          }\n          break;\n        case ErrorDetails.INTERNAL_EXCEPTION:\n          this.recoverWorkerError(data);\n          break;\n      }\n    };\n    _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {\n      this.state = State.IDLE;\n      // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n      // in that case, reset startFragRequested flag\n      if (!this._hasEnoughToStart) {\n        this.startFragRequested = false;\n        this.nextLoadPosition = this.lastCurrentTime;\n      }\n      this.tickImmediate();\n    };\n    _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {\n      var type = _ref.type;\n      if (type !== ElementaryStreamTypes.AUDIO || !this.altAudio) {\n        var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n        if (mediaBuffer) {\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n          this.tick();\n        }\n      }\n    };\n    _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n      if (this.level > -1 && this.fragCurrent) {\n        this.level = this.fragCurrent.level;\n        if (this.level === -1) {\n          this.resetWhenMissingContext(this.fragCurrent);\n        }\n      }\n      this.levels = data.levels;\n    };\n    _proto.swapAudioCodec = function swapAudioCodec() {\n      this.audioCodecSwap = !this.audioCodecSwap;\n    }\n\n    /**\n     * Seeks to the set startPosition if not equal to the mediaElement's current time.\n     */;\n    _proto.seekToStartPos = function seekToStartPos() {\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      var currentTime = media.currentTime;\n      var startPosition = this.startPosition;\n      // only adjust currentTime if different from startPosition or if startPosition not buffered\n      // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n      if (startPosition >= 0 && currentTime < startPosition) {\n        if (media.seeking) {\n          this.log(\"could not seek to \" + startPosition + \", already seeking at \" + currentTime);\n          return;\n        }\n\n        // Offset start position by timeline offset\n        var timelineOffset = this.timelineOffset;\n        if (timelineOffset && startPosition) {\n          startPosition += timelineOffset;\n        }\n        var details = this.getLevelDetails();\n        var buffered = BufferHelper.getBuffered(media);\n        var bufferStart = buffered.length ? buffered.start(0) : 0;\n        var delta = bufferStart - startPosition;\n        var skipTolerance = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);\n        if (this.config.startOnSegmentBoundary || delta > 0 && (delta < skipTolerance || this.loadingParts && delta < 2 * ((details == null ? void 0 : details.partTarget) || 0))) {\n          this.log(\"adjusting start position by \" + delta + \" to match buffer start\");\n          startPosition += delta;\n          this.startPosition = startPosition;\n        }\n        if (currentTime < startPosition) {\n          this.log(\"seek to target start position \" + startPosition + \" from current time \" + currentTime + \" buffer start \" + bufferStart);\n          media.currentTime = startPosition;\n        }\n      }\n    };\n    _proto._getAudioCodec = function _getAudioCodec(currentLevel) {\n      var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n      if (this.audioCodecSwap && audioCodec) {\n        this.log('Swapping audio codec');\n        if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n          audioCodec = 'mp4a.40.2';\n        } else {\n          audioCodec = 'mp4a.40.5';\n        }\n      }\n      return audioCodec;\n    };\n    _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(fragment, level) {\n      var _this3 = this;\n      fragment.bitrateTest = true;\n      this._doFragLoad(fragment, level).then(function (data) {\n        var hls = _this3.hls;\n        var frag = data == null ? void 0 : data.frag;\n        if (!frag || _this3.fragContextChanged(frag)) {\n          return;\n        }\n        level.fragmentError = 0;\n        _this3.state = State.IDLE;\n        _this3.startFragRequested = false;\n        _this3.bitrateTest = false;\n        var stats = frag.stats;\n        // Bitrate tests fragments are neither parsed nor buffered\n        stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n        hls.trigger(Events.FRAG_LOADED, data);\n        frag.bitrateTest = false;\n      }).catch(function (reason) {\n        if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {\n          return;\n        }\n        _this3.warn(reason);\n        _this3.resetFragmentLoading(fragment);\n      });\n    };\n    _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n      var id = this.playlistType;\n      var hls = this.hls;\n      var remuxResult = transmuxResult.remuxResult,\n        chunkMeta = transmuxResult.chunkMeta;\n      var context = this.getCurrentContext(chunkMeta);\n      if (!context) {\n        this.resetWhenMissingContext(chunkMeta);\n        return;\n      }\n      var frag = context.frag,\n        part = context.part,\n        level = context.level;\n      var video = remuxResult.video,\n        text = remuxResult.text,\n        id3 = remuxResult.id3,\n        initSegment = remuxResult.initSegment;\n      var details = level.details;\n      // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n      var audio = this.altAudio ? undefined : remuxResult.audio;\n\n      // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n      // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n      if (this.fragContextChanged(frag)) {\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      this.state = State.PARSING;\n      if (initSegment) {\n        var tracks = initSegment.tracks;\n        if (tracks) {\n          var mapFragment = frag.initSegment || frag;\n          if (this.unhandledEncryptionError(initSegment, frag)) {\n            return;\n          }\n          this._bufferInitSegment(level, tracks, mapFragment, chunkMeta);\n          hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n            frag: mapFragment,\n            id: id,\n            tracks: tracks\n          });\n        }\n        var baseTime = initSegment.initPTS;\n        var timescale = initSegment.timescale;\n        var initPTS = this.initPTS[frag.cc];\n        if (isFiniteNumber(baseTime) && (!initPTS || initPTS.baseTime !== baseTime || initPTS.timescale !== timescale)) {\n          var trackId = initSegment.trackId;\n          this.initPTS[frag.cc] = {\n            baseTime: baseTime,\n            timescale: timescale,\n            trackId: trackId\n          };\n          hls.trigger(Events.INIT_PTS_FOUND, {\n            frag: frag,\n            id: id,\n            initPTS: baseTime,\n            timescale: timescale,\n            trackId: trackId\n          });\n        }\n      }\n\n      // Avoid buffering if backtracking this fragment\n      if (video && details) {\n        if (audio && video.type === 'audiovideo') {\n          this.logMuxedErr(frag);\n        }\n        var prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n        var isFirstFragment = frag.sn === details.startSN;\n        var isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n        if (remuxResult.independent !== false) {\n          var startPTS = video.startPTS,\n            endPTS = video.endPTS,\n            startDTS = video.startDTS,\n            endDTS = video.endDTS;\n          if (part) {\n            part.elementaryStreams[video.type] = {\n              startPTS: startPTS,\n              endPTS: endPTS,\n              startDTS: startDTS,\n              endDTS: endDTS\n            };\n          } else {\n            if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n              this.couldBacktrack = true;\n            }\n            if (video.dropped && video.independent) {\n              // Backtrack if dropped frames create a gap after currentTime\n\n              var bufferInfo = this.getMainFwdBufferInfo();\n              var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n              var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n              if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n                this.backtrack(frag);\n                return;\n              } else if (isFirstInDiscontinuity) {\n                // Mark segment with a gap to avoid loop loading\n                frag.gap = true;\n              }\n              // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n              frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n            } else if (isFirstFragment && startPTS - (details.appliedTimelineOffset || 0) > MAX_START_GAP_JUMP) {\n              // Mark segment with a gap to skip large start gap\n              frag.gap = true;\n            }\n          }\n          frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n          if (this.backtrackFragment) {\n            this.backtrackFragment = frag;\n          }\n          this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n        } else if (isFirstFragment || isFirstInDiscontinuity) {\n          // Mark segment with a gap to avoid loop loading\n          frag.gap = true;\n        } else {\n          this.backtrack(frag);\n          return;\n        }\n      }\n      if (audio) {\n        var _startPTS = audio.startPTS,\n          _endPTS = audio.endPTS,\n          _startDTS = audio.startDTS,\n          _endDTS = audio.endDTS;\n        if (part) {\n          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n            startPTS: _startPTS,\n            endPTS: _endPTS,\n            startDTS: _startDTS,\n            endDTS: _endDTS\n          };\n        }\n        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);\n        this.bufferFragmentData(audio, frag, part, chunkMeta);\n      }\n      if (details && id3 != null && id3.samples.length) {\n        var emittedID3 = {\n          id: id,\n          frag: frag,\n          details: details,\n          samples: id3.samples\n        };\n        hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n      }\n      if (details && text) {\n        var emittedText = {\n          id: id,\n          frag: frag,\n          details: details,\n          samples: text.samples\n        };\n        hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n      }\n    };\n    _proto.logMuxedErr = function logMuxedErr(frag) {\n      this.warn((isMediaFragment(frag) ? 'Media' : 'Init') + \" segment with muxed audiovideo where only video expected: \" + frag.url);\n    };\n    _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n      var _this4 = this;\n      if (this.state !== State.PARSING) {\n        return;\n      }\n      this.audioOnly = !!tracks.audio && !tracks.video;\n\n      // if audio track is expected to come from audio stream controller, discard any coming from main\n      if (this.altAudio && !this.audioOnly) {\n        delete tracks.audio;\n        if (tracks.audiovideo) {\n          this.logMuxedErr(frag);\n        }\n      }\n      // include levelCodec in audio and video tracks\n      var audio = tracks.audio,\n        video = tracks.video,\n        audiovideo = tracks.audiovideo;\n      if (audio) {\n        var levelCodec = currentLevel.audioCodec;\n        var audioCodec = pickMostCompleteCodecName(audio.codec, levelCodec);\n        // Add level and profile to make up for remuxer not being able to parse full codec\n        // (logger warning \"Unhandled audio codec...\")\n        if (audioCodec === 'mp4a') {\n          audioCodec = 'mp4a.40.5';\n        }\n        // Handle `audioCodecSwitch`\n        var ua = navigator.userAgent.toLowerCase();\n        if (this.audioCodecSwitch) {\n          if (audioCodec) {\n            if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n              audioCodec = 'mp4a.40.2';\n            } else {\n              audioCodec = 'mp4a.40.5';\n            }\n          }\n          // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n          // force HE-AAC, as it seems that most browsers prefers it.\n          // don't force HE-AAC if mono stream, or in Firefox\n          var audioMetadata = audio.metadata;\n          if (audioMetadata && 'channelCount' in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua.indexOf('firefox') === -1) {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n        if (audioCodec && audioCodec.indexOf('mp4a.40.5') !== -1 && ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n          // Exclude mpeg audio\n          audioCodec = 'mp4a.40.2';\n          this.log(\"Android: force audio codec to \" + audioCodec);\n        }\n        if (levelCodec && levelCodec !== audioCodec) {\n          this.log(\"Swapping manifest audio codec \\\"\" + levelCodec + \"\\\" for \\\"\" + audioCodec + \"\\\"\");\n        }\n        audio.levelCodec = audioCodec;\n        audio.id = PlaylistLevelType.MAIN;\n        this.log(\"Init audio buffer, container:\" + audio.container + \", codecs[selected/level/parsed]=[\" + (audioCodec || '') + \"/\" + (levelCodec || '') + \"/\" + audio.codec + \"]\");\n        delete tracks.audiovideo;\n      }\n      if (video) {\n        video.levelCodec = currentLevel.videoCodec;\n        video.id = PlaylistLevelType.MAIN;\n        var parsedVideoCodec = video.codec;\n        if ((parsedVideoCodec == null ? void 0 : parsedVideoCodec.length) === 4) {\n          // Make up for passthrough-remuxer not being able to parse full codec\n          // (logger warning \"Unhandled video codec...\")\n          switch (parsedVideoCodec) {\n            case 'hvc1':\n            case 'hev1':\n              video.codec = 'hvc1.1.6.L120.90';\n              break;\n            case 'av01':\n              video.codec = 'av01.0.04M.08';\n              break;\n            case 'avc1':\n              video.codec = 'avc1.42e01e';\n              break;\n          }\n        }\n        this.log(\"Init video buffer, container:\" + video.container + \", codecs[level/parsed]=[\" + (currentLevel.videoCodec || '') + \"/\" + parsedVideoCodec + \"]\" + (video.codec !== parsedVideoCodec ? ' parsed-corrected=' + video.codec : '') + (video.supplemental ? ' supplemental=' + video.supplemental : ''));\n        delete tracks.audiovideo;\n      }\n      if (audiovideo) {\n        this.log(\"Init audiovideo buffer, container:\" + audiovideo.container + \", codecs[level/parsed]=[\" + currentLevel.codecs + \"/\" + audiovideo.codec + \"]\");\n        delete tracks.video;\n        delete tracks.audio;\n      }\n      var trackTypes = Object.keys(tracks);\n      if (trackTypes.length) {\n        this.hls.trigger(Events.BUFFER_CODECS, tracks);\n        if (!this.hls) {\n          // Exit after fatal tracks error\n          return;\n        }\n        // loop through tracks that are going to be provided to bufferController\n        trackTypes.forEach(function (trackName) {\n          var track = tracks[trackName];\n          var initSegment = track.initSegment;\n          if (initSegment != null && initSegment.byteLength) {\n            _this4.hls.trigger(Events.BUFFER_APPENDING, {\n              type: trackName,\n              data: initSegment,\n              frag: frag,\n              part: null,\n              chunkMeta: chunkMeta,\n              parent: frag.type\n            });\n          }\n        });\n      }\n      // trigger handler right now\n      this.tickImmediate();\n    };\n    _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {\n      // Observe video SourceBuffer (this.mediaBuffer) only when alt-audio is used, otherwise observe combined media buffer\n      var bufferOutput = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;\n      return this.getFwdBufferInfo(bufferOutput, PlaylistLevelType.MAIN);\n    };\n    _proto.backtrack = function backtrack(frag) {\n      this.couldBacktrack = true;\n      // Causes findFragments to backtrack through fragments to find the keyframe\n      this.backtrackFragment = frag;\n      this.resetTransmuxer();\n      this.flushBufferGap(frag);\n      this.fragmentTracker.removeFragment(frag);\n      this.fragPrevious = null;\n      this.nextLoadPosition = frag.start;\n      this.state = State.IDLE;\n    };\n    _proto.checkFragmentChanged = function checkFragmentChanged() {\n      var video = this.media;\n      var fragPlayingCurrent = null;\n      if (video && video.readyState > 1 && video.seeking === false) {\n        var currentTime = video.currentTime;\n        /* if video element is in seeked state, currentTime can only increase.\n          (assuming that playback rate is positive ...)\n          As sometimes currentTime jumps back to zero after a\n          media decode error, check this, to avoid seeking back to\n          wrong position after a media decode error\n        */\n\n        if (BufferHelper.isBuffered(video, currentTime)) {\n          fragPlayingCurrent = this.getAppendedFrag(currentTime);\n        } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n          /* ensure that FRAG_CHANGED event is triggered at startup,\n            when first video frame is displayed and playback is paused.\n            add a tolerance of 100ms, in case current position is not buffered,\n            check if current pos+100ms is buffered and use that buffer range\n            for FRAG_CHANGED event reporting */\n          fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n        }\n        if (fragPlayingCurrent) {\n          this.backtrackFragment = null;\n          var fragPlaying = this.fragPlaying;\n          var fragCurrentLevel = fragPlayingCurrent.level;\n          if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {\n            this.fragPlaying = fragPlayingCurrent;\n            this.hls.trigger(Events.FRAG_CHANGED, {\n              frag: fragPlayingCurrent\n            });\n            if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n              this.hls.trigger(Events.LEVEL_SWITCHED, {\n                level: fragCurrentLevel\n              });\n            }\n          }\n        }\n      }\n    };\n    return _createClass(StreamController, [{\n      key: \"hasEnoughToStart\",\n      get: function get() {\n        return this._hasEnoughToStart;\n      }\n    }, {\n      key: \"maxBufferLength\",\n      get: function get() {\n        var levels = this.levels,\n          level = this.level;\n        var levelInfo = levels == null ? void 0 : levels[level];\n        if (!levelInfo) {\n          return this.config.maxBufferLength;\n        }\n        return this.getMaxBufferLength(levelInfo.maxBitrate);\n      }\n    }, {\n      key: \"nextLevel\",\n      get: function get() {\n        var frag = this.nextBufferedFrag;\n        if (frag) {\n          return frag.level;\n        }\n        return -1;\n      }\n    }, {\n      key: \"currentFrag\",\n      get: function get() {\n        var _this$media2;\n        if (this.fragPlaying) {\n          return this.fragPlaying;\n        }\n        var currentTime = ((_this$media2 = this.media) == null ? void 0 : _this$media2.currentTime) || this.lastCurrentTime;\n        if (isFiniteNumber(currentTime)) {\n          return this.getAppendedFrag(currentTime);\n        }\n        return null;\n      }\n    }, {\n      key: \"currentProgramDateTime\",\n      get: function get() {\n        var _this$media3;\n        var currentTime = ((_this$media3 = this.media) == null ? void 0 : _this$media3.currentTime) || this.lastCurrentTime;\n        if (isFiniteNumber(currentTime)) {\n          var details = this.getLevelDetails();\n          var frag = this.currentFrag || (details ? findFragmentByPTS(null, details.fragments, currentTime) : null);\n          if (frag) {\n            var programDateTime = frag.programDateTime;\n            if (programDateTime !== null) {\n              var epocMs = programDateTime + (currentTime - frag.start) * 1000;\n              return new Date(epocMs);\n            }\n          }\n        }\n        return null;\n      }\n    }, {\n      key: \"currentLevel\",\n      get: function get() {\n        var frag = this.currentFrag;\n        if (frag) {\n          return frag.level;\n        }\n        return -1;\n      }\n    }, {\n      key: \"nextBufferedFrag\",\n      get: function get() {\n        var frag = this.currentFrag;\n        if (frag) {\n          return this.followingBufferedFrag(frag);\n        }\n        return null;\n      }\n    }, {\n      key: \"forceStartLoad\",\n      get: function get() {\n        return this._forceStartLoad;\n      }\n    }]);\n  }(BaseStreamController);\n\n  var KeyLoader = /*#__PURE__*/function (_Logger) {\n    function KeyLoader(config, logger) {\n      var _this;\n      _this = _Logger.call(this, 'key-loader', logger) || this;\n      _this.config = void 0;\n      _this.keyIdToKeyInfo = {};\n      _this.emeController = null;\n      _this.config = config;\n      return _this;\n    }\n    _inheritsLoose(KeyLoader, _Logger);\n    var _proto = KeyLoader.prototype;\n    _proto.abort = function abort(type) {\n      for (var id in this.keyIdToKeyInfo) {\n        var loader = this.keyIdToKeyInfo[id].loader;\n        if (loader) {\n          var _loader$context;\n          if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {\n            return;\n          }\n          loader.abort();\n        }\n      }\n    };\n    _proto.detach = function detach() {\n      for (var id in this.keyIdToKeyInfo) {\n        var keyInfo = this.keyIdToKeyInfo[id];\n        // Remove cached EME keys on detach\n        if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n          delete this.keyIdToKeyInfo[id];\n        }\n      }\n    };\n    _proto.destroy = function destroy() {\n      this.detach();\n      for (var id in this.keyIdToKeyInfo) {\n        var loader = this.keyIdToKeyInfo[id].loader;\n        if (loader) {\n          loader.destroy();\n        }\n      }\n      this.keyIdToKeyInfo = {};\n    };\n    _proto.createKeyLoadError = function createKeyLoadError(frag, details, error, networkDetails, response) {\n      if (details === void 0) {\n        details = ErrorDetails.KEY_LOAD_ERROR;\n      }\n      return new LoadError({\n        type: ErrorTypes.NETWORK_ERROR,\n        details: details,\n        fatal: false,\n        frag: frag,\n        response: response,\n        error: error,\n        networkDetails: networkDetails\n      });\n    };\n    _proto.loadClear = function loadClear(loadingFrag, encryptedFragments, startFragRequested) {\n      var _this2 = this;\n      if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {\n        // Access key-system with nearest key on start (loading frag is unencrypted)\n        if (encryptedFragments.length) {\n          var _loop = function _loop() {\n              var frag = encryptedFragments[i];\n              // Loading at or before segment with EXT-X-KEY, or first frag loading and last EXT-X-KEY\n              if (loadingFrag.cc <= frag.cc && (!isMediaFragment(loadingFrag) || !isMediaFragment(frag) || loadingFrag.sn < frag.sn) || !startFragRequested && i == l - 1) {\n                return {\n                  v: _this2.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n                    if (!_this2.emeController) {\n                      return;\n                    }\n                    frag.setKeyFormat(keySystemFormat);\n                    var keySystem = keySystemFormatToKeySystemDomain(keySystemFormat);\n                    if (keySystem) {\n                      return _this2.emeController.getKeySystemAccess([keySystem]);\n                    }\n                  })\n                };\n              }\n            },\n            _ret;\n          for (var i = 0, l = encryptedFragments.length; i < l; i++) {\n            _ret = _loop();\n            if (_ret) return _ret.v;\n          }\n        }\n        if (this.config.requireKeySystemAccessOnStart) {\n          var keySystemsInConfig = getKeySystemsForConfig(this.config);\n          if (keySystemsInConfig.length) {\n            return this.emeController.getKeySystemAccess(keySystemsInConfig);\n          }\n        }\n      }\n      return null;\n    };\n    _proto.load = function load(frag) {\n      var _this3 = this;\n      if (!frag.decryptdata && frag.encrypted && this.emeController && this.config.emeEnabled) {\n        // Multiple keys, but none selected, resolve in eme-controller\n        return this.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n          return _this3.loadInternal(frag, keySystemFormat);\n        });\n      }\n      return this.loadInternal(frag);\n    };\n    _proto.loadInternal = function loadInternal(frag, keySystemFormat) {\n      var _keyInfo, _keyInfo2;\n      if (keySystemFormat) {\n        frag.setKeyFormat(keySystemFormat);\n      }\n      var decryptdata = frag.decryptdata;\n      if (!decryptdata) {\n        var error = new Error(keySystemFormat ? \"Expected frag.decryptdata to be defined after setting format \" + keySystemFormat : \"Missing decryption data on fragment in onKeyLoading (emeEnabled with controller: \" + (this.emeController && this.config.emeEnabled) + \")\");\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n      }\n      var uri = decryptdata.uri;\n      if (!uri) {\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"Invalid key URI: \\\"\" + uri + \"\\\"\")));\n      }\n      var id = getKeyId(decryptdata);\n      var keyInfo = this.keyIdToKeyInfo[id];\n      if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n        decryptdata.key = keyInfo.decryptdata.key;\n        return Promise.resolve({\n          frag: frag,\n          keyInfo: keyInfo\n        });\n      }\n      // Return key load promise once it has a mediakey session with an usable key status\n      if (this.emeController && (_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n        var keyStatus = this.emeController.getKeyStatus(keyInfo.decryptdata);\n        switch (keyStatus) {\n          case 'usable':\n          case 'usable-in-future':\n            return keyInfo.keyLoadPromise.then(function (keyLoadedData) {\n              // Return the correct fragment with updated decryptdata key and loaded keyInfo\n              var keyInfo = keyLoadedData.keyInfo;\n              decryptdata.key = keyInfo.decryptdata.key;\n              return {\n                frag: frag,\n                keyInfo: keyInfo\n              };\n            });\n        }\n        // If we have a key session and status and it is not pending or usable, continue\n        // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n      }\n\n      // Load the key or return the loading promise\n      this.log((this.keyIdToKeyInfo[id] ? 'Rel' : 'L') + \"oading\" + (decryptdata.keyId ? ' keyId: ' + arrayToHex(decryptdata.keyId) : '') + \" URI: \" + decryptdata.uri + \" from \" + frag.type + \" \" + frag.level);\n      keyInfo = this.keyIdToKeyInfo[id] = {\n        decryptdata: decryptdata,\n        keyLoadPromise: null,\n        loader: null,\n        mediaKeySessionContext: null\n      };\n      switch (decryptdata.method) {\n        case 'SAMPLE-AES':\n        case 'SAMPLE-AES-CENC':\n        case 'SAMPLE-AES-CTR':\n          if (decryptdata.keyFormat === 'identity') {\n            // loadKeyHTTP handles http(s) and data URLs\n            return this.loadKeyHTTP(keyInfo, frag);\n          }\n          return this.loadKeyEME(keyInfo, frag);\n        case 'AES-128':\n        case 'AES-256':\n        case 'AES-256-CTR':\n          return this.loadKeyHTTP(keyInfo, frag);\n        default:\n          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"Key supplied with unsupported METHOD: \\\"\" + decryptdata.method + \"\\\"\")));\n      }\n    };\n    _proto.loadKeyEME = function loadKeyEME(keyInfo, frag) {\n      var keyLoadedData = {\n        frag: frag,\n        keyInfo: keyInfo\n      };\n      if (this.emeController && this.config.emeEnabled) {\n        var _frag$initSegment;\n        if (!keyInfo.decryptdata.keyId && (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data) {\n          var keyIds = parseKeyIdsFromTenc(frag.initSegment.data);\n          if (keyIds.length) {\n            var keyId = keyIds[0];\n            if (keyId.some(function (b) {\n              return b !== 0;\n            })) {\n              this.log(\"Using keyId found in init segment \" + arrayToHex(keyId));\n              LevelKey.setKeyIdForUri(keyInfo.decryptdata.uri, keyId);\n            } else {\n              keyId = LevelKey.addKeyIdForUri(keyInfo.decryptdata.uri);\n              this.log(\"Generating keyId to patch media \" + arrayToHex(keyId));\n            }\n            keyInfo.decryptdata.keyId = keyId;\n          }\n        }\n        if (!keyInfo.decryptdata.keyId && !isMediaFragment(frag)) {\n          // Resolve so that unencrypted init segment is loaded\n          // key id is extracted from tenc box when processing key for next segment above\n          return Promise.resolve(keyLoadedData);\n        }\n        var keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n        return (keyInfo.keyLoadPromise = keySessionContextPromise.then(function (keySessionContext) {\n          keyInfo.mediaKeySessionContext = keySessionContext;\n          return keyLoadedData;\n        })).catch(function (error) {\n          // Remove promise for license renewal or retry\n          keyInfo.keyLoadPromise = null;\n          if ('data' in error) {\n            error.data.frag = frag;\n          }\n          throw error;\n        });\n      }\n      return Promise.resolve(keyLoadedData);\n    };\n    _proto.loadKeyHTTP = function loadKeyHTTP(keyInfo, frag) {\n      var _this4 = this;\n      var config = this.config;\n      var Loader = config.loader;\n      var keyLoader = new Loader(config);\n      frag.keyLoader = keyInfo.loader = keyLoader;\n      return keyInfo.keyLoadPromise = new Promise(function (resolve, reject) {\n        var loaderContext = {\n          keyInfo: keyInfo,\n          frag: frag,\n          responseType: 'arraybuffer',\n          url: keyInfo.decryptdata.uri\n        };\n\n        // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n        // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n        // this will also align retry logic with fragment-loader\n        var loadPolicy = config.keyLoadPolicy.default;\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: 0,\n          retryDelay: 0,\n          maxRetryDelay: 0\n        };\n        var loaderCallbacks = {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            var frag = context.frag,\n              keyInfo = context.keyInfo;\n            var id = getKeyId(keyInfo.decryptdata);\n            if (!frag.decryptdata || keyInfo !== _this4.keyIdToKeyInfo[id]) {\n              return reject(_this4.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n            }\n            keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n            // detach fragment key loader on load success\n            frag.keyLoader = null;\n            keyInfo.loader = null;\n            resolve({\n              frag: frag,\n              keyInfo: keyInfo\n            });\n          },\n          onError: function onError(response, context, networkDetails, stats) {\n            _this4.resetLoader(context);\n            reject(_this4.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"HTTP Error \" + response.code + \" loading key \" + response.text), networkDetails, _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response)));\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            _this4.resetLoader(context);\n            reject(_this4.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n          },\n          onAbort: function onAbort(stats, context, networkDetails) {\n            _this4.resetLoader(context);\n            reject(_this4.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n          }\n        };\n        keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n      });\n    };\n    _proto.resetLoader = function resetLoader(context) {\n      var frag = context.frag,\n        keyInfo = context.keyInfo,\n        uri = context.url;\n      var loader = keyInfo.loader;\n      if (frag.keyLoader === loader) {\n        frag.keyLoader = null;\n        keyInfo.loader = null;\n      }\n      var id = getKeyId(keyInfo.decryptdata) || uri;\n      delete this.keyIdToKeyInfo[id];\n      if (loader) {\n        loader.destroy();\n      }\n    };\n    return KeyLoader;\n  }(Logger);\n  function getKeyId(decryptdata) {\n    if (decryptdata.keyFormat !== KeySystemFormats.FAIRPLAY) {\n      var keyId = decryptdata.keyId;\n      if (keyId) {\n        return arrayToHex(keyId);\n      }\n    }\n    return decryptdata.uri;\n  }\n\n  function mapContextToLevelType(context) {\n    var type = context.type;\n    switch (type) {\n      case PlaylistContextType.AUDIO_TRACK:\n        return PlaylistLevelType.AUDIO;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        return PlaylistLevelType.SUBTITLE;\n      default:\n        return PlaylistLevelType.MAIN;\n    }\n  }\n  function getResponseUrl(response, context) {\n    var url = response.url;\n    // responseURL not supported on some browsers (it is used to detect URL redirection)\n    // data-uri mode also not supported (but no need to detect redirection)\n    if (url === undefined || url.indexOf('data:') === 0) {\n      // fallback to initial URL\n      url = context.url;\n    }\n    return url;\n  }\n  var PlaylistLoader = /*#__PURE__*/function () {\n    function PlaylistLoader(hls) {\n      this.hls = void 0;\n      this.loaders = Object.create(null);\n      this.variableList = null;\n      this.onManifestLoaded = this.checkAutostartLoad;\n      this.hls = hls;\n      this.registerListeners();\n    }\n    var _proto = PlaylistLoader.prototype;\n    _proto.startLoad = function startLoad(startPosition) {};\n    _proto.stopLoad = function stopLoad() {\n      this.destroyInternalLoaders();\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n      hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n      hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    }\n\n    /**\n     * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n     */;\n    _proto.createInternalLoader = function createInternalLoader(context) {\n      var config = this.hls.config;\n      var PLoader = config.pLoader;\n      var Loader = config.loader;\n      var InternalLoader = PLoader || Loader;\n      var loader = new InternalLoader(config);\n      this.loaders[context.type] = loader;\n      return loader;\n    };\n    _proto.getInternalLoader = function getInternalLoader(context) {\n      return this.loaders[context.type];\n    };\n    _proto.resetInternalLoader = function resetInternalLoader(contextType) {\n      if (this.loaders[contextType]) {\n        delete this.loaders[contextType];\n      }\n    }\n\n    /**\n     * Call `destroy` on all internal loader instances mapped (one per context type)\n     */;\n    _proto.destroyInternalLoaders = function destroyInternalLoaders() {\n      for (var contextType in this.loaders) {\n        var loader = this.loaders[contextType];\n        if (loader) {\n          loader.destroy();\n        }\n        this.resetInternalLoader(contextType);\n      }\n    };\n    _proto.destroy = function destroy() {\n      this.variableList = null;\n      this.unregisterListeners();\n      this.destroyInternalLoaders();\n    };\n    _proto.onManifestLoading = function onManifestLoading(event, data) {\n      var url = data.url;\n      this.variableList = null;\n      this.load({\n        id: null,\n        level: 0,\n        responseType: 'text',\n        type: PlaylistContextType.MANIFEST,\n        url: url,\n        deliveryDirectives: null,\n        levelOrTrack: null\n      });\n    };\n    _proto.onLevelLoading = function onLevelLoading(event, data) {\n      var id = data.id,\n        level = data.level,\n        pathwayId = data.pathwayId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives,\n        levelInfo = data.levelInfo;\n      this.load({\n        id: id,\n        level: level,\n        pathwayId: pathwayId,\n        responseType: 'text',\n        type: PlaylistContextType.LEVEL,\n        url: url,\n        deliveryDirectives: deliveryDirectives,\n        levelOrTrack: levelInfo\n      });\n    };\n    _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {\n      var id = data.id,\n        groupId = data.groupId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives,\n        track = data.track;\n      this.load({\n        id: id,\n        groupId: groupId,\n        level: null,\n        responseType: 'text',\n        type: PlaylistContextType.AUDIO_TRACK,\n        url: url,\n        deliveryDirectives: deliveryDirectives,\n        levelOrTrack: track\n      });\n    };\n    _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {\n      var id = data.id,\n        groupId = data.groupId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives,\n        track = data.track;\n      this.load({\n        id: id,\n        groupId: groupId,\n        level: null,\n        responseType: 'text',\n        type: PlaylistContextType.SUBTITLE_TRACK,\n        url: url,\n        deliveryDirectives: deliveryDirectives,\n        levelOrTrack: track\n      });\n    };\n    _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n      // abort and delete loader of removed levels\n      var loader = this.loaders[PlaylistContextType.LEVEL];\n      if (loader) {\n        var context = loader.context;\n        if (context && !data.levels.some(function (lvl) {\n          return lvl === context.levelOrTrack;\n        })) {\n          loader.abort();\n          delete this.loaders[PlaylistContextType.LEVEL];\n        }\n      }\n    };\n    _proto.load = function load(context) {\n      var _context$deliveryDire,\n        _this = this;\n      var config = this.hls.config;\n\n      // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n      // Check if a loader for this context already exists\n      var loader = this.getInternalLoader(context);\n      if (loader) {\n        var logger = this.hls.logger;\n        var loaderContext = loader.context;\n        if (loaderContext && loaderContext.levelOrTrack === context.levelOrTrack && (loaderContext.url === context.url || loaderContext.deliveryDirectives && !context.deliveryDirectives)) {\n          // same URL can't overlap, or wait for blocking request\n          if (loaderContext.url === context.url) {\n            logger.log(\"[playlist-loader]: ignore \" + context.url + \" ongoing request\");\n          } else {\n            logger.log(\"[playlist-loader]: ignore \" + context.url + \" in favor of \" + loaderContext.url);\n          }\n          return;\n        }\n        logger.log(\"[playlist-loader]: aborting previous loader for type: \" + context.type);\n        loader.abort();\n      }\n\n      // apply different configs for retries depending on\n      // context (manifest, level, audio/subs playlist)\n      var loadPolicy;\n      if (context.type === PlaylistContextType.MANIFEST) {\n        loadPolicy = config.manifestLoadPolicy.default;\n      } else {\n        loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n          timeoutRetry: null,\n          errorRetry: null\n        });\n      }\n      loader = this.createInternalLoader(context);\n\n      // Override level/track timeout for LL-HLS requests\n      // (the default of 10000ms is counter productive to blocking playlist reload requests)\n      if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {\n        var levelDetails;\n        if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n          levelDetails = this.hls.levels[context.level].details;\n        } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n          levelDetails = this.hls.audioTracks[context.id].details;\n        } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n          levelDetails = this.hls.subtitleTracks[context.id].details;\n        }\n        if (levelDetails) {\n          var partTarget = levelDetails.partTarget;\n          var targetDuration = levelDetails.targetduration;\n          if (partTarget && targetDuration) {\n            var maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n            loadPolicy = _extends({}, loadPolicy, {\n              maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n              maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n            });\n          }\n        }\n      }\n      var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n      var loaderConfig = {\n        loadPolicy: loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n      };\n      var loaderCallbacks = {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          var loader = _this.getInternalLoader(context);\n          _this.resetInternalLoader(context.type);\n          var string = response.data;\n          stats.parsing.start = performance.now();\n          if (M3U8Parser.isMediaPlaylist(string) || context.type !== PlaylistContextType.MANIFEST) {\n            _this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n          } else {\n            _this.handleMasterPlaylist(response, stats, context, networkDetails);\n          }\n        },\n        onError: function onError(response, context, networkDetails, stats) {\n          _this.handleNetworkError(context, networkDetails, false, response, stats);\n        },\n        onTimeout: function onTimeout(stats, context, networkDetails) {\n          _this.handleNetworkError(context, networkDetails, true, undefined, stats);\n        }\n      };\n\n      // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n      loader.load(context, loaderConfig, loaderCallbacks);\n    };\n    _proto.checkAutostartLoad = function checkAutostartLoad() {\n      if (!this.hls) {\n        return;\n      }\n      var _this$hls = this.hls,\n        _this$hls$config = _this$hls.config,\n        autoStartLoad = _this$hls$config.autoStartLoad,\n        startPosition = _this$hls$config.startPosition,\n        forceStartLoad = _this$hls.forceStartLoad;\n      if (autoStartLoad || forceStartLoad) {\n        this.hls.logger.log((autoStartLoad ? 'auto' : 'force') + \" startLoad with configured startPosition \" + startPosition);\n        this.hls.startLoad(startPosition);\n      }\n    };\n    _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {\n      var _this2 = this;\n      var hls = this.hls;\n      var string = response.data;\n      var url = getResponseUrl(response, context);\n      var parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n      if (parsedResult.playlistParsingError) {\n        stats.parsing.end = performance.now();\n        this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n        return;\n      }\n      var contentSteering = parsedResult.contentSteering,\n        levels = parsedResult.levels,\n        sessionData = parsedResult.sessionData,\n        sessionKeys = parsedResult.sessionKeys,\n        startTimeOffset = parsedResult.startTimeOffset,\n        variableList = parsedResult.variableList;\n      this.variableList = variableList;\n\n      // Treat unknown codec as audio or video codec based on passing `isTypeSupported` check\n      // (allows for playback of any supported codec even if not indexed in utils/codecs)\n      levels.forEach(function (levelParsed) {\n        var unknownCodecs = levelParsed.unknownCodecs;\n        if (unknownCodecs) {\n          var preferManagedMediaSource = _this2.hls.config.preferManagedMediaSource;\n          var audioCodec = levelParsed.audioCodec,\n            videoCodec = levelParsed.videoCodec;\n          for (var i = unknownCodecs.length; i--;) {\n            var unknownCodec = unknownCodecs[i];\n            if (areCodecsMediaSourceSupported(unknownCodec, 'audio', preferManagedMediaSource)) {\n              levelParsed.audioCodec = audioCodec = audioCodec ? audioCodec + \",\" + unknownCodec : unknownCodec;\n              sampleEntryCodesISO.audio[audioCodec.substring(0, 4)] = 2;\n              unknownCodecs.splice(i, 1);\n            } else if (areCodecsMediaSourceSupported(unknownCodec, 'video', preferManagedMediaSource)) {\n              levelParsed.videoCodec = videoCodec = videoCodec ? videoCodec + \",\" + unknownCodec : unknownCodec;\n              sampleEntryCodesISO.video[videoCodec.substring(0, 4)] = 2;\n              unknownCodecs.splice(i, 1);\n            }\n          }\n        }\n      });\n      var _M3U8Parser$parseMast = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult),\n        _M3U8Parser$parseMast2 = _M3U8Parser$parseMast.AUDIO,\n        audioTracks = _M3U8Parser$parseMast2 === void 0 ? [] : _M3U8Parser$parseMast2,\n        subtitles = _M3U8Parser$parseMast.SUBTITLES,\n        captions = _M3U8Parser$parseMast['CLOSED-CAPTIONS'];\n      if (audioTracks.length) {\n        // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n        var embeddedAudioFound = audioTracks.some(function (audioTrack) {\n          return !audioTrack.url;\n        });\n\n        // if no embedded audio track defined, but audio codec signaled in quality level,\n        // we need to signal this main audio track this could happen with playlists with\n        // alt audio rendition in which quality levels (main)\n        // contains both audio+video. but with mixed audio track not signaled\n        if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n          this.hls.logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n          audioTracks.unshift({\n            type: 'main',\n            name: 'main',\n            groupId: 'main',\n            default: false,\n            autoselect: false,\n            forced: false,\n            id: -1,\n            attrs: new AttrList({}),\n            bitrate: 0,\n            url: ''\n          });\n        }\n      }\n      hls.trigger(Events.MANIFEST_LOADED, {\n        levels: levels,\n        audioTracks: audioTracks,\n        subtitles: subtitles,\n        captions: captions,\n        contentSteering: contentSteering,\n        url: url,\n        stats: stats,\n        networkDetails: networkDetails,\n        sessionData: sessionData,\n        sessionKeys: sessionKeys,\n        startTimeOffset: startTimeOffset,\n        variableList: variableList\n      });\n    };\n    _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n      var hls = this.hls;\n      var id = context.id,\n        level = context.level,\n        type = context.type;\n      var url = getResponseUrl(response, context);\n      var levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;\n      var levelType = mapContextToLevelType(context);\n      var levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, 0, this.variableList);\n\n      // We have done our first request (Manifest-type) and receive\n      // not a master playlist but a chunk-list (track/level)\n      // We fire the manifest-loaded event anyway with the parsed level-details\n      // by creating a single-level structure for it.\n      if (type === PlaylistContextType.MANIFEST) {\n        var singleLevel = {\n          attrs: new AttrList({}),\n          bitrate: 0,\n          details: levelDetails,\n          name: '',\n          url: url\n        };\n        levelDetails.requestScheduled = stats.loading.start + computeReloadInterval(levelDetails, 0);\n        hls.trigger(Events.MANIFEST_LOADED, {\n          levels: [singleLevel],\n          audioTracks: [],\n          url: url,\n          stats: stats,\n          networkDetails: networkDetails,\n          sessionData: null,\n          sessionKeys: null,\n          contentSteering: null,\n          startTimeOffset: null,\n          variableList: null\n        });\n      }\n\n      // save parsing time\n      stats.parsing.end = performance.now();\n\n      // extend the context with the new levelDetails property\n      context.levelDetails = levelDetails;\n      this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n    };\n    _proto.handleManifestParsingError = function handleManifestParsingError(response, context, error, networkDetails, stats) {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.MANIFEST_PARSING_ERROR,\n        fatal: context.type === PlaylistContextType.MANIFEST,\n        url: response.url,\n        err: error,\n        error: error,\n        reason: error.message,\n        response: response,\n        context: context,\n        networkDetails: networkDetails,\n        stats: stats\n      });\n    };\n    _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response, stats) {\n      if (timeout === void 0) {\n        timeout = false;\n      }\n      var message = \"A network \" + (timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')) + \" occurred while loading \" + context.type;\n      if (context.type === PlaylistContextType.LEVEL) {\n        message += \": \" + context.level + \" id: \" + context.id;\n      } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n        message += \" id: \" + context.id + \" group-id: \\\"\" + context.groupId + \"\\\"\";\n      }\n      var error = new Error(message);\n      this.hls.logger.warn(\"[playlist-loader]: \" + message);\n      var details = ErrorDetails.UNKNOWN;\n      var fatal = false;\n      var loader = this.getInternalLoader(context);\n      switch (context.type) {\n        case PlaylistContextType.MANIFEST:\n          details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n          fatal = true;\n          break;\n        case PlaylistContextType.LEVEL:\n          details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n          fatal = false;\n          break;\n        case PlaylistContextType.AUDIO_TRACK:\n          details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n          fatal = false;\n          break;\n        case PlaylistContextType.SUBTITLE_TRACK:\n          details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n          fatal = false;\n          break;\n      }\n      if (loader) {\n        this.resetInternalLoader(context.type);\n      }\n      var errorData = {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: details,\n        fatal: fatal,\n        url: context.url,\n        loader: loader,\n        context: context,\n        error: error,\n        networkDetails: networkDetails,\n        stats: stats\n      };\n      if (response) {\n        var url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n        errorData.response = _objectSpread2({\n          url: url,\n          data: undefined\n        }, response);\n      }\n      this.hls.trigger(Events.ERROR, errorData);\n    };\n    _proto.handlePlaylistLoaded = function handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n      var hls = this.hls;\n      var type = context.type,\n        level = context.level,\n        levelOrTrack = context.levelOrTrack,\n        id = context.id,\n        groupId = context.groupId,\n        deliveryDirectives = context.deliveryDirectives;\n      var url = getResponseUrl(response, context);\n      var parent = mapContextToLevelType(context);\n      var levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n      var error = levelDetails.playlistParsingError;\n      if (error) {\n        this.hls.logger.warn(error + \" \" + levelDetails.url);\n        if (!hls.config.ignorePlaylistParsingErrors) {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.LEVEL_PARSING_ERROR,\n            fatal: false,\n            url: url,\n            error: error,\n            reason: error.message,\n            response: response,\n            context: context,\n            level: levelIndex,\n            parent: parent,\n            networkDetails: networkDetails,\n            stats: stats\n          });\n          return;\n        }\n        levelDetails.playlistParsingError = null;\n      }\n      if (!levelDetails.fragments.length) {\n        var _error = levelDetails.playlistParsingError = new Error('No Segments found in Playlist');\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.NETWORK_ERROR,\n          details: ErrorDetails.LEVEL_EMPTY_ERROR,\n          fatal: false,\n          url: url,\n          error: _error,\n          reason: _error.message,\n          response: response,\n          context: context,\n          level: levelIndex,\n          parent: parent,\n          networkDetails: networkDetails,\n          stats: stats\n        });\n        return;\n      }\n      if (levelDetails.live && loader) {\n        if (loader.getCacheAge) {\n          levelDetails.ageHeader = loader.getCacheAge() || 0;\n        }\n        if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n          levelDetails.ageHeader = 0;\n        }\n      }\n      switch (type) {\n        case PlaylistContextType.MANIFEST:\n        case PlaylistContextType.LEVEL:\n          if (levelIndex) {\n            if (!levelOrTrack) {\n              // fall-through to hls.levels[0]\n              levelIndex = 0;\n            } else {\n              if (levelOrTrack !== hls.levels[levelIndex]) {\n                // correct levelIndex when lower levels were removed from hls.levels\n                var updatedIndex = hls.levels.indexOf(levelOrTrack);\n                if (updatedIndex > -1) {\n                  levelIndex = updatedIndex;\n                }\n              }\n            }\n          }\n          hls.trigger(Events.LEVEL_LOADED, {\n            details: levelDetails,\n            levelInfo: levelOrTrack || hls.levels[0],\n            level: levelIndex || 0,\n            id: id || 0,\n            stats: stats,\n            networkDetails: networkDetails,\n            deliveryDirectives: deliveryDirectives,\n            withoutMultiVariant: type === PlaylistContextType.MANIFEST\n          });\n          break;\n        case PlaylistContextType.AUDIO_TRACK:\n          hls.trigger(Events.AUDIO_TRACK_LOADED, {\n            details: levelDetails,\n            track: levelOrTrack,\n            id: id || 0,\n            groupId: groupId || '',\n            stats: stats,\n            networkDetails: networkDetails,\n            deliveryDirectives: deliveryDirectives\n          });\n          break;\n        case PlaylistContextType.SUBTITLE_TRACK:\n          hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n            details: levelDetails,\n            track: levelOrTrack,\n            id: id || 0,\n            groupId: groupId || '',\n            stats: stats,\n            networkDetails: networkDetails,\n            deliveryDirectives: deliveryDirectives\n          });\n          break;\n      }\n    };\n    return PlaylistLoader;\n  }();\n\n  /**\n   * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n   * @public\n   */\n  var Hls = /*#__PURE__*/function () {\n    /**\n     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n     * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n     */\n    function Hls(userConfig) {\n      if (userConfig === void 0) {\n        userConfig = {};\n      }\n      /**\n       * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n       */\n      this.config = void 0;\n      /**\n       * The configuration object provided on player instantiation.\n       */\n      this.userConfig = void 0;\n      /**\n       * The logger functions used by this player instance, configured on player instantiation.\n       */\n      this.logger = void 0;\n      this.coreComponents = void 0;\n      this.networkControllers = void 0;\n      this._emitter = new EventEmitter();\n      this._autoLevelCapping = -1;\n      this._maxHdcpLevel = null;\n      this.abrController = void 0;\n      this.bufferController = void 0;\n      this.capLevelController = void 0;\n      this.latencyController = void 0;\n      this.levelController = void 0;\n      this.streamController = void 0;\n      this.audioStreamController = void 0;\n      this.subtititleStreamController = void 0;\n      this.audioTrackController = void 0;\n      this.subtitleTrackController = void 0;\n      this.interstitialsController = void 0;\n      this.gapController = void 0;\n      this.emeController = void 0;\n      this.cmcdController = void 0;\n      this._media = null;\n      this._url = null;\n      this._sessionId = void 0;\n      this.triggeringException = void 0;\n      this.started = false;\n      var logger = this.logger = enableLogs(userConfig.debug || false, 'Hls instance', userConfig.assetPlayerId);\n      var config = this.config = mergeConfig(Hls.DefaultConfig, userConfig, logger);\n      this.userConfig = userConfig;\n      if (config.progressive) {\n        enableStreamingMode(config, logger);\n      }\n\n      // core controllers and network loaders\n      var _AbrController = config.abrController,\n        _BufferController = config.bufferController,\n        _CapLevelController = config.capLevelController,\n        _ErrorController = config.errorController,\n        _FpsController = config.fpsController;\n      var errorController = new _ErrorController(this);\n      var abrController = this.abrController = new _AbrController(this);\n      // FragmentTracker must be defined before StreamController because the order of event handling is important\n      var fragmentTracker = new FragmentTracker(this);\n      var _InterstitialsController = config.interstitialsController;\n      var interstitialsController = _InterstitialsController ? this.interstitialsController = new _InterstitialsController(this, Hls) : null;\n      var bufferController = this.bufferController = new _BufferController(this, fragmentTracker);\n      var capLevelController = this.capLevelController = new _CapLevelController(this);\n      var fpsController = new _FpsController(this);\n      var playListLoader = new PlaylistLoader(this);\n      var _ContentSteeringController = config.contentSteeringController;\n      // Instantiate ConentSteeringController before LevelController to receive Multivariant Playlist events first\n      var contentSteering = _ContentSteeringController ? new _ContentSteeringController(this) : null;\n      var levelController = this.levelController = new LevelController(this, contentSteering);\n      var id3TrackController = new ID3TrackController(this);\n      var keyLoader = new KeyLoader(this.config, this.logger);\n      var streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n      var gapController = this.gapController = new GapController(this, fragmentTracker);\n\n      // Cap level controller uses streamController to flush the buffer\n      capLevelController.setStreamController(streamController);\n      // fpsController uses streamController to switch when frames are being dropped\n      fpsController.setStreamController(streamController);\n      var networkControllers = [playListLoader, levelController, streamController];\n      if (interstitialsController) {\n        networkControllers.splice(1, 0, interstitialsController);\n      }\n      if (contentSteering) {\n        networkControllers.splice(1, 0, contentSteering);\n      }\n      this.networkControllers = networkControllers;\n      var coreComponents = [abrController, bufferController, gapController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n      this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n      var AudioStreamControllerClass = config.audioStreamController;\n      if (AudioStreamControllerClass) {\n        networkControllers.push(this.audioStreamController = new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n      }\n      // Instantiate subtitleTrackController before SubtitleStreamController to receive level events first\n      this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n      var SubtitleStreamControllerClass = config.subtitleStreamController;\n      if (SubtitleStreamControllerClass) {\n        networkControllers.push(this.subtititleStreamController = new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n      }\n      this.createController(config.timelineController, coreComponents);\n      keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n      this.cmcdController = this.createController(config.cmcdController, coreComponents);\n      this.latencyController = this.createController(LatencyController, coreComponents);\n      this.coreComponents = coreComponents;\n\n      // Error controller handles errors before and after all other controllers\n      // This listener will be invoked after all other controllers error listeners\n      networkControllers.push(errorController);\n      var onErrorOut = errorController.onErrorOut;\n      if (typeof onErrorOut === 'function') {\n        this.on(Events.ERROR, onErrorOut, errorController);\n      }\n      // Autostart load handler\n      this.on(Events.MANIFEST_LOADED, playListLoader.onManifestLoaded, playListLoader);\n    }\n    /**\n     * Check if the required MediaSource Extensions are available.\n     */\n    Hls.isMSESupported = function isMSESupported$1() {\n      return isMSESupported();\n    }\n\n    /**\n     * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.\n     */;\n    Hls.isSupported = function isSupported$1() {\n      return isSupported();\n    }\n\n    /**\n     * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).\n     */;\n    Hls.getMediaSource = function getMediaSource$1() {\n      return getMediaSource();\n    };\n    var _proto = Hls.prototype;\n    _proto.createController = function createController(ControllerClass, components) {\n      if (ControllerClass) {\n        var controllerInstance = new ControllerClass(this);\n        if (components) {\n          components.push(controllerInstance);\n        }\n        return controllerInstance;\n      }\n      return null;\n    }\n\n    // Delegate the EventEmitter through the public API of Hls.js\n    ;\n    _proto.on = function on(event, listener, context) {\n      if (context === void 0) {\n        context = this;\n      }\n      this._emitter.on(event, listener, context);\n    };\n    _proto.once = function once(event, listener, context) {\n      if (context === void 0) {\n        context = this;\n      }\n      this._emitter.once(event, listener, context);\n    };\n    _proto.removeAllListeners = function removeAllListeners(event) {\n      this._emitter.removeAllListeners(event);\n    };\n    _proto.off = function off(event, listener, context, once) {\n      if (context === void 0) {\n        context = this;\n      }\n      this._emitter.off(event, listener, context, once);\n    };\n    _proto.listeners = function listeners(event) {\n      return this._emitter.listeners(event);\n    };\n    _proto.emit = function emit(event, name, eventObject) {\n      return this._emitter.emit(event, name, eventObject);\n    };\n    _proto.trigger = function trigger(event, eventObject) {\n      if (this.config.debug) {\n        return this.emit(event, event, eventObject);\n      } else {\n        try {\n          return this.emit(event, event, eventObject);\n        } catch (error) {\n          this.logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + error.message + '\". Here is a stacktrace:', error);\n          // Prevent recursion in error event handlers that throw #5497\n          if (!this.triggeringException) {\n            this.triggeringException = true;\n            var fatal = event === Events.ERROR;\n            this.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.INTERNAL_EXCEPTION,\n              fatal: fatal,\n              event: event,\n              error: error\n            });\n            this.triggeringException = false;\n          }\n        }\n      }\n      return false;\n    };\n    _proto.listenerCount = function listenerCount(event) {\n      return this._emitter.listenerCount(event);\n    }\n\n    /**\n     * Dispose of the instance\n     */;\n    _proto.destroy = function destroy() {\n      this.logger.log('destroy');\n      this.trigger(Events.DESTROYING, undefined);\n      this.detachMedia();\n      this.removeAllListeners();\n      this._autoLevelCapping = -1;\n      this._url = null;\n      this.networkControllers.forEach(function (component) {\n        return component.destroy();\n      });\n      this.networkControllers.length = 0;\n      this.coreComponents.forEach(function (component) {\n        return component.destroy();\n      });\n      this.coreComponents.length = 0;\n      // Remove any references that could be held in config options or callbacks\n      var config = this.config;\n      config.xhrSetup = config.fetchSetup = undefined;\n      // @ts-ignore\n      this.userConfig = null;\n    }\n\n    /**\n     * Attaches Hls.js to a media element\n     */;\n    _proto.attachMedia = function attachMedia(data) {\n      if (!data || 'media' in data && !data.media) {\n        var error = new Error(\"attachMedia failed: invalid argument (\" + data + \")\");\n        this.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.ATTACH_MEDIA_ERROR,\n          fatal: true,\n          error: error\n        });\n        return;\n      }\n      this.logger.log(\"attachMedia\");\n      if (this._media) {\n        this.logger.warn(\"media must be detached before attaching\");\n        this.detachMedia();\n      }\n      var attachMediaSource = 'media' in data;\n      var media = attachMediaSource ? data.media : data;\n      var attachingData = attachMediaSource ? data : {\n        media: media\n      };\n      this._media = media;\n      this.trigger(Events.MEDIA_ATTACHING, attachingData);\n    }\n\n    /**\n     * Detach Hls.js from the media\n     */;\n    _proto.detachMedia = function detachMedia() {\n      this.logger.log('detachMedia');\n      this.trigger(Events.MEDIA_DETACHING, {});\n      this._media = null;\n    }\n\n    /**\n     * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance\n     */;\n    _proto.transferMedia = function transferMedia() {\n      this._media = null;\n      var transferMedia = this.bufferController.transferMedia();\n      this.trigger(Events.MEDIA_DETACHING, {\n        transferMedia: transferMedia\n      });\n      return transferMedia;\n    }\n\n    /**\n     * Set the source URL. Can be relative or absolute.\n     */;\n    _proto.loadSource = function loadSource(url) {\n      this.stopLoad();\n      var media = this.media;\n      var loadedSource = this._url;\n      var loadingSource = this._url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n        alwaysNormalize: true\n      });\n      this._autoLevelCapping = -1;\n      this._maxHdcpLevel = null;\n      this.logger.log(\"loadSource:\" + loadingSource);\n      if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n        // Remove and re-create MediaSource\n        this.detachMedia();\n        this.attachMedia(media);\n      }\n      // when attaching to a source URL, trigger a playlist load\n      this.trigger(Events.MANIFEST_LOADING, {\n        url: url\n      });\n    }\n\n    /**\n     * Gets the currently loaded URL\n     */;\n    /**\n     * Start loading data from the stream source.\n     * Depending on default config, client starts loading automatically when a source is set.\n     *\n     * @param startPosition - Set the start position to stream from.\n     * Defaults to -1 (None: starts from earliest point)\n     */\n    _proto.startLoad = function startLoad(startPosition, skipSeekToStartPosition) {\n      if (startPosition === void 0) {\n        startPosition = -1;\n      }\n      this.logger.log(\"startLoad(\" + (startPosition + (skipSeekToStartPosition ? ', <skip seek to start>' : '')) + \")\");\n      this.started = true;\n      this.resumeBuffering();\n      for (var i = 0; i < this.networkControllers.length; i++) {\n        this.networkControllers[i].startLoad(startPosition, skipSeekToStartPosition);\n        if (!this.started || !this.networkControllers) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Stop loading of any stream data.\n     */;\n    _proto.stopLoad = function stopLoad() {\n      this.logger.log('stopLoad');\n      this.started = false;\n      for (var i = 0; i < this.networkControllers.length; i++) {\n        this.networkControllers[i].stopLoad();\n        if (this.started || !this.networkControllers) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.\n     */;\n    /**\n     * Resumes stream controller segment loading after `pauseBuffering` has been called.\n     */\n    _proto.resumeBuffering = function resumeBuffering() {\n      if (!this.bufferingEnabled) {\n        this.logger.log(\"resume buffering\");\n        this.networkControllers.forEach(function (controller) {\n          if (controller.resumeBuffering) {\n            controller.resumeBuffering();\n          }\n        });\n      }\n    }\n\n    /**\n     * Prevents stream controller from loading new segments until `resumeBuffering` is called.\n     * This allows for media buffering to be paused without interupting playlist loading.\n     */;\n    _proto.pauseBuffering = function pauseBuffering() {\n      if (this.bufferingEnabled) {\n        this.logger.log(\"pause buffering\");\n        this.networkControllers.forEach(function (controller) {\n          if (controller.pauseBuffering) {\n            controller.pauseBuffering();\n          }\n        });\n      }\n    };\n    /**\n     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n     */\n    _proto.swapAudioCodec = function swapAudioCodec() {\n      this.logger.log('swapAudioCodec');\n      this.streamController.swapAudioCodec();\n    }\n\n    /**\n     * When the media-element fails, this allows to detach and then re-attach it\n     * as one call (convenience method).\n     *\n     * Automatic recovery of media-errors by this process is configurable.\n     */;\n    _proto.recoverMediaError = function recoverMediaError() {\n      this.logger.log('recoverMediaError');\n      var media = this._media;\n      var time = media == null ? void 0 : media.currentTime;\n      this.detachMedia();\n      if (media) {\n        this.attachMedia(media);\n        if (time) {\n          this.startLoad(time);\n        }\n      }\n    };\n    _proto.removeLevel = function removeLevel(levelIndex) {\n      this.levelController.removeLevel(levelIndex);\n    }\n\n    /**\n     * @returns a UUID for this player instance\n     */;\n    /**\n     * Find and select the best matching audio track, making a level switch when a Group change is necessary.\n     * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.\n     */\n    _proto.setAudioOption = function setAudioOption(audioOption) {\n      var _this$audioTrackContr;\n      return ((_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption)) || null;\n    }\n    /**\n     * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.\n     * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.\n     */;\n    _proto.setSubtitleOption = function setSubtitleOption(subtitleOption) {\n      var _this$subtitleTrackCo;\n      return ((_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption)) || null;\n    }\n\n    /**\n     * Get the complete list of audio tracks across all media groups\n     */;\n    /**\n     * returns mediaCapabilities.decodingInfo for a variant/rendition\n     */\n    _proto.getMediaDecodingInfo = function getMediaDecodingInfo(level, audioTracks) {\n      if (audioTracks === void 0) {\n        audioTracks = this.allAudioTracks;\n      }\n      var audioTracksByGroup = getAudioTracksByGroup(audioTracks);\n      return getMediaDecodingInfoPromise(level, audioTracksByGroup, navigator.mediaCapabilities);\n    };\n    return _createClass(Hls, [{\n      key: \"url\",\n      get: function get() {\n        return this._url;\n      }\n\n      /**\n       * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position\n       */\n    }, {\n      key: \"hasEnoughToStart\",\n      get: function get() {\n        return this.streamController.hasEnoughToStart;\n      }\n\n      /**\n       * Get the startPosition set on startLoad(position) or on autostart with config.startPosition\n       */\n    }, {\n      key: \"startPosition\",\n      get: function get() {\n        return this.streamController.startPositionValue;\n      }\n    }, {\n      key: \"loadingEnabled\",\n      get: function get() {\n        return this.started;\n      }\n\n      /**\n       * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.\n       */\n    }, {\n      key: \"bufferingEnabled\",\n      get: function get() {\n        return this.streamController.bufferingEnabled;\n      }\n    }, {\n      key: \"inFlightFragments\",\n      get: function get() {\n        var _inFlightData;\n        var inFlightData = (_inFlightData = {}, _inFlightData[PlaylistLevelType.MAIN] = this.streamController.inFlightFrag, _inFlightData);\n        if (this.audioStreamController) {\n          inFlightData[PlaylistLevelType.AUDIO] = this.audioStreamController.inFlightFrag;\n        }\n        if (this.subtititleStreamController) {\n          inFlightData[PlaylistLevelType.SUBTITLE] = this.subtititleStreamController.inFlightFrag;\n        }\n        return inFlightData;\n      }\n    }, {\n      key: \"sessionId\",\n      get: function get() {\n        var _sessionId = this._sessionId;\n        if (!_sessionId) {\n          _sessionId = this._sessionId = uuid();\n        }\n        return _sessionId;\n      }\n\n      /**\n       * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH\n       */\n    }, {\n      key: \"levels\",\n      get: function get() {\n        var levels = this.levelController.levels;\n        return levels ? levels : [];\n      }\n\n      /**\n       * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.\n       */\n    }, {\n      key: \"latestLevelDetails\",\n      get: function get() {\n        return this.streamController.getLevelDetails() || null;\n      }\n\n      /**\n       * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.\n       */\n    }, {\n      key: \"loadLevelObj\",\n      get: function get() {\n        return this.levelController.loadLevelObj;\n      }\n\n      /**\n       * Index of quality level (variant) currently played\n       */\n    }, {\n      key: \"currentLevel\",\n      get: function get() {\n        return this.streamController.currentLevel;\n      }\n\n      /**\n       * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n       */,\n      set: function set(newLevel) {\n        this.logger.log(\"set currentLevel:\" + newLevel);\n        this.levelController.manualLevel = newLevel;\n        this.streamController.immediateLevelSwitch();\n      }\n\n      /**\n       * Index of next quality level loaded as scheduled by stream controller.\n       */\n    }, {\n      key: \"nextLevel\",\n      get: function get() {\n        return this.streamController.nextLevel;\n      }\n\n      /**\n       * Set quality level index for next loaded data.\n       * This will switch the video quality asap, without interrupting playback.\n       * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n       * @param newLevel - Pass -1 for automatic level selection\n       */,\n      set: function set(newLevel) {\n        this.logger.log(\"set nextLevel:\" + newLevel);\n        this.levelController.manualLevel = newLevel;\n        this.streamController.nextLevelSwitch();\n      }\n\n      /**\n       * Return the quality level of the currently or last (of none is loaded currently) segment\n       */\n    }, {\n      key: \"loadLevel\",\n      get: function get() {\n        return this.levelController.level;\n      }\n\n      /**\n       * Set quality level index for next loaded data in a conservative way.\n       * This will switch the quality without flushing, but interrupt current loading.\n       * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n       * @param newLevel - Pass -1 for automatic level selection\n       */,\n      set: function set(newLevel) {\n        this.logger.log(\"set loadLevel:\" + newLevel);\n        this.levelController.manualLevel = newLevel;\n      }\n\n      /**\n       * get next quality level loaded\n       */\n    }, {\n      key: \"nextLoadLevel\",\n      get: function get() {\n        return this.levelController.nextLoadLevel;\n      }\n\n      /**\n       * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n       * Same as `loadLevel` but will wait for next switch (until current loading is done).\n       */,\n      set: function set(level) {\n        this.levelController.nextLoadLevel = level;\n      }\n\n      /**\n       * Return \"first level\": like a default level, if not set,\n       * falls back to index of first level referenced in manifest\n       */\n    }, {\n      key: \"firstLevel\",\n      get: function get() {\n        return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n      }\n\n      /**\n       * Sets \"first-level\", see getter.\n       */,\n      set: function set(newLevel) {\n        this.logger.log(\"set firstLevel:\" + newLevel);\n        this.levelController.firstLevel = newLevel;\n      }\n\n      /**\n       * Return the desired start level for the first fragment that will be loaded.\n       * The default value of -1 indicates automatic start level selection.\n       * Setting hls.nextAutoLevel without setting a startLevel will result in\n       * the nextAutoLevel value being used for one fragment load.\n       */\n    }, {\n      key: \"startLevel\",\n      get: function get() {\n        var startLevel = this.levelController.startLevel;\n        if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {\n          return this.abrController.forcedAutoLevel;\n        }\n        return startLevel;\n      }\n\n      /**\n       * set  start level (level of first fragment that will be played back)\n       * if not overrided by user, first level appearing in manifest will be used as start level\n       * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n       * (determined from download of first segment)\n       */,\n      set: function set(newLevel) {\n        this.logger.log(\"set startLevel:\" + newLevel);\n        // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n        if (newLevel !== -1) {\n          newLevel = Math.max(newLevel, this.minAutoLevel);\n        }\n        this.levelController.startLevel = newLevel;\n      }\n\n      /**\n       * Whether level capping is enabled.\n       * Default value is set via `config.capLevelToPlayerSize`.\n       */\n    }, {\n      key: \"capLevelToPlayerSize\",\n      get: function get() {\n        return this.config.capLevelToPlayerSize;\n      }\n\n      /**\n       * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n       */,\n      set: function set(shouldStartCapping) {\n        var newCapLevelToPlayerSize = !!shouldStartCapping;\n        if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n          if (newCapLevelToPlayerSize) {\n            this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n          } else {\n            this.capLevelController.stopCapping();\n            this.autoLevelCapping = -1;\n            this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n          }\n          this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n        }\n      }\n\n      /**\n       * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n       */\n    }, {\n      key: \"autoLevelCapping\",\n      get: function get() {\n        return this._autoLevelCapping;\n      }\n\n      /**\n       * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n       */,\n      set:\n      /**\n       * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n       */\n      function set(newLevel) {\n        if (this._autoLevelCapping !== newLevel) {\n          this.logger.log(\"set autoLevelCapping:\" + newLevel);\n          this._autoLevelCapping = newLevel;\n          this.levelController.checkMaxAutoUpdated();\n        }\n      }\n    }, {\n      key: \"bandwidthEstimate\",\n      get: function get() {\n        var bwEstimator = this.abrController.bwEstimator;\n        if (!bwEstimator) {\n          return NaN;\n        }\n        return bwEstimator.getEstimate();\n      },\n      set: function set(abrEwmaDefaultEstimate) {\n        this.abrController.resetEstimator(abrEwmaDefaultEstimate);\n      }\n    }, {\n      key: \"abrEwmaDefaultEstimate\",\n      get: function get() {\n        var bwEstimator = this.abrController.bwEstimator;\n        if (!bwEstimator) {\n          return NaN;\n        }\n        return bwEstimator.defaultEstimate;\n      }\n\n      /**\n       * get time to first byte estimate\n       * @type {number}\n       */\n    }, {\n      key: \"ttfbEstimate\",\n      get: function get() {\n        var bwEstimator = this.abrController.bwEstimator;\n        if (!bwEstimator) {\n          return NaN;\n        }\n        return bwEstimator.getEstimateTTFB();\n      }\n    }, {\n      key: \"maxHdcpLevel\",\n      get: function get() {\n        return this._maxHdcpLevel;\n      },\n      set: function set(value) {\n        if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {\n          this._maxHdcpLevel = value;\n          this.levelController.checkMaxAutoUpdated();\n        }\n      }\n\n      /**\n       * True when automatic level selection enabled\n       */\n    }, {\n      key: \"autoLevelEnabled\",\n      get: function get() {\n        return this.levelController.manualLevel === -1;\n      }\n\n      /**\n       * Level set manually (if any)\n       */\n    }, {\n      key: \"manualLevel\",\n      get: function get() {\n        return this.levelController.manualLevel;\n      }\n\n      /**\n       * min level selectable in auto mode according to config.minAutoBitrate\n       */\n    }, {\n      key: \"minAutoLevel\",\n      get: function get() {\n        var levels = this.levels,\n          minAutoBitrate = this.config.minAutoBitrate;\n        if (!levels) return 0;\n        var len = levels.length;\n        for (var i = 0; i < len; i++) {\n          if (levels[i].maxBitrate >= minAutoBitrate) {\n            return i;\n          }\n        }\n        return 0;\n      }\n\n      /**\n       * max level selectable in auto mode according to autoLevelCapping\n       */\n    }, {\n      key: \"maxAutoLevel\",\n      get: function get() {\n        var levels = this.levels,\n          autoLevelCapping = this.autoLevelCapping,\n          maxHdcpLevel = this.maxHdcpLevel;\n        var maxAutoLevel;\n        if (autoLevelCapping === -1 && levels != null && levels.length) {\n          maxAutoLevel = levels.length - 1;\n        } else {\n          maxAutoLevel = autoLevelCapping;\n        }\n        if (maxHdcpLevel) {\n          for (var i = maxAutoLevel; i--;) {\n            var hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n            if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n              return i;\n            }\n          }\n        }\n        return maxAutoLevel;\n      }\n    }, {\n      key: \"firstAutoLevel\",\n      get: function get() {\n        return this.abrController.firstAutoLevel;\n      }\n\n      /**\n       * next automatically selected quality level\n       */\n    }, {\n      key: \"nextAutoLevel\",\n      get: function get() {\n        return this.abrController.nextAutoLevel;\n      }\n\n      /**\n       * this setter is used to force next auto level.\n       * this is useful to force a switch down in auto mode:\n       * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n       * forced value is valid for one fragment. upon successful frag loading at forced level,\n       * this value will be resetted to -1 by ABR controller.\n       */,\n      set: function set(nextLevel) {\n        this.abrController.nextAutoLevel = nextLevel;\n      }\n\n      /**\n       * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n       */\n    }, {\n      key: \"playingDate\",\n      get: function get() {\n        return this.streamController.currentProgramDateTime;\n      }\n    }, {\n      key: \"mainForwardBufferInfo\",\n      get: function get() {\n        return this.streamController.getMainFwdBufferInfo();\n      }\n    }, {\n      key: \"maxBufferLength\",\n      get: function get() {\n        return this.streamController.maxBufferLength;\n      }\n    }, {\n      key: \"allAudioTracks\",\n      get: function get() {\n        var audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.allAudioTracks : [];\n      }\n\n      /**\n       * Get the list of selectable audio tracks\n       */\n    }, {\n      key: \"audioTracks\",\n      get: function get() {\n        var audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.audioTracks : [];\n      }\n\n      /**\n       * index of the selected audio track (index in audio track lists)\n       */\n    }, {\n      key: \"audioTrack\",\n      get: function get() {\n        var audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.audioTrack : -1;\n      }\n\n      /**\n       * selects an audio track, based on its index in audio track lists\n       */,\n      set: function set(audioTrackId) {\n        var audioTrackController = this.audioTrackController;\n        if (audioTrackController) {\n          audioTrackController.audioTrack = audioTrackId;\n        }\n      }\n\n      /**\n       * get the complete list of subtitle tracks across all media groups\n       */\n    }, {\n      key: \"allSubtitleTracks\",\n      get: function get() {\n        var subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];\n      }\n\n      /**\n       * get alternate subtitle tracks list from playlist\n       */\n    }, {\n      key: \"subtitleTracks\",\n      get: function get() {\n        var subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n      }\n\n      /**\n       * index of the selected subtitle track (index in subtitle track lists)\n       */\n    }, {\n      key: \"subtitleTrack\",\n      get: function get() {\n        var subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n      },\n      set:\n      /**\n       * select an subtitle track, based on its index in subtitle track lists\n       */\n      function set(subtitleTrackId) {\n        var subtitleTrackController = this.subtitleTrackController;\n        if (subtitleTrackController) {\n          subtitleTrackController.subtitleTrack = subtitleTrackId;\n        }\n      }\n\n      /**\n       * Whether subtitle display is enabled or not\n       */\n    }, {\n      key: \"media\",\n      get: function get() {\n        return this._media;\n      }\n    }, {\n      key: \"subtitleDisplay\",\n      get: function get() {\n        var subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n      }\n\n      /**\n       * Enable/disable subtitle display rendering\n       */,\n      set: function set(value) {\n        var subtitleTrackController = this.subtitleTrackController;\n        if (subtitleTrackController) {\n          subtitleTrackController.subtitleDisplay = value;\n        }\n      }\n\n      /**\n       * get mode for Low-Latency HLS loading\n       */\n    }, {\n      key: \"lowLatencyMode\",\n      get: function get() {\n        return this.config.lowLatencyMode;\n      }\n\n      /**\n       * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n       */,\n      set: function set(mode) {\n        this.config.lowLatencyMode = mode;\n      }\n\n      /**\n       * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n       * @returns null prior to loading live Playlist\n       */\n    }, {\n      key: \"liveSyncPosition\",\n      get: function get() {\n        return this.latencyController.liveSyncPosition;\n      }\n\n      /**\n       * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n       * @returns 0 before first playlist is loaded\n       */\n    }, {\n      key: \"latency\",\n      get: function get() {\n        return this.latencyController.latency;\n      }\n\n      /**\n       * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n       * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n       * @returns 0 before first playlist is loaded\n       */\n    }, {\n      key: \"maxLatency\",\n      get: function get() {\n        return this.latencyController.maxLatency;\n      }\n\n      /**\n       * target distance from the edge as calculated by the latency controller\n       */\n    }, {\n      key: \"targetLatency\",\n      get: function get() {\n        return this.latencyController.targetLatency;\n      },\n      set: function set(latency) {\n        this.latencyController.targetLatency = latency;\n      }\n\n      /**\n       * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n       */\n    }, {\n      key: \"drift\",\n      get: function get() {\n        return this.latencyController.drift;\n      }\n\n      /**\n       * set to true when startLoad is called before MANIFEST_PARSED event\n       */\n    }, {\n      key: \"forceStartLoad\",\n      get: function get() {\n        return this.streamController.forceStartLoad;\n      }\n\n      /**\n       * ContentSteering pathways getter\n       */\n    }, {\n      key: \"pathways\",\n      get: function get() {\n        return this.levelController.pathways;\n      }\n\n      /**\n       * ContentSteering pathwayPriority getter/setter\n       */\n    }, {\n      key: \"pathwayPriority\",\n      get: function get() {\n        return this.levelController.pathwayPriority;\n      },\n      set: function set(pathwayPriority) {\n        this.levelController.pathwayPriority = pathwayPriority;\n      }\n\n      /**\n       * returns true when all SourceBuffers are buffered to the end\n       */\n    }, {\n      key: \"bufferedToEnd\",\n      get: function get() {\n        var _this$bufferControlle;\n        return !!((_this$bufferControlle = this.bufferController) != null && _this$bufferControlle.bufferedToEnd);\n      }\n\n      /**\n       * returns Interstitials Program Manager\n       */\n    }, {\n      key: \"interstitialsManager\",\n      get: function get() {\n        var _this$interstitialsCo;\n        return ((_this$interstitialsCo = this.interstitialsController) == null ? void 0 : _this$interstitialsCo.interstitialsManager) || null;\n      }\n    }], [{\n      key: \"version\",\n      get:\n      /**\n       * Get the video-dev/hls.js package version.\n       */\n      function get() {\n        return version;\n      }\n    }, {\n      key: \"Events\",\n      get: function get() {\n        return Events;\n      }\n    }, {\n      key: \"MetadataSchema\",\n      get: function get() {\n        return MetadataSchema;\n      }\n    }, {\n      key: \"ErrorTypes\",\n      get: function get() {\n        return ErrorTypes;\n      }\n    }, {\n      key: \"ErrorDetails\",\n      get: function get() {\n        return ErrorDetails;\n      }\n\n      /**\n       * Get the default configuration applied to new instances.\n       */\n    }, {\n      key: \"DefaultConfig\",\n      get: function get() {\n        if (!Hls.defaultConfig) {\n          return hlsDefaultConfig;\n        }\n        return Hls.defaultConfig;\n      }\n\n      /**\n       * Replace the default configuration applied to new instances.\n       */,\n      set: function set(defaultConfig) {\n        Hls.defaultConfig = defaultConfig;\n      }\n    }]);\n  }();\n  Hls.defaultConfig = void 0;\n\n  return Hls;\n\n}));\n})(false);\n//# sourceMappingURL=hls.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDa0c7QUFDcEcsQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFVBQVU7QUFDekIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7O0FBRUE7QUFDQSxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUU7QUFDQSwrREFBK0QsU0FBUztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsVUFBVTtBQUN6QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFVBQVU7QUFDekIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0VBQWdFLFlBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEZBQTBGLGlCQUFpQjtBQUMzRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwrQkFBK0I7QUFDckY7QUFDQSx3REFBd0QsK0JBQStCO0FBQ3ZGO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBLHFEQUFxRCwrQkFBK0I7QUFDcEY7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSwwREFBMEQsK0JBQStCO0FBQ3pGO0FBQ0EsNERBQTRELCtCQUErQjtBQUMzRjtBQUNBLDREQUE0RCwrQkFBK0I7QUFDM0Y7QUFDQSw4REFBOEQsK0JBQStCO0FBQzdGO0FBQ0Esb0RBQW9ELHFDQUFxQztBQUN6RjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLHVEQUF1RCxxQ0FBcUM7QUFDNUY7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQSxvSkFBb0o7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsNkJBQTZCO0FBQ2xHO0FBQ0EsdUVBQXVFLDZCQUE2QjtBQUNwRztBQUNBLHdFQUF3RSxzREFBc0Q7QUFDOUg7QUFDQSx3RUFBd0Usc0RBQXNEO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixXQUFXO0FBQ3JHO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0Esb0hBQW9IO0FBQ3BIO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsNEhBQTRIO0FBQzVIO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBLDJFQUEyRSxZQUFZLGdEQUFnRDtBQUN2STtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLDhEQUE4RCwwQkFBMEI7QUFDeEY7QUFDQSxpRkFBaUY7QUFDakY7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSwrREFBK0QsOEVBQThFO0FBQzdJO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0Q7QUFDQSx5R0FBeUc7QUFDekc7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQSxpRUFBaUUsOEJBQThCO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLG9DQUFvQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBLDRFQUE0RSxtQ0FBbUM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsYUFBYTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBMEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpRkFBaUY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw4QkFBOEI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOElBQThJO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdPQUFnTztBQUNoTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTSxHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxxQ0FBcUMsR0FBRyxVQUFVO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsV0FBVztBQUNYO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSwyRUFBMkUsMkJBQTJCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsb0JBQW9CLEdBQUcsWUFBWSxHQUFHLGdCQUFnQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsUUFBUSxPQUFPLHVCQUF1QixZQUFZLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCLFdBQVcsUUFBUTtBQUM1SjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlLFlBQVksR0FBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZSxZQUFZLEdBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQ0FBb0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFFBQVE7QUFDUixrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBLFVBQVU7QUFDVjtBQUNBLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsOEJBQThCO0FBQ3JILHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQyxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVELDRCQUE0Qiw2Q0FBNkM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEMsNEhBQTRIO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1IsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEMsNkRBQTZEO0FBQzdELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csYUFBYTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakcsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCx5QkFBeUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVksaUJBQWlCLG1CQUFtQixLQUFLLGdCQUFnQixpREFBaUQ7QUFDcEs7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJLE1BQU0saUJBQWlCLEdBQUcsY0FBYyxVQUFVLFFBQVE7QUFDakc7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNFdBQTRXLENBQUU7QUFDOVc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQ0FBc0M7QUFDdEMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQ0FBc0M7QUFDdEMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQsU0FBUztBQUNUO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtRUFBbUUsa0JBQWtCLEtBQUssZ0JBQWdCLE1BQU0sTUFBTTtBQUN0SCxTQUFTO0FBQ1Q7QUFDQSxvRUFBb0Usa0JBQWtCLEtBQUssZ0JBQWdCLE1BQU0sTUFBTTtBQUN2SDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsYUFBYSxTQUFTO0FBQ2pHO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsMEJBQTBCO0FBQzFCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0o7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLGdGQUFnRjtBQUNoRixXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRKQUE0SjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSwyQ0FBMkM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsK0NBQStDO0FBQzVHO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdCQUF3QjtBQUNwRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkRBQTZELHdCQUF3QjtBQUNyRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsd0JBQXdCO0FBQ3BGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2REFBNkQsd0JBQXdCO0FBQ3JGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQyxtQ0FBbUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLCtDQUErQyxJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2V0FBNlcsQ0FBRTtBQUMvVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsYUFBYTtBQUMxRztBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFLE1BQU0sRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLEdBQUcsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRztBQUNyQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUJBQXVCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlWQUF5VixDQUFFO0FBQzNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxTQUFTLE1BQU0saUJBQWlCLEdBQUcsY0FBYyxVQUFVLFdBQVcsT0FBTyxRQUFRO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFLGFBQWEsV0FBVyxjQUFjLFFBQVEsV0FBVzs7QUFFOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0ZBQXNGLFlBQVk7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9DQUFvQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9DQUFvQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsWUFBWTtBQUNaO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUM7QUFDRCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZpbmctYmx1ZXByaW50LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMuanM/Y2IzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gX19ITFNfV09SS0VSX0JVTkRMRV9fKF9fSU5fV09SS0VSX18pe1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuSGxzID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfY29uc3RydWN0KHQsIGUsIHIpIHtcbiAgICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB2YXIgbyA9IFtudWxsXTtcbiAgICBvLnB1c2guYXBwbHkobywgZSk7XG4gICAgdmFyIHAgPSBuZXcgKHQuYmluZC5hcHBseSh0LCBvKSkoKTtcbiAgICByZXR1cm4gciAmJiBfc2V0UHJvdG90eXBlT2YocCwgci5wcm90b3R5cGUpLCBwO1xuICB9XG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICAgIHZhciBvID0gclt0XTtcbiAgICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCBmYWxzZSwgby5jb25maWd1cmFibGUgPSB0cnVlLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9IHRydWUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KSwgZTtcbiAgfVxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICAgIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSkgOiBlW3JdID0gdCwgZTtcbiAgfVxuICBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAobikge1xuICAgICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgdmFyIHQgPSBhcmd1bWVudHNbZV07XG4gICAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG4gIH1cbiAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2UodCwgbykge1xuICAgIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShvLnByb3RvdHlwZSksIHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdCwgX3NldFByb3RvdHlwZU9mKHQsIG8pO1xuICB9XG4gIGZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKHQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIC0xICE9PSBGdW5jdGlvbi50b1N0cmluZy5jYWxsKHQpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICB9IGNhdGNoICh0KSB7fVxuICAgIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXQ7XG4gICAgfSkoKTtcbiAgfVxuICBmdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gICAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gICAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICAgIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgIHZhciBpID0gZS5jYWxsKHQsIHIpO1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKHQpIHtcbiAgICB2YXIgciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgTWFwID8gbmV3IE1hcCgpIDogdm9pZCAwO1xuICAgIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmIChudWxsID09PSB0IHx8ICFfaXNOYXRpdmVGdW5jdGlvbih0KSkgcmV0dXJuIHQ7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICBpZiAodm9pZCAwICE9PSByKSB7XG4gICAgICAgIGlmIChyLmhhcyh0KSkgcmV0dXJuIHIuZ2V0KHQpO1xuICAgICAgICByLnNldCh0LCBXcmFwcGVyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0KHQsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSksIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCB0KTtcbiAgICB9LCBfd3JhcE5hdGl2ZVN1cGVyKHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcmFuZG9tIHY0IFVVSURcbiAgICpcbiAgICogQHJldHVybnMgQSByYW5kb20gdjQgVVVJRFxuICAgKlxuICAgKiBAZ3JvdXAgVXRpbHNcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYigpKTtcbiAgICAgICAgdmFyIF91dWlkID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgICAgcmV0dXJuIF91dWlkLnNsaWNlKF91dWlkLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHZhciBkdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgX3V1aWQyID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHZhciByID0gKGR0ICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcbiAgICAgICAgICBkdCA9IE1hdGguZmxvb3IoZHQgLyAxNik7XG4gICAgICAgICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3V1aWQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG4gIFx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbiAgfVxuXG4gIHZhciBldmVudGVtaXR0ZXIzID0ge2V4cG9ydHM6IHt9fTtcblxuICB2YXIgaGFzUmVxdWlyZWRFdmVudGVtaXR0ZXIzO1xuXG4gIGZ1bmN0aW9uIHJlcXVpcmVFdmVudGVtaXR0ZXIzICgpIHtcbiAgXHRpZiAoaGFzUmVxdWlyZWRFdmVudGVtaXR0ZXIzKSByZXR1cm4gZXZlbnRlbWl0dGVyMy5leHBvcnRzO1xuICBcdGhhc1JlcXVpcmVkRXZlbnRlbWl0dGVyMyA9IDE7XG4gIFx0KGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICBcdFx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgXHRcdCAgLCBwcmVmaXggPSAnfic7XG5cbiAgXHRcdC8qKlxuICBcdFx0ICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAgXHRcdCAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICBcdFx0ICpcbiAgXHRcdCAqIEBjb25zdHJ1Y3RvclxuICBcdFx0ICogQHByaXZhdGVcbiAgXHRcdCAqL1xuICBcdFx0ZnVuY3Rpb24gRXZlbnRzKCkge31cblxuICBcdFx0Ly9cbiAgXHRcdC8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4gIFx0XHQvLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbiAgXHRcdC8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4gIFx0XHQvLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3RcbiAgXHRcdC8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuICBcdFx0Ly9cbiAgXHRcdGlmIChPYmplY3QuY3JlYXRlKSB7XG4gIFx0XHQgIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIFx0XHQgIC8vXG4gIFx0XHQgIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIFx0XHQgIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIFx0XHQgIC8vXG4gIFx0XHQgIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdC8qKlxuICBcdFx0ICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gIFx0XHQgKlxuICBcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICBcdFx0ICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAgXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gIFx0XHQgKiBAY29uc3RydWN0b3JcbiAgXHRcdCAqIEBwcml2YXRlXG4gIFx0XHQgKi9cbiAgXHRcdGZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIFx0XHQgIHRoaXMuZm4gPSBmbjtcbiAgXHRcdCAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgXHRcdCAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0LyoqXG4gIFx0XHQgKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAgXHRcdCAqXG4gIFx0XHQgKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICBcdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICBcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICBcdFx0ICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAgXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICBcdFx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAgXHRcdCAqIEBwcml2YXRlXG4gIFx0XHQgKi9cbiAgXHRcdGZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBcdFx0ICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gIFx0XHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICBcdFx0ICB9XG5cbiAgXHRcdCAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gIFx0XHQgICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIFx0XHQgIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIFx0XHQgIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIFx0XHQgIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICBcdFx0ICByZXR1cm4gZW1pdHRlcjtcbiAgXHRcdH1cblxuICBcdFx0LyoqXG4gIFx0XHQgKiBDbGVhciBldmVudCBieSBuYW1lLlxuICBcdFx0ICpcbiAgXHRcdCAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gIFx0XHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICBcdFx0ICogQHByaXZhdGVcbiAgXHRcdCAqL1xuICBcdFx0ZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgXHRcdCAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgXHRcdCAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG4gIFx0XHR9XG5cbiAgXHRcdC8qKlxuICBcdFx0ICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICBcdFx0ICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICBcdFx0ICpcbiAgXHRcdCAqIEBjb25zdHJ1Y3RvclxuICBcdFx0ICogQHB1YmxpY1xuICBcdFx0ICovXG4gIFx0XHRmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIFx0XHQgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgXHRcdCAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICBcdFx0fVxuXG4gIFx0XHQvKipcbiAgXHRcdCAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gIFx0XHQgKiBsaXN0ZW5lcnMuXG4gIFx0XHQgKlxuICBcdFx0ICogQHJldHVybnMge0FycmF5fVxuICBcdFx0ICogQHB1YmxpY1xuICBcdFx0ICovXG4gIFx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICBcdFx0ICB2YXIgbmFtZXMgPSBbXVxuICBcdFx0ICAgICwgZXZlbnRzXG4gIFx0XHQgICAgLCBuYW1lO1xuXG4gIFx0XHQgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIFx0XHQgIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICBcdFx0ICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgXHRcdCAgfVxuXG4gIFx0XHQgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFx0XHQgICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICBcdFx0ICB9XG5cbiAgXHRcdCAgcmV0dXJuIG5hbWVzO1xuICBcdFx0fTtcblxuICBcdFx0LyoqXG4gIFx0XHQgKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICBcdFx0ICpcbiAgXHRcdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAgXHRcdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICBcdFx0ICogQHB1YmxpY1xuICBcdFx0ICovXG4gIFx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICBcdFx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICBcdFx0ICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBcdFx0ICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIFx0XHQgIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgXHRcdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gIFx0XHQgICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgXHRcdCAgfVxuXG4gIFx0XHQgIHJldHVybiBlZTtcbiAgXHRcdH07XG5cbiAgXHRcdC8qKlxuICBcdFx0ICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICBcdFx0ICpcbiAgXHRcdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAgXHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICBcdFx0ICogQHB1YmxpY1xuICBcdFx0ICovXG4gIFx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIFx0XHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gIFx0XHQgICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBcdFx0ICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIFx0XHQgIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICBcdFx0ICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbiAgXHRcdH07XG5cbiAgXHRcdC8qKlxuICBcdFx0ICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gIFx0XHQgKlxuICBcdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICBcdFx0ICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICBcdFx0ICogQHB1YmxpY1xuICBcdFx0ICovXG4gIFx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgXHRcdCAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgXHRcdCAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIFx0XHQgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICBcdFx0ICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICBcdFx0ICAgICwgYXJnc1xuICBcdFx0ICAgICwgaTtcblxuICBcdFx0ICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gIFx0XHQgICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgXHRcdCAgICBzd2l0Y2ggKGxlbikge1xuICBcdFx0ICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICBcdFx0ICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgXHRcdCAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICBcdFx0ICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICBcdFx0ICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgXHRcdCAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICBcdFx0ICAgIH1cblxuICBcdFx0ICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHQgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgXHRcdCAgICB9XG5cbiAgXHRcdCAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICBcdFx0ICB9IGVsc2Uge1xuICBcdFx0ICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gIFx0XHQgICAgICAsIGo7XG5cbiAgXHRcdCAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgXHRcdCAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gIFx0XHQgICAgICBzd2l0Y2ggKGxlbikge1xuICBcdFx0ICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gIFx0XHQgICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gIFx0XHQgICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICBcdFx0ICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gIFx0XHQgICAgICAgIGRlZmF1bHQ6XG4gIFx0XHQgICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICBcdFx0ICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gIFx0XHQgICAgICAgICAgfVxuXG4gIFx0XHQgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgXHRcdCAgICAgIH1cbiAgXHRcdCAgICB9XG4gIFx0XHQgIH1cblxuICBcdFx0ICByZXR1cm4gdHJ1ZTtcbiAgXHRcdH07XG5cbiAgXHRcdC8qKlxuICBcdFx0ICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gIFx0XHQgKlxuICBcdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICBcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICBcdFx0ICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gIFx0XHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gIFx0XHQgKiBAcHVibGljXG4gIFx0XHQgKi9cbiAgXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgXHRcdCAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xuICBcdFx0fTtcblxuICBcdFx0LyoqXG4gIFx0XHQgKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAgXHRcdCAqXG4gIFx0XHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gIFx0XHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gIFx0XHQgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAgXHRcdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAgXHRcdCAqIEBwdWJsaWNcbiAgXHRcdCAqL1xuICBcdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgXHRcdCAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG4gIFx0XHR9O1xuXG4gIFx0XHQvKipcbiAgXHRcdCAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gIFx0XHQgKlxuICBcdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICBcdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gIFx0XHQgKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICBcdFx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAgXHRcdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAgXHRcdCAqIEBwdWJsaWNcbiAgXHRcdCAqL1xuICBcdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBcdFx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBcdFx0ICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgXHRcdCAgaWYgKCFmbikge1xuICBcdFx0ICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgXHRcdCAgICByZXR1cm4gdGhpcztcbiAgXHRcdCAgfVxuXG4gIFx0XHQgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBcdFx0ICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gIFx0XHQgICAgaWYgKFxuICBcdFx0ICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICBcdFx0ICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICBcdFx0ICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICBcdFx0ICAgICkge1xuICBcdFx0ICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICBcdFx0ICAgIH1cbiAgXHRcdCAgfSBlbHNlIHtcbiAgXHRcdCAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICBcdFx0ICAgICAgaWYgKFxuICBcdFx0ICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gIFx0XHQgICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgXHRcdCAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gIFx0XHQgICAgICApIHtcbiAgXHRcdCAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgXHRcdCAgICAgIH1cbiAgXHRcdCAgICB9XG5cbiAgXHRcdCAgICAvL1xuICBcdFx0ICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgXHRcdCAgICAvL1xuICBcdFx0ICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gIFx0XHQgICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIFx0XHQgIH1cblxuICBcdFx0ICByZXR1cm4gdGhpcztcbiAgXHRcdH07XG5cbiAgXHRcdC8qKlxuICBcdFx0ICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gIFx0XHQgKlxuICBcdFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gIFx0XHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gIFx0XHQgKiBAcHVibGljXG4gIFx0XHQgKi9cbiAgXHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIFx0XHQgIHZhciBldnQ7XG5cbiAgXHRcdCAgaWYgKGV2ZW50KSB7XG4gIFx0XHQgICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgXHRcdCAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgXHRcdCAgfSBlbHNlIHtcbiAgXHRcdCAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIFx0XHQgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICBcdFx0ICB9XG5cbiAgXHRcdCAgcmV0dXJuIHRoaXM7XG4gIFx0XHR9O1xuXG4gIFx0XHQvL1xuICBcdFx0Ly8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbiAgXHRcdC8vXG4gIFx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG4gIFx0XHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuICBcdFx0Ly9cbiAgXHRcdC8vIEV4cG9zZSB0aGUgcHJlZml4LlxuICBcdFx0Ly9cbiAgXHRcdEV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuICBcdFx0Ly9cbiAgXHRcdC8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4gIFx0XHQvL1xuICBcdFx0RXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuICBcdFx0Ly9cbiAgXHRcdC8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuICBcdFx0Ly9cbiAgXHRcdHtcbiAgXHRcdCAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gIFx0XHR9IFxuICBcdH0gKGV2ZW50ZW1pdHRlcjMpKTtcbiAgXHRyZXR1cm4gZXZlbnRlbWl0dGVyMy5leHBvcnRzO1xuICB9XG5cbiAgdmFyIGV2ZW50ZW1pdHRlcjNFeHBvcnRzID0gcmVxdWlyZUV2ZW50ZW1pdHRlcjMoKTtcbiAgdmFyIEV2ZW50RW1pdHRlciA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhldmVudGVtaXR0ZXIzRXhwb3J0cyk7XG5cbiAgdmFyIHVybFRvb2xraXQgPSB7ZXhwb3J0czoge319O1xuXG4gIHZhciBoYXNSZXF1aXJlZFVybFRvb2xraXQ7XG5cbiAgZnVuY3Rpb24gcmVxdWlyZVVybFRvb2xraXQgKCkge1xuICBcdGlmIChoYXNSZXF1aXJlZFVybFRvb2xraXQpIHJldHVybiB1cmxUb29sa2l0LmV4cG9ydHM7XG4gIFx0aGFzUmVxdWlyZWRVcmxUb29sa2l0ID0gMTtcbiAgXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICBcdFx0Ly8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxODA4XG5cbiAgXHRcdChmdW5jdGlvbiAocm9vdCkge1xuICBcdFx0ICB2YXIgVVJMX1JFR0VYID1cbiAgXHRcdCAgICAvXig/PSgoPzpbYS16QS1aMC05K1xcLS5dKzopPykpXFwxKD89KCg/OlxcL1xcL1teXFwvPyNdKik/KSlcXDIoPz0oKD86KD86W14/I1xcL10qXFwvKSpbXjs/I1xcL10qKT8pKVxcMygoPzo7W14/I10qKT8pKFxcP1teI10qKT8oI1teXSopPyQvO1xuICBcdFx0ICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKD89KFteXFwvPyNdKikpXFwxKFteXSopJC87XG4gIFx0XHQgIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuICBcdFx0ICB2YXIgU0xBU0hfRE9UX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pW15cXC9dKig/PVxcLykvZztcblxuICBcdFx0ICB2YXIgVVJMVG9vbGtpdCA9IHtcbiAgXHRcdCAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuICBcdFx0ICAgIC8vIEUuZ1xuICBcdFx0ICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXG4gIFx0XHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG4gIFx0XHQgICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcbiAgXHRcdCAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXG4gIFx0XHQgICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24gKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG4gIFx0XHQgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgXHRcdCAgICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXG4gIFx0XHQgICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG4gIFx0XHQgICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcbiAgXHRcdCAgICAgIGlmICghcmVsYXRpdmVVUkwpIHtcbiAgXHRcdCAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuICBcdFx0ICAgICAgICAvLyBlbnRpcmUgYmFzZSBVUkwgKGkuZS4sIGlzIHNldCBlcXVhbCB0byB0aGUgYmFzZSBVUkwpXG4gIFx0XHQgICAgICAgIC8vIGFuZCB3ZSBhcmUgZG9uZS5cbiAgXHRcdCAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICBcdFx0ICAgICAgICAgIHJldHVybiBiYXNlVVJMO1xuICBcdFx0ICAgICAgICB9XG4gIFx0XHQgICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICBcdFx0ICAgICAgICBpZiAoIWJhc2VQYXJ0c0Zvck5vcm1hbGlzZSkge1xuICBcdFx0ICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICBcdFx0ICAgICAgICB9XG4gIFx0XHQgICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKFxuICBcdFx0ICAgICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoXG4gIFx0XHQgICAgICAgICk7XG4gIFx0XHQgICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSk7XG4gIFx0XHQgICAgICB9XG4gIFx0XHQgICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuICBcdFx0ICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzKSB7XG4gIFx0XHQgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIHJlbGF0aXZlIFVSTC4nKTtcbiAgXHRcdCAgICAgIH1cbiAgXHRcdCAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnNjaGVtZSkge1xuICBcdFx0ICAgICAgICAvLyAyYikgSWYgdGhlIGVtYmVkZGVkIFVSTCBzdGFydHMgd2l0aCBhIHNjaGVtZSBuYW1lLCBpdCBpc1xuICBcdFx0ICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuICBcdFx0ICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gIFx0XHQgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVVJMO1xuICBcdFx0ICAgICAgICB9XG4gIFx0XHQgICAgICAgIHJlbGF0aXZlUGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpO1xuICBcdFx0ICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhyZWxhdGl2ZVBhcnRzKTtcbiAgXHRcdCAgICAgIH1cbiAgXHRcdCAgICAgIHZhciBiYXNlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICBcdFx0ICAgICAgaWYgKCFiYXNlUGFydHMpIHtcbiAgXHRcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gIFx0XHQgICAgICB9XG4gIFx0XHQgICAgICBpZiAoIWJhc2VQYXJ0cy5uZXRMb2MgJiYgYmFzZVBhcnRzLnBhdGggJiYgYmFzZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICBcdFx0ICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2NcbiAgXHRcdCAgICAgICAgLy8gVGhpcyBjYXVzZXMgJ2V4YW1wbGUuY29tL2EnIHRvIGJlIGhhbmRsZWQgYXMgJy8vZXhhbXBsZS5jb20vYScgaW5zdGVhZCBvZiAnL2V4YW1wbGUuY29tL2EnXG4gIFx0XHQgICAgICAgIHZhciBwYXRoUGFydHMgPSBGSVJTVF9TRUdNRU5UX1JFR0VYLmV4ZWMoYmFzZVBhcnRzLnBhdGgpO1xuICBcdFx0ICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuICBcdFx0ICAgICAgICBiYXNlUGFydHMucGF0aCA9IHBhdGhQYXJ0c1syXTtcbiAgXHRcdCAgICAgIH1cbiAgXHRcdCAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuICBcdFx0ICAgICAgICBiYXNlUGFydHMucGF0aCA9ICcvJztcbiAgXHRcdCAgICAgIH1cbiAgXHRcdCAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuICBcdFx0ICAgICAgICAvLyAyYykgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBzY2hlbWUgb2ZcbiAgXHRcdCAgICAgICAgLy8gdGhlIGJhc2UgVVJMLlxuICBcdFx0ICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG4gIFx0XHQgICAgICAgIG5ldExvYzogcmVsYXRpdmVQYXJ0cy5uZXRMb2MsXG4gIFx0XHQgICAgICAgIHBhdGg6IG51bGwsXG4gIFx0XHQgICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG4gIFx0XHQgICAgICAgIHF1ZXJ5OiByZWxhdGl2ZVBhcnRzLnF1ZXJ5LFxuICBcdFx0ICAgICAgICBmcmFnbWVudDogcmVsYXRpdmVQYXJ0cy5mcmFnbWVudCxcbiAgXHRcdCAgICAgIH07XG4gIFx0XHQgICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XG4gIFx0XHQgICAgICAgIC8vIDMpIElmIHRoZSBlbWJlZGRlZCBVUkwncyA8bmV0X2xvYz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gIFx0XHQgICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG4gIFx0XHQgICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cbiAgXHRcdCAgICAgICAgYnVpbHRQYXJ0cy5uZXRMb2MgPSBiYXNlUGFydHMubmV0TG9jO1xuICBcdFx0ICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG4gIFx0XHQgICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cbiAgXHRcdCAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gIFx0XHQgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcbiAgXHRcdCAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXG4gIFx0XHQgICAgICAgICAgICAvLyBzbGFzaCksIHRoZW4gdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgYmFzZSBVUkwgcGF0aFxuICBcdFx0ICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gIFx0XHQgICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICBcdFx0ICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cGFyYW1zPiBvZiB0aGUgYmFzZVxuICBcdFx0ICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuICBcdFx0ICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xuICBcdFx0ICAgICAgICAgICAgICBidWlsdFBhcnRzLnBhcmFtcyA9IGJhc2VQYXJ0cy5wYXJhbXM7XG4gIFx0XHQgICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgXHRcdCAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXG4gIFx0XHQgICAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmQgd2Ugc2tpcCB0byBzdGVwIDcuXG4gIFx0XHQgICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuICBcdFx0ICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XG4gIFx0XHQgICAgICAgICAgICAgIH1cbiAgXHRcdCAgICAgICAgICAgIH1cbiAgXHRcdCAgICAgICAgICB9IGVsc2Uge1xuICBcdFx0ICAgICAgICAgICAgLy8gNikgVGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgYmFzZSBVUkwncyBwYXRoIChhbnl0aGluZ1xuICBcdFx0ICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuICBcdFx0ICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcbiAgXHRcdCAgICAgICAgICAgIC8vIGFwcGVuZGVkIGluIGl0cyBwbGFjZS5cbiAgXHRcdCAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICBcdFx0ICAgICAgICAgICAgdmFyIG5ld1BhdGggPVxuICBcdFx0ICAgICAgICAgICAgICBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICtcbiAgXHRcdCAgICAgICAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICBcdFx0ICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKG5ld1BhdGgpO1xuICBcdFx0ICAgICAgICAgIH1cbiAgXHRcdCAgICAgICAgfVxuICBcdFx0ICAgICAgfVxuICBcdFx0ICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xuICBcdFx0ICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZVxuICBcdFx0ICAgICAgICAgID8gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aClcbiAgXHRcdCAgICAgICAgICA6IHJlbGF0aXZlUGFydHMucGF0aDtcbiAgXHRcdCAgICAgIH1cbiAgXHRcdCAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJ1aWx0UGFydHMpO1xuICBcdFx0ICAgIH0sXG4gIFx0XHQgICAgcGFyc2VVUkw6IGZ1bmN0aW9uICh1cmwpIHtcbiAgXHRcdCAgICAgIHZhciBwYXJ0cyA9IFVSTF9SRUdFWC5leGVjKHVybCk7XG4gIFx0XHQgICAgICBpZiAoIXBhcnRzKSB7XG4gIFx0XHQgICAgICAgIHJldHVybiBudWxsO1xuICBcdFx0ICAgICAgfVxuICBcdFx0ICAgICAgcmV0dXJuIHtcbiAgXHRcdCAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcbiAgXHRcdCAgICAgICAgbmV0TG9jOiBwYXJ0c1syXSB8fCAnJyxcbiAgXHRcdCAgICAgICAgcGF0aDogcGFydHNbM10gfHwgJycsXG4gIFx0XHQgICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG4gIFx0XHQgICAgICAgIHF1ZXJ5OiBwYXJ0c1s1XSB8fCAnJyxcbiAgXHRcdCAgICAgICAgZnJhZ21lbnQ6IHBhcnRzWzZdIHx8ICcnLFxuICBcdFx0ICAgICAgfTtcbiAgXHRcdCAgICB9LFxuICBcdFx0ICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gIFx0XHQgICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG4gIFx0XHQgICAgICAvLyB0aGVuIGFwcGxpZWQsIGluIG9yZGVyLCB0byB0aGUgbmV3IHBhdGg6XG4gIFx0XHQgICAgICAvLyA2YSkgQWxsIG9jY3VycmVuY2VzIG9mIFwiLi9cIiwgd2hlcmUgXCIuXCIgaXMgYSBjb21wbGV0ZSBwYXRoXG4gIFx0XHQgICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cbiAgXHRcdCAgICAgIC8vIDZiKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCIuXCIgYXMgYSBjb21wbGV0ZSBwYXRoIHNlZ21lbnQsXG4gIFx0XHQgICAgICAvLyB0aGF0IFwiLlwiIGlzIHJlbW92ZWQuXG4gIFx0XHQgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG4gIFx0XHQgICAgICAvLyA2YykgQWxsIG9jY3VycmVuY2VzIG9mIFwiPHNlZ21lbnQ+Ly4uL1wiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICBcdFx0ICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIGFyZSByZW1vdmVkLlxuICBcdFx0ICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcbiAgXHRcdCAgICAgIC8vIHJlbW92aW5nIHRoZSBsZWZ0bW9zdCBtYXRjaGluZyBwYXR0ZXJuIG9uIGVhY2ggaXRlcmF0aW9uLFxuICBcdFx0ICAgICAgLy8gdW50aWwgbm8gbWF0Y2hpbmcgcGF0dGVybiByZW1haW5zLlxuICBcdFx0ICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICBcdFx0ICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIHRoYXRcbiAgXHRcdCAgICAgIC8vIFwiPHNlZ21lbnQ+Ly4uXCIgaXMgcmVtb3ZlZC5cbiAgXHRcdCAgICAgIHdoaWxlIChcbiAgXHRcdCAgICAgICAgcGF0aC5sZW5ndGggIT09IChwYXRoID0gcGF0aC5yZXBsYWNlKFNMQVNIX0RPVF9ET1RfUkVHRVgsICcnKSkubGVuZ3RoXG4gIFx0XHQgICAgICApIHt9XG4gIFx0XHQgICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICBcdFx0ICAgIH0sXG4gIFx0XHQgICAgYnVpbGRVUkxGcm9tUGFydHM6IGZ1bmN0aW9uIChwYXJ0cykge1xuICBcdFx0ICAgICAgcmV0dXJuIChcbiAgXHRcdCAgICAgICAgcGFydHMuc2NoZW1lICtcbiAgXHRcdCAgICAgICAgcGFydHMubmV0TG9jICtcbiAgXHRcdCAgICAgICAgcGFydHMucGF0aCArXG4gIFx0XHQgICAgICAgIHBhcnRzLnBhcmFtcyArXG4gIFx0XHQgICAgICAgIHBhcnRzLnF1ZXJ5ICtcbiAgXHRcdCAgICAgICAgcGFydHMuZnJhZ21lbnRcbiAgXHRcdCAgICAgICk7XG4gIFx0XHQgICAgfSxcbiAgXHRcdCAgfTtcblxuICBcdFx0ICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XG4gIFx0XHR9KSgpOyBcbiAgXHR9ICh1cmxUb29sa2l0KSk7XG4gIFx0cmV0dXJuIHVybFRvb2xraXQuZXhwb3J0cztcbiAgfVxuXG4gIHZhciB1cmxUb29sa2l0RXhwb3J0cyA9IHJlcXVpcmVVcmxUb29sa2l0KCk7XG5cbiAgLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19udW1iZXJfaXNmaW5pdGVcbiAgdmFyIGlzRmluaXRlTnVtYmVyID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcbiAgfTtcblxuICAvLyBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX251bWJlcl9pc3NhZmVpbnRlZ2VyXG4gIHZhciBpc1NhZmVJbnRlZ2VyID0gTnVtYmVyLmlzU2FmZUludGVnZXIgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgTWF0aC5hYnModmFsdWUpIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gIH07XG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxuICB2YXIgRXJyb3JUeXBlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXJyb3JUeXBlcykge1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbmV0d29yayBlcnJvciAobG9hZGluZyBlcnJvciAvIHRpbWVvdXQgLi4uKVxuICAgIEVycm9yVHlwZXNbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJuZXR3b3JrRXJyb3JcIjtcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIG1lZGlhIEVycm9yICh2aWRlby9wYXJzaW5nL21lZGlhc291cmNlIGVycm9yKVxuICAgIEVycm9yVHlwZXNbXCJNRURJQV9FUlJPUlwiXSA9IFwibWVkaWFFcnJvclwiO1xuICAgIC8vIEVNRSAoZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMpIGVycm9yc1xuICAgIEVycm9yVHlwZXNbXCJLRVlfU1lTVEVNX0VSUk9SXCJdID0gXCJrZXlTeXN0ZW1FcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbXV4IEVycm9yIChkZW11eGluZy9yZW11eGluZylcbiAgICBFcnJvclR5cGVzW1wiTVVYX0VSUk9SXCJdID0gXCJtdXhFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGFsbCBvdGhlciBlcnJvcnNcbiAgICBFcnJvclR5cGVzW1wiT1RIRVJfRVJST1JcIl0gPSBcIm90aGVyRXJyb3JcIjtcbiAgICByZXR1cm4gRXJyb3JUeXBlcztcbiAgfSh7fSk7XG4gIHZhciBFcnJvckRldGFpbHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEVycm9yRGV0YWlscykge1xuICAgIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fS0VZU1wiXSA9IFwia2V5U3lzdGVtTm9LZXlzXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19BQ0NFU1NcIl0gPSBcImtleVN5c3RlbU5vQWNjZXNzXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19TRVNTSU9OXCJdID0gXCJrZXlTeXN0ZW1Ob1Nlc3Npb25cIjtcbiAgICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRVwiXSA9IFwia2V5U3lzdGVtTm9Db25maWd1cmVkTGljZW5zZVwiO1xuICAgIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWRcIjtcbiAgICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9SRVFVRVNUX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2VydmVyQ2VydGlmaWNhdGVSZXF1ZXN0RmFpbGVkXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfVVBEQVRFX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2VydmVyQ2VydGlmaWNhdGVVcGRhdGVGYWlsZWRcIjtcbiAgICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2Vzc2lvblVwZGF0ZUZhaWxlZFwiO1xuICAgIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVEXCJdID0gXCJrZXlTeXN0ZW1TdGF0dXNPdXRwdXRSZXN0cmljdGVkXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1JcIl0gPSBcImtleVN5c3RlbVN0YXR1c0ludGVybmFsRXJyb3JcIjtcbiAgICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX0RFU1RST1lfTUVESUFfS0VZU19FUlJPUlwiXSA9IFwia2V5U3lzdGVtRGVzdHJveU1lZGlhS2V5c0Vycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9ERVNUUk9ZX0NMT1NFX1NFU1NJT05fRVJST1JcIl0gPSBcImtleVN5c3RlbURlc3Ryb3lDbG9zZVNlc3Npb25FcnJvclwiO1xuICAgIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fREVTVFJPWV9SRU1PVkVfU0VTU0lPTl9FUlJPUlwiXSA9IFwia2V5U3lzdGVtRGVzdHJveVJlbW92ZVNlc3Npb25FcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9MT0FEX0VSUk9SXCJdID0gXCJtYW5pZmVzdExvYWRFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICAgIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX0xPQURfVElNRU9VVFwiXSA9IFwibWFuaWZlc3RMb2FkVGltZU91dFwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgcGFyc2luZyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICAgIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX1BBUlNJTkdfRVJST1JcIl0gPSBcIm1hbmlmZXN0UGFyc2luZ0Vycm9yXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICAgIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcIm1hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIjtcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHdoaWNoIGNvbnRhaW5zIG5vIGZyYWdtZW50cyAtIGRhdGE6IHsgdXJsOiBmYXVsdHkgVVJMLCByZWFzb246IFwibm8gZnJhZ21lbnRzIGZvdW5kIGluIGxldmVsXCIsIGxldmVsOiBpbmRleCBvZiB0aGUgYmFkIGxldmVsIH1cbiAgICBFcnJvckRldGFpbHNbXCJMRVZFTF9FTVBUWV9FUlJPUlwiXSA9IFwibGV2ZWxFbXB0eUVycm9yXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICAgIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfRVJST1JcIl0gPSBcImxldmVsTG9hZEVycm9yXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gICAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfTE9BRF9USU1FT1VUXCJdID0gXCJsZXZlbExvYWRUaW1lT3V0XCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBwYXJzZSBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgZXJyb3I6IEVycm9yLCByZWFzb246IGVycm9yIG1lc3NhZ2UgfVxuICAgIEVycm9yRGV0YWlsc1tcIkxFVkVMX1BBUlNJTkdfRVJST1JcIl0gPSBcImxldmVsUGFyc2luZ0Vycm9yXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBzd2l0Y2ggZXJyb3IgLSBkYXRhOiB7IGxldmVsIDogZmF1bHR5IGxldmVsIElkLCBldmVudCA6IGVycm9yIGRlc2NyaXB0aW9ufVxuICAgIEVycm9yRGV0YWlsc1tcIkxFVkVMX1NXSVRDSF9FUlJPUlwiXSA9IFwibGV2ZWxTd2l0Y2hFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gICAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9FUlJPUlwiXSA9IFwiYXVkaW9UcmFja0xvYWRFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBFcnJvckRldGFpbHNbXCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcImF1ZGlvVHJhY2tMb2FkVGltZU91dFwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgc3VidGl0bGUgdHJhY2sgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9MT0FEX0VSUk9SXCJdID0gXCJzdWJ0aXRsZVRyYWNrTG9hZEVycm9yXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBzdWJ0aXRsZSB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gICAgRXJyb3JEZXRhaWxzW1wiU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUXCJdID0gXCJzdWJ0aXRsZVRyYWNrTG9hZFRpbWVPdXRcIjtcbiAgICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICAgIEVycm9yRGV0YWlsc1tcIkZSQUdfTE9BRF9FUlJPUlwiXSA9IFwiZnJhZ0xvYWRFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfVElNRU9VVFwiXSA9IFwiZnJhZ0xvYWRUaW1lT3V0XCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBkZWNyeXB0aW9uIGVycm9yIGV2ZW50IC0gZGF0YToge2lkIDogZGVtdXhlciBJZCxmcmFnOiBmcmFnbWVudCBvYmplY3QsIHJlYXNvbiA6IHBhcnNpbmcgZXJyb3IgZGVzY3JpcHRpb24gfVxuICAgIEVycm9yRGV0YWlsc1tcIkZSQUdfREVDUllQVF9FUlJPUlwiXSA9IFwiZnJhZ0RlY3J5cHRFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgcGFyc2luZyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgICAvLyB3aWxsIGJlIHJlbmFtZWQgREVNVVhfUEFSU0lOR19FUlJPUiBhbmQgc3dpdGNoZWQgdG8gTVVYX0VSUk9SIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbiAgICBFcnJvckRldGFpbHNbXCJGUkFHX1BBUlNJTkdfRVJST1JcIl0gPSBcImZyYWdQYXJzaW5nRXJyb3JcIjtcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IG9yIHBhcnQgbG9hZCBza2lwcGVkIGJlY2F1c2Ugb2YgYSBHQVAgdGFnIG9yIGF0dHJpYnV0ZVxuICAgIEVycm9yRGV0YWlsc1tcIkZSQUdfR0FQXCJdID0gXCJmcmFnR2FwXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSByZW11eCBhbGxvYyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBieXRlcyA6IG5iIG9mIGJ5dGVzIG9uIHdoaWNoIGFsbG9jYXRpb24gZmFpbGVkICwgcmVhc29uIDogZXJyb3IgdGV4dCB9XG4gICAgRXJyb3JEZXRhaWxzW1wiUkVNVVhfQUxMT0NfRVJST1JcIl0gPSBcInJlbXV4QWxsb2NFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX0xPQURfRVJST1JcIl0gPSBcImtleUxvYWRFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9USU1FT1VUXCJdID0gXCJrZXlMb2FkVGltZU91dFwiO1xuICAgIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgc291cmNlQnVmZmVyIHRvIE1lZGlhU291cmNlIC0gZGF0YSA6IHsgZXJyb3IgOiBleGNlcHRpb24gLCBtaW1lVHlwZSA6IG1pbWVUeXBlIH1cbiAgICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQUREX0NPREVDX0VSUk9SXCJdID0gXCJidWZmZXJBZGRDb2RlY0Vycm9yXCI7XG4gICAgLy8gVHJpZ2dlcmVkIHdoZW4gc291cmNlIGJ1ZmZlcihzKSBjb3VsZCBub3QgYmUgY3JlYXRlZCB1c2luZyBsZXZlbCAobWFuaWZlc3QgQ09ERUNTIGF0dHJpYnV0ZSksIHBhcnNlZCBtZWRpYSwgb3IgYmVzdCBndWVzcyBjb2RlYyhzKSAtIGRhdGE6IHsgcmVhc29uIDogZXJyb3IgcmVhc29uIH1cbiAgICBFcnJvckRldGFpbHNbXCJCVUZGRVJfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUlwiXSA9IFwiYnVmZmVySW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIjtcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmQgZXJyb3IgLSBkYXRhOiBhcHBlbmQgZXJyb3IgZGVzY3JpcHRpb25cbiAgICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQVBQRU5EX0VSUk9SXCJdID0gXCJidWZmZXJBcHBlbmRFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZGluZyBlcnJvciBldmVudCAtIGRhdGE6IGFwcGVuZGluZyBlcnJvciBkZXNjcmlwdGlvblxuICAgIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRJTkdfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc3RhbGxlZCBlcnJvciBldmVudFxuICAgIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9TVEFMTEVEX0VSUk9SXCJdID0gXCJidWZmZXJTdGFsbGVkRXJyb3JcIjtcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBmdWxsIGV2ZW50XG4gICAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0ZVTExfRVJST1JcIl0gPSBcImJ1ZmZlckZ1bGxFcnJvclwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHNlZWsgb3ZlciBob2xlIGV2ZW50XG4gICAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX1NFRUtfT1ZFUl9IT0xFXCJdID0gXCJidWZmZXJTZWVrT3ZlckhvbGVcIjtcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBudWRnZSBvbiBzdGFsbCAocGxheWJhY2sgaXMgc3R1Y2sgYWx0aG91Z2ggY3VycmVudFRpbWUgaXMgaW4gYSBidWZmZXJlZCBhcmVhKVxuICAgIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9OVURHRV9PTl9TVEFMTFwiXSA9IFwiYnVmZmVyTnVkZ2VPblN0YWxsXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBJbnRlcnN0aXRpYWwgQXNzZXQgTGlzdCBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmw6IGZhdWx0eSBVUkwsIHJlc3BvbnNlOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfSB9XG4gICAgRXJyb3JEZXRhaWxzW1wiQVNTRVRfTElTVF9MT0FEX0VSUk9SXCJdID0gXCJhc3NldExpc3RMb2FkRXJyb3JcIjtcbiAgICAvLyBJZGVudGlmaWVyIGZvciBhIEludGVyc3RpdGlhbCBBc3NldCBMaXN0IGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsOiBmYXVsdHkgVVJMLCByZXNwb25zZTogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH0gfVxuICAgIEVycm9yRGV0YWlsc1tcIkFTU0VUX0xJU1RfTE9BRF9USU1FT1VUXCJdID0gXCJhc3NldExpc3RMb2FkVGltZW91dFwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgSW50ZXJzdGl0aWFsIEFzc2V0IExpc3QgcGFyc2luZyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29uLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICAgIEVycm9yRGV0YWlsc1tcIkFTU0VUX0xJU1RfUEFSU0lOR19FUlJPUlwiXSA9IFwiYXNzZXRMaXN0UGFyc2luZ0Vycm9yXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYSBJbnRlcnN0aXRpYWwgQXNzZXQgTGlzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb24sIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gICAgRXJyb3JEZXRhaWxzW1wiSU5URVJTVElUSUFMX0FTU0VUX0lURU1fRVJST1JcIl0gPSBcImludGVyc3RpdGlhbEFzc2V0SXRlbUVycm9yXCI7XG4gICAgLy8gSWRlbnRpZmllciBmb3IgYW4gaW50ZXJuYWwgZXhjZXB0aW9uIGhhcHBlbmluZyBpbnNpZGUgaGxzLmpzIHdoaWxlIGhhbmRsaW5nIGFuIGV2ZW50XG4gICAgRXJyb3JEZXRhaWxzW1wiSU5URVJOQUxfRVhDRVBUSU9OXCJdID0gXCJpbnRlcm5hbEV4Y2VwdGlvblwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGFuIGludGVybmFsIGNhbGwgdG8gYWJvcnQgYSBsb2FkZXJcbiAgICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9BQk9SVEVEXCJdID0gXCJhYm9ydGVkXCI7XG4gICAgLy8gVHJpZ2dlcmVkIHdoZW4gYXR0YWNoTWVkaWEgZmFpbHNcbiAgICBFcnJvckRldGFpbHNbXCJBVFRBQ0hfTUVESUFfRVJST1JcIl0gPSBcImF0dGFjaE1lZGlhRXJyb3JcIjtcbiAgICAvLyBVbmNhdGVnb3JpemVkIGVycm9yXG4gICAgRXJyb3JEZXRhaWxzW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gIH0oe30pO1xuXG4gIHZhciBFdmVudHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEV2ZW50cykge1xuICAgIC8vIEZpcmVkIGJlZm9yZSBNZWRpYVNvdXJjZSBpcyBhdHRhY2hpbmcgdG8gbWVkaWEgZWxlbWVudFxuICAgIEV2ZW50c1tcIk1FRElBX0FUVEFDSElOR1wiXSA9IFwiaGxzTWVkaWFBdHRhY2hpbmdcIjtcbiAgICAvLyBGaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50XG4gICAgRXZlbnRzW1wiTUVESUFfQVRUQUNIRURcIl0gPSBcImhsc01lZGlhQXR0YWNoZWRcIjtcbiAgICAvLyBGaXJlZCBiZWZvcmUgZGV0YWNoaW5nIE1lZGlhU291cmNlIGZyb20gbWVkaWEgZWxlbWVudFxuICAgIEV2ZW50c1tcIk1FRElBX0RFVEFDSElOR1wiXSA9IFwiaGxzTWVkaWFEZXRhY2hpbmdcIjtcbiAgICAvLyBGaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gbWVkaWEgZWxlbWVudFxuICAgIEV2ZW50c1tcIk1FRElBX0RFVEFDSEVEXCJdID0gXCJobHNNZWRpYURldGFjaGVkXCI7XG4gICAgLy8gRmlyZWQgd2hlbiBIVE1MTWVkaWFFbGVtZW50IGRpc3BhdGNoZXMgXCJlbmRlZFwiIGV2ZW50LCBvciBzdGFsbHMgYXQgZW5kIG9mIFZPRCBwcm9ncmFtXG4gICAgRXZlbnRzW1wiTUVESUFfRU5ERURcIl0gPSBcImhsc01lZGlhRW5kZWRcIjtcbiAgICAvLyBGaXJlZCBhZnRlciBwbGF5YmFjayBzdGFsbCBpcyByZXNvbHZlZCB3aXRoIHBsYXlpbmcsIHNlZWtlZCwgb3IgZW5kZWQgZXZlbnQgZm9sbG93aW5nIEJVRkZFUl9TVEFMTEVEX0VSUk9SXG4gICAgRXZlbnRzW1wiU1RBTExfUkVTT0xWRURcIl0gPSBcImhsc1N0YWxsUmVzb2x2ZWRcIjtcbiAgICAvLyBGaXJlZCB3aGVuIHRoZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXRcbiAgICBFdmVudHNbXCJCVUZGRVJfUkVTRVRcIl0gPSBcImhsc0J1ZmZlclJlc2V0XCI7XG4gICAgLy8gRmlyZWQgd2hlbiB3ZSBrbm93IGFib3V0IHRoZSBjb2RlY3MgdGhhdCB3ZSBuZWVkIGJ1ZmZlcnMgZm9yIHRvIHB1c2ggaW50byAtIGRhdGE6IHt0cmFja3MgOiB7IGNvbnRhaW5lciwgY29kZWMsIGxldmVsQ29kZWMsIGluaXRTZWdtZW50LCBtZXRhZGF0YSB9fVxuICAgIEV2ZW50c1tcIkJVRkZFUl9DT0RFQ1NcIl0gPSBcImhsc0J1ZmZlckNvZGVjc1wiO1xuICAgIC8vIGZpcmVkIHdoZW4gc291cmNlYnVmZmVycyBoYXZlIGJlZW4gY3JlYXRlZCAtIGRhdGE6IHsgdHJhY2tzIDogdHJhY2tzIH1cbiAgICBFdmVudHNbXCJCVUZGRVJfQ1JFQVRFRFwiXSA9IFwiaGxzQnVmZmVyQ3JlYXRlZFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gICAgRXZlbnRzW1wiQlVGRkVSX0FQUEVORElOR1wiXSA9IFwiaGxzQnVmZmVyQXBwZW5kaW5nXCI7XG4gICAgLy8gZmlyZWQgd2hlbiB3ZSBhcmUgZG9uZSB3aXRoIGFwcGVuZGluZyBhIG1lZGlhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcsIHBlbmRpbmcgOiBuYiBvZiBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgZm9yIHRoaXMgc2VnbWVudCBwYXJlbnR9XG4gICAgRXZlbnRzW1wiQlVGRkVSX0FQUEVOREVEXCJdID0gXCJobHNCdWZmZXJBcHBlbmRlZFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhIC0gZGF0YTogeyB9XG4gICAgRXZlbnRzW1wiQlVGRkVSX0VPU1wiXSA9IFwiaGxzQnVmZmVyRW9zXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhbGwgYnVmZmVycyBhcmUgZnVsbCB0byB0aGUgZW5kIG9mIHRoZSBwcm9ncmFtLCBhZnRlciBjYWxsaW5nIE1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCkgKHVubGVzcyByZXN0cmljdGVkKVxuICAgIEV2ZW50c1tcIkJVRkZFUkVEX1RPX0VORFwiXSA9IFwiaGxzQnVmZmVyZWRUb0VuZFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBzaG91bGQgYmUgZmx1c2hlZCAtIGRhdGEgeyBzdGFydE9mZnNldCwgZW5kT2Zmc2V0IH1cbiAgICBFdmVudHNbXCJCVUZGRVJfRkxVU0hJTkdcIl0gPSBcImhsc0J1ZmZlckZsdXNoaW5nXCI7XG4gICAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIGhhcyBiZWVuIGZsdXNoZWQgLSBkYXRhOiB7IH1cbiAgICBFdmVudHNbXCJCVUZGRVJfRkxVU0hFRFwiXSA9IFwiaGxzQnVmZmVyRmx1c2hlZFwiO1xuICAgIC8vIGZpcmVkIHRvIHNpZ25hbCB0aGF0IGEgbWFuaWZlc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IG1hbmlmZXN0VVJMfVxuICAgIEV2ZW50c1tcIk1BTklGRVNUX0xPQURJTkdcIl0gPSBcImhsc01hbmlmZXN0TG9hZGluZ1wiO1xuICAgIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGF1ZGlvVHJhY2tzIDogWyBhdmFpbGFibGUgYXVkaW8gdHJhY2tzIF0sIHVybCA6IG1hbmlmZXN0VVJMLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgICBFdmVudHNbXCJNQU5JRkVTVF9MT0FERURcIl0gPSBcImhsc01hbmlmZXN0TG9hZGVkXCI7XG4gICAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gcGFyc2VkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgZmlyc3RMZXZlbCA6IGluZGV4IG9mIGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIE1hbmlmZXN0fVxuICAgIEV2ZW50c1tcIk1BTklGRVNUX1BBUlNFRFwiXSA9IFwiaGxzTWFuaWZlc3RQYXJzZWRcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICAgIEV2ZW50c1tcIkxFVkVMX1NXSVRDSElOR1wiXSA9IFwiaGxzTGV2ZWxTd2l0Y2hpbmdcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIGVmZmVjdGl2ZSAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICAgIEV2ZW50c1tcIkxFVkVMX1NXSVRDSEVEXCJdID0gXCJobHNMZXZlbFN3aXRjaGVkXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBsZXZlbCBVUkwsIGxldmVsIDogaWQgb2YgbGV2ZWwgYmVpbmcgbG9hZGVkfVxuICAgIEV2ZW50c1tcIkxFVkVMX0xPQURJTkdcIl0gPSBcImhsc0xldmVsTG9hZGluZ1wiO1xuICAgIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiBsb2FkZWQgbGV2ZWwsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICAgIEV2ZW50c1tcIkxFVkVMX0xPQURFRFwiXSA9IFwiaGxzTGV2ZWxMb2FkZWRcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBkZXRhaWxzIGhhdmUgYmVlbiB1cGRhdGVkIGJhc2VkIG9uIHByZXZpb3VzIGRldGFpbHMsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCB9XG4gICAgRXZlbnRzW1wiTEVWRUxfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxVcGRhdGVkXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgUFRTIGluZm9ybWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQgYWZ0ZXIgcGFyc2luZyBhIGZyYWdtZW50IC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsLCBkcmlmdDogUFRTIGRyaWZ0IG9ic2VydmVkIHdoZW4gcGFyc2luZyBsYXN0IGZyYWdtZW50IH1cbiAgICBFdmVudHNbXCJMRVZFTF9QVFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxQdHNVcGRhdGVkXCI7XG4gICAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgbGV2ZWxzIGhhdmUgY2hhbmdlZCBhZnRlciByZW1vdmluZyBhIGxldmVsIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSB9XG4gICAgRXZlbnRzW1wiTEVWRUxTX1VQREFURURcIl0gPSBcImhsc0xldmVsc1VwZGF0ZWRcIjtcbiAgICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBhdWRpbyB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzIH1cbiAgICBFdmVudHNbXCJBVURJT19UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzQXVkaW9UcmFja3NVcGRhdGVkXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2hpbmcgaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tTd2l0Y2hpbmdcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBhY3R1YWxseSBvY2N1cnMgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICAgIEV2ZW50c1tcIkFVRElPX1RSQUNLX1NXSVRDSEVEXCJdID0gXCJobHNBdWRpb1RyYWNrU3dpdGNoZWRcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBhdWRpbyB0cmFjayBVUkwsIGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICAgIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkaW5nXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgaWQgOiBhdWRpbyB0cmFjayBpZCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gICAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfTE9BREVEXCJdID0gXCJobHNBdWRpb1RyYWNrTG9hZGVkXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFja3MncyBkZXRhaWxzIGhhdmUgYmVlbiB1cGRhdGVkIGJhc2VkIG9uIHByZXZpb3VzIGRldGFpbHMsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogdHJhY2sgaWQgfVxuICAgIEV2ZW50c1tcIkFVRElPX1RSQUNLX1VQREFURURcIl0gPSBcImhsc0F1ZGlvVHJhY2tVcGRhdGVkXCI7XG4gICAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgc3VidGl0bGUgdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCAtIGRhdGE6IHsgc3VidGl0bGVUcmFja3MgOiBzdWJ0aXRsZVRyYWNrcyB9XG4gICAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tTX1VQREFURURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZFwiO1xuICAgIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IHN1YnRpdGxlIHRyYWNrcyB3ZXJlIGNsZWFyZWQgYXMgYSByZXN1bHQgb2Ygc3RvcHBpbmcgdGhlIG1lZGlhXG4gICAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tTX0NMRUFSRURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tzQ2xlYXJlZFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gYW4gc3VidGl0bGUgdHJhY2sgc3dpdGNoIG9jY3VycyAtIGRhdGE6IHsgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XG4gICAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfU1dJVENIXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrU3dpdGNoXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBzdWJ0aXRsZSB0cmFjayBVUkwsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxuICAgIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkaW5nXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19MT0FERURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkZWRcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgIHJhY2tzJ3MgZGV0YWlscyBoYXZlIGJlZW4gdXBkYXRlZCBiYXNlZCBvbiBwcmV2aW91cyBkZXRhaWxzLCBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IHRyYWNrIGlkIH1cbiAgICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS19VUERBVEVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrVXBkYXRlZFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSBmcmFnbWVudCBoYXMgYmVlbiBwcm9jZXNzZWQgLSBkYXRhOiB7IHN1Y2Nlc3MgOiBib29sZWFuLCBmcmFnIDogdGhlIHByb2Nlc3NlZCBmcmFnIH1cbiAgICBFdmVudHNbXCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRFwiXSA9IFwiaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhIHNldCBvZiBWVFRDdWVzIHRvIGJlIG1hbmFnZWQgZXh0ZXJuYWxseSBoYXMgYmVlbiBwYXJzZWQgLSBkYXRhOiB7IHR5cGU6IHN0cmluZywgdHJhY2s6IHN0cmluZywgY3VlczogWyBWVFRDdWUgXSB9XG4gICAgRXZlbnRzW1wiQ1VFU19QQVJTRURcIl0gPSBcImhsc0N1ZXNQYXJzZWRcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGEgdGV4dCB0cmFjayB0byBiZSBtYW5hZ2VkIGV4dGVybmFsbHkgaXMgZm91bmQgLSBkYXRhOiB7IHRyYWNrczogWyB7IGxhYmVsOiBzdHJpbmcsIGtpbmQ6IHN0cmluZywgZGVmYXVsdDogYm9vbGVhbiB9IF0gfVxuICAgIEV2ZW50c1tcIk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkRcIl0gPSBcImhsc05vbk5hdGl2ZVRleHRUcmFja3NGb3VuZFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gdGhlIGZpcnN0IHRpbWVzdGFtcCBpcyBmb3VuZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBpbml0UFRTOiBpbml0UFRTLCB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRXZlbnRzW1wiSU5JVF9QVFNfRk9VTkRcIl0gPSBcImhsc0luaXRQdHNGb3VuZFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRXZlbnRzW1wiRlJBR19MT0FESU5HXCJdID0gXCJobHNGcmFnTG9hZGluZ1wiO1xuICAgIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIHByb2dyZXNzaW5nIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCB7IHRyZXF1ZXN0LCB0Zmlyc3QsIGxvYWRlZCB9IH1cbiAgICAvLyBGUkFHX0xPQURfUFJPR1JFU1MgPSAnaGxzRnJhZ0xvYWRQcm9ncmVzcycsXG4gICAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBhYm9ydGluZyBmb3IgZW1lcmdlbmN5IHN3aXRjaCBkb3duIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgICBFdmVudHNbXCJGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURURcIl0gPSBcImhsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICAgIEV2ZW50c1tcIkZSQUdfTE9BREVEXCJdID0gXCJobHNGcmFnTG9hZGVkXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGhhcyBmaW5pc2hlZCBkZWNyeXB0aW5nIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0c3RhcnQsIHRkZWNyeXB0IH0gfVxuICAgIEV2ZW50c1tcIkZSQUdfREVDUllQVEVEXCJdID0gXCJobHNGcmFnRGVjcnlwdGVkXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBJbml0IFNlZ21lbnQgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudCB9XG4gICAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVFwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBzZWkgdGV4dCBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBzZWkgc2FtcGxlcyBwZXMgXSB9XG4gICAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX1VTRVJEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ1VzZXJkYXRhXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIGlkMyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBpZDMgc2FtcGxlcyBwZXMgXSB9XG4gICAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX01FVEFEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ01ldGFkYXRhXCI7XG4gICAgLy8gZmlyZWQgd2hlbiBkYXRhIGhhdmUgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cbiAgICAvLyBGUkFHX1BBUlNJTkdfREFUQSA9ICdobHNGcmFnUGFyc2luZ0RhdGEnLFxuICAgIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcGFyc2luZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0IH1cbiAgICBFdmVudHNbXCJGUkFHX1BBUlNFRFwiXSA9IFwiaGxzRnJhZ1BhcnNlZFwiO1xuICAgIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcmVtdXhlZCBNUDQgYm94ZXMgaGF2ZSBhbGwgYmVlbiBhcHBlbmRlZCBpbnRvIFNvdXJjZUJ1ZmZlciAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgICBFdmVudHNbXCJGUkFHX0JVRkZFUkVEXCJdID0gXCJobHNGcmFnQnVmZmVyZWRcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IG1hdGNoaW5nIHdpdGggY3VycmVudCBtZWRpYSBwb3NpdGlvbiBpcyBjaGFuZ2luZyAtIGRhdGEgOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRXZlbnRzW1wiRlJBR19DSEFOR0VEXCJdID0gXCJobHNGcmFnQ2hhbmdlZFwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7IGN1cnJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzIH1cbiAgICBFdmVudHNbXCJGUFNfRFJPUFwiXSA9IFwiaGxzRnBzRHJvcFwiO1xuICAgIC8vIHRyaWdnZXJlZCB3aGVuIEZQUyBkcm9wIHRyaWdnZXJzIGF1dG8gbGV2ZWwgY2FwcGluZyAtIGRhdGE6IHsgbGV2ZWwsIGRyb3BwZWRMZXZlbCB9XG4gICAgRXZlbnRzW1wiRlBTX0RST1BfTEVWRUxfQ0FQUElOR1wiXSA9IFwiaGxzRnBzRHJvcExldmVsQ2FwcGluZ1wiO1xuICAgIC8vIHRyaWdnZXJlZCB3aGVuIG1heEF1dG9MZXZlbCBjaGFuZ2VzIC0gZGF0YSB7IGF1dG9MZXZlbENhcHBpbmcsIGxldmVscywgbWF4QXV0b0xldmVsLCBtaW5BdXRvTGV2ZWwsIG1heEhkY3BMZXZlbCB9XG4gICAgRXZlbnRzW1wiTUFYX0FVVE9fTEVWRUxfVVBEQVRFRFwiXSA9IFwiaGxzTWF4QXV0b0xldmVsVXBkYXRlZFwiO1xuICAgIC8vIElkZW50aWZpZXIgZm9yIGFuIGVycm9yIGV2ZW50IC0gZGF0YTogeyB0eXBlIDogZXJyb3IgdHlwZSwgZGV0YWlscyA6IGVycm9yIGRldGFpbHMsIGZhdGFsIDogaWYgdHJ1ZSwgaGxzLmpzIGNhbm5vdC93aWxsIG5vdCB0cnkgdG8gcmVjb3ZlciwgaWYgZmFsc2UsIGhscy5qcyB3aWxsIHRyeSB0byByZWNvdmVyLG90aGVyIGVycm9yIHNwZWNpZmljIGRhdGEgfVxuICAgIEV2ZW50c1tcIkVSUk9SXCJdID0gXCJobHNFcnJvclwiO1xuICAgIC8vIGZpcmVkIHdoZW4gaGxzLmpzIGluc3RhbmNlIHN0YXJ0cyBkZXN0cm95aW5nLiBEaWZmZXJlbnQgZnJvbSBNRURJQV9ERVRBQ0hFRCBhcyBvbmUgY291bGQgd2FudCB0byBkZXRhY2ggYW5kIHJlYXR0YWNoIGEgbWVkaWEgdG8gdGhlIGluc3RhbmNlIG9mIGhscy5qcyB0byBoYW5kbGUgbWlkLXJvbGxzIGZvciBleGFtcGxlIC0gZGF0YTogeyB9XG4gICAgRXZlbnRzW1wiREVTVFJPWUlOR1wiXSA9IFwiaGxzRGVzdHJveWluZ1wiO1xuICAgIC8vIGZpcmVkIHdoZW4gYSBkZWNyeXB0IGtleSBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gICAgRXZlbnRzW1wiS0VZX0xPQURJTkdcIl0gPSBcImhsc0tleUxvYWRpbmdcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIGtleUluZm8gOiBLZXlMb2FkZXJJbmZvIH1cbiAgICBFdmVudHNbXCJLRVlfTE9BREVEXCJdID0gXCJobHNLZXlMb2FkZWRcIjtcbiAgICAvLyBkZXByZWNhdGVkOyBwbGVhc2UgdXNlIEJBQ0tfQlVGRkVSX1JFQUNIRUQgLSBkYXRhIDogeyBidWZmZXJFbmQ6IG51bWJlciB9XG4gICAgRXZlbnRzW1wiTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEXCJdID0gXCJobHNMaXZlQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgICAvLyBmaXJlZCB3aGVuIHRoZSBiYWNrIGJ1ZmZlciBpcyByZWFjaGVkIGFzIGRlZmluZWQgYnkgdGhlIGJhY2tCdWZmZXJMZW5ndGggY29uZmlnIG9wdGlvbiAtIGRhdGEgOiB7IGJ1ZmZlckVuZDogbnVtYmVyIH1cbiAgICBFdmVudHNbXCJCQUNLX0JVRkZFUl9SRUFDSEVEXCJdID0gXCJobHNCYWNrQnVmZmVyUmVhY2hlZFwiO1xuICAgIC8vIGZpcmVkIGFmdGVyIHN0ZWVyaW5nIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgc3RlZXJpbmdNYW5pZmVzdDogU3RlZXJpbmdNYW5pZmVzdCBvYmplY3QsIHVybDogc3RlZXJpbmcgbWFuaWZlc3QgVVJMIH1cbiAgICBFdmVudHNbXCJTVEVFUklOR19NQU5JRkVTVF9MT0FERURcIl0gPSBcImhsc1N0ZWVyaW5nTWFuaWZlc3RMb2FkZWRcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGFzc2V0IGxpc3QgaGFzIGJlZ3VuIGxvYWRpbmdcbiAgICBFdmVudHNbXCJBU1NFVF9MSVNUX0xPQURJTkdcIl0gPSBcImhsc0Fzc2V0TGlzdExvYWRpbmdcIjtcbiAgICAvLyBmaXJlZCB3aGVuIGEgdmFsaWQgYXNzZXQgbGlzdCBpcyBsb2FkZWRcbiAgICBFdmVudHNbXCJBU1NFVF9MSVNUX0xPQURFRFwiXSA9IFwiaGxzQXNzZXRMaXN0TG9hZGVkXCI7XG4gICAgLy8gZmlyZWQgd2hlbiB0aGUgbGlzdCBvZiBJbnRlcnN0aXRpYWwgRXZlbnRzIGFuZCBJbnRlcnN0aXRpYWwgU2NoZWR1bGUgaXMgdXBkYXRlZFxuICAgIEV2ZW50c1tcIklOVEVSU1RJVElBTFNfVVBEQVRFRFwiXSA9IFwiaGxzSW50ZXJzdGl0aWFsc1VwZGF0ZWRcIjtcbiAgICAvLyBmaXJlZCB3aGVuIHRoZSBidWZmZXIgcmVhY2hlcyBhbiBJbnRlcnN0aXRpYWwgU2NoZWR1bGUgYm91bmRhcnkgKGJvdGggUHJpbWFyeSBzZWdtZW50cyBhbmQgSW50ZXJzdGl0aWFsIEFzc2V0cylcbiAgICBFdmVudHNbXCJJTlRFUlNUSVRJQUxTX0JVRkZFUkVEX1RPX0JPVU5EQVJZXCJdID0gXCJobHNJbnRlcnN0aXRpYWxzQnVmZmVyZWRUb0JvdW5kYXJ5XCI7XG4gICAgLy8gZmlyZWQgd2hlbiBhIHBsYXllciBpbnN0YW5jZSBmb3IgYW4gSW50ZXJzdGl0aWFsIEFzc2V0IGhhcyBiZWVuIGNyZWF0ZWRcbiAgICBFdmVudHNbXCJJTlRFUlNUSVRJQUxfQVNTRVRfUExBWUVSX0NSRUFURURcIl0gPSBcImhsc0ludGVyc3RpdGlhbEFzc2V0UGxheWVyQ3JlYXRlZFwiO1xuICAgIC8vIEludGVyc3RpdGlhbCBwbGF5YmFjayBzdGFydGVkXG4gICAgRXZlbnRzW1wiSU5URVJTVElUSUFMX1NUQVJURURcIl0gPSBcImhsc0ludGVyc3RpdGlhbFN0YXJ0ZWRcIjtcbiAgICAvLyBJbnRlcnN0aXRpYWxBc3NldCBwbGF5YmFjayBzdGFydGVkXG4gICAgRXZlbnRzW1wiSU5URVJTVElUSUFMX0FTU0VUX1NUQVJURURcIl0gPSBcImhsc0ludGVyc3RpdGlhbEFzc2V0U3RhcnRlZFwiO1xuICAgIC8vIEludGVyc3RpdGlhbEFzc2V0IHBsYXliYWNrIGVuZGVkXG4gICAgRXZlbnRzW1wiSU5URVJTVElUSUFMX0FTU0VUX0VOREVEXCJdID0gXCJobHNJbnRlcnN0aXRpYWxBc3NldEVuZGVkXCI7XG4gICAgLy8gSW50ZXJzdGl0aWFsQXNzZXQgcGxheWJhY2sgZXJyb3JlZFxuICAgIEV2ZW50c1tcIklOVEVSU1RJVElBTF9BU1NFVF9FUlJPUlwiXSA9IFwiaGxzSW50ZXJzdGl0aWFsQXNzZXRFcnJvclwiO1xuICAgIC8vIEludGVyc3RpdGlhbCBwbGF5YmFjayBlbmRlZFxuICAgIEV2ZW50c1tcIklOVEVSU1RJVElBTF9FTkRFRFwiXSA9IFwiaGxzSW50ZXJzdGl0aWFsRW5kZWRcIjtcbiAgICAvLyBJbnRlcnN0aXRpYWwgc2NoZWR1bGUgcmVzdW1lZCBwcmltYXJ5IHBsYXliYWNrXG4gICAgRXZlbnRzW1wiSU5URVJTVElUSUFMU19QUklNQVJZX1JFU1VNRURcIl0gPSBcImhsc0ludGVyc3RpdGlhbHNQcmltYXJ5UmVzdW1lZFwiO1xuICAgIC8vIEludGVyc3RpdGlhbCBwbGF5ZXJzIGRpc3BhdGNoIHRoaXMgZXZlbnQgd2hlbiBwbGF5b3V0IGxpbWl0IGlzIHJlYWNoZWRcbiAgICBFdmVudHNbXCJQTEFZT1VUX0xJTUlUX1JFQUNIRURcIl0gPSBcImhsc1BsYXlvdXRMaW1pdFJlYWNoZWRcIjtcbiAgICAvLyBFdmVudCBEYXRlUmFuZ2UgY3VlIFwiZW50ZXJcIiBldmVudCBkaXNwYXRjaGVkXG4gICAgRXZlbnRzW1wiRVZFTlRfQ1VFX0VOVEVSXCJdID0gXCJobHNFdmVudEN1ZUVudGVyXCI7XG4gICAgcmV0dXJuIEV2ZW50cztcbiAgfSh7fSk7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgZWFjaCBFdmVudCB0eXBlIGFuZCBwYXlsb2FkIGJ5IEV2ZW50IG5hbWUuIFVzZWQgaW4ge0BsaW5rIGhscy5qcyNIbHNFdmVudEVtaXR0ZXJ9IHRvIHN0cm9uZ2x5IHR5cGUgdGhlIGV2ZW50IGxpc3RlbmVyIEFQSS5cbiAgICovXG5cbiAgdmFyIFBsYXlsaXN0Q29udGV4dFR5cGUgPSB7XG4gICAgTUFOSUZFU1Q6IFwibWFuaWZlc3RcIixcbiAgICBMRVZFTDogXCJsZXZlbFwiLFxuICAgIEFVRElPX1RSQUNLOiBcImF1ZGlvVHJhY2tcIixcbiAgICBTVUJUSVRMRV9UUkFDSzogXCJzdWJ0aXRsZVRyYWNrXCJcbiAgfTtcbiAgdmFyIFBsYXlsaXN0TGV2ZWxUeXBlID0ge1xuICAgIE1BSU46IFwibWFpblwiLFxuICAgIEFVRElPOiBcImF1ZGlvXCIsXG4gICAgU1VCVElUTEU6IFwic3VidGl0bGVcIlxuICB9O1xuXG4gIC8qXG4gICAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAgICogLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3ZpbmdfYXZlcmFnZSNFeHBvbmVudGlhbF9tb3ZpbmdfYXZlcmFnZVxuICAgKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gICAqL1xuICB2YXIgRVdNQSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgICBmdW5jdGlvbiBFV01BKGhhbGZMaWZlLCBlc3RpbWF0ZSwgd2VpZ2h0KSB7XG4gICAgICBpZiAoZXN0aW1hdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBlc3RpbWF0ZSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAod2VpZ2h0ID09PSB2b2lkIDApIHtcbiAgICAgICAgd2VpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFsZkxpZmUgPSB2b2lkIDA7XG4gICAgICB0aGlzLmFscGhhXyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZXN0aW1hdGVfID0gdm9pZCAwO1xuICAgICAgdGhpcy50b3RhbFdlaWdodF8gPSB2b2lkIDA7XG4gICAgICB0aGlzLmhhbGZMaWZlID0gaGFsZkxpZmU7XG4gICAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgICB0aGlzLmFscGhhXyA9IGhhbGZMaWZlID8gTWF0aC5leHAoTWF0aC5sb2coMC41KSAvIGhhbGZMaWZlKSA6IDA7XG4gICAgICB0aGlzLmVzdGltYXRlXyA9IGVzdGltYXRlO1xuICAgICAgdGhpcy50b3RhbFdlaWdodF8gPSB3ZWlnaHQ7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBFV01BLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uc2FtcGxlID0gZnVuY3Rpb24gc2FtcGxlKHdlaWdodCwgdmFsdWUpIHtcbiAgICAgIHZhciBhZGpBbHBoYSA9IE1hdGgucG93KHRoaXMuYWxwaGFfLCB3ZWlnaHQpO1xuICAgICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICAgIHRoaXMudG90YWxXZWlnaHRfICs9IHdlaWdodDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRUb3RhbFdlaWdodCA9IGZ1bmN0aW9uIGdldFRvdGFsV2VpZ2h0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG90YWxXZWlnaHRfO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEVzdGltYXRlID0gZnVuY3Rpb24gZ2V0RXN0aW1hdGUoKSB7XG4gICAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgICAgdmFyIHplcm9GYWN0b3IgPSAxIC0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHRoaXMudG90YWxXZWlnaHRfKTtcbiAgICAgICAgaWYgKHplcm9GYWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gICAgfTtcbiAgICByZXR1cm4gRVdNQTtcbiAgfSgpO1xuXG4gIHZhciBFd21hQmFuZFdpZHRoRXN0aW1hdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKHNsb3csIGZhc3QsIGRlZmF1bHRFc3RpbWF0ZSwgZGVmYXVsdFRURkIpIHtcbiAgICAgIGlmIChkZWZhdWx0VFRGQiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlZmF1bHRUVEZCID0gMTAwO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gdm9pZCAwO1xuICAgICAgdGhpcy5taW5XZWlnaHRfID0gdm9pZCAwO1xuICAgICAgdGhpcy5taW5EZWxheU1zXyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuc2xvd18gPSB2b2lkIDA7XG4gICAgICB0aGlzLmZhc3RfID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZWZhdWx0VFRGQl8gPSB2b2lkIDA7XG4gICAgICB0aGlzLnR0ZmJfID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gZGVmYXVsdEVzdGltYXRlO1xuICAgICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgICB0aGlzLm1pbkRlbGF5TXNfID0gNTA7XG4gICAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdyk7XG4gICAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gICAgICB0aGlzLmRlZmF1bHRUVEZCXyA9IGRlZmF1bHRUVEZCO1xuICAgICAgdGhpcy50dGZiXyA9IG5ldyBFV01BKHNsb3cpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRXdtYUJhbmRXaWR0aEVzdGltYXRvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzbG93LCBmYXN0KSB7XG4gICAgICB2YXIgc2xvd18gPSB0aGlzLnNsb3dfLFxuICAgICAgICBmYXN0XyA9IHRoaXMuZmFzdF8sXG4gICAgICAgIHR0ZmJfID0gdGhpcy50dGZiXztcbiAgICAgIGlmIChzbG93Xy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdywgc2xvd18uZ2V0RXN0aW1hdGUoKSwgc2xvd18uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZmFzdF8uaGFsZkxpZmUgIT09IGZhc3QpIHtcbiAgICAgICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QsIGZhc3RfLmdldEVzdGltYXRlKCksIGZhc3RfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR0ZmJfLmhhbGZMaWZlICE9PSBzbG93KSB7XG4gICAgICAgIHRoaXMudHRmYl8gPSBuZXcgRVdNQShzbG93LCB0dGZiXy5nZXRFc3RpbWF0ZSgpLCB0dGZiXy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICAgIHZhciBudW1CaXRzID0gOCAqIG51bUJ5dGVzO1xuICAgICAgLy8gd2VpZ2h0IGlzIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICAgIHZhciBkdXJhdGlvblMgPSBkdXJhdGlvbk1zIC8gMTAwMDtcbiAgICAgIC8vIHZhbHVlIGlzIGJhbmR3aWR0aCBpbiBiaXRzL3NcbiAgICAgIHZhciBiYW5kd2lkdGhJbkJwcyA9IG51bUJpdHMgLyBkdXJhdGlvblM7XG4gICAgICB0aGlzLmZhc3RfLnNhbXBsZShkdXJhdGlvblMsIGJhbmR3aWR0aEluQnBzKTtcbiAgICAgIHRoaXMuc2xvd18uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICAgIH07XG4gICAgX3Byb3RvLnNhbXBsZVRURkIgPSBmdW5jdGlvbiBzYW1wbGVUVEZCKHR0ZmIpIHtcbiAgICAgIC8vIHdlaWdodCBpcyBmcmVxdWVuY3kgY3VydmUgYXBwbGllZCB0byBUVEZCIGluIHNlY29uZHNcbiAgICAgIC8vIChsb25nZXIgdGltZXMgaGF2ZSBsZXNzIHdlaWdodCB3aXRoIGV4cGVjdGVkIGlucHV0IHVuZGVyIDEgc2Vjb25kKVxuICAgICAgdmFyIHNlY29uZHMgPSB0dGZiIC8gMTAwMDtcbiAgICAgIHZhciB3ZWlnaHQgPSBNYXRoLnNxcnQoMikgKiBNYXRoLmV4cCgtTWF0aC5wb3coc2Vjb25kcywgMikgLyAyKTtcbiAgICAgIHRoaXMudHRmYl8uc2FtcGxlKHdlaWdodCwgTWF0aC5tYXgodHRmYiwgNSkpO1xuICAgIH07XG4gICAgX3Byb3RvLmNhbkVzdGltYXRlID0gZnVuY3Rpb24gY2FuRXN0aW1hdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYXN0Xy5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgICB9O1xuICAgIF9wcm90by5nZXRFc3RpbWF0ZSA9IGZ1bmN0aW9uIGdldEVzdGltYXRlKCkge1xuICAgICAgaWYgKHRoaXMuY2FuRXN0aW1hdGUoKSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgICAvLyBUYWtlIHRoZSBtaW5pbXVtIG9mIHRoZXNlIHR3byBlc3RpbWF0ZXMuICBUaGlzIHNob3VsZCBoYXZlIHRoZSBlZmZlY3Qgb2ZcbiAgICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldEVzdGltYXRlVFRGQiA9IGZ1bmN0aW9uIGdldEVzdGltYXRlVFRGQigpIHtcbiAgICAgIGlmICh0aGlzLnR0ZmJfLmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR0ZmJfLmdldEVzdGltYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0VFRGQl87XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IsIFt7XG4gICAgICBrZXk6IFwiZGVmYXVsdEVzdGltYXRlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVzdGltYXRlXztcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcblxuICB2YXIgTG9nZ2VyID0gZnVuY3Rpb24gTG9nZ2VyKGxhYmVsLCBsb2dnZXIpIHtcbiAgICB0aGlzLnRyYWNlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVidWcgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgdGhpcy53YXJuID0gdm9pZCAwO1xuICAgIHRoaXMuaW5mbyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuICAgIHZhciBsYiA9IFwiW1wiICsgbGFiZWwgKyBcIl06XCI7XG4gICAgdGhpcy50cmFjZSA9IG5vb3A7XG4gICAgdGhpcy5kZWJ1ZyA9IGxvZ2dlci5kZWJ1Zy5iaW5kKG51bGwsIGxiKTtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChudWxsLCBsYik7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChudWxsLCBsYik7XG4gICAgdGhpcy5pbmZvID0gbG9nZ2VyLmluZm8uYmluZChudWxsLCBsYik7XG4gICAgdGhpcy5lcnJvciA9IGxvZ2dlci5lcnJvci5iaW5kKG51bGwsIGxiKTtcbiAgfTtcbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG4gIHZhciBmYWtlTG9nZ2VyID0ge1xuICAgIHRyYWNlOiBub29wLFxuICAgIGRlYnVnOiBub29wLFxuICAgIGxvZzogbm9vcCxcbiAgICB3YXJuOiBub29wLFxuICAgIGluZm86IG5vb3AsXG4gICAgZXJyb3I6IG5vb3BcbiAgfTtcbiAgZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKCkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZmFrZUxvZ2dlcik7XG4gIH1cblxuICAvLyBsZXQgbGFzdENhbGxUaW1lO1xuICAvLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XG4gIC8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4gIC8vICAgbGFzdENhbGxUaW1lID0gbm93O1xuICAvLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xuICAvLyAgIHJldHVybiBtc2c7XG4gIC8vIH1cblxuICBmdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlLCBpZCkge1xuICAgIHZhciBmdW5jID0gc2VsZi5jb25zb2xlW3R5cGVdO1xuICAgIHJldHVybiBmdW5jID8gZnVuYy5iaW5kKHNlbGYuY29uc29sZSwgKGlkID8gJ1snICsgaWQgKyAnXSAnIDogJycpICsgXCJbXCIgKyB0eXBlICsgXCJdID5cIikgOiBub29wO1xuICB9XG4gIGZ1bmN0aW9uIGdldExvZ2dlckZuKGtleSwgZGVidWdDb25maWcsIGlkKSB7XG4gICAgcmV0dXJuIGRlYnVnQ29uZmlnW2tleV0gPyBkZWJ1Z0NvbmZpZ1trZXldLmJpbmQoZGVidWdDb25maWcpIDogY29uc29sZVByaW50Rm4oa2V5LCBpZCk7XG4gIH1cbiAgdmFyIGV4cG9ydGVkTG9nZ2VyID0gY3JlYXRlTG9nZ2VyKCk7XG4gIGZ1bmN0aW9uIGVuYWJsZUxvZ3MoZGVidWdDb25maWcsIGNvbnRleHQsIGlkKSB7XG4gICAgLy8gY2hlY2sgdGhhdCBjb25zb2xlIGlzIGF2YWlsYWJsZVxuICAgIHZhciBuZXdMb2dnZXIgPSBjcmVhdGVMb2dnZXIoKTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gW1xuICAgICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAgIC8vICd0cmFjZScsXG4gICAgICAnZGVidWcnLCAnbG9nJywgJ2luZm8nLCAnd2FybicsICdlcnJvciddO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgbmV3TG9nZ2VyW2tleV0gPSBnZXRMb2dnZXJGbihrZXksIGRlYnVnQ29uZmlnLCBpZCk7XG4gICAgICB9KTtcbiAgICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3QgYWxsb3cgdG8gdXNlIGJpbmQgb24gY29uc29sZSBvYmplY3QgYW55d2F5XG4gICAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3TG9nZ2VyLmxvZyhcIkRlYnVnIGxvZ3MgZW5hYmxlZCBmb3IgXFxcIlwiICsgY29udGV4dCArIFwiXFxcIiBpbiBobHMuanMgdmVyc2lvbiBcIiArIFwiMS42LjE1XCIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBsb2cgZm4gdGhyZXcgYW4gZXhjZXB0aW9uLiBBbGwgbG9nZ2VyIG1ldGhvZHMgYXJlIG5vLW9wcy4gKi9cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvZ2dlcigpO1xuICAgICAgfVxuICAgICAgLy8gZ2xvYmFsIGV4cG9ydGVkIGxvZ2dlciB1c2VzIHRoZSBzYW1lIGZ1bmN0aW9ucyBhcyBuZXcgbG9nZ2VyIHdpdGhvdXQgYGlkYFxuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZXhwb3J0ZWRMb2dnZXJba2V5XSA9IGdldExvZ2dlckZuKGtleSwgZGVidWdDb25maWcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IGdsb2JhbCBleHBvcnRlZCBsb2dnZXJcbiAgICAgIF9leHRlbmRzKGV4cG9ydGVkTG9nZ2VyLCBuZXdMb2dnZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TG9nZ2VyO1xuICB9XG4gIHZhciBsb2dnZXIgPSBleHBvcnRlZExvZ2dlcjtcblxuICBmdW5jdGlvbiBnZXRNZWRpYVNvdXJjZShwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpIHtcbiAgICBpZiAocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIG1tcyA9IChwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgfHwgIXNlbGYuTWVkaWFTb3VyY2UpICYmIHNlbGYuTWFuYWdlZE1lZGlhU291cmNlO1xuICAgIHJldHVybiBtbXMgfHwgc2VsZi5NZWRpYVNvdXJjZSB8fCBzZWxmLldlYktpdE1lZGlhU291cmNlO1xuICB9XG4gIGZ1bmN0aW9uIGlzTWFuYWdlZE1lZGlhU291cmNlKHNvdXJjZSkge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlID09PSBzZWxmLk1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgfVxuICBmdW5jdGlvbiBpc0NvbXBhdGlibGVUcmFja0NoYW5nZShjdXJyZW50VHJhY2tzLCByZXF1aXJlZFRyYWNrcykge1xuICAgIHZhciB0cmFja05hbWVzID0gT2JqZWN0LmtleXMoY3VycmVudFRyYWNrcyk7XG4gICAgdmFyIHJlcXVpcmVkVHJhY2tOYW1lcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkVHJhY2tzKTtcbiAgICB2YXIgdHJhY2tDb3VudCA9IHRyYWNrTmFtZXMubGVuZ3RoO1xuICAgIHZhciByZXF1aXJlZFRyYWNrQ291bnQgPSByZXF1aXJlZFRyYWNrTmFtZXMubGVuZ3RoO1xuICAgIHJldHVybiAhdHJhY2tDb3VudCB8fCAhcmVxdWlyZWRUcmFja0NvdW50IHx8IHRyYWNrQ291bnQgPT09IHJlcXVpcmVkVHJhY2tDb3VudCAmJiAhdHJhY2tOYW1lcy5zb21lKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWRUcmFja05hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcbiAgLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbiAgLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gICAqXG4gICAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gICAqIFZlcnNpb246IDEuMFxuICAgKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XG4gICAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAgICovXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVURi04IGFycmF5IHRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gYXJyYXkgLSBUaGUgVVRGLTggYXJyYXkgdG8gY29udmVydFxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nXG4gICAqXG4gICAqIEBncm91cCBVdGlsc1xuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgZnVuY3Rpb24gdXRmOEFycmF5VG9TdHIoYXJyYXksIGV4aXRPbk51bGwpIHtcbiAgICBpZiAoZXhpdE9uTnVsbCA9PT0gdm9pZCAwKSB7XG4gICAgICBleGl0T25OdWxsID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoYXJyYXkpO1xuICAgICAgaWYgKGV4aXRPbk51bGwpIHtcbiAgICAgICAgLy8gZ3JhYiB1cCB0byB0aGUgZmlyc3QgbnVsbFxuICAgICAgICB2YXIgaWR4ID0gZGVjb2RlZC5pbmRleE9mKCdcXDAnKTtcbiAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTEgPyBkZWNvZGVkLnN1YnN0cmluZygwLCBpZHgpIDogZGVjb2RlZDtcbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBhbnkgbnVsbCBjaGFyYWN0ZXJzXG4gICAgICByZXR1cm4gZGVjb2RlZC5yZXBsYWNlKC9cXDAvZywgJycpO1xuICAgIH1cbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBjO1xuICAgIHZhciBjaGFyMjtcbiAgICB2YXIgY2hhcjM7XG4gICAgdmFyIG91dCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgYyA9IGFycmF5W2krK107XG4gICAgICBpZiAoYyA9PT0gMHgwMCAmJiBleGl0T25OdWxsKSB7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IDB4MDAgfHwgYyA9PT0gMHgwMykge1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIDMgKEVORF9PRl9URVhUKSBvciAwIChOVUxMKSB0aGVuIHNraXAgaXRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAvLyAweHh4eHh4eFxuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDB4MWYpIDw8IDYgfCBjaGFyMiAmIDB4M2YpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIC8vIDExMTAgeHh4eCAgMTB4eCB4eHh4ICAxMHh4IHh4eHhcbiAgICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMHgwZikgPDwgMTIgfCAoY2hhcjIgJiAweDNmKSA8PCA2IHwgKGNoYXIzICYgMHgzZikgPDwgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogIGhleCBkdW1wIGhlbHBlciBjbGFzc1xuICAgKi9cblxuICBmdW5jdGlvbiBhcnJheVRvSGV4KGFycmF5KSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoID0gYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgIH1cbiAgICAgIHN0ciArPSBoO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGZ1bmN0aW9uIGhleFRvQXJyYXlCdWZmZXIoc3RyKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShzdHIucmVwbGFjZSgvXjB4LywgJycpLnJlcGxhY2UoLyhbXFxkYS1mQS1GXXsyfSkgPy9nLCAnMHgkMSAnKS5yZXBsYWNlKC8gKyQvLCAnJykuc3BsaXQoJyAnKSkuYnVmZmVyO1xuICB9XG5cbiAgdmFyIExvYWRTdGF0cyA9IGZ1bmN0aW9uIExvYWRTdGF0cygpIHtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgdGhpcy5yZXRyeSA9IDA7XG4gICAgdGhpcy50b3RhbCA9IDA7XG4gICAgdGhpcy5jaHVua0NvdW50ID0gMDtcbiAgICB0aGlzLmJ3RXN0aW1hdGUgPSAwO1xuICAgIHRoaXMubG9hZGluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICAgIHRoaXMucGFyc2luZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICB9O1xuXG4gIHZhciBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgPSB7XG4gICAgQVVESU86IFwiYXVkaW9cIixcbiAgICBWSURFTzogXCJ2aWRlb1wiLFxuICAgIEFVRElPVklERU86IFwiYXVkaW92aWRlb1wiXG4gIH07XG4gIHZhciBCYXNlU2VnbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZVNlZ21lbnQoYmFzZSkge1xuICAgICAgdGhpcy5fYnl0ZVJhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgICB0aGlzLl9zdGF0cyA9IG51bGw7XG4gICAgICB0aGlzLl9zdHJlYW1zID0gbnVsbDtcbiAgICAgIC8vIGJhc2V1cmwgaXMgdGhlIFVSTCB0byB0aGUgcGxheWxpc3RcbiAgICAgIHRoaXMuYmFzZSA9IHZvaWQgMDtcbiAgICAgIC8vIHJlbHVybCBpcyB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHRoYXQgY29tZXMgZnJvbSBpbnNpZGUgdGhlIHBsYXlsaXN0LlxuICAgICAgdGhpcy5yZWx1cmwgPSB2b2lkIDA7XG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJhc2UgPSB7XG4gICAgICAgICAgdXJsOiBiYXNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgbWFrZUVudW1lcmFibGUodGhpcywgJ3N0YXRzJyk7XG4gICAgfVxuXG4gICAgLy8gc2V0Qnl0ZVJhbmdlIGNvbnZlcnRzIGEgRVhULVgtQllURVJBTkdFIGF0dHJpYnV0ZSBpbnRvIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgICB2YXIgX3Byb3RvID0gQmFzZVNlZ21lbnQucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRCeXRlUmFuZ2UgPSBmdW5jdGlvbiBzZXRCeXRlUmFuZ2UodmFsdWUsIHByZXZpb3VzKSB7XG4gICAgICB2YXIgcGFyYW1zID0gdmFsdWUuc3BsaXQoJ0AnLCAyKTtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5ieXRlUmFuZ2VFbmRPZmZzZXQpIHx8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHBhcmFtc1sxXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ieXRlUmFuZ2UgPSBbc3RhcnQsIHBhcnNlSW50KHBhcmFtc1swXSkgKyBzdGFydF07XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbyA9IGZ1bmN0aW9uIGNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8oKSB7XG4gICAgICB2YXIgZWxlbWVudGFyeVN0cmVhbXMgPSB0aGlzLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IG51bGw7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dID0gbnVsbDtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXSA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEJhc2VTZWdtZW50LCBbe1xuICAgICAga2V5OiBcImJhc2V1cmxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlLnVybDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYnl0ZVJhbmdlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2J5dGVSYW5nZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJieXRlUmFuZ2VTdGFydE9mZnNldFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVswXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYnl0ZVJhbmdlRW5kT2Zmc2V0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbGVtZW50YXJ5U3RyZWFtc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHJlYW1zID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9zdHJlYW1zO1xuICAgICAgICAgIHRoaXMuX3N0cmVhbXMgPSAoX3RoaXMkX3N0cmVhbXMgPSB7fSwgX3RoaXMkX3N0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IG51bGwsIF90aGlzJF9zdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsLCBfdGhpcyRfc3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10gPSBudWxsLCBfdGhpcyRfc3RyZWFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmVhbXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtcyA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYXNTdGF0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0cyAhPT0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFzU3RyZWFtc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJlYW1zICE9PSBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGF0c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0cyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3N0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0cztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdGF0cyA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1cmxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3VybCAmJiB0aGlzLmJhc2V1cmwgJiYgdGhpcy5yZWx1cmwpIHtcbiAgICAgICAgICB0aGlzLl91cmwgPSB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHtcbiAgICAgICAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cmwgfHwgJyc7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGlzTWVkaWFGcmFnbWVudChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCc7XG4gIH1cblxuICAvKipcbiAgICogT2JqZWN0IHJlcHJlc2VudGluZyBwYXJzZWQgZGF0YSBmcm9tIGFuIEhMUyBTZWdtZW50LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsRGV0YWlscy5mcmFnbWVudHN9LlxuICAgKi9cbiAgdmFyIEZyYWdtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVNlZ21lbnQyKSB7XG4gICAgZnVuY3Rpb24gRnJhZ21lbnQodHlwZSwgYmFzZSkge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfQmFzZVNlZ21lbnQyLmNhbGwodGhpcywgYmFzZSkgfHwgdGhpcztcbiAgICAgIF90aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGw7XG4gICAgICBfdGhpcy5fcHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgIF90aGlzLl9yZWYgPSBudWxsO1xuICAgICAgLy8gQXBwcm94aW1hdGUgYml0IHJhdGUgb2YgdGhlIGZyYWdtZW50IGV4cHJlc3NlZCBpbiBiaXRzIHBlciBzZWNvbmQgKGJwcykgYXMgaW5kaWNhdGVkIGJ5IHRoZSBsYXN0IEVYVC1YLUJJVFJBVEUgKGticHMpIHRhZ1xuICAgICAgX3RoaXMuX2JpdHJhdGUgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgX3RoaXMudGFnTGlzdCA9IFtdO1xuICAgICAgLy8gRVhUSU5GIGhhcyB0byBiZSBwcmVzZW50IGZvciBhIG0zdTggdG8gYmUgY29uc2lkZXJlZCB2YWxpZFxuICAgICAgX3RoaXMuZHVyYXRpb24gPSAwO1xuICAgICAgLy8gc24gbm90YXRlcyB0aGUgc2VxdWVuY2UgbnVtYmVyIGZvciBhIHNlZ21lbnQsIGFuZCBpZiBzZXQgdG8gYSBzdHJpbmcgY2FuIGJlICdpbml0U2VnbWVudCdcbiAgICAgIF90aGlzLnNuID0gMDtcbiAgICAgIC8vIGxldmVsa2V5cyBhcmUgdGhlIEVYVC1YLUtFWSB0YWdzIHRoYXQgYXBwbHkgdG8gdGhpcyBzZWdtZW50IGZvciBkZWNyeXB0aW9uXG4gICAgICAvLyBjb3JlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJpdmF0ZSBmaWVsZCBfZGVjcnlwdGRhdGEgaXMgdGhlIGxhY2sgb2YgdGhlIGluaXRpYWxpemVkIElWXG4gICAgICAvLyBfZGVjcnlwdGRhdGEgd2lsbCBzZXQgdGhlIElWIGZvciB0aGlzIHNlZ21lbnQgYmFzZWQgb24gdGhlIHNlZ21lbnQgbnVtYmVyIGluIHRoZSBmcmFnbWVudFxuICAgICAgX3RoaXMubGV2ZWxrZXlzID0gdm9pZCAwO1xuICAgICAgLy8gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBmcmFnbWVudCB0eXBlXG4gICAgICBfdGhpcy50eXBlID0gdm9pZCAwO1xuICAgICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGxvYWRlci4gU2V0IHdoaWxlIHRoZSBmcmFnbWVudCBpcyBsb2FkaW5nLCBhbmQgcmVtb3ZlZCBhZnRlcndhcmRzLiBVc2VkIHRvIGFib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgICAgIF90aGlzLmxvYWRlciA9IG51bGw7XG4gICAgICAvLyBBIHJlZmVyZW5jZSB0byB0aGUga2V5IGxvYWRlci4gU2V0IHdoaWxlIHRoZSBrZXkgaXMgbG9hZGluZywgYW5kIHJlbW92ZWQgYWZ0ZXJ3YXJkcy4gVXNlZCB0byBhYm9ydCBrZXkgbG9hZGluZ1xuICAgICAgX3RoaXMua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgIC8vIFRoZSBsZXZlbC90cmFjayBpbmRleCB0byB3aGljaCB0aGUgZnJhZ21lbnQgYmVsb25nc1xuICAgICAgX3RoaXMubGV2ZWwgPSAtMTtcbiAgICAgIC8vIFRoZSBjb250aW51aXR5IGNvdW50ZXIgb2YgdGhlIGZyYWdtZW50XG4gICAgICBfdGhpcy5jYyA9IDA7XG4gICAgICAvLyBUaGUgc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgICBfdGhpcy5zdGFydFBUUyA9IHZvaWQgMDtcbiAgICAgIC8vIFRoZSBlbmRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgICBfdGhpcy5lbmRQVFMgPSB2b2lkIDA7XG4gICAgICAvLyBUaGUgc3RhcnRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgICBfdGhpcy5zdGFydERUUyA9IHZvaWQgMDtcbiAgICAgIC8vIFRoZSBlbmRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgICBfdGhpcy5lbmREVFMgPSB2b2lkIDA7XG4gICAgICAvLyBUaGUgc3RhcnQgdGltZSBvZiB0aGUgZnJhZ21lbnQsIGFzIGxpc3RlZCBpbiB0aGUgbWFuaWZlc3QuIFVwZGF0ZWQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgICBfdGhpcy5zdGFydCA9IDA7XG4gICAgICAvLyBUaGUgb2Zmc2V0IHRpbWUgKHNlY29uZHMpIG9mIHRoZSBmcmFnbWVudCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgUGxheWxpc3RcbiAgICAgIF90aGlzLnBsYXlsaXN0T2Zmc2V0ID0gMDtcbiAgICAgIC8vIFNldCBieSBgdXBkYXRlRnJhZ1BUU0RUU2AgaW4gbGV2ZWwtaGVscGVyXG4gICAgICBfdGhpcy5kZWx0YVBUUyA9IHZvaWQgMDtcbiAgICAgIC8vIFRoZSBtYXhpbXVtIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChhdWRpby92aWRlbyBQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgICAgX3RoaXMubWF4U3RhcnRQVFMgPSB2b2lkIDA7XG4gICAgICAvLyBUaGUgbWluaW11bSBlbmRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgICBfdGhpcy5taW5FbmRQVFMgPSB2b2lkIDA7XG4gICAgICAvLyBJbml0IFNlZ21lbnQgYnl0ZXMgKHVuc2V0IGZvciBtZWRpYSBzZWdtZW50cylcbiAgICAgIF90aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgICAvLyBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzZWdtZW50IHdhcyBkb3dubG9hZGVkIGluIG9yZGVyIHRvIHRlc3QgYml0cmF0ZSwgYW5kIHdhcyBub3QgYnVmZmVyZWRcbiAgICAgIF90aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICAvLyAjRVhUSU5GICBzZWdtZW50IHRpdGxlXG4gICAgICBfdGhpcy50aXRsZSA9IG51bGw7XG4gICAgICAvLyBUaGUgTWVkaWEgSW5pdGlhbGl6YXRpb24gU2VjdGlvbiBmb3IgdGhpcyBzZWdtZW50XG4gICAgICBfdGhpcy5pbml0U2VnbWVudCA9IG51bGw7XG4gICAgICAvLyBGcmFnbWVudCBpcyB0aGUgbGFzdCBmcmFnbWVudCBpbiB0aGUgbWVkaWEgcGxheWxpc3RcbiAgICAgIF90aGlzLmVuZExpc3QgPSB2b2lkIDA7XG4gICAgICAvLyBGcmFnbWVudCBpcyBtYXJrZWQgYnkgYW4gRVhULVgtR0FQIHRhZyBpbmRpY2F0aW5nIHRoYXQgaXQgZG9lcyBub3QgY29udGFpbiBtZWRpYSBkYXRhIGFuZCBzaG91bGQgbm90IGJlIGxvYWRlZFxuICAgICAgX3RoaXMuZ2FwID0gdm9pZCAwO1xuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgX3RoaXMudXJsSWQgPSAwO1xuICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKEZyYWdtZW50LCBfQmFzZVNlZ21lbnQyKTtcbiAgICB2YXIgX3Byb3RvMiA9IEZyYWdtZW50LnByb3RvdHlwZTtcbiAgICBfcHJvdG8yLmFkZFN0YXJ0ID0gZnVuY3Rpb24gYWRkU3RhcnQodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0U3RhcnQodGhpcy5zdGFydCArIHZhbHVlKTtcbiAgICB9O1xuICAgIF9wcm90bzIuc2V0U3RhcnQgPSBmdW5jdGlvbiBzZXRTdGFydCh2YWx1ZSkge1xuICAgICAgdGhpcy5zdGFydCA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuX3JlZikge1xuICAgICAgICB0aGlzLl9yZWYuc3RhcnQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90bzIuc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBzZXREdXJhdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5kdXJhdGlvbiA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuX3JlZikge1xuICAgICAgICB0aGlzLl9yZWYuZHVyYXRpb24gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90bzIuc2V0S2V5Rm9ybWF0ID0gZnVuY3Rpb24gc2V0S2V5Rm9ybWF0KGtleUZvcm1hdCkge1xuICAgICAgdmFyIGxldmVsa2V5cyA9IHRoaXMubGV2ZWxrZXlzO1xuICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICB2YXIgX3RoaXMkX2RlY3J5cHRkYXRhO1xuICAgICAgICB2YXIga2V5ID0gbGV2ZWxrZXlzW2tleUZvcm1hdF07XG4gICAgICAgIGlmIChrZXkgJiYgISgoX3RoaXMkX2RlY3J5cHRkYXRhID0gdGhpcy5fZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgX3RoaXMkX2RlY3J5cHRkYXRhLmtleUlkKSkge1xuICAgICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0ga2V5LmdldERlY3J5cHREYXRhKHRoaXMuc24sIGxldmVsa2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90bzIuYWJvcnRSZXF1ZXN0cyA9IGZ1bmN0aW9uIGFib3J0UmVxdWVzdHMoKSB7XG4gICAgICB2YXIgX3RoaXMkbG9hZGVyLCBfdGhpcyRrZXlMb2FkZXI7XG4gICAgICAoX3RoaXMkbG9hZGVyID0gdGhpcy5sb2FkZXIpID09IG51bGwgfHwgX3RoaXMkbG9hZGVyLmFib3J0KCk7XG4gICAgICAoX3RoaXMka2V5TG9hZGVyID0gdGhpcy5rZXlMb2FkZXIpID09IG51bGwgfHwgX3RoaXMka2V5TG9hZGVyLmFib3J0KCk7XG4gICAgfTtcbiAgICBfcHJvdG8yLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvID0gZnVuY3Rpb24gc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUywgcGFydGlhbCkge1xuICAgICAgaWYgKHBhcnRpYWwgPT09IHZvaWQgMCkge1xuICAgICAgICBwYXJ0aWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudGFyeVN0cmVhbXMgPSB0aGlzLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgdmFyIGluZm8gPSBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcbiAgICAgIGlmICghaW5mbykge1xuICAgICAgICBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHtcbiAgICAgICAgICBzdGFydFBUUzogc3RhcnRQVFMsXG4gICAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFM6IHN0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUUzogZW5kRFRTLFxuICAgICAgICAgIHBhcnRpYWw6IHBhcnRpYWxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW5mby5zdGFydFBUUyA9IE1hdGgubWluKGluZm8uc3RhcnRQVFMsIHN0YXJ0UFRTKTtcbiAgICAgIGluZm8uZW5kUFRTID0gTWF0aC5tYXgoaW5mby5lbmRQVFMsIGVuZFBUUyk7XG4gICAgICBpbmZvLnN0YXJ0RFRTID0gTWF0aC5taW4oaW5mby5zdGFydERUUywgc3RhcnREVFMpO1xuICAgICAgaW5mby5lbmREVFMgPSBNYXRoLm1heChpbmZvLmVuZERUUywgZW5kRFRTKTtcbiAgICB9O1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoRnJhZ21lbnQsIFt7XG4gICAgICBrZXk6IFwiYnl0ZUxlbmd0aFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1N0YXRzKSB7XG4gICAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5zdGF0cy50b3RhbDtcbiAgICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnl0ZVJhbmdlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuYnl0ZVJhbmdlWzBdO1xuICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoc3RhcnQpICYmIGlzRmluaXRlTnVtYmVyKGVuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQgLSBzdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImJpdHJhdGVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZUxlbmd0aCAqIDggLyB0aGlzLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9iaXRyYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2JpdHJhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYml0cmF0ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZWNyeXB0ZGF0YVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRfZGVjcnlwdGRhdGEyO1xuICAgICAgICB2YXIgbGV2ZWxrZXlzID0gdGhpcy5sZXZlbGtleXM7XG4gICAgICAgIGlmICghbGV2ZWxrZXlzIHx8IGxldmVsa2V5cy5OT05FKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsa2V5cy5pZGVudGl0eSkge1xuICAgICAgICAgIGlmICghdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gbGV2ZWxrZXlzLmlkZW50aXR5LmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKChfdGhpcyRfZGVjcnlwdGRhdGEyID0gdGhpcy5fZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgX3RoaXMkX2RlY3J5cHRkYXRhMi5rZXlJZCkpIHtcbiAgICAgICAgICB2YXIga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKGxldmVsa2V5cyk7XG4gICAgICAgICAgaWYgKGtleUZvcm1hdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWxLZXkgPSB0aGlzLl9kZWNyeXB0ZGF0YSA9IGxldmVsa2V5c1trZXlGb3JtYXRzWzBdXSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKGxldmVsS2V5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gbGV2ZWxLZXkuZ2V0RGVjcnlwdERhdGEodGhpcy5zbiwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbmRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVuZFByb2dyYW1EYXRlVGltZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW1EYXRlVGltZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdXJhdGlvbiA9ICFpc0Zpbml0ZU51bWJlcih0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmFtRGF0ZVRpbWUgKyBkdXJhdGlvbiAqIDEwMDA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVuY3J5cHRlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRfZGVjcnlwdGRhdGEzO1xuICAgICAgICAvLyBBdCB0aGUgbTN1OC1wYXJzZXIgbGV2ZWwgd2UgbmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgbWFuaWZlc3Qgc2lnbmFsbGVkIGtleWZvcm1hdHNcbiAgICAgICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgICAgIC8vIEN1cnJlbnRseSwga2V5Rm9ybWF0IHdpbGwgb25seSBiZSBzZXQgZm9yIGlkZW50aXR5IGtleXNcbiAgICAgICAgaWYgKChfdGhpcyRfZGVjcnlwdGRhdGEzID0gdGhpcy5fZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgX3RoaXMkX2RlY3J5cHRkYXRhMy5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgICAgIHZhciBfdGhpcyRsZXZlbGtleXMka2V5Rm87XG4gICAgICAgICAgdmFyIGtleUZvcm1hdHMgPSBPYmplY3Qua2V5cyh0aGlzLmxldmVsa2V5cyk7XG4gICAgICAgICAgdmFyIGxlbiA9IGtleUZvcm1hdHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW4gPiAxIHx8IGxlbiA9PT0gMSAmJiAoX3RoaXMkbGV2ZWxrZXlzJGtleUZvID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0pICE9IG51bGwgJiYgX3RoaXMkbGV2ZWxrZXlzJGtleUZvLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvZ3JhbURhdGVUaW1lXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9PT0gbnVsbCAmJiB0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgIHRoaXMucHJvZ3JhbURhdGVUaW1lID0gRGF0ZS5wYXJzZSh0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyYW1EYXRlVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvZ3JhbURhdGVUaW1lID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlZlwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghaXNNZWRpYUZyYWdtZW50KHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9yZWYpIHtcbiAgICAgICAgICB0aGlzLl9yZWYgPSB7XG4gICAgICAgICAgICBiYXNlOiB0aGlzLmJhc2UsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgc246IHRoaXMuc24sXG4gICAgICAgICAgICBwcm9ncmFtRGF0ZVRpbWU6IHRoaXMucHJvZ3JhbURhdGVUaW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVmO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShCYXNlU2VnbWVudCk7XG5cbiAgLyoqXG4gICAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgUGFydGlhbCBTZWdtZW50LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsRGV0YWlscy5wYXJ0TGlzdH0uXG4gICAqL1xuICB2YXIgUGFydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTZWdtZW50Mykge1xuICAgIGZ1bmN0aW9uIFBhcnQocGFydEF0dHJzLCBmcmFnLCBiYXNlLCBpbmRleCwgcHJldmlvdXMpIHtcbiAgICAgIHZhciBfdGhpczI7XG4gICAgICBfdGhpczIgPSBfQmFzZVNlZ21lbnQzLmNhbGwodGhpcywgYmFzZSkgfHwgdGhpcztcbiAgICAgIF90aGlzMi5mcmFnT2Zmc2V0ID0gMDtcbiAgICAgIF90aGlzMi5kdXJhdGlvbiA9IDA7XG4gICAgICBfdGhpczIuZ2FwID0gZmFsc2U7XG4gICAgICBfdGhpczIuaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICAgIF90aGlzMi5yZWx1cmwgPSB2b2lkIDA7XG4gICAgICBfdGhpczIuZnJhZ21lbnQgPSB2b2lkIDA7XG4gICAgICBfdGhpczIuaW5kZXggPSB2b2lkIDA7XG4gICAgICBfdGhpczIuZHVyYXRpb24gPSBwYXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ0RVUkFUSU9OJyk7XG4gICAgICBfdGhpczIuZ2FwID0gcGFydEF0dHJzLmJvb2woJ0dBUCcpO1xuICAgICAgX3RoaXMyLmluZGVwZW5kZW50ID0gcGFydEF0dHJzLmJvb2woJ0lOREVQRU5ERU5UJyk7XG4gICAgICBfdGhpczIucmVsdXJsID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ1VSSScpO1xuICAgICAgX3RoaXMyLmZyYWdtZW50ID0gZnJhZztcbiAgICAgIF90aGlzMi5pbmRleCA9IGluZGV4O1xuICAgICAgdmFyIGJ5dGVSYW5nZSA9IHBhcnRBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdCWVRFUkFOR0UnKTtcbiAgICAgIGlmIChieXRlUmFuZ2UpIHtcbiAgICAgICAgX3RoaXMyLnNldEJ5dGVSYW5nZShieXRlUmFuZ2UsIHByZXZpb3VzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBfdGhpczIuZnJhZ09mZnNldCA9IHByZXZpb3VzLmZyYWdPZmZzZXQgKyBwcmV2aW91cy5kdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKFBhcnQsIF9CYXNlU2VnbWVudDMpO1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoUGFydCwgW3tcbiAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0ICsgdGhpcy5mcmFnT2Zmc2V0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbmRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxvYWRlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICAgIHJldHVybiAhIShlbGVtZW50YXJ5U3RyZWFtcy5hdWRpbyB8fCBlbGVtZW50YXJ5U3RyZWFtcy52aWRlbyB8fCBlbGVtZW50YXJ5U3RyZWFtcy5hdWRpb3ZpZGVvKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oQmFzZVNlZ21lbnQpO1xuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGcm9tUHJvdG90eXBlQ2hhaW4ob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAocHJvdG90eXBlKSB7XG4gICAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIHByb3BlcnR5KTtcbiAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGcm9tUHJvdG90eXBlQ2hhaW4ocHJvdG90eXBlLCBwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1ha2VFbnVtZXJhYmxlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB2YXIgZCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvckZyb21Qcm90b3R5cGVDaGFpbihvYmplY3QsIHByb3BlcnR5KTtcbiAgICBpZiAoZCkge1xuICAgICAgZC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkKTtcbiAgICB9XG4gIH1cblxuICB2YXIgVUlOVDMyX01BWCQxID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbiAgdmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4gIC8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXG4gIC8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuICAvLyBUaGVyZSBpcyBubyByZWFzb24gbm90IHRvIGRvIHRoaXMgYW5kIHNvbWUgYnJvd3NlcnMvU291cmNlQnVmZmVyLWRlbXV4ZXJzXG4gIC8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4gIC8vIEhlcmUgd2UgYXJlIG1hcHBpbmcgb3VyIGludGVybmFsIHRyYWNrIHR5cGVzIHRvIGNvbnN0YW50IE1QNCB0cmFjayBJRHNcbiAgLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xuICAvLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cbiAgdmFyIFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICAgIHZpZGVvOiAxLFxuICAgIGF1ZGlvOiAyLFxuICAgIGlkMzogMyxcbiAgICB0ZXh0OiA0XG4gIH07XG4gIGZ1bmN0aW9uIGJpbjJzdHIoZGF0YSkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGEpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRVaW50MTYoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgICByZXR1cm4gdmFsIDwgMCA/IDY1NTM2ICsgdmFsIDogdmFsO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCk7XG4gICAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRVaW50NjQoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCk7XG4gICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICByZXN1bHQgKz0gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICAgIHJldHVybiBidWZmZXJbb2Zmc2V0XSA8PCAyNCB8IGJ1ZmZlcltvZmZzZXQgKyAxXSA8PCAxNiB8IGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCA4IHwgYnVmZmVyW29mZnNldCArIDNdO1xuICB9XG5cbiAgLy8gRmluZCBcIm1vb2ZcIiBib3hcbiAgZnVuY3Rpb24gaGFzTW9vZkRhdGEoZGF0YSkge1xuICAgIHZhciBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7KSB7XG4gICAgICB2YXIgc2l6ZSA9IHJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgICBpZiAoc2l6ZSA+IDggJiYgZGF0YVtpICsgNF0gPT09IDB4NmQgJiYgZGF0YVtpICsgNV0gPT09IDB4NmYgJiYgZGF0YVtpICsgNl0gPT09IDB4NmYgJiYgZGF0YVtpICsgN10gPT09IDB4NjYpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgZGF0YSBmb3IgYSBib3ggc3BlY2lmaWVkIGJ5IGl0cyBwYXRoXG4gIGZ1bmN0aW9uIGZpbmRCb3goZGF0YSwgcGF0aCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKCFwYXRoLmxlbmd0aCkge1xuICAgICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIHZhciBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7KSB7XG4gICAgICB2YXIgc2l6ZSA9IHJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgICB2YXIgdHlwZSA9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcbiAgICAgIHZhciBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuICAgICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBwYXRoIGFuZCB3ZSd2ZSBmb3VuZCB0aGUgYm94IHdlIHdlcmVcbiAgICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICAgIHJlc3VsdHMucHVzaChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICAgIHZhciBzdWJyZXN1bHRzID0gZmluZEJveChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmRib3gpLCBwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc3VicmVzdWx0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpID0gZW5kYm94O1xuICAgIH1cblxuICAgIC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgZGF0YVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VnbWVudEluZGV4KHNpZHgpIHtcbiAgICB2YXIgcmVmZXJlbmNlcyA9IFtdO1xuICAgIHZhciB2ZXJzaW9uID0gc2lkeFswXTtcblxuICAgIC8vIHNldCBpbml0aWFsIG9mZnNldCwgd2Ugc2tpcCB0aGUgcmVmZXJlbmNlIElEIChub3QgbmVlZGVkKVxuICAgIHZhciBpbmRleCA9IDg7XG4gICAgdmFyIHRpbWVzY2FsZSA9IHJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICAgIGluZGV4ICs9IDQ7XG4gICAgdmFyIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IDA7XG4gICAgdmFyIGZpcnN0T2Zmc2V0ID0gMDtcbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihzaWR4LCBpbmRleCk7XG4gICAgICBmaXJzdE9mZnNldCA9IHJlYWRVaW50MzIoc2lkeCwgaW5kZXggKyA0KTtcbiAgICAgIGluZGV4ICs9IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50NjQoc2lkeCwgaW5kZXgpO1xuICAgICAgZmlyc3RPZmZzZXQgPSByZWFkVWludDY0KHNpZHgsIGluZGV4ICsgOCk7XG4gICAgICBpbmRleCArPSAxNjtcbiAgICB9XG5cbiAgICAvLyBza2lwIHJlc2VydmVkXG4gICAgaW5kZXggKz0gMjtcbiAgICB2YXIgc3RhcnRCeXRlID0gc2lkeC5sZW5ndGggKyBmaXJzdE9mZnNldDtcbiAgICB2YXIgcmVmZXJlbmNlc0NvdW50ID0gcmVhZFVpbnQxNihzaWR4LCBpbmRleCk7XG4gICAgaW5kZXggKz0gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZmVyZW5jZXNDb3VudDsgaSsrKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlSW5kZXggPSBpbmRleDtcbiAgICAgIHZhciByZWZlcmVuY2VJbmZvID0gcmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuICAgICAgdmFyIHJlZmVyZW5jZVNpemUgPSByZWZlcmVuY2VJbmZvICYgMHg3ZmZmZmZmZjtcbiAgICAgIHZhciByZWZlcmVuY2VUeXBlID0gKHJlZmVyZW5jZUluZm8gJiAweDgwMDAwMDAwKSA+Pj4gMzE7XG4gICAgICBpZiAocmVmZXJlbmNlVHlwZSA9PT0gMSkge1xuICAgICAgICBsb2dnZXIud2FybignU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHN1YnNlZ21lbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgIHJlZmVyZW5jZVNpemU6IHJlZmVyZW5jZVNpemUsXG4gICAgICAgIHN1YnNlZ21lbnREdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uLFxuICAgICAgICAvLyB1bnNjYWxlZFxuICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgZHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgICBzdGFydDogc3RhcnRCeXRlLFxuICAgICAgICAgIGVuZDogc3RhcnRCeXRlICsgcmVmZXJlbmNlU2l6ZSAtIDFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzdGFydEJ5dGUgKz0gcmVmZXJlbmNlU2l6ZTtcblxuICAgICAgLy8gU2tpcHBpbmcgMSBiaXQgZm9yIHxzdGFydHNXaXRoU2FwfCwgMyBiaXRzIGZvciB8c2FwVHlwZXwsIGFuZCAyOCBiaXRzXG4gICAgICAvLyBmb3IgfHNhcERlbHRhfC5cbiAgICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG5cbiAgICAgIC8vIHNraXAgdG8gbmV4dCByZWZcbiAgICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWU6IGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSxcbiAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlLFxuICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgIHJlZmVyZW5jZXNDb3VudDogcmVmZXJlbmNlc0NvdW50LFxuICAgICAgcmVmZXJlbmNlczogcmVmZXJlbmNlc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcbiAgICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAgICogbnVtYmVyIG9mIGNsb2NrIHRpY2tzIHBlciBzZWNvbmQgdG8gYXNzdW1lIGZvciB0aW1lLWJhc2VkIHZhbHVlc1xuICAgKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cbiAgICpcbiAgICogVG8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lIG9mIGFuIE1QNCwgeW91IG5lZWQgdHdvIHBpZWNlcyBvZlxuICAgKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcbiAgICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICAgKiBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGlzIGFsd2F5cyBleHByZXNzZWQgaW4gdGhlIHRpbWVzY2FsZSBmcm9tXG4gICAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XG4gICAqIGBgYFxuICAgKiBtb292ID4gdHJhayA+IG1kaWEgPiBtZGhkLnRpbWVzY2FsZVxuICAgKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXG4gICAqIGBgYFxuICAgKiBAcGFyYW0gaW5pdFNlZ21lbnQgdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcbiAgICogQHJldHVybnMgYSBoYXNoIG9mIHRyYWNrIHR5cGUgdG8gdGltZXNjYWxlIHZhbHVlcyBvciBudWxsIGlmXG4gICAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICAgKi9cblxuICBmdW5jdGlvbiBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJha3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFrID0gdHJha3NbaV07XG4gICAgICB2YXIgdGtoZCA9IGZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuICAgICAgaWYgKHRraGQpIHtcbiAgICAgICAgdmFyIHZlcnNpb24gPSB0a2hkWzBdO1xuICAgICAgICB2YXIgdHJhY2tJZCA9IHJlYWRVaW50MzIodGtoZCwgdmVyc2lvbiA9PT0gMCA/IDEyIDogMjApO1xuICAgICAgICB2YXIgbWRoZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XG4gICAgICAgIGlmIChtZGhkKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IG1kaGRbMF07XG4gICAgICAgICAgdmFyIHRpbWVzY2FsZSA9IHJlYWRVaW50MzIobWRoZCwgdmVyc2lvbiA9PT0gMCA/IDEyIDogMjApO1xuICAgICAgICAgIHZhciBoZGxyID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcbiAgICAgICAgICBpZiAoaGRscikge1xuICAgICAgICAgICAgdmFyIGhkbHJUeXBlID0gYmluMnN0cihoZGxyLnN1YmFycmF5KDgsIDEyKSk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHtcbiAgICAgICAgICAgICAgc291bjogRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLFxuICAgICAgICAgICAgICB2aWRlOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9cbiAgICAgICAgICAgIH1baGRsclR5cGVdO1xuICAgICAgICAgICAgLy8gUGFyc2UgY29kZWMgZGV0YWlsc1xuICAgICAgICAgICAgdmFyIHN0c2RCb3ggPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKVswXTtcbiAgICAgICAgICAgIHZhciBzdHNkID0gcGFyc2VTdHNkKHN0c2RCb3gpO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgLy8gQWRkICdhdWRpbycsICd2aWRlbycsIGFuZCAnYXVkaW92aWRlbycgdHJhY2sgcmVjb3JkcyB0aGF0IHdpbGwgbWFwIHRvIFNvdXJjZUJ1ZmZlcnNcbiAgICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0ge1xuICAgICAgICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgc3RzZDogc3RzZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXN1bHRbdHlwZV0gPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgICAgaWQ6IHRyYWNrSWRcbiAgICAgICAgICAgICAgfSwgc3RzZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBBZGQgJ21ldGEnIGFuZCBvdGhlciB0cmFjayByZWNvcmRzXG4gICAgICAgICAgICAgIHJlc3VsdFt0cmFja0lkXSA9IHtcbiAgICAgICAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBoZGxyVHlwZSxcbiAgICAgICAgICAgICAgICBzdHNkOiBzdHNkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0cmV4ID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ212ZXgnLCAndHJleCddKTtcbiAgICB0cmV4LmZvckVhY2goZnVuY3Rpb24gKHRyZXgpIHtcbiAgICAgIHZhciB0cmFja0lkID0gcmVhZFVpbnQzMih0cmV4LCA0KTtcbiAgICAgIHZhciB0cmFjayA9IHJlc3VsdFt0cmFja0lkXTtcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICB0cmFjay5kZWZhdWx0ID0ge1xuICAgICAgICAgIGR1cmF0aW9uOiByZWFkVWludDMyKHRyZXgsIDEyKSxcbiAgICAgICAgICBmbGFnczogcmVhZFVpbnQzMih0cmV4LCAyMClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU3RzZChzdHNkKSB7XG4gICAgdmFyIHNhbXBsZUVudHJpZXMgPSBzdHNkLnN1YmFycmF5KDgpO1xuICAgIHZhciBzYW1wbGVFbnRyaWVzRW5kID0gc2FtcGxlRW50cmllcy5zdWJhcnJheSg4ICsgNzgpO1xuICAgIHZhciBmb3VyQ0MgPSBiaW4yc3RyKHNhbXBsZUVudHJpZXMuc3ViYXJyYXkoNCwgOCkpO1xuICAgIHZhciBjb2RlYyA9IGZvdXJDQztcbiAgICB2YXIgc3VwcGxlbWVudGFsO1xuICAgIHZhciBlbmNyeXB0ZWQgPSBmb3VyQ0MgPT09ICdlbmNhJyB8fCBmb3VyQ0MgPT09ICdlbmN2JztcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICB2YXIgZW5jQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbZm91ckNDXSlbMF07XG4gICAgICB2YXIgZW5jQm94Q2hpbGRyZW4gPSBlbmNCb3guc3ViYXJyYXkoZm91ckNDID09PSAnZW5jYScgPyAyOCA6IDc4KTtcbiAgICAgIHZhciBzaW5mcyA9IGZpbmRCb3goZW5jQm94Q2hpbGRyZW4sIFsnc2luZiddKTtcbiAgICAgIHNpbmZzLmZvckVhY2goZnVuY3Rpb24gKHNpbmYpIHtcbiAgICAgICAgdmFyIHNjaG0gPSBmaW5kQm94KHNpbmYsIFsnc2NobSddKVswXTtcbiAgICAgICAgaWYgKHNjaG0pIHtcbiAgICAgICAgICB2YXIgc2NoZW1lID0gYmluMnN0cihzY2htLnN1YmFycmF5KDQsIDgpKTtcbiAgICAgICAgICBpZiAoc2NoZW1lID09PSAnY2JjcycgfHwgc2NoZW1lID09PSAnY2VuYycpIHtcbiAgICAgICAgICAgIHZhciBmcm1hID0gZmluZEJveChzaW5mLCBbJ2ZybWEnXSlbMF07XG4gICAgICAgICAgICBpZiAoZnJtYSkge1xuICAgICAgICAgICAgICAvLyBmb3IgZW5jcnlwdGVkIGNvbnRlbnQgY29kZWMgZm91ckNDIHdpbGwgYmUgaW4gZnJtYVxuICAgICAgICAgICAgICBjb2RlYyA9IGJpbjJzdHIoZnJtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGNvZGVjRm91ckNDID0gY29kZWM7XG4gICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgY2FzZSAnYXZjMSc6XG4gICAgICBjYXNlICdhdmMyJzpcbiAgICAgIGNhc2UgJ2F2YzMnOlxuICAgICAgY2FzZSAnYXZjNCc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBleHRyYWN0IHByb2ZpbGUgKyBjb21wYXRpYmlsaXR5ICsgbGV2ZWwgb3V0IG9mIGF2Y0MgYm94XG4gICAgICAgICAgdmFyIGF2Y0NCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsnYXZjQyddKVswXTtcbiAgICAgICAgICBpZiAoYXZjQ0JveCAmJiBhdmNDQm94Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIGNvZGVjICs9ICcuJyArIHRvSGV4KGF2Y0NCb3hbMV0pICsgdG9IZXgoYXZjQ0JveFsyXSkgKyB0b0hleChhdmNDQm94WzNdKTtcbiAgICAgICAgICAgIHN1cHBsZW1lbnRhbCA9IHBhcnNlU3VwcGxlbWVudGFsRG9WaUNvZGVjKGNvZGVjRm91ckNDID09PSAnYXZjMScgPyAnZHZhMScgOiAnZHZhdicsIHNhbXBsZUVudHJpZXNFbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbXA0YSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29kZWNCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFtmb3VyQ0NdKVswXTtcbiAgICAgICAgICB2YXIgZXNkc0JveCA9IGZpbmRCb3goY29kZWNCb3guc3ViYXJyYXkoMjgpLCBbJ2VzZHMnXSlbMF07XG4gICAgICAgICAgaWYgKGVzZHNCb3ggJiYgZXNkc0JveC5sZW5ndGggPiA3KSB7XG4gICAgICAgICAgICB2YXIgaSA9IDQ7XG4gICAgICAgICAgICAvLyBFUyBEZXNjcmlwdG9yIHRhZ1xuICAgICAgICAgICAgaWYgKGVzZHNCb3hbaSsrXSAhPT0gMHgwMykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBza2lwQkVSSW50ZWdlcihlc2RzQm94LCBpKTtcbiAgICAgICAgICAgIGkgKz0gMjsgLy8gc2tpcCBlc19pZDtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGVzZHNCb3hbaSsrXTtcbiAgICAgICAgICAgIGlmIChmbGFncyAmIDB4ODApIHtcbiAgICAgICAgICAgICAgaSArPSAyOyAvLyBza2lwIGRlcGVuZGVuY3kgZXNfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFncyAmIDB4NDApIHtcbiAgICAgICAgICAgICAgaSArPSBlc2RzQm94W2krK107IC8vIHNraXAgVVJMXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNvZGVyIGNvbmZpZyBkZXNjcmlwdG9yXG4gICAgICAgICAgICBpZiAoZXNkc0JveFtpKytdICE9PSAweDA0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IHNraXBCRVJJbnRlZ2VyKGVzZHNCb3gsIGkpO1xuICAgICAgICAgICAgdmFyIG9iamVjdFR5cGUgPSBlc2RzQm94W2krK107XG4gICAgICAgICAgICBpZiAob2JqZWN0VHlwZSA9PT0gMHg0MCkge1xuICAgICAgICAgICAgICBjb2RlYyArPSAnLicgKyB0b0hleChvYmplY3RUeXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAxMjtcbiAgICAgICAgICAgIC8vIERlY29kZXIgc3BlY2lmaWMgaW5mb1xuICAgICAgICAgICAgaWYgKGVzZHNCb3hbaSsrXSAhPT0gMHgwNSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBza2lwQkVSSW50ZWdlcihlc2RzQm94LCBpKTtcbiAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSBlc2RzQm94W2krK107XG4gICAgICAgICAgICB2YXIgYXVkaW9PYmplY3RUeXBlID0gKGZpcnN0Qnl0ZSAmIDB4ZjgpID4+IDM7XG4gICAgICAgICAgICBpZiAoYXVkaW9PYmplY3RUeXBlID09PSAzMSkge1xuICAgICAgICAgICAgICBhdWRpb09iamVjdFR5cGUgKz0gMSArICgoZmlyc3RCeXRlICYgMHg3KSA8PCAzKSArICgoZXNkc0JveFtpXSAmIDB4ZTApID4+IDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZWMgKz0gJy4nICsgYXVkaW9PYmplY3RUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaHZjMSc6XG4gICAgICBjYXNlICdoZXYxJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBodmNDQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2h2Y0MnXSlbMF07XG4gICAgICAgICAgaWYgKGh2Y0NCb3ggJiYgaHZjQ0JveC5sZW5ndGggPiAxMikge1xuICAgICAgICAgICAgdmFyIHByb2ZpbGVCeXRlID0gaHZjQ0JveFsxXTtcbiAgICAgICAgICAgIHZhciBwcm9maWxlU3BhY2UgPSBbJycsICdBJywgJ0InLCAnQyddW3Byb2ZpbGVCeXRlID4+IDZdO1xuICAgICAgICAgICAgdmFyIGdlbmVyYWxQcm9maWxlSWRjID0gcHJvZmlsZUJ5dGUgJiAweDFmO1xuICAgICAgICAgICAgdmFyIHByb2ZpbGVDb21wYXQgPSByZWFkVWludDMyKGh2Y0NCb3gsIDIpO1xuICAgICAgICAgICAgdmFyIHRpZXJGbGFnID0gKHByb2ZpbGVCeXRlICYgMHgyMCkgPj4gNSA/ICdIJyA6ICdMJztcbiAgICAgICAgICAgIHZhciBsZXZlbElEQyA9IGh2Y0NCb3hbMTJdO1xuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnRJbmRpY2F0b3IgPSBodmNDQm94LnN1YmFycmF5KDYsIDEyKTtcbiAgICAgICAgICAgIGNvZGVjICs9ICcuJyArIHByb2ZpbGVTcGFjZSArIGdlbmVyYWxQcm9maWxlSWRjO1xuICAgICAgICAgICAgY29kZWMgKz0gJy4nICsgcmV2ZXJzZTMyQml0SW50KHByb2ZpbGVDb21wYXQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgY29kZWMgKz0gJy4nICsgdGllckZsYWcgKyBsZXZlbElEQztcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50U3RyaW5nID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IGNvbnN0cmFpbnRJbmRpY2F0b3IubGVuZ3RoOyBfaS0tOykge1xuICAgICAgICAgICAgICB2YXIgX2J5dGUgPSBjb25zdHJhaW50SW5kaWNhdG9yW19pXTtcbiAgICAgICAgICAgICAgaWYgKF9ieXRlIHx8IGNvbnN0cmFpbnRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZEJ5dGUgPSBfYnl0ZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50U3RyaW5nID0gJy4nICsgZW5jb2RlZEJ5dGUgKyBjb25zdHJhaW50U3RyaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlYyArPSBjb25zdHJhaW50U3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdXBwbGVtZW50YWwgPSBwYXJzZVN1cHBsZW1lbnRhbERvVmlDb2RlYyhjb2RlY0ZvdXJDQyA9PSAnaGV2MScgPyAnZHZoZScgOiAnZHZoMScsIHNhbXBsZUVudHJpZXNFbmQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkdmgxJzpcbiAgICAgIGNhc2UgJ2R2aGUnOlxuICAgICAgY2FzZSAnZHZhdic6XG4gICAgICBjYXNlICdkdmExJzpcbiAgICAgIGNhc2UgJ2RhdjEnOlxuICAgICAgICB7XG4gICAgICAgICAgY29kZWMgPSBwYXJzZVN1cHBsZW1lbnRhbERvVmlDb2RlYyhjb2RlYywgc2FtcGxlRW50cmllc0VuZCkgfHwgY29kZWM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3ZwMDknOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHZwY0NCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsndnBjQyddKVswXTtcbiAgICAgICAgICBpZiAodnBjQ0JveCAmJiB2cGNDQm94Lmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgIHZhciBwcm9maWxlID0gdnBjQ0JveFs0XTtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHZwY0NCb3hbNV07XG4gICAgICAgICAgICB2YXIgYml0RGVwdGggPSB2cGNDQm94WzZdID4+IDQgJiAweDBmO1xuICAgICAgICAgICAgY29kZWMgKz0gJy4nICsgYWRkTGVhZGluZ1plcm8ocHJvZmlsZSkgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhsZXZlbCkgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhiaXREZXB0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdhdjAxJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBhdjFDQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2F2MUMnXSlbMF07XG4gICAgICAgICAgaWYgKGF2MUNCb3ggJiYgYXYxQ0JveC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgX3Byb2ZpbGUgPSBhdjFDQm94WzFdID4+PiA1O1xuICAgICAgICAgICAgdmFyIF9sZXZlbCA9IGF2MUNCb3hbMV0gJiAweDFmO1xuICAgICAgICAgICAgdmFyIF90aWVyRmxhZyA9IGF2MUNCb3hbMl0gPj4+IDcgPyAnSCcgOiAnTSc7XG4gICAgICAgICAgICB2YXIgaGlnaEJpdERlcHRoID0gKGF2MUNCb3hbMl0gJiAweDQwKSA+PiA2O1xuICAgICAgICAgICAgdmFyIHR3ZWx2ZUJpdCA9IChhdjFDQm94WzJdICYgMHgyMCkgPj4gNTtcbiAgICAgICAgICAgIHZhciBfYml0RGVwdGggPSBfcHJvZmlsZSA9PT0gMiAmJiBoaWdoQml0RGVwdGggPyB0d2VsdmVCaXQgPyAxMiA6IDEwIDogaGlnaEJpdERlcHRoID8gMTAgOiA4O1xuICAgICAgICAgICAgdmFyIG1vbm9jaHJvbWUgPSAoYXYxQ0JveFsyXSAmIDB4MTApID4+IDQ7XG4gICAgICAgICAgICB2YXIgY2hyb21hU3Vic2FtcGxpbmdYID0gKGF2MUNCb3hbMl0gJiAweDA4KSA+PiAzO1xuICAgICAgICAgICAgdmFyIGNocm9tYVN1YnNhbXBsaW5nWSA9IChhdjFDQm94WzJdICYgMHgwNCkgPj4gMjtcbiAgICAgICAgICAgIHZhciBjaHJvbWFTYW1wbGVQb3NpdGlvbiA9IGF2MUNCb3hbMl0gJiAweDAzO1xuICAgICAgICAgICAgLy8gVE9ETzogcGFyc2UgY29sb3JfZGVzY3JpcHRpb25fcHJlc2VudF9mbGFnXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGl0IHRvIEJULjcwOS9saW1pdGVkIHJhbmdlIGZvciBub3dcbiAgICAgICAgICAgIC8vIG1vcmUgaW5mbyBodHRwczovL2FvbWVkaWFjb2RlYy5naXRodWIuaW8vYXYxLWlzb2JtZmYvI2F2MWNvZGVjY29uZmlndXJhdGlvbmJveC1zeW50YXhcbiAgICAgICAgICAgIHZhciBjb2xvclByaW1hcmllcyA9IDE7XG4gICAgICAgICAgICB2YXIgdHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MgPSAxO1xuICAgICAgICAgICAgdmFyIG1hdHJpeENvZWZmaWNpZW50cyA9IDE7XG4gICAgICAgICAgICB2YXIgdmlkZW9GdWxsUmFuZ2VGbGFnID0gMDtcbiAgICAgICAgICAgIGNvZGVjICs9ICcuJyArIF9wcm9maWxlICsgJy4nICsgYWRkTGVhZGluZ1plcm8oX2xldmVsKSArIF90aWVyRmxhZyArICcuJyArIGFkZExlYWRpbmdaZXJvKF9iaXREZXB0aCkgKyAnLicgKyBtb25vY2hyb21lICsgJy4nICsgY2hyb21hU3Vic2FtcGxpbmdYICsgY2hyb21hU3Vic2FtcGxpbmdZICsgY2hyb21hU2FtcGxlUG9zaXRpb24gKyAnLicgKyBhZGRMZWFkaW5nWmVybyhjb2xvclByaW1hcmllcykgKyAnLicgKyBhZGRMZWFkaW5nWmVybyh0cmFuc2ZlckNoYXJhY3RlcmlzdGljcykgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhtYXRyaXhDb2VmZmljaWVudHMpICsgJy4nICsgdmlkZW9GdWxsUmFuZ2VGbGFnO1xuICAgICAgICAgICAgc3VwcGxlbWVudGFsID0gcGFyc2VTdXBwbGVtZW50YWxEb1ZpQ29kZWMoJ2RhdjEnLCBzYW1wbGVFbnRyaWVzRW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgIGVuY3J5cHRlZDogZW5jcnlwdGVkLFxuICAgICAgc3VwcGxlbWVudGFsOiBzdXBwbGVtZW50YWxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU3VwcGxlbWVudGFsRG9WaUNvZGVjKGZvdXJDQywgc2FtcGxlRW50cmllc0VuZCkge1xuICAgIHZhciBkdnZDUmVzdWx0ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2R2dkMnXSk7IC8vIHVzZWQgYnkgRG9WaSBQcm9maWxlIDggdG8gMTBcbiAgICB2YXIgZHZYQ0JveCA9IGR2dkNSZXN1bHQubGVuZ3RoID8gZHZ2Q1Jlc3VsdFswXSA6IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydkdmNDJ10pWzBdOyAvLyB1c2VkIGJ5IERvVmkgUHJvZmlsZXMgdXAgdG8gNyBhbmQgMjBcbiAgICBpZiAoZHZYQ0JveCkge1xuICAgICAgdmFyIGRvVmlQcm9maWxlID0gZHZYQ0JveFsyXSA+PiAxICYgMHg3ZjtcbiAgICAgIHZhciBkb1ZpTGV2ZWwgPSBkdlhDQm94WzJdIDw8IDUgJiAweDIwIHwgZHZYQ0JveFszXSA+PiAzICYgMHgxZjtcbiAgICAgIHJldHVybiBmb3VyQ0MgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhkb1ZpUHJvZmlsZSkgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhkb1ZpTGV2ZWwpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXZlcnNlMzJCaXRJbnQodmFsKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICByZXN1bHQgfD0gKHZhbCA+PiBpICYgMSkgPDwgMzIgLSAxIC0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA+Pj4gMDtcbiAgfVxuICBmdW5jdGlvbiBza2lwQkVSSW50ZWdlcihieXRlcywgaSkge1xuICAgIHZhciBsaW1pdCA9IGkgKyA1O1xuICAgIHdoaWxlIChieXRlc1tpKytdICYgMHg4MCAmJiBpIDwgbGltaXQpIHtcbiAgICAgIC8qIGRvIG5vdGhpbmcgKi9cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgZnVuY3Rpb24gdG9IZXgoeCkge1xuICAgIHJldHVybiAoJzAnICsgeC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvKG51bSkge1xuICAgIHJldHVybiAobnVtIDwgMTAgPyAnMCcgOiAnJykgKyBudW07XG4gIH1cbiAgZnVuY3Rpb24gcGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkge1xuICAgIGlmICghaW5pdFNlZ21lbnQgfHwgIWRlY3J5cHRkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXlJZCA9IGRlY3J5cHRkYXRhLmtleUlkO1xuICAgIGlmIChrZXlJZCAmJiBkZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICAgIGFwcGx5VG9UZW5jQm94ZXMoaW5pdFNlZ21lbnQsIGZ1bmN0aW9uICh0ZW5jLCBpc0F1ZGlvKSB7XG4gICAgICAgIC8vIExvb2sgZm9yIGRlZmF1bHQga2V5IGlkIChrZXlJRCBvZmZzZXQgaXMgYWx3YXlzIDggd2l0aGluIHRoZSB0ZW5jIGJveCk6XG4gICAgICAgIHZhciB0ZW5jS2V5SWQgPSB0ZW5jLnN1YmFycmF5KDgsIDI0KTtcbiAgICAgICAgaWYgKCF0ZW5jS2V5SWQuc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBiICE9PSAwO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJbZW1lXSBQYXRjaGluZyBrZXlJZCBpbiAnZW5jXCIgKyAoaXNBdWRpbyA/ICdhJyA6ICd2JykgKyBcIj5zaW5mPj50ZW5jJyBib3g6IFwiICsgYXJyYXlUb0hleCh0ZW5jS2V5SWQpICsgXCIgLT4gXCIgKyBhcnJheVRvSGV4KGtleUlkKSk7XG4gICAgICAgICAgdGVuYy5zZXQoa2V5SWQsIDgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VLZXlJZHNGcm9tVGVuYyhpbml0U2VnbWVudCkge1xuICAgIHZhciBrZXlJZHMgPSBbXTtcbiAgICBhcHBseVRvVGVuY0JveGVzKGluaXRTZWdtZW50LCBmdW5jdGlvbiAodGVuYykge1xuICAgICAgcmV0dXJuIGtleUlkcy5wdXNoKHRlbmMuc3ViYXJyYXkoOCwgMjQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5SWRzO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5VG9UZW5jQm94ZXMoaW5pdFNlZ21lbnQsIHByZWRpY2F0ZSkge1xuICAgIHZhciB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICAgIHRyYWtzLmZvckVhY2goZnVuY3Rpb24gKHRyYWspIHtcbiAgICAgIHZhciBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG4gICAgICBpZiAoIXN0c2QpIHJldHVybjtcbiAgICAgIHZhciBzYW1wbGVFbnRyaWVzID0gc3RzZC5zdWJhcnJheSg4KTtcbiAgICAgIHZhciBlbmNCb3hlcyA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgWydlbmNhJ10pO1xuICAgICAgdmFyIGlzQXVkaW8gPSBlbmNCb3hlcy5sZW5ndGggPiAwO1xuICAgICAgaWYgKCFpc0F1ZGlvKSB7XG4gICAgICAgIGVuY0JveGVzID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbJ2VuY3YnXSk7XG4gICAgICB9XG4gICAgICBlbmNCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbmMpIHtcbiAgICAgICAgdmFyIGVuY0JveENoaWxkcmVuID0gaXNBdWRpbyA/IGVuYy5zdWJhcnJheSgyOCkgOiBlbmMuc3ViYXJyYXkoNzgpO1xuICAgICAgICB2YXIgc2luZkJveGVzID0gZmluZEJveChlbmNCb3hDaGlsZHJlbiwgWydzaW5mJ10pO1xuICAgICAgICBzaW5mQm94ZXMuZm9yRWFjaChmdW5jdGlvbiAoc2luZikge1xuICAgICAgICAgIHZhciB0ZW5jID0gcGFyc2VTaW5mKHNpbmYpO1xuICAgICAgICAgIGlmICh0ZW5jKSB7XG4gICAgICAgICAgICBwcmVkaWNhdGUodGVuYywgaXNBdWRpbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2luZihzaW5mKSB7XG4gICAgdmFyIHNjaG0gPSBmaW5kQm94KHNpbmYsIFsnc2NobSddKVswXTtcbiAgICBpZiAoc2NobSkge1xuICAgICAgdmFyIHNjaGVtZSA9IGJpbjJzdHIoc2NobS5zdWJhcnJheSg0LCA4KSk7XG4gICAgICBpZiAoc2NoZW1lID09PSAnY2JjcycgfHwgc2NoZW1lID09PSAnY2VuYycpIHtcbiAgICAgICAgdmFyIHRlbmMgPSBmaW5kQm94KHNpbmYsIFsnc2NoaScsICd0ZW5jJ10pWzBdO1xuICAgICAgICBpZiAodGVuYykge1xuICAgICAgICAgIHJldHVybiB0ZW5jO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBGb3IgUmVmZXJlbmNlOlxuICAgIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tGcmFnbWVudEhlYWRlckJveFxuICAgICAgICAgICAgIGV4dGVuZHMgRnVsbEJveCjigJh0Zmhk4oCZLCAwLCB0Zl9mbGFncyl7XG4gICAgICAgdW5zaWduZWQgaW50KDMyKSAgdHJhY2tfSUQ7XG4gICAgICAgLy8gYWxsIHRoZSBmb2xsb3dpbmcgYXJlIG9wdGlvbmFsIGZpZWxkc1xuICAgICAgIHVuc2lnbmVkIGludCg2NCkgIGJhc2VfZGF0YV9vZmZzZXQ7XG4gICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4O1xuICAgICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uO1xuICAgICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX3NpemU7XG4gICAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICB9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFNhbXBsZURhdGEoZGF0YSwgaW5pdERhdGEsIGxvZ2dlcikge1xuICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICB2YXIgdHJhZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZicsICd0cmFmJ10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFmID0gdHJhZnNbaV07XG4gICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSB0ZmhkICYgdHJ1biBwZXIgdHJhZlxuICAgICAgLy8gVGhpcyBpcyB0cnVlIGZvciBDTUFGIHN0eWxlIGNvbnRlbnQsIGFuZCB3ZSBzaG91bGQgcGVyaGFwcyBjaGVjayB0aGUgZnR5cFxuICAgICAgLy8gYW5kIG9ubHkgbG9vayBmb3IgYSBzaW5nbGUgdHJ1biB0aGVuLCBidXQgZm9yIElTT0JNRkYgd2Ugc2hvdWxkIGNoZWNrXG4gICAgICAvLyBmb3IgbXVsdGlwbGUgdHJhY2sgcnVucy5cbiAgICAgIHZhciB0ZmhkID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSlbMF07XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIHZhciBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICB2YXIgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJhY2tzW2lkXSB8fCAodHJhY2tzW2lkXSA9IHtcbiAgICAgICAgc3RhcnQ6IE5hTixcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIHNhbXBsZUNvdW50OiAwLFxuICAgICAgICB0aW1lc2NhbGU6IHRyYWNrLnRpbWVzY2FsZSxcbiAgICAgICAgdHlwZTogdHJhY2sudHlwZVxuICAgICAgfSk7XG4gICAgICB2YXIgdHJhY2tUaW1lcyA9IHRyYWNrc1tpZF07XG4gICAgICAvLyBnZXQgc3RhcnQgRFRTXG4gICAgICB2YXIgdGZkdCA9IGZpbmRCb3godHJhZiwgWyd0ZmR0J10pWzBdO1xuICAgICAgaWYgKHRmZHQpIHtcbiAgICAgICAgdmFyIHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgICB2YXIgYmFzZVRpbWUgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgIC8vIElmIHZhbHVlIGlzIHRvbyBsYXJnZSwgYXNzdW1lIHNpZ25lZCA2NC1iaXQuIE5lZ2F0aXZlIHRyYWNrIGZyYWdtZW50IGRlY29kZSB0aW1lcyBhcmUgaW52YWxpZCwgYnV0IHRoZXkgZXhpc3QgaW4gdGhlIHdpbGQuXG4gICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBsYXJnZSB2YWx1ZXMgZnJvbSBiZWluZyB1c2VkIGZvciBpbml0UFRTLCB3aGljaCBjYW4gY2F1c2UgcGxheWxpc3Qgc3luYyBpc3N1ZXMuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzUzMDNcbiAgICAgICAgICBpZiAoYmFzZVRpbWUgPT09IFVJTlQzMl9NQVgkMSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJbbXA0LWRlbXV4ZXJdOiBJZ25vcmluZyBhc3N1bWVkIGludmFsaWQgc2lnbmVkIDY0LWJpdCB0cmFjayBmcmFnbWVudCBkZWNvZGUgdGltZVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVRpbWUgKj0gVUlOVDMyX01BWCQxICsgMTtcbiAgICAgICAgICAgIGJhc2VUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihiYXNlVGltZSkgJiYgKCFpc0Zpbml0ZU51bWJlcih0cmFja1RpbWVzLnN0YXJ0KSB8fCBiYXNlVGltZSA8IHRyYWNrVGltZXMuc3RhcnQpKSB7XG4gICAgICAgICAgdHJhY2tUaW1lcy5zdGFydCA9IGJhc2VUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdHJhY2tEZWZhdWx0ID0gdHJhY2suZGVmYXVsdDtcbiAgICAgIHZhciB0ZmhkRmxhZ3MgPSByZWFkVWludDMyKHRmaGQsIDApIHwgKHRyYWNrRGVmYXVsdCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tEZWZhdWx0LmZsYWdzKTtcbiAgICAgIHZhciBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSAodHJhY2tEZWZhdWx0ID09IG51bGwgPyB2b2lkIDAgOiB0cmFja0RlZmF1bHQuZHVyYXRpb24pIHx8IDA7XG4gICAgICBpZiAodGZoZEZsYWdzICYgMHgwMDAwMDgpIHtcbiAgICAgICAgLy8gMHgwMDAwMDggaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gZmllbGRcbiAgICAgICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDAyKSB7XG4gICAgICAgICAgLy8gMHgwMDAwMDIgaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4IGZpZWxkLCB3aGljaCBwcmVjZWRlcyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgICAgICAgIC8vIElmIHByZXNlbnQsIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBleGlzdHMgYXQgYnl0ZSBvZmZzZXQgMTJcbiAgICAgICAgICBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDEyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBkdXJhdGlvbiBpcyBhdCBieXRlIG9mZnNldCA4XG4gICAgICAgICAgZGVmYXVsdFNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCA4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRydW5zID0gZmluZEJveCh0cmFmLCBbJ3RydW4nXSk7XG4gICAgICB2YXIgc2FtcGxlRFRTID0gdHJhY2tUaW1lcy5zdGFydCB8fCAwO1xuICAgICAgdmFyIHJhd0R1cmF0aW9uID0gMDtcbiAgICAgIHZhciBzYW1wbGVEdXJhdGlvbiA9IGRlZmF1bHRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdHJ1bnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHRydW4gPSB0cnVuc1tqXTtcbiAgICAgICAgdmFyIHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuLCA0KTtcbiAgICAgICAgdmFyIHNhbXBsZUluZGV4ID0gdHJhY2tUaW1lcy5zYW1wbGVDb3VudDtcbiAgICAgICAgdHJhY2tUaW1lcy5zYW1wbGVDb3VudCArPSBzYW1wbGVDb3VudDtcbiAgICAgICAgLy8gR2V0IGR1cmF0aW9uIGZyb20gc2FtcGxlc1xuICAgICAgICB2YXIgZGF0YU9mZnNldFByZXNlbnQgPSB0cnVuWzNdICYgMHgwMTtcbiAgICAgICAgdmFyIGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ID0gdHJ1blszXSAmIDB4MDQ7XG4gICAgICAgIHZhciBzYW1wbGVEdXJhdGlvblByZXNlbnQgPSB0cnVuWzJdICYgMHgwMTtcbiAgICAgICAgdmFyIHNhbXBsZVNpemVQcmVzZW50ID0gdHJ1blsyXSAmIDB4MDI7XG4gICAgICAgIHZhciBzYW1wbGVGbGFnc1ByZXNlbnQgPSB0cnVuWzJdICYgMHgwNDtcbiAgICAgICAgdmFyIHNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldFByZXNlbnQgPSB0cnVuWzJdICYgMHgwODtcbiAgICAgICAgdmFyIG9mZnNldCA9IDg7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBzYW1wbGVDb3VudDtcbiAgICAgICAgaWYgKGRhdGFPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ICYmIHNhbXBsZUNvdW50KSB7XG4gICAgICAgICAgdmFyIGlzTm9uU3luY1NhbXBsZSA9IHRydW5bb2Zmc2V0ICsgMV0gJiAweDAxO1xuICAgICAgICAgIGlmICghaXNOb25TeW5jU2FtcGxlICYmIHRyYWNrVGltZXMua2V5RnJhbWVJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFja1RpbWVzLmtleUZyYW1lSW5kZXggPSBzYW1wbGVJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgaWYgKHNhbXBsZUR1cmF0aW9uUHJlc2VudCkge1xuICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBkZWZhdWx0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2FtcGxlRFRTICs9IHNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIHJhd0R1cmF0aW9uICs9IHNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyZW1haW5pbmctLSkge1xuICAgICAgICAgIGlmIChzYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0cnVuLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICB2YXIgX2lzTm9uU3luY1NhbXBsZSA9IHRydW5bb2Zmc2V0ICsgMV0gJiAweDAxO1xuICAgICAgICAgICAgaWYgKCFfaXNOb25TeW5jU2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmICh0cmFja1RpbWVzLmtleUZyYW1lSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRyYWNrVGltZXMua2V5RnJhbWVJbmRleCA9IHRyYWNrVGltZXMuc2FtcGxlQ291bnQgLSAocmVtYWluaW5nICsgMSk7XG4gICAgICAgICAgICAgICAgdHJhY2tUaW1lcy5rZXlGcmFtZVN0YXJ0ID0gc2FtcGxlRFRTO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzYW1wbGVEVFMgKz0gc2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgcmF3RHVyYXRpb24gKz0gc2FtcGxlRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYXdEdXJhdGlvbiAmJiBkZWZhdWx0U2FtcGxlRHVyYXRpb24pIHtcbiAgICAgICAgICByYXdEdXJhdGlvbiArPSBkZWZhdWx0U2FtcGxlRHVyYXRpb24gKiBzYW1wbGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhY2tUaW1lcy5kdXJhdGlvbiArPSByYXdEdXJhdGlvbjtcbiAgICB9XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0cmFja3MpLnNvbWUoZnVuY3Rpb24gKHRyYWNrSWQpIHtcbiAgICAgIHJldHVybiB0cmFja3NbdHJhY2tJZF0uZHVyYXRpb247XG4gICAgfSkpIHtcbiAgICAgIC8vIElmIGR1cmF0aW9uIHNhbXBsZXMgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIHRyYWYgdXNlIHNpZHggc3Vic2VnbWVudF9kdXJhdGlvblxuICAgICAgdmFyIHNpZHhNaW5TdGFydCA9IEluZmluaXR5O1xuICAgICAgdmFyIHNpZHhNYXhFbmQgPSAwO1xuICAgICAgdmFyIHNpZHhzID0gZmluZEJveChkYXRhLCBbJ3NpZHgnXSk7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBzaWR4cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBzaWR4ID0gcGFyc2VTZWdtZW50SW5kZXgoc2lkeHNbX2kyXSk7XG4gICAgICAgIGlmIChzaWR4ICE9IG51bGwgJiYgc2lkeC5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgc2lkeE1pblN0YXJ0ID0gTWF0aC5taW4oc2lkeE1pblN0YXJ0LCBzaWR4LmVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSAvIHNpZHgudGltZXNjYWxlKTtcbiAgICAgICAgICB2YXIgc3ViU2VnbWVudER1cmF0aW9uID0gc2lkeC5yZWZlcmVuY2VzLnJlZHVjZShmdW5jdGlvbiAoZHVyLCByZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBkdXIgKyByZWYuaW5mby5kdXJhdGlvbiB8fCAwO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIHNpZHhNYXhFbmQgPSBNYXRoLm1heChzaWR4TWF4RW5kLCBzdWJTZWdtZW50RHVyYXRpb24gKyBzaWR4LmVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSAvIHNpZHgudGltZXNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNpZHhNYXhFbmQgJiYgaXNGaW5pdGVOdW1iZXIoc2lkeE1heEVuZCkpIHtcbiAgICAgICAgT2JqZWN0LmtleXModHJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja0lkKSB7XG4gICAgICAgICAgaWYgKCF0cmFja3NbdHJhY2tJZF0uZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRyYWNrc1t0cmFja0lkXS5kdXJhdGlvbiA9IHNpZHhNYXhFbmQgKiB0cmFja3NbdHJhY2tJZF0udGltZXNjYWxlIC0gdHJhY2tzW3RyYWNrSWRdLnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFja3M7XG4gIH1cblxuICAvLyBUT0RPOiBDaGVjayBpZiB0aGUgbGFzdCBtb29mK21kYXQgcGFpciBpcyBwYXJ0IG9mIHRoZSB2YWxpZCByYW5nZVxuICBmdW5jdGlvbiBzZWdtZW50VmFsaWRSYW5nZShkYXRhKSB7XG4gICAgdmFyIHNlZ21lbnRlZFJhbmdlID0ge1xuICAgICAgdmFsaWQ6IG51bGwsXG4gICAgICByZW1haW5kZXI6IG51bGxcbiAgICB9O1xuICAgIHZhciBtb29mcyA9IGZpbmRCb3goZGF0YSwgWydtb29mJ10pO1xuICAgIGlmIChtb29mcy5sZW5ndGggPCAyKSB7XG4gICAgICBzZWdtZW50ZWRSYW5nZS5yZW1haW5kZXIgPSBkYXRhO1xuICAgICAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IG1vb2ZzW21vb2ZzLmxlbmd0aCAtIDFdO1xuICAgIC8vIE9mZnNldCBieSA4IGJ5dGVzOyBmaW5kQm94IG9mZnNldHMgdGhlIHN0YXJ0IGJ5IGFzIG11Y2hcbiAgICBzZWdtZW50ZWRSYW5nZS52YWxpZCA9IGRhdGEuc2xpY2UoMCwgbGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gICAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gZGF0YS5zbGljZShsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH1cbiAgZnVuY3Rpb24gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpIHtcbiAgICB2YXIgdGVtcCA9IG5ldyBVaW50OEFycmF5KGRhdGExLmxlbmd0aCArIGRhdGEyLmxlbmd0aCk7XG4gICAgdGVtcC5zZXQoZGF0YTEpO1xuICAgIHRlbXAuc2V0KGRhdGEyLCBkYXRhMS5sZW5ndGgpO1xuICAgIHJldHVybiB0ZW1wO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB0cmFjaykge1xuICAgIHZhciBzZWlTYW1wbGVzID0gW107XG4gICAgdmFyIHZpZGVvRGF0YSA9IHRyYWNrLnNhbXBsZXM7XG4gICAgdmFyIHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZTtcbiAgICB2YXIgdHJhY2tJZCA9IHRyYWNrLmlkO1xuICAgIHZhciBpc0hFVkNGbGF2b3IgPSBmYWxzZTtcbiAgICB2YXIgbW9vZnMgPSBmaW5kQm94KHZpZGVvRGF0YSwgWydtb29mJ10pO1xuICAgIG1vb2ZzLm1hcChmdW5jdGlvbiAobW9vZikge1xuICAgICAgdmFyIG1vb2ZPZmZzZXQgPSBtb29mLmJ5dGVPZmZzZXQgLSA4O1xuICAgICAgdmFyIHRyYWZzID0gZmluZEJveChtb29mLCBbJ3RyYWYnXSk7XG4gICAgICB0cmFmcy5tYXAoZnVuY3Rpb24gKHRyYWYpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgICAgdmFyIGJhc2VUaW1lID0gZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgICAgdmFyIHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgLyB0aW1lc2NhbGU7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICBpZiAoYmFzZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVPZmZzZXQgPSBiYXNlVGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uICh0ZmhkKSB7XG4gICAgICAgICAgdmFyIGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgICB2YXIgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICAgIHZhciBiYXNlRGF0YU9mZnNldFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDEpICE9PSAwO1xuICAgICAgICAgIHZhciBzYW1wbGVEZXNjcmlwdGlvbkluZGV4UHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwMikgIT09IDA7XG4gICAgICAgICAgdmFyIGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDgpICE9PSAwO1xuICAgICAgICAgIHZhciBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICAgIHZhciBkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMTApICE9PSAwO1xuICAgICAgICAgIHZhciBkZWZhdWx0U2FtcGxlU2l6ZSA9IDA7XG4gICAgICAgICAgdmFyIGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMjApICE9PSAwO1xuICAgICAgICAgIHZhciB0ZmhkT2Zmc2V0ID0gODtcbiAgICAgICAgICBpZiAoaWQgPT09IHRyYWNrSWQpIHtcbiAgICAgICAgICAgIGlmIChiYXNlRGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgdGZoZE9mZnNldCArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50KSB7XG4gICAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdFNhbXBsZVNpemUgPSByZWFkVWludDMyKHRmaGQsIHRmaGRPZmZzZXQpO1xuICAgICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICBpc0hFVkNGbGF2b3IgPSBpc0hFVkModHJhY2suY29kZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluZEJveCh0cmFmLCBbJ3RydW4nXSkubWFwKGZ1bmN0aW9uICh0cnVuKSB7XG4gICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gdHJ1blswXTtcbiAgICAgICAgICAgICAgdmFyIGZsYWdzID0gcmVhZFVpbnQzMih0cnVuLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICAgICAgICB2YXIgZGF0YU9mZnNldFByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDAwMSkgIT09IDA7XG4gICAgICAgICAgICAgIHZhciBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAwMDQpICE9PSAwO1xuICAgICAgICAgICAgICB2YXIgc2FtcGxlRHVyYXRpb25QcmVzZW50ID0gKGZsYWdzICYgMHgwMDAxMDApICE9PSAwO1xuICAgICAgICAgICAgICB2YXIgc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgICB2YXIgc2FtcGxlU2l6ZVByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDIwMCkgIT09IDA7XG4gICAgICAgICAgICAgIHZhciBzYW1wbGVTaXplID0gMDtcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwNDAwKSAhPT0gMDtcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZUNvbXBvc2l0aW9uT2Zmc2V0c1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDgwMCkgIT09IDA7XG4gICAgICAgICAgICAgIHZhciBjb21wb3NpdGlvbk9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG4gICAgICAgICAgICAgIHZhciB0cnVuT2Zmc2V0ID0gODsgLy8gcGFzdCB2ZXJzaW9uLCBmbGFncywgYW5kIHNhbXBsZSBjb3VudFxuXG4gICAgICAgICAgICAgIGlmIChkYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHNhbXBsZU9mZnNldCA9IGRhdGFPZmZzZXQgKyBtb29mT2Zmc2V0O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpeCA9IDA7IGl4IDwgc2FtcGxlQ291bnQ7IGl4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gZGVmYXVsdFNhbXBsZVNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZUNvbXBvc2l0aW9uT2Zmc2V0c1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFNpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrLnR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbHVUb3RhbFNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKG5hbHVUb3RhbFNpemUgPCBzYW1wbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYWx1U2l6ZSA9IHJlYWRVaW50MzIodmlkZW9EYXRhLCBzYW1wbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU0VJTWVzc2FnZShpc0hFVkNGbGF2b3IsIHZpZGVvRGF0YVtzYW1wbGVPZmZzZXRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdmlkZW9EYXRhLnN1YmFycmF5KHNhbXBsZU9mZnNldCwgc2FtcGxlT2Zmc2V0ICsgbmFsdVNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KGRhdGEsIGlzSEVWQ0ZsYXZvciA/IDIgOiAxLCB0aW1lT2Zmc2V0ICsgY29tcG9zaXRpb25PZmZzZXQgLyB0aW1lc2NhbGUsIHNlaVNhbXBsZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSBuYWx1U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbmFsdVRvdGFsU2l6ZSArPSBuYWx1U2l6ZSArIDQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVPZmZzZXQgKz0gc2FtcGxlRHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VpU2FtcGxlcztcbiAgfVxuICBmdW5jdGlvbiBpc0hFVkMoY29kZWMpIHtcbiAgICBpZiAoIWNvZGVjKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBiYXNlQ29kZWMgPSBjb2RlYy5zdWJzdHJpbmcoMCwgNCk7XG4gICAgcmV0dXJuIGJhc2VDb2RlYyA9PT0gJ2h2YzEnIHx8IGJhc2VDb2RlYyA9PT0gJ2hldjEnIHx8XG4gICAgLy8gRG9sYnkgVmlzaW9uXG4gICAgYmFzZUNvZGVjID09PSAnZHZoMScgfHwgYmFzZUNvZGVjID09PSAnZHZoZSc7XG4gIH1cbiAgZnVuY3Rpb24gaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgbmFsdUhlYWRlcikge1xuICAgIGlmIChpc0hFVkNGbGF2b3IpIHtcbiAgICAgIHZhciBuYWx1VHlwZSA9IG5hbHVIZWFkZXIgPj4gMSAmIDB4M2Y7XG4gICAgICByZXR1cm4gbmFsdVR5cGUgPT09IDM5IHx8IG5hbHVUeXBlID09PSA0MDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9uYWx1VHlwZSA9IG5hbHVIZWFkZXIgJiAweDFmO1xuICAgICAgcmV0dXJuIF9uYWx1VHlwZSA9PT0gNjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHUodW5lc2NhcGVkRGF0YSwgaGVhZGVyU2l6ZSwgcHRzLCBzYW1wbGVzKSB7XG4gICAgdmFyIGRhdGEgPSBkaXNjYXJkRVBCKHVuZXNjYXBlZERhdGEpO1xuICAgIHZhciBzZWlQdHIgPSAwO1xuICAgIC8vIHNraXAgbmFsIGhlYWRlclxuICAgIHNlaVB0ciArPSBoZWFkZXJTaXplO1xuICAgIHZhciBwYXlsb2FkVHlwZSA9IDA7XG4gICAgdmFyIHBheWxvYWRTaXplID0gMDtcbiAgICB2YXIgYiA9IDA7XG4gICAgd2hpbGUgKHNlaVB0ciA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICBwYXlsb2FkVHlwZSA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICB9IHdoaWxlIChiID09PSAweGZmKTtcblxuICAgICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgICAgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7XG4gICAgICB2YXIgbGVmdE92ZXIgPSBkYXRhLmxlbmd0aCAtIHNlaVB0cjtcbiAgICAgIC8vIENyZWF0ZSBhIHZhcmlhYmxlIHRvIHByb2Nlc3MgdGhlIHBheWxvYWRcbiAgICAgIHZhciBwYXlQdHIgPSBzZWlQdHI7XG5cbiAgICAgIC8vIEluY3JlbWVudCB0aGUgc2VpUHRyIHRvIHRoZSBlbmQgb2YgdGhlIHBheWxvYWRcbiAgICAgIGlmIChwYXlsb2FkU2l6ZSA8IGxlZnRPdmVyKSB7XG4gICAgICAgIHNlaVB0ciArPSBwYXlsb2FkU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPiBsZWZ0T3Zlcikge1xuICAgICAgICAvLyBTb21lIHR5cGUgb2YgY29ycnVwdGlvbiBoYXMgaGFwcGVuZWQ/XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIk1hbGZvcm1lZCBTRUkgcGF5bG9hZC4gXCIgKyBwYXlsb2FkU2l6ZSArIFwiIGlzIHRvbyBzbWFsbCwgb25seSBcIiArIGxlZnRPdmVyICsgXCIgYnl0ZXMgbGVmdCB0byBwYXJzZS5cIik7XG4gICAgICAgIC8vIFdlIG1pZ2h0IGJlIGFibGUgdG8gcGFyc2Ugc29tZSBkYXRhLCBidXQgbGV0J3MgYmUgc2FmZSBhbmQgaWdub3JlIGl0LlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCkge1xuICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBkYXRhW3BheVB0cisrXTtcbiAgICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZXJDb2RlID0gcmVhZFVpbnQxNihkYXRhLCBwYXlQdHIpO1xuICAgICAgICAgIHBheVB0ciArPSAyO1xuICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgICB2YXIgdXNlclN0cnVjdHVyZSA9IHJlYWRVaW50MzIoZGF0YSwgcGF5UHRyKTtcbiAgICAgICAgICAgIHBheVB0ciArPSA0O1xuICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgICAgdmFyIHVzZXJEYXRhVHlwZSA9IGRhdGFbcGF5UHRyKytdO1xuXG4gICAgICAgICAgICAgIC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcbiAgICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSBkYXRhW3BheVB0cisrXTtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxDQ3MgPSAweDFmICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICAgIHZhciBlbmFibGVkID0gMHg0MCAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxCeXRlcyA9IGVuYWJsZWQgPyAyICsgdG90YWxDQ3MgKiAzIDogMDtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVswXSA9IGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdG90YWxCeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpXSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogdXNlckRhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZFR5cGU6IHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgICAgICAgICBieXRlczogYnl0ZUFycmF5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFR5cGUgPT09IDUpIHtcbiAgICAgICAgaWYgKHBheWxvYWRTaXplID4gMTYpIHtcbiAgICAgICAgICB2YXIgdXVpZFN0ckFycmF5ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgMTY7IF9pMysrKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBkYXRhW3BheVB0cisrXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaChfYi5sZW5ndGggPT0gMSA/ICcwJyArIF9iIDogX2IpO1xuICAgICAgICAgICAgaWYgKF9pMyA9PT0gMyB8fCBfaTMgPT09IDUgfHwgX2kzID09PSA3IHx8IF9pMyA9PT0gOSkge1xuICAgICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaCgnLScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gcGF5bG9hZFNpemUgLSAxNjtcbiAgICAgICAgICB2YXIgdXNlckRhdGFCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgdXNlckRhdGFCeXRlc1tfaTRdID0gZGF0YVtwYXlQdHIrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICBwYXlsb2FkVHlwZTogcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICAgIHV1aWQ6IHV1aWRTdHJBcnJheS5qb2luKCcnKSxcbiAgICAgICAgICAgIHVzZXJEYXRhOiB1dGY4QXJyYXlUb1N0cih1c2VyRGF0YUJ5dGVzKSxcbiAgICAgICAgICAgIHVzZXJEYXRhQnl0ZXM6IHVzZXJEYXRhQnl0ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAgICovXG4gIGZ1bmN0aW9uIGRpc2NhcmRFUEIoZGF0YSkge1xuICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgdmFyIEVQQlBvc2l0aW9ucyA9IFtdO1xuICAgIHZhciBpID0gMTtcblxuICAgIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICAgIGlmIChkYXRhW2ldID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgLy8gYXJyYXlcbiAgICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgICB2YXIgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG4gICAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUVtc2coZGF0YSkge1xuICAgIHZhciB2ZXJzaW9uID0gZGF0YVswXTtcbiAgICB2YXIgc2NoZW1lSWRVcmkgPSAnJztcbiAgICB2YXIgdmFsdWUgPSAnJztcbiAgICB2YXIgdGltZVNjYWxlID0gMDtcbiAgICB2YXIgcHJlc2VudGF0aW9uVGltZURlbHRhID0gMDtcbiAgICB2YXIgcHJlc2VudGF0aW9uVGltZSA9IDA7XG4gICAgdmFyIGV2ZW50RHVyYXRpb24gPSAwO1xuICAgIHZhciBpZCA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgMTIpO1xuICAgICAgcHJlc2VudGF0aW9uVGltZURlbHRhID0gcmVhZFVpbnQzMihkYXRhLCAxNik7XG4gICAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCAyMCk7XG4gICAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgMjQpO1xuICAgICAgb2Zmc2V0ID0gMjg7XG4gICAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgdmFyIGxlZnRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB2YXIgcmlnaHRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBwcmVzZW50YXRpb25UaW1lID0gTWF0aC5wb3coMiwgMzIpICogbGVmdFByZXNlbnRhdGlvblRpbWUgKyByaWdodFByZXNlbnRhdGlvblRpbWU7XG4gICAgICBpZiAoIWlzU2FmZUludGVnZXIocHJlc2VudGF0aW9uVGltZSkpIHtcbiAgICAgICAgcHJlc2VudGF0aW9uVGltZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBsb2dnZXIud2FybignUHJlc2VudGF0aW9uIHRpbWUgZXhjZWVkcyBzYWZlIGludGVnZXIgbGltaXQgYW5kIHdyYXBwZWQgdG8gbWF4IHNhZmUgaW50ZWdlciBpbiBwYXJzaW5nIGVtc2cgYm94Jyk7XG4gICAgICB9XG4gICAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICB2YXIgcGF5bG9hZCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWVJZFVyaTogc2NoZW1lSWRVcmksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB0aW1lU2NhbGU6IHRpbWVTY2FsZSxcbiAgICAgIHByZXNlbnRhdGlvblRpbWU6IHByZXNlbnRhdGlvblRpbWUsXG4gICAgICBwcmVzZW50YXRpb25UaW1lRGVsdGE6IHByZXNlbnRhdGlvblRpbWVEZWx0YSxcbiAgICAgIGV2ZW50RHVyYXRpb246IGV2ZW50RHVyYXRpb24sXG4gICAgICBpZDogaWQsXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtcDRCb3godHlwZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXlsb2FkID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBheWxvYWRbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICB2YXIgbGVuID0gcGF5bG9hZC5sZW5ndGg7XG4gICAgdmFyIHNpemUgPSA4O1xuICAgIHZhciBpID0gbGVuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBtcDRwc3NoKHN5c3RlbUlkLCBrZXlpZHMsIGRhdGEpIHtcbiAgICBpZiAoc3lzdGVtSWQuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN5c3RlbSBpZCcpO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvbjtcbiAgICB2YXIga2lkcztcbiAgICB7XG4gICAgICB2ZXJzaW9uID0gMDtcbiAgICAgIGtpZHMgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB2YXIga2lkQ291bnQ7XG4gICAgaWYgKHZlcnNpb24gPiAwKSB7XG4gICAgICBraWRDb3VudCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgaWYgKGtleWlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5ldyBEYXRhVmlldyhraWRDb3VudC5idWZmZXIpLnNldFVpbnQzMigwLCBrZXlpZHMubGVuZ3RoLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtpZENvdW50ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgdmFyIGRhdGFTaXplID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgIG5ldyBEYXRhVmlldyhkYXRhU2l6ZS5idWZmZXIpLnNldFVpbnQzMigwLCBkYXRhLmJ5dGVMZW5ndGgsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1wNEJveChbMTEyLCAxMTUsIDExNSwgMTA0XSwgbmV3IFVpbnQ4QXJyYXkoW3ZlcnNpb24sIDB4MDAsIDB4MDAsIDB4MDAgLy8gRmxhZ3NcbiAgICBdKSwgc3lzdGVtSWQsXG4gICAgLy8gMTYgYnl0ZXNcbiAgICBraWRDb3VudCwga2lkcywgZGF0YVNpemUsIGRhdGEpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTXVsdGlQc3NoKGluaXREYXRhKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAoaW5pdERhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGluaXREYXRhLmJ5dGVMZW5ndGg7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHdoaWxlIChvZmZzZXQgKyAzMiA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgdmFyIHBzc2ggPSBwYXJzZVBzc2godmlldyk7XG4gICAgICAgIHJlc3VsdHMucHVzaChwc3NoKTtcbiAgICAgICAgb2Zmc2V0ICs9IHBzc2guc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VQc3NoKHZpZXcpIHtcbiAgICB2YXIgc2l6ZSA9IHZpZXcuZ2V0VWludDMyKDApO1xuICAgIHZhciBvZmZzZXQgPSB2aWV3LmJ5dGVPZmZzZXQ7XG4gICAgdmFyIGxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHNpemU6IGxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB2aWV3LmdldFVpbnQzMig0KTtcbiAgICBpZiAodHlwZSAhPT0gMHg3MDczNzM2OCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHNpemU6IHNpemVcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uID0gdmlldy5nZXRVaW50MzIoOCkgPj4+IDI0O1xuICAgIGlmICh2ZXJzaW9uICE9PSAwICYmIHZlcnNpb24gIT09IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBzaXplOiBzaXplXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgYnVmZmVyID0gdmlldy5idWZmZXI7XG4gICAgdmFyIHN5c3RlbUlkID0gYXJyYXlUb0hleChuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCArIDEyLCAxNikpO1xuICAgIHZhciBraWRzID0gbnVsbDtcbiAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgdmFyIGRhdGFTaXplT2Zmc2V0ID0gMDtcbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgZGF0YVNpemVPZmZzZXQgPSAyODtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtpZENvdW50cyA9IHZpZXcuZ2V0VWludDMyKDI4KTtcbiAgICAgIGlmICgha2lkQ291bnRzIHx8IGxlbmd0aCA8IDMyICsga2lkQ291bnRzICogMTYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBraWRzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtpZENvdW50czsgaSsrKSB7XG4gICAgICAgIGtpZHMucHVzaChuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCArIDMyICsgaSAqIDE2LCAxNikpO1xuICAgICAgfVxuICAgICAgZGF0YVNpemVPZmZzZXQgPSAzMiArIGtpZENvdW50cyAqIDE2O1xuICAgIH1cbiAgICBpZiAoIWRhdGFTaXplT2Zmc2V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGRhdGFTaXplT3JLaWRDb3VudCA9IHZpZXcuZ2V0VWludDMyKGRhdGFTaXplT2Zmc2V0KTtcbiAgICBpZiAoc2l6ZSAtIDMyIDwgZGF0YVNpemVPcktpZENvdW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgfTtcbiAgICB9XG4gICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0ICsgZGF0YVNpemVPZmZzZXQgKyA0LCBkYXRhU2l6ZU9yS2lkQ291bnQpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgc3lzdGVtSWQ6IHN5c3RlbUlkLFxuICAgICAga2lkczoga2lkcyxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIHNpemU6IHNpemVcbiAgICB9O1xuICB9XG5cbiAgdmFyIHVzZXJBZ2VudEhldmNTdXBwb3J0SXNJbmFjY3VyYXRlID0gZnVuY3Rpb24gdXNlckFnZW50SGV2Y1N1cHBvcnRJc0luYWNjdXJhdGUoKSB7XG4gICAgcmV0dXJuIC9cXChXaW5kb3dzLitGaXJlZm94XFwvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfTtcblxuICAvLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbiAgLy8gdmFsdWVzIGluZGljYXRlIGNvZGVjIHNlbGVjdGlvbiBwcmVmZXJlbmNlIChsb3dlciBpcyBoaWdoZXIgcHJpb3JpdHkpXG4gIHZhciBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICAgIGF1ZGlvOiB7XG4gICAgICBhM2RzOiAxLFxuICAgICAgJ2FjLTMnOiAwLjk1LFxuICAgICAgJ2FjLTQnOiAxLFxuICAgICAgYWxhYzogMC45LFxuICAgICAgYWxhdzogMSxcbiAgICAgIGRyYTE6IDEsXG4gICAgICAnZHRzKyc6IDEsXG4gICAgICAnZHRzLSc6IDEsXG4gICAgICBkdHNjOiAxLFxuICAgICAgZHRzZTogMSxcbiAgICAgIGR0c2g6IDEsXG4gICAgICAnZWMtMyc6IDAuOSxcbiAgICAgIGVuY2E6IDEsXG4gICAgICBmTGFDOiAwLjksXG4gICAgICAvLyBNUDQtUkEgbGlzdGVkIGNvZGVjIGVudHJ5IGZvciBGTEFDXG4gICAgICBmbGFjOiAwLjksXG4gICAgICAvLyBsZWdhY3kgYnJvd3NlciBjb2RlYyBuYW1lIGZvciBGTEFDXG4gICAgICBGTEFDOiAwLjksXG4gICAgICAvLyBzb21lIG1hbmlmZXN0cyBtYXkgbGlzdCBcIkZMQUNcIiB3aXRoIEFwcGxlJ3MgdG9vbHNcbiAgICAgIGc3MTk6IDEsXG4gICAgICBnNzI2OiAxLFxuICAgICAgbTRhZTogMSxcbiAgICAgIG1oYTE6IDEsXG4gICAgICBtaGEyOiAxLFxuICAgICAgbWhtMTogMSxcbiAgICAgIG1obTI6IDEsXG4gICAgICBtbHBhOiAxLFxuICAgICAgbXA0YTogMSxcbiAgICAgICdyYXcgJzogMSxcbiAgICAgIE9wdXM6IDEsXG4gICAgICBvcHVzOiAxLFxuICAgICAgLy8gYnJvd3NlcnMgZXhwZWN0IHRoaXMgdG8gYmUgbG93ZXJjYXNlIGRlc3BpdGUgTVA0UkEgc2F5cyAnT3B1cydcbiAgICAgIHNhbXI6IDEsXG4gICAgICBzYXdiOiAxLFxuICAgICAgc2F3cDogMSxcbiAgICAgIHNldmM6IDEsXG4gICAgICBzcWNwOiAxLFxuICAgICAgc3NtdjogMSxcbiAgICAgIHR3b3M6IDEsXG4gICAgICB1bGF3OiAxXG4gICAgfSxcbiAgICB2aWRlbzoge1xuICAgICAgYXZjMTogMSxcbiAgICAgIGF2YzI6IDEsXG4gICAgICBhdmMzOiAxLFxuICAgICAgYXZjNDogMSxcbiAgICAgIGF2Y3A6IDEsXG4gICAgICBhdjAxOiAwLjgsXG4gICAgICBkYXYxOiAwLjgsXG4gICAgICBkcmFjOiAxLFxuICAgICAgZHZhMTogMSxcbiAgICAgIGR2YXY6IDEsXG4gICAgICBkdmgxOiAwLjcsXG4gICAgICBkdmhlOiAwLjcsXG4gICAgICBlbmN2OiAxLFxuICAgICAgaGV2MTogMC43NSxcbiAgICAgIGh2YzE6IDAuNzUsXG4gICAgICBtanAyOiAxLFxuICAgICAgbXA0djogMSxcbiAgICAgIG12YzE6IDEsXG4gICAgICBtdmMyOiAxLFxuICAgICAgbXZjMzogMSxcbiAgICAgIG12YzQ6IDEsXG4gICAgICByZXN2OiAxLFxuICAgICAgcnY2MDogMSxcbiAgICAgIHMyNjM6IDEsXG4gICAgICBzdmMxOiAxLFxuICAgICAgc3ZjMjogMSxcbiAgICAgICd2Yy0xJzogMSxcbiAgICAgIHZwMDg6IDEsXG4gICAgICB2cDA5OiAwLjlcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHN0cHA6IDEsXG4gICAgICB3dnR0OiAxXG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkge1xuICAgIHZhciB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICAgIHJldHVybiAhIXR5cGVDb2RlcyAmJiAhIXR5cGVDb2Rlc1tjb2RlYy5zbGljZSgwLCA0KV07XG4gIH1cbiAgZnVuY3Rpb24gYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWNzLCB0eXBlLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpIHtcbiAgICBpZiAocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhY29kZWNzLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIHJldHVybiAhaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjLCB0eXBlLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgdHlwZSwgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB7XG4gICAgdmFyIF9NZWRpYVNvdXJjZSRpc1R5cGVTdTtcbiAgICBpZiAocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgcmV0dXJuIChfTWVkaWFTb3VyY2UkaXNUeXBlU3UgPSBNZWRpYVNvdXJjZSA9PSBudWxsID8gdm9pZCAwIDogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKG1pbWVUeXBlRm9yQ29kZWMoY29kZWMsIHR5cGUpKSkgIT0gbnVsbCA/IF9NZWRpYVNvdXJjZSRpc1R5cGVTdSA6IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIG1pbWVUeXBlRm9yQ29kZWMoY29kZWMsIHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSArIFwiL21wNDtjb2RlY3M9XCIgKyBjb2RlYztcbiAgfVxuICBmdW5jdGlvbiB2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlKHZpZGVvQ29kZWMpIHtcbiAgICBpZiAodmlkZW9Db2RlYykge1xuICAgICAgdmFyIGZvdXJDQyA9IHZpZGVvQ29kZWMuc3Vic3RyaW5nKDAsIDQpO1xuICAgICAgcmV0dXJuIHNhbXBsZUVudHJ5Q29kZXNJU08udmlkZW9bZm91ckNDXTtcbiAgICB9XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgZnVuY3Rpb24gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGNvZGVjU2V0KSB7XG4gICAgdmFyIGxpbWl0ZWRIZXZjU3VwcG9ydCA9IHVzZXJBZ2VudEhldmNTdXBwb3J0SXNJbmFjY3VyYXRlKCk7XG4gICAgcmV0dXJuIGNvZGVjU2V0LnNwbGl0KCcsJykucmVkdWNlKGZ1bmN0aW9uIChudW0sIGZvdXJDQykge1xuICAgICAgdmFyIGxvd2VyUHJpb3JpdHkgPSBsaW1pdGVkSGV2Y1N1cHBvcnQgJiYgaXNIRVZDKGZvdXJDQyk7XG4gICAgICB2YXIgcHJlZmVyZW5jZVZhbHVlID0gbG93ZXJQcmlvcml0eSA/IDkgOiBzYW1wbGVFbnRyeUNvZGVzSVNPLnZpZGVvW2ZvdXJDQ107XG4gICAgICBpZiAocHJlZmVyZW5jZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiAocHJlZmVyZW5jZVZhbHVlICogMiArIG51bSkgLyAobnVtID8gMyA6IDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzYW1wbGVFbnRyeUNvZGVzSVNPLmF1ZGlvW2ZvdXJDQ10gKyBudW0pIC8gKG51bSA/IDIgOiAxKTtcbiAgICB9LCAwKTtcbiAgfVxuICB2YXIgQ09ERUNfQ09NUEFUSUJMRV9OQU1FUyA9IHt9O1xuICBmdW5jdGlvbiBnZXRDb2RlY0NvbXBhdGlibGVOYW1lTG93ZXIobG93ZXJDYXNlQ29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkge1xuICAgIGlmIChwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENPREVDX0NPTVBBVElCTEVfTkFNRVNbbG93ZXJDYXNlQ29kZWNdKSB7XG4gICAgICByZXR1cm4gQ09ERUNfQ09NUEFUSUJMRV9OQU1FU1tsb3dlckNhc2VDb2RlY107XG4gICAgfVxuICAgIHZhciBjb2RlY3NUb0NoZWNrID0ge1xuICAgICAgLy8gSWRlYWx5IGZMYUMgYW5kIE9wdXMgd291bGQgYmUgZmlyc3QgKHNwZWMtY29tcGxpYW50KSBidXRcbiAgICAgIC8vIHNvbWUgYnJvd3NlcnMgd2lsbCByZXBvcnQgdGhhdCBmTGFDIGlzIHN1cHBvcnRlZCB0aGVuIGZhaWwuXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE0MjI3MjhcbiAgICAgIGZsYWM6IFsnZmxhYycsICdmTGFDJywgJ0ZMQUMnXSxcbiAgICAgIG9wdXM6IFsnb3B1cycsICdPcHVzJ10sXG4gICAgICAvLyBSZXBsYWNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQsXG4gICAgICAvLyBhbmQgZGVtdXhlciBjYW4gZmFsbGJhY2sgdG8gJ2F1ZGlvL21wZWcnIG9yICdhdWRpby9tcDQ7Y29kZWNzPVwibXAzXCInXG4gICAgICAnbXA0YS40MC4zNCc6IFsnbXAzJ11cbiAgICB9W2xvd2VyQ2FzZUNvZGVjXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVjc1RvQ2hlY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfZ2V0TWVkaWFTb3VyY2U7XG4gICAgICBpZiAoaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjc1RvQ2hlY2tbaV0sICdhdWRpbycsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpIHtcbiAgICAgICAgQ09ERUNfQ09NUEFUSUJMRV9OQU1FU1tsb3dlckNhc2VDb2RlY10gPSBjb2RlY3NUb0NoZWNrW2ldO1xuICAgICAgICByZXR1cm4gY29kZWNzVG9DaGVja1tpXTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZWNzVG9DaGVja1tpXSA9PT0gJ21wMycgJiYgKF9nZXRNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpICE9IG51bGwgJiYgX2dldE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXBlZycpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvd2VyQ2FzZUNvZGVjO1xuICB9XG4gIHZhciBBVURJT19DT0RFQ19SRUdFWFAgPSAvZmxhY3xvcHVzfG1wNGFcXC40MFxcLjM0L2k7XG4gIGZ1bmN0aW9uIGdldENvZGVjQ29tcGF0aWJsZU5hbWUoY29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkge1xuICAgIGlmIChwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnJlcGxhY2UoQVVESU9fQ09ERUNfUkVHRVhQLCBmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIGdldENvZGVjQ29tcGF0aWJsZU5hbWVMb3dlcihtLnRvTG93ZXJDYXNlKCksIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZVZpZGVvQ29kZWMob3JpZ2luYWxDb2RlY3MsIG5ld1ZpZGVvQ29kZWMpIHtcbiAgICB2YXIgY29kZWNzID0gW107XG4gICAgaWYgKG9yaWdpbmFsQ29kZWNzKSB7XG4gICAgICB2YXIgYWxsQ29kZWNzID0gb3JpZ2luYWxDb2RlY3Muc3BsaXQoJywnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsQ29kZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaXNDb2RlY1R5cGUoYWxsQ29kZWNzW2ldLCAndmlkZW8nKSkge1xuICAgICAgICAgIGNvZGVjcy5wdXNoKGFsbENvZGVjc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld1ZpZGVvQ29kZWMpIHtcbiAgICAgIGNvZGVjcy5wdXNoKG5ld1ZpZGVvQ29kZWMpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZWNzLmpvaW4oJywnKTtcbiAgfVxuICBmdW5jdGlvbiBwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lKHBhcnNlZENvZGVjLCBsZXZlbENvZGVjKSB7XG4gICAgLy8gUGFyc2luZyBvZiBtcDRhIGNvZGVjcyBzdHJpbmdzIGluIG1wNC10b29scyBmcm9tIG1lZGlhIGlzIGluY29tcGxldGUgYXMgb2YgZDhjNmM3YVxuICAgIC8vIHNvIHVzZSBsZXZlbCBjb2RlYyBpcyBwYXJzZWQgY29kZWMgaXMgdW5hdmFpbGFibGUgb3IgaW5jb21wbGV0ZVxuICAgIGlmIChwYXJzZWRDb2RlYyAmJiAocGFyc2VkQ29kZWMubGVuZ3RoID4gNCB8fCBbJ2FjLTMnLCAnZWMtMycsICdhbGFjJywgJ2ZMYUMnLCAnT3B1cyddLmluZGV4T2YocGFyc2VkQ29kZWMpICE9PSAtMSkpIHtcbiAgICAgIGlmIChpc0NvZGVjU3VwcG9ydGVkQXNUeXBlKHBhcnNlZENvZGVjLCAnYXVkaW8nKSB8fCBpc0NvZGVjU3VwcG9ydGVkQXNUeXBlKHBhcnNlZENvZGVjLCAndmlkZW8nKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZXZlbENvZGVjKSB7XG4gICAgICB2YXIgbGV2ZWxDb2RlY3MgPSBsZXZlbENvZGVjLnNwbGl0KCcsJyk7XG4gICAgICBpZiAobGV2ZWxDb2RlY3MubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAocGFyc2VkQ29kZWMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWxDb2RlY3MubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICBpZiAobGV2ZWxDb2RlY3NbaV0uc3Vic3RyaW5nKDAsIDQpID09PSBwYXJzZWRDb2RlYy5zdWJzdHJpbmcoMCwgNCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxldmVsQ29kZWNzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGV2ZWxDb2RlY3NbMF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZXZlbENvZGVjIHx8IHBhcnNlZENvZGVjO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ29kZWNTdXBwb3J0ZWRBc1R5cGUoY29kZWMsIHR5cGUpIHtcbiAgICByZXR1cm4gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpICYmIGlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgdHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydEFWQzFUb0FWQ09USSh2aWRlb0NvZGVjcykge1xuICAgIC8vIENvbnZlcnQgYXZjMSBjb2RlYyBzdHJpbmcgZnJvbSBSRkMtNDI4MSB0byBSRkMtNjM4MSBmb3IgTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkXG4gICAgLy8gRXhhbXBsZXM6IGF2YzEuNjYuMzAgdG8gYXZjMS40MjAwMWUgYW5kIGF2YzEuNzcuMzAsYXZjMS42Ni4zMCB0byBhdmMxLjRkMDAxZSxhdmMxLjQyMDAxZS5cbiAgICB2YXIgY29kZWNzID0gdmlkZW9Db2RlY3Muc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF2Y2RhdGEgPSBjb2RlY3NbaV0uc3BsaXQoJy4nKTtcbiAgICAgIC8vIG9ubHkgY29udmVydCBjb2RlYyBzdHJpbmdzIHN0YXJ0aW5nIHdpdGggYXZjMSAoRXhhbXBsZXM6IGF2YzEuNjQwMDFmLGR2aDEuMDUuMDcpXG4gICAgICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyICYmIGF2Y2RhdGFbMF0gPT09ICdhdmMxJykge1xuICAgICAgICBjb2RlY3NbaV0gPSBcImF2YzEuXCIgKyBwYXJzZUludChhdmNkYXRhWzFdKS50b1N0cmluZygxNikgKyAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhWzJdKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjcy5qb2luKCcsJyk7XG4gIH1cbiAgZnVuY3Rpb24gZmlsbEluTWlzc2luZ0FWMDFQYXJhbXModmlkZW9Db2RlYykge1xuICAgIC8vIFVzZWQgdG8gZmlsbCBpbiBpbmNvbXBsZXRlIEFWMSBwbGF5bGlzdCBDT0RFQ1Mgc3RyaW5ncyBmb3IgbWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvIHF1ZXJpZXNcbiAgICBpZiAodmlkZW9Db2RlYy5zdGFydHNXaXRoKCdhdjAxLicpKSB7XG4gICAgICB2YXIgYXYxcGFyYW1zID0gdmlkZW9Db2RlYy5zcGxpdCgnLicpO1xuICAgICAgdmFyIHBsYWNlaG9sZGVycyA9IFsnMCcsICcxMTEnLCAnMDEnLCAnMDEnLCAnMDEnLCAnMCddO1xuICAgICAgZm9yICh2YXIgaSA9IGF2MXBhcmFtcy5sZW5ndGg7IGkgPiA0ICYmIGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGF2MXBhcmFtc1tpXSA9IHBsYWNlaG9sZGVyc1tpIC0gNF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXYxcGFyYW1zLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZGVvQ29kZWM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TTJUU1N1cHBvcnRlZEF1ZGlvVHlwZXMocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB7XG4gICAgdmFyIE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB8fCB7XG4gICAgICBpc1R5cGVTdXBwb3J0ZWQ6IGZ1bmN0aW9uIGlzVHlwZVN1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIG1wZWc6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXBlZycpLFxuICAgICAgbXAzOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKSxcbiAgICAgIGFjMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cImFjLTNcIicpIFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q29kZWNzRm9yTWltZVR5cGUobWltZVR5cGUpIHtcbiAgICByZXR1cm4gbWltZVR5cGUucmVwbGFjZSgvXi4rY29kZWNzPVtcIiddPyhbXlwiJ10rKS4qJC8sICckMScpO1xuICB9XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB2YXIgc3VwcG9ydGVkUmVzdWx0ID0ge1xuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBwb3dlckVmZmljaWVudDogdHJ1ZSxcbiAgICBzbW9vdGg6IHRydWVcbiAgICAvLyBrZXlTeXN0ZW1BY2Nlc3M6IG51bGwsXG4gIH07XG5cbiAgLy8gQHRzLWlnbm9yZVxuICB2YXIgdW5zdXBwb3J0ZWRSZXN1bHQgPSB7XG4gICAgc3VwcG9ydGVkOiBmYWxzZSxcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIHBvd2VyRWZmaWNpZW50OiBmYWxzZVxuICAgIC8vIGtleVN5c3RlbUFjY2VzczogbnVsbCxcbiAgfTtcbiAgdmFyIFNVUFBPUlRFRF9JTkZPX0RFRkFVTFQgPSB7XG4gICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgIGNvbmZpZ3VyYXRpb25zOiBbXSxcbiAgICBkZWNvZGluZ0luZm9SZXN1bHRzOiBbc3VwcG9ydGVkUmVzdWx0XVxuICB9O1xuICBmdW5jdGlvbiBnZXRVbnN1cHBvcnRlZFJlc3VsdChlcnJvciwgY29uZmlndXJhdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VwcG9ydGVkOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYXRpb25zOiBjb25maWd1cmF0aW9ucyxcbiAgICAgIGRlY29kaW5nSW5mb1Jlc3VsdHM6IFt1bnN1cHBvcnRlZFJlc3VsdF0sXG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJlcXVpcmVzTWVkaWFDYXBhYmlsaXRpZXNEZWNvZGluZ0luZm8obGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgY3VycmVudFZpZGVvUmFuZ2UsIGN1cnJlbnRGcmFtZVJhdGUsIGN1cnJlbnRCdywgYXVkaW9QcmVmZXJlbmNlKSB7XG4gICAgLy8gT25seSB0ZXN0IHN1cHBvcnQgd2hlbiBjb25maWd1cmF0aW9uIGlzIGV4Y2VlZHMgbWluaW11bSBvcHRpb25zXG4gICAgdmFyIHZpZGVvQ29kZWNzID0gbGV2ZWwudmlkZW9Db2RlYztcbiAgICB2YXIgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0NvZGVjID8gbGV2ZWwuYXVkaW9Hcm91cHMgOiBudWxsO1xuICAgIHZhciBhdWRpb0NvZGVjUHJlZmVyZW5jZSA9IGF1ZGlvUHJlZmVyZW5jZSA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9QcmVmZXJlbmNlLmF1ZGlvQ29kZWM7XG4gICAgdmFyIGNoYW5uZWxzUHJlZmVyZW5jZSA9IGF1ZGlvUHJlZmVyZW5jZSA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9QcmVmZXJlbmNlLmNoYW5uZWxzO1xuICAgIHZhciBtYXhDaGFubmVscyA9IGNoYW5uZWxzUHJlZmVyZW5jZSA/IHBhcnNlSW50KGNoYW5uZWxzUHJlZmVyZW5jZSkgOiBhdWRpb0NvZGVjUHJlZmVyZW5jZSA/IEluZmluaXR5IDogMjtcbiAgICB2YXIgYXVkaW9DaGFubmVscyA9IG51bGw7XG4gICAgaWYgKGF1ZGlvR3JvdXBzICE9IG51bGwgJiYgYXVkaW9Hcm91cHMubGVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoYXVkaW9Hcm91cHMubGVuZ3RoID09PSAxICYmIGF1ZGlvR3JvdXBzWzBdKSB7XG4gICAgICAgICAgYXVkaW9DaGFubmVscyA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbYXVkaW9Hcm91cHNbMF1dLmNoYW5uZWxzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF1ZGlvQ2hhbm5lbHMgPSBhdWRpb0dyb3Vwcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZ3JvdXBJZCkge1xuICAgICAgICAgICAgaWYgKGdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgdmFyIGF1ZGlvVHJhY2tHcm91cCA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbZ3JvdXBJZF07XG4gICAgICAgICAgICAgIGlmICghYXVkaW9UcmFja0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXVkaW8gdHJhY2sgZ3JvdXAgXCIgKyBncm91cElkICsgXCIgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFN1bSBhbGwgY2hhbm5lbCBrZXkgdmFsdWVzXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGF1ZGlvVHJhY2tHcm91cC5jaGFubmVscykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSAoYWNjW2tleV0gfHwgMCkgKyBhdWRpb1RyYWNrR3JvdXAuY2hhbm5lbHNba2V5XTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIDI6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2aWRlb0NvZGVjcyAhPT0gdW5kZWZpbmVkICYmIChcbiAgICAvLyBGb3JjZSBtZWRpYSBjYXBhYmlsaXRpZXMgY2hlY2sgZm9yIEhFVkMgdG8gYXZvaWQgZmFpbHVyZSBvbiBXaW5kb3dzXG4gICAgdmlkZW9Db2RlY3Muc3BsaXQoJywnKS5zb21lKGZ1bmN0aW9uICh2aWRlb0NvZGVjKSB7XG4gICAgICByZXR1cm4gaXNIRVZDKHZpZGVvQ29kZWMpO1xuICAgIH0pIHx8IGxldmVsLndpZHRoID4gMTkyMCAmJiBsZXZlbC5oZWlnaHQgPiAxMDg4IHx8IGxldmVsLmhlaWdodCA+IDE5MjAgJiYgbGV2ZWwud2lkdGggPiAxMDg4IHx8IGxldmVsLmZyYW1lUmF0ZSA+IE1hdGgubWF4KGN1cnJlbnRGcmFtZVJhdGUsIDMwKSB8fCBsZXZlbC52aWRlb1JhbmdlICE9PSAnU0RSJyAmJiBsZXZlbC52aWRlb1JhbmdlICE9PSBjdXJyZW50VmlkZW9SYW5nZSB8fCBsZXZlbC5iaXRyYXRlID4gTWF0aC5tYXgoY3VycmVudEJ3LCA4ZTYpKSB8fCAhIWF1ZGlvQ2hhbm5lbHMgJiYgaXNGaW5pdGVOdW1iZXIobWF4Q2hhbm5lbHMpICYmIE9iamVjdC5rZXlzKGF1ZGlvQ2hhbm5lbHMpLnNvbWUoZnVuY3Rpb24gKGNoYW5uZWxzKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoY2hhbm5lbHMpID4gbWF4Q2hhbm5lbHM7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TWVkaWFEZWNvZGluZ0luZm9Qcm9taXNlKGxldmVsLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1lZGlhQ2FwYWJpbGl0aWVzLCBjYWNoZSkge1xuICAgIGlmIChjYWNoZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjYWNoZSA9IHt9O1xuICAgIH1cbiAgICB2YXIgdmlkZW9Db2RlY3MgPSBsZXZlbC52aWRlb0NvZGVjO1xuICAgIGlmICghdmlkZW9Db2RlY3MgJiYgIWxldmVsLmF1ZGlvQ29kZWMgfHwgIW1lZGlhQ2FwYWJpbGl0aWVzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFNVUFBPUlRFRF9JTkZPX0RFRkFVTFQpO1xuICAgIH1cbiAgICB2YXIgY29uZmlndXJhdGlvbnMgPSBbXTtcbiAgICB2YXIgdmlkZW9EZWNvZGVMaXN0ID0gbWFrZVZpZGVvQ29uZmlndXJhdGlvbnMobGV2ZWwpO1xuICAgIHZhciB2aWRlb0NvdW50ID0gdmlkZW9EZWNvZGVMaXN0Lmxlbmd0aDtcbiAgICB2YXIgYXVkaW9EZWNvZGVMaXN0ID0gbWFrZUF1ZGlvQ29uZmlndXJhdGlvbnMobGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgdmlkZW9Db3VudCA+IDApO1xuICAgIHZhciBhdWRpb0NvdW50ID0gYXVkaW9EZWNvZGVMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gdmlkZW9Db3VudCB8fCAxICogYXVkaW9Db3VudCB8fCAxOyBpLS07KSB7XG4gICAgICB2YXIgY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ21lZGlhLXNvdXJjZSdcbiAgICAgIH07XG4gICAgICBpZiAodmlkZW9Db3VudCkge1xuICAgICAgICBjb25maWd1cmF0aW9uLnZpZGVvID0gdmlkZW9EZWNvZGVMaXN0W2kgJSB2aWRlb0NvdW50XTtcbiAgICAgIH1cbiAgICAgIGlmIChhdWRpb0NvdW50KSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uYXVkaW8gPSBhdWRpb0RlY29kZUxpc3RbaSAlIGF1ZGlvQ291bnRdO1xuICAgICAgICB2YXIgYXVkaW9CaXRyYXRlID0gY29uZmlndXJhdGlvbi5hdWRpby5iaXRyYXRlO1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbi52aWRlbyAmJiBhdWRpb0JpdHJhdGUpIHtcbiAgICAgICAgICBjb25maWd1cmF0aW9uLnZpZGVvLmJpdHJhdGUgLT0gYXVkaW9CaXRyYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25maWd1cmF0aW9ucy5wdXNoKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBpZiAodmlkZW9Db2RlY3MpIHtcbiAgICAgIC8vIE92ZXJyaWRlIFdpbmRvd3MgRmlyZWZveCBIRVZDIE1lZGlhQ2FwYWJpbGl0aWVzIHJlc3VsdCAoaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzcwNDYpXG4gICAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgaWYgKHZpZGVvQ29kZWNzLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAodmlkZW9Db2RlYykge1xuICAgICAgICByZXR1cm4gaXNIRVZDKHZpZGVvQ29kZWMpO1xuICAgICAgfSkgJiYgdXNlckFnZW50SGV2Y1N1cHBvcnRJc0luYWNjdXJhdGUoKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGdldFVuc3VwcG9ydGVkUmVzdWx0KG5ldyBFcnJvcihcIk92ZXJyaWRpbmcgV2luZG93cyBGaXJlZm94IEhFVkMgTWVkaWFDYXBhYmlsaXRpZXMgcmVzdWx0IGJhc2VkIG9uIHVzZXItYWdlbnQgc3RyaW5nOiAoXCIgKyB1YSArIFwiKVwiKSwgY29uZmlndXJhdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGNvbmZpZ3VyYXRpb25zLm1hcChmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgICAgLy8gQ2FjaGUgTWVkaWFDYXBhYmlsaXRpZXMgcHJvbWlzZXNcbiAgICAgIHZhciBkZWNvZGluZ0luZm9LZXkgPSBnZXRNZWRpYURlY29kaW5nSW5mb0tleShjb25maWd1cmF0aW9uKTtcbiAgICAgIHJldHVybiBjYWNoZVtkZWNvZGluZ0luZm9LZXldIHx8IChjYWNoZVtkZWNvZGluZ0luZm9LZXldID0gbWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvKGNvbmZpZ3VyYXRpb24pKTtcbiAgICB9KSkudGhlbihmdW5jdGlvbiAoZGVjb2RpbmdJbmZvUmVzdWx0cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VwcG9ydGVkOiAhZGVjb2RpbmdJbmZvUmVzdWx0cy5zb21lKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgcmV0dXJuICFpbmZvLnN1cHBvcnRlZDtcbiAgICAgICAgfSksXG4gICAgICAgIGNvbmZpZ3VyYXRpb25zOiBjb25maWd1cmF0aW9ucyxcbiAgICAgICAgZGVjb2RpbmdJbmZvUmVzdWx0czogZGVjb2RpbmdJbmZvUmVzdWx0c1xuICAgICAgfTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25zOiBjb25maWd1cmF0aW9ucyxcbiAgICAgICAgZGVjb2RpbmdJbmZvUmVzdWx0czogW10sXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlVmlkZW9Db25maWd1cmF0aW9ucyhsZXZlbCkge1xuICAgIHZhciBfbGV2ZWwkdmlkZW9Db2RlYztcbiAgICB2YXIgdmlkZW9Db2RlY3MgPSAoX2xldmVsJHZpZGVvQ29kZWMgPSBsZXZlbC52aWRlb0NvZGVjKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJHZpZGVvQ29kZWMuc3BsaXQoJywnKTtcbiAgICB2YXIgYml0cmF0ZSA9IGdldFZhcmlhbnREZWNvZGluZ0JpdHJhdGUobGV2ZWwpO1xuICAgIHZhciB3aWR0aCA9IGxldmVsLndpZHRoIHx8IDY0MDtcbiAgICB2YXIgaGVpZ2h0ID0gbGV2ZWwuaGVpZ2h0IHx8IDQ4MDtcbiAgICAvLyBBc3N1bWUgYSBmcmFtZXJhdGUgb2YgMzBmcHMgc2luY2UgTWVkaWFDYXBhYmlsaXRpZXMgd2lsbCBub3QgYWNjZXB0IExldmVsIGRlZmF1bHQgb2YgMC5cbiAgICB2YXIgZnJhbWVyYXRlID0gbGV2ZWwuZnJhbWVSYXRlIHx8IDMwO1xuICAgIHZhciB2aWRlb1JhbmdlID0gbGV2ZWwudmlkZW9SYW5nZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB2aWRlb0NvZGVjcyA/IHZpZGVvQ29kZWNzLm1hcChmdW5jdGlvbiAodmlkZW9Db2RlYykge1xuICAgICAgdmFyIHZpZGVvQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgY29udGVudFR5cGU6IG1pbWVUeXBlRm9yQ29kZWMoZmlsbEluTWlzc2luZ0FWMDFQYXJhbXModmlkZW9Db2RlYyksICd2aWRlbycpLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBiaXRyYXRlOiBiaXRyYXRlLFxuICAgICAgICBmcmFtZXJhdGU6IGZyYW1lcmF0ZVxuICAgICAgfTtcbiAgICAgIGlmICh2aWRlb1JhbmdlICE9PSAnc2RyJykge1xuICAgICAgICB2aWRlb0NvbmZpZ3VyYXRpb24udHJhbnNmZXJGdW5jdGlvbiA9IHZpZGVvUmFuZ2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmlkZW9Db25maWd1cmF0aW9uO1xuICAgIH0pIDogW107XG4gIH1cbiAgZnVuY3Rpb24gbWFrZUF1ZGlvQ29uZmlndXJhdGlvbnMobGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgaGFzVmlkZW8pIHtcbiAgICB2YXIgX2xldmVsJGF1ZGlvQ29kZWM7XG4gICAgdmFyIGF1ZGlvQ29kZWNzID0gKF9sZXZlbCRhdWRpb0NvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbCRhdWRpb0NvZGVjLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNvbWJpbmVkQml0cmF0ZSA9IGdldFZhcmlhbnREZWNvZGluZ0JpdHJhdGUobGV2ZWwpO1xuICAgIGlmIChhdWRpb0NvZGVjcyAmJiBsZXZlbC5hdWRpb0dyb3Vwcykge1xuICAgICAgcmV0dXJuIGxldmVsLmF1ZGlvR3JvdXBzLnJlZHVjZShmdW5jdGlvbiAoY29uZmlndXJhdGlvbnMsIGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICB2YXIgX2F1ZGlvVHJhY2tzQnlHcm91cCRnO1xuICAgICAgICB2YXIgdHJhY2tzID0gYXVkaW9Hcm91cElkID8gKF9hdWRpb1RyYWNrc0J5R3JvdXAkZyA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbYXVkaW9Hcm91cElkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hdWRpb1RyYWNrc0J5R3JvdXAkZy50cmFja3MgOiBudWxsO1xuICAgICAgICBpZiAodHJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrcy5yZWR1Y2UoZnVuY3Rpb24gKGNvbmZpZ3MsIGF1ZGlvVHJhY2spIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgICAgICB2YXIgY2hhbm5lbHNOdW1iZXIgPSBwYXJzZUZsb2F0KGF1ZGlvVHJhY2suY2hhbm5lbHMgfHwgJycpO1xuICAgICAgICAgICAgICBhdWRpb0NvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uIChhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF1ZGlvQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBtaW1lVHlwZUZvckNvZGVjKGF1ZGlvQ29kZWMsICdhdWRpbycpLFxuICAgICAgICAgICAgICAgICAgYml0cmF0ZTogaGFzVmlkZW8gPyBlc3RpbWF0ZWRBdWRpb0JpdHJhdGUoYXVkaW9Db2RlYywgY29tYmluZWRCaXRyYXRlKSA6IGNvbWJpbmVkQml0cmF0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxzTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICBhdWRpb0NvbmZpZ3VyYXRpb24uY2hhbm5lbHMgPSAnJyArIGNoYW5uZWxzTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWdzLnB1c2goYXVkaW9Db25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29uZmlncztcbiAgICAgICAgICB9LCBjb25maWd1cmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgZnVuY3Rpb24gZXN0aW1hdGVkQXVkaW9CaXRyYXRlKGF1ZGlvQ29kZWMsIGxldmVsQml0cmF0ZSkge1xuICAgIGlmIChsZXZlbEJpdHJhdGUgPD0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciBhdWRpb0JpdHJhdGUgPSAxMjgwMDA7XG4gICAgaWYgKGF1ZGlvQ29kZWMgPT09ICdlYy0zJykge1xuICAgICAgYXVkaW9CaXRyYXRlID0gNzY4MDAwO1xuICAgIH0gZWxzZSBpZiAoYXVkaW9Db2RlYyA9PT0gJ2FjLTMnKSB7XG4gICAgICBhdWRpb0JpdHJhdGUgPSA2NDAwMDA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihsZXZlbEJpdHJhdGUgLyAyLCBhdWRpb0JpdHJhdGUpOyAvLyBEb24ndCBleGNlZWQgc29tZSAlIG9mIGxldmVsIGJpdHJhdGVcbiAgfVxuICBmdW5jdGlvbiBnZXRWYXJpYW50RGVjb2RpbmdCaXRyYXRlKGxldmVsKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLm1heChsZXZlbC5iaXRyYXRlICogMC45LCBsZXZlbC5hdmVyYWdlQml0cmF0ZSkgLyAxMDAwKSAqIDEwMDAgfHwgMTtcbiAgfVxuICBmdW5jdGlvbiBnZXRNZWRpYURlY29kaW5nSW5mb0tleShjb25maWcpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIGF1ZGlvID0gY29uZmlnLmF1ZGlvLFxuICAgICAgdmlkZW8gPSBjb25maWcudmlkZW87XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICB2YXIgY29kZWMgPSBnZXRDb2RlY3NGb3JNaW1lVHlwZSh2aWRlby5jb250ZW50VHlwZSk7XG4gICAgICBrZXkgKz0gY29kZWMgKyBcIl9yXCIgKyB2aWRlby5oZWlnaHQgKyBcInhcIiArIHZpZGVvLndpZHRoICsgXCJmXCIgKyBNYXRoLmNlaWwodmlkZW8uZnJhbWVyYXRlKSArICh2aWRlby50cmFuc2ZlckZ1bmN0aW9uIHx8ICdzZCcpICsgXCJfXCIgKyBNYXRoLmNlaWwodmlkZW8uYml0cmF0ZSAvIDFlNSk7XG4gICAgfVxuICAgIGlmIChhdWRpbykge1xuICAgICAgdmFyIF9jb2RlYyA9IGdldENvZGVjc0Zvck1pbWVUeXBlKGF1ZGlvLmNvbnRlbnRUeXBlKTtcbiAgICAgIGtleSArPSBcIlwiICsgKHZpZGVvID8gJ18nIDogJycpICsgX2NvZGVjICsgXCJfY1wiICsgYXVkaW8uY2hhbm5lbHM7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cblxuICB2YXIgSGRjcExldmVscyA9IFsnTk9ORScsICdUWVBFLTAnLCAnVFlQRS0xJywgbnVsbF07XG4gIGZ1bmN0aW9uIGlzSGRjcExldmVsKHZhbHVlKSB7XG4gICAgcmV0dXJuIEhkY3BMZXZlbHMuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgfVxuICB2YXIgVmlkZW9SYW5nZVZhbHVlcyA9IFsnU0RSJywgJ1BRJywgJ0hMRyddO1xuICBmdW5jdGlvbiBpc1ZpZGVvUmFuZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiBWaWRlb1JhbmdlVmFsdWVzLmluZGV4T2YodmFsdWUpID4gLTE7XG4gIH1cbiAgdmFyIEhsc1NraXAgPSB7XG4gICAgTm86IFwiXCIsXG4gICAgWWVzOiBcIllFU1wiLFxuICAgIHYyOiBcInYyXCJcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0U2tpcFZhbHVlKGRldGFpbHMpIHtcbiAgICB2YXIgY2FuU2tpcFVudGlsID0gZGV0YWlscy5jYW5Ta2lwVW50aWwsXG4gICAgICBjYW5Ta2lwRGF0ZVJhbmdlcyA9IGRldGFpbHMuY2FuU2tpcERhdGVSYW5nZXMsXG4gICAgICBhZ2UgPSBkZXRhaWxzLmFnZTtcbiAgICAvLyBBIENsaWVudCBTSE9VTEQgTk9UIHJlcXVlc3QgYSBQbGF5bGlzdCBEZWx0YSBVcGRhdGUgdW5sZXNzIGl0IGFscmVhZHlcbiAgICAvLyBoYXMgYSB2ZXJzaW9uIG9mIHRoZSBQbGF5bGlzdCB0aGF0IGlzIG5vIG9sZGVyIHRoYW4gb25lLWhhbGYgb2YgdGhlIFNraXAgQm91bmRhcnkuXG4gICAgLy8gQHNlZTogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1wYW50b3MtaGxzLXJmYzgyMTZiaXMjc2VjdGlvbi02LjMuN1xuICAgIHZhciBwbGF5bGlzdFJlY2VudEVub3VnaCA9IGFnZSA8IGNhblNraXBVbnRpbCAvIDI7XG4gICAgaWYgKGNhblNraXBVbnRpbCAmJiBwbGF5bGlzdFJlY2VudEVub3VnaCkge1xuICAgICAgaWYgKGNhblNraXBEYXRlUmFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBIbHNTa2lwLnYyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEhsc1NraXAuWWVzO1xuICAgIH1cbiAgICByZXR1cm4gSGxzU2tpcC5ObztcbiAgfVxuICB2YXIgSGxzVXJsUGFyYW1ldGVycyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGxzVXJsUGFyYW1ldGVycyhtc24sIHBhcnQsIHNraXApIHtcbiAgICAgIHRoaXMubXNuID0gdm9pZCAwO1xuICAgICAgdGhpcy5wYXJ0ID0gdm9pZCAwO1xuICAgICAgdGhpcy5za2lwID0gdm9pZCAwO1xuICAgICAgdGhpcy5tc24gPSBtc247XG4gICAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEhsc1VybFBhcmFtZXRlcnMucHJvdG90eXBlO1xuICAgIF9wcm90by5hZGREaXJlY3RpdmVzID0gZnVuY3Rpb24gYWRkRGlyZWN0aXZlcyh1cmkpIHtcbiAgICAgIHZhciB1cmwgPSBuZXcgc2VsZi5VUkwodXJpKTtcbiAgICAgIGlmICh0aGlzLm1zbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX21zbicsIHRoaXMubXNuLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3BhcnQnLCB0aGlzLnBhcnQudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3NraXAnLCB0aGlzLnNraXApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybC5ocmVmO1xuICAgIH07XG4gICAgcmV0dXJuIEhsc1VybFBhcmFtZXRlcnM7XG4gIH0oKTtcbiAgdmFyIExldmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXZlbChkYXRhKSB7XG4gICAgICB0aGlzLl9hdHRycyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYml0cmF0ZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY29kZWNTZXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gdm9pZCAwO1xuICAgICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgICAgdGhpcy5zdXBwbGVtZW50YWwgPSB2b2lkIDA7XG4gICAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZXRhaWxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgIHRoaXMubG9hZEVycm9yID0gMDtcbiAgICAgIHRoaXMubG9hZGVkID0gdm9pZCAwO1xuICAgICAgdGhpcy5yZWFsQml0cmF0ZSA9IDA7XG4gICAgICB0aGlzLnN1cHBvcnRlZFByb21pc2UgPSB2b2lkIDA7XG4gICAgICB0aGlzLnN1cHBvcnRlZFJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2F2Z0JpdHJhdGUgPSAwO1xuICAgICAgdGhpcy5fYXVkaW9Hcm91cHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9zdWJ0aXRsZUdyb3VwcyA9IHZvaWQgMDtcbiAgICAgIC8vIERlcHJlY2F0ZWQgKHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgICAgIHRoaXMuX3VybElkID0gMDtcbiAgICAgIHRoaXMudXJsID0gW2RhdGEudXJsXTtcbiAgICAgIHRoaXMuX2F0dHJzID0gW2RhdGEuYXR0cnNdO1xuICAgICAgdGhpcy5iaXRyYXRlID0gZGF0YS5iaXRyYXRlO1xuICAgICAgaWYgKGRhdGEuZGV0YWlscykge1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICB9XG4gICAgICB0aGlzLmlkID0gZGF0YS5pZCB8fCAwO1xuICAgICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGggfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgMDtcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gZGF0YS5hdHRycy5vcHRpb25hbEZsb2F0KCdGUkFNRS1SQVRFJywgMCk7XG4gICAgICB0aGlzLl9hdmdCaXRyYXRlID0gZGF0YS5hdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKTtcbiAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IGRhdGEuYXVkaW9Db2RlYztcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IGRhdGEudmlkZW9Db2RlYztcbiAgICAgIHRoaXMuY29kZWNTZXQgPSBbZGF0YS52aWRlb0NvZGVjLCBkYXRhLmF1ZGlvQ29kZWNdLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gISFjO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLnN1YnN0cmluZygwLCA0KTtcbiAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgIGlmICgnc3VwcGxlbWVudGFsJyBpbiBkYXRhKSB7XG4gICAgICAgIHZhciBfZGF0YSRzdXBwbGVtZW50YWw7XG4gICAgICAgIHRoaXMuc3VwcGxlbWVudGFsID0gZGF0YS5zdXBwbGVtZW50YWw7XG4gICAgICAgIHZhciBzdXBwbGVtZW50YWxWaWRlbyA9IChfZGF0YSRzdXBwbGVtZW50YWwgPSBkYXRhLnN1cHBsZW1lbnRhbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHN1cHBsZW1lbnRhbC52aWRlb0NvZGVjO1xuICAgICAgICBpZiAoc3VwcGxlbWVudGFsVmlkZW8gJiYgc3VwcGxlbWVudGFsVmlkZW8gIT09IGRhdGEudmlkZW9Db2RlYykge1xuICAgICAgICAgIHRoaXMuY29kZWNTZXQgKz0gXCIsXCIgKyBzdXBwbGVtZW50YWxWaWRlby5zdWJzdHJpbmcoMCwgNCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkR3JvdXBJZCgnYXVkaW8nLCBkYXRhLmF0dHJzLkFVRElPKTtcbiAgICAgIHRoaXMuYWRkR3JvdXBJZCgndGV4dCcsIGRhdGEuYXR0cnMuU1VCVElUTEVTKTtcbiAgICB9XG4gICAgdmFyIF9wcm90bzIgPSBMZXZlbC5wcm90b3R5cGU7XG4gICAgX3Byb3RvMi5oYXNBdWRpb0dyb3VwID0gZnVuY3Rpb24gaGFzQXVkaW9Hcm91cChncm91cElkKSB7XG4gICAgICByZXR1cm4gaGFzR3JvdXAodGhpcy5fYXVkaW9Hcm91cHMsIGdyb3VwSWQpO1xuICAgIH07XG4gICAgX3Byb3RvMi5oYXNTdWJ0aXRsZUdyb3VwID0gZnVuY3Rpb24gaGFzU3VidGl0bGVHcm91cChncm91cElkKSB7XG4gICAgICByZXR1cm4gaGFzR3JvdXAodGhpcy5fc3VidGl0bGVHcm91cHMsIGdyb3VwSWQpO1xuICAgIH07XG4gICAgX3Byb3RvMi5hZGRHcm91cElkID0gZnVuY3Rpb24gYWRkR3JvdXBJZCh0eXBlLCBncm91cElkKSB7XG4gICAgICBpZiAoIWdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgdmFyIGF1ZGlvR3JvdXBzID0gdGhpcy5fYXVkaW9Hcm91cHM7XG4gICAgICAgIGlmICghYXVkaW9Hcm91cHMpIHtcbiAgICAgICAgICBhdWRpb0dyb3VwcyA9IHRoaXMuX2F1ZGlvR3JvdXBzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1ZGlvR3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgPT09IC0xKSB7XG4gICAgICAgICAgYXVkaW9Hcm91cHMucHVzaChncm91cElkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgdmFyIHN1YnRpdGxlR3JvdXBzID0gdGhpcy5fc3VidGl0bGVHcm91cHM7XG4gICAgICAgIGlmICghc3VidGl0bGVHcm91cHMpIHtcbiAgICAgICAgICBzdWJ0aXRsZUdyb3VwcyA9IHRoaXMuX3N1YnRpdGxlR3JvdXBzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnRpdGxlR3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgPT09IC0xKSB7XG4gICAgICAgICAgc3VidGl0bGVHcm91cHMucHVzaChncm91cElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlcHJlY2F0ZWQgbWV0aG9kcyAocmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgIDtcbiAgICBfcHJvdG8yLmFkZEZhbGxiYWNrID0gZnVuY3Rpb24gYWRkRmFsbGJhY2soKSB7fTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKExldmVsLCBbe1xuICAgICAga2V5OiBcIm1heEJpdHJhdGVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yZWFsQml0cmF0ZSwgdGhpcy5iaXRyYXRlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXZlcmFnZUJpdHJhdGVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXZnQml0cmF0ZSB8fCB0aGlzLnJlYWxCaXRyYXRlIHx8IHRoaXMuYml0cmF0ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXR0cnNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXR0cnNbMF07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvZGVjc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJzLkNPREVDUyB8fCAnJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGF0aHdheUlkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnNbJ1BBVEhXQVktSUQnXSB8fCAnLic7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInZpZGVvUmFuZ2VcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyc1snVklERU8tUkFOR0UnXSB8fCAnU0RSJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2NvcmVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5vcHRpb25hbEZsb2F0KCdTQ09SRScsIDApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1cmlcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmxbMF0gfHwgJyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImF1ZGlvR3JvdXBzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1ZGlvR3JvdXBzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdWJ0aXRsZUdyb3Vwc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJ0aXRsZUdyb3VwcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXJsSWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge31cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXVkaW9Hcm91cElkc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1ZGlvR3JvdXBzID8gW3RoaXMuYXVkaW9Hcm91cElkXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidGV4dEdyb3VwSWRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidGl0bGVHcm91cHMgPyBbdGhpcy50ZXh0R3JvdXBJZF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImF1ZGlvR3JvdXBJZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRhdWRpb0dyb3VwcztcbiAgICAgICAgcmV0dXJuIChfdGhpcyRhdWRpb0dyb3VwcyA9IHRoaXMuYXVkaW9Hcm91cHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhdWRpb0dyb3Vwc1swXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidGV4dEdyb3VwSWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkc3VidGl0bGVHcm91cHM7XG4gICAgICAgIHJldHVybiAoX3RoaXMkc3VidGl0bGVHcm91cHMgPSB0aGlzLnN1YnRpdGxlR3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc3VidGl0bGVHcm91cHNbMF07XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGhhc0dyb3VwKGdyb3VwcywgZ3JvdXBJZCkge1xuICAgIGlmICghZ3JvdXBJZCB8fCAhZ3JvdXBzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBncm91cHMuaW5kZXhPZihncm91cElkKSAhPT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgV2hldGhlciB3ZSBjYW4gZGV0ZWN0IGFuZCB2YWxpZGF0ZSBIRFIgY2FwYWJpbGl0eSB3aXRoaW4gdGhlIHdpbmRvdyBjb250ZXh0XG4gICAqL1xuICBmdW5jdGlvbiBpc0hkclN1cHBvcnRlZCgpIHtcbiAgICBpZiAodHlwZW9mIG1hdGNoTWVkaWEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBtZWRpYVF1ZXJ5TGlzdCA9IG1hdGNoTWVkaWEoJyhkeW5hbWljLXJhbmdlOiBoaWdoKScpO1xuICAgICAgdmFyIGJhZFF1ZXJ5ID0gbWF0Y2hNZWRpYSgnYmFkIHF1ZXJ5Jyk7XG4gICAgICBpZiAobWVkaWFRdWVyeUxpc3QubWVkaWEgIT09IGJhZFF1ZXJ5Lm1lZGlhKSB7XG4gICAgICAgIHJldHVybiBtZWRpYVF1ZXJ5TGlzdC5tYXRjaGVzID09PSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2FuaXRpemVzIGlucHV0cyB0byByZXR1cm4gdGhlIGFjdGl2ZSB2aWRlbyBzZWxlY3Rpb24gb3B0aW9ucyBmb3IgSERSL1NEUi5cbiAgICogV2hlbiBib3RoIGlucHV0cyBhcmUgbnVsbDpcbiAgICpcbiAgICogICAgYHsgcHJlZmVySERSOiBmYWxzZSwgYWxsb3dlZFZpZGVvUmFuZ2VzOiBbXSB9YFxuICAgKlxuICAgKiBXaGVuIGBjdXJyZW50VmlkZW9SYW5nZWAgbm9uLW51bGwsIG1haW50YWluIHRoZSBhY3RpdmUgcmFuZ2U6XG4gICAqXG4gICAqICAgIGB7IHByZWZlckhEUjogY3VycmVudFZpZGVvUmFuZ2UgIT09ICdTRFInLCBhbGxvd2VkVmlkZW9SYW5nZXM6IFtjdXJyZW50VmlkZW9SYW5nZV0gfWBcbiAgICpcbiAgICogV2hlbiBWaWRlb1NlbGVjdGlvbk9wdGlvbiBub24tbnVsbDpcbiAgICpcbiAgICogIC0gQWxsb3cgYWxsIHZpZGVvIHJhbmdlcyBpZiBgYWxsb3dlZFZpZGVvUmFuZ2VzYCB1bnNwZWNpZmllZC5cbiAgICogIC0gSWYgYHByZWZlckhEUmAgaXMgbm9uLW51bGwgdXNlIHRoZSB2YWx1ZSB0byBmaWx0ZXIgYGFsbG93ZWRWaWRlb1Jhbmdlc2AuXG4gICAqICAtIEVsc2UgY2hlY2sgd2luZG93IGZvciBIRFIgc3VwcG9ydCBhbmQgc2V0IGBwcmVmZXJIRFJgIHRvIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSBjdXJyZW50VmlkZW9SYW5nZVxuICAgKiBAcGFyYW0gdmlkZW9QcmVmZXJlbmNlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWaWRlb1NlbGVjdGlvbk9wdGlvbnMoY3VycmVudFZpZGVvUmFuZ2UsIHZpZGVvUHJlZmVyZW5jZSkge1xuICAgIHZhciBwcmVmZXJIRFIgPSBmYWxzZTtcbiAgICB2YXIgYWxsb3dlZFZpZGVvUmFuZ2VzID0gW107XG4gICAgaWYgKGN1cnJlbnRWaWRlb1JhbmdlKSB7XG4gICAgICBwcmVmZXJIRFIgPSBjdXJyZW50VmlkZW9SYW5nZSAhPT0gJ1NEUic7XG4gICAgICBhbGxvd2VkVmlkZW9SYW5nZXMgPSBbY3VycmVudFZpZGVvUmFuZ2VdO1xuICAgIH1cbiAgICBpZiAodmlkZW9QcmVmZXJlbmNlKSB7XG4gICAgICBhbGxvd2VkVmlkZW9SYW5nZXMgPSB2aWRlb1ByZWZlcmVuY2UuYWxsb3dlZFZpZGVvUmFuZ2VzIHx8IFZpZGVvUmFuZ2VWYWx1ZXMuc2xpY2UoMCk7XG4gICAgICB2YXIgYWxsb3dBdXRvUHJlZmVySERSID0gYWxsb3dlZFZpZGVvUmFuZ2VzLmpvaW4oJycpICE9PSAnU0RSJyAmJiAhdmlkZW9QcmVmZXJlbmNlLnZpZGVvQ29kZWM7XG4gICAgICBwcmVmZXJIRFIgPSB2aWRlb1ByZWZlcmVuY2UucHJlZmVySERSICE9PSB1bmRlZmluZWQgPyB2aWRlb1ByZWZlcmVuY2UucHJlZmVySERSIDogYWxsb3dBdXRvUHJlZmVySERSICYmIGlzSGRyU3VwcG9ydGVkKCk7XG4gICAgICBpZiAoIXByZWZlckhEUikge1xuICAgICAgICBhbGxvd2VkVmlkZW9SYW5nZXMgPSBbJ1NEUiddO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcHJlZmVySERSOiBwcmVmZXJIRFIsXG4gICAgICBhbGxvd2VkVmlkZW9SYW5nZXM6IGFsbG93ZWRWaWRlb1Jhbmdlc1xuICAgIH07XG4gIH1cblxuICB2YXIgb21pdENpcmN1bGFyUmVmc1JlcGxhY2VyID0gZnVuY3Rpb24gb21pdENpcmN1bGFyUmVmc1JlcGxhY2VyKHJlcGxhY2VyKSB7XG4gICAgdmFyIGtub3duID0gbmV3IFdlYWtTZXQoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF8sIHZhbHVlKSB7XG4gICAgICBpZiAocmVwbGFjZXIpIHtcbiAgICAgICAgdmFsdWUgPSByZXBsYWNlcihfLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoa25vd24uaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBrbm93bi5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG4gIHZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0LCByZXBsYWNlcikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmplY3QsIG9taXRDaXJjdWxhclJlZnNSZXBsYWNlcihyZXBsYWNlcikpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFN0YXJ0Q29kZWNUaWVyKGNvZGVjVGllcnMsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSwgdmlkZW9QcmVmZXJlbmNlKSB7XG4gICAgdmFyIGNvZGVjU2V0cyA9IE9iamVjdC5rZXlzKGNvZGVjVGllcnMpO1xuICAgIHZhciBjaGFubmVsc1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5jaGFubmVscztcbiAgICB2YXIgYXVkaW9Db2RlY1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5hdWRpb0NvZGVjO1xuICAgIHZhciB2aWRlb0NvZGVjUHJlZmVyZW5jZSA9IHZpZGVvUHJlZmVyZW5jZSA9PSBudWxsID8gdm9pZCAwIDogdmlkZW9QcmVmZXJlbmNlLnZpZGVvQ29kZWM7XG4gICAgdmFyIHByZWZlclN0ZXJlbyA9IGNoYW5uZWxzUHJlZmVyZW5jZSAmJiBwYXJzZUludChjaGFubmVsc1ByZWZlcmVuY2UpID09PSAyO1xuICAgIC8vIFVzZSBmaXJzdCBsZXZlbCBzZXQgdG8gZGV0ZXJtaW5lIHN0ZXJlbywgYW5kIG1pbmltdW0gcmVzb2x1dGlvbiBhbmQgZnJhbWVyYXRlXG4gICAgdmFyIGhhc1N0ZXJlbyA9IGZhbHNlO1xuICAgIHZhciBoYXNDdXJyZW50VmlkZW9SYW5nZSA9IGZhbHNlO1xuICAgIHZhciBtaW5IZWlnaHQgPSBJbmZpbml0eTtcbiAgICB2YXIgbWluRnJhbWVyYXRlID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkJpdHJhdGUgPSBJbmZpbml0eTtcbiAgICB2YXIgbWluSW5kZXggPSBJbmZpbml0eTtcbiAgICB2YXIgc2VsZWN0ZWRTY29yZSA9IDA7XG4gICAgdmFyIHZpZGVvUmFuZ2VzID0gW107XG4gICAgdmFyIF9nZXRWaWRlb1NlbGVjdGlvbk9wdCA9IGdldFZpZGVvU2VsZWN0aW9uT3B0aW9ucyhjdXJyZW50VmlkZW9SYW5nZSwgdmlkZW9QcmVmZXJlbmNlKSxcbiAgICAgIHByZWZlckhEUiA9IF9nZXRWaWRlb1NlbGVjdGlvbk9wdC5wcmVmZXJIRFIsXG4gICAgICBhbGxvd2VkVmlkZW9SYW5nZXMgPSBfZ2V0VmlkZW9TZWxlY3Rpb25PcHQuYWxsb3dlZFZpZGVvUmFuZ2VzO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIHRpZXIgPSBjb2RlY1RpZXJzW2NvZGVjU2V0c1tpXV07XG4gICAgICBoYXNTdGVyZW8gfHwgKGhhc1N0ZXJlbyA9IHRpZXIuY2hhbm5lbHNbMl0gPiAwKTtcbiAgICAgIG1pbkhlaWdodCA9IE1hdGgubWluKG1pbkhlaWdodCwgdGllci5taW5IZWlnaHQpO1xuICAgICAgbWluRnJhbWVyYXRlID0gTWF0aC5taW4obWluRnJhbWVyYXRlLCB0aWVyLm1pbkZyYW1lcmF0ZSk7XG4gICAgICBtaW5CaXRyYXRlID0gTWF0aC5taW4obWluQml0cmF0ZSwgdGllci5taW5CaXRyYXRlKTtcbiAgICAgIHZhciBtYXRjaGluZ1ZpZGVvUmFuZ2VzID0gYWxsb3dlZFZpZGVvUmFuZ2VzLmZpbHRlcihmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRpZXIudmlkZW9SYW5nZXNbcmFuZ2VdID4gMDtcbiAgICAgIH0pO1xuICAgICAgaWYgKG1hdGNoaW5nVmlkZW9SYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBoYXNDdXJyZW50VmlkZW9SYW5nZSA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gY29kZWNTZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgX2xvb3AoKTtcbiAgICB9XG4gICAgbWluSGVpZ2h0ID0gaXNGaW5pdGVOdW1iZXIobWluSGVpZ2h0KSA/IG1pbkhlaWdodCA6IDA7XG4gICAgbWluRnJhbWVyYXRlID0gaXNGaW5pdGVOdW1iZXIobWluRnJhbWVyYXRlKSA/IG1pbkZyYW1lcmF0ZSA6IDA7XG4gICAgdmFyIG1heEhlaWdodCA9IE1hdGgubWF4KDEwODAsIG1pbkhlaWdodCk7XG4gICAgdmFyIG1heEZyYW1lcmF0ZSA9IE1hdGgubWF4KDMwLCBtaW5GcmFtZXJhdGUpO1xuICAgIG1pbkJpdHJhdGUgPSBpc0Zpbml0ZU51bWJlcihtaW5CaXRyYXRlKSA/IG1pbkJpdHJhdGUgOiBjdXJyZW50Qnc7XG4gICAgY3VycmVudEJ3ID0gTWF0aC5tYXgobWluQml0cmF0ZSwgY3VycmVudEJ3KTtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gdmFyaWFudHMgd2l0aCBtYXRjaGluZyBwcmVmZXJlbmNlLCBzZXQgY3VycmVudFZpZGVvUmFuZ2UgdG8gdW5kZWZpbmVkXG4gICAgaWYgKCFoYXNDdXJyZW50VmlkZW9SYW5nZSkge1xuICAgICAgY3VycmVudFZpZGVvUmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBoYXNNdWx0aXBsZVNldHMgPSBjb2RlY1NldHMubGVuZ3RoID4gMTtcbiAgICB2YXIgY29kZWNTZXQgPSBjb2RlY1NldHMucmVkdWNlKGZ1bmN0aW9uIChzZWxlY3RlZCwgY2FuZGlkYXRlKSB7XG4gICAgICAvLyBSZW1vdmUgY2FuZGlhdGVzIHdoaWNoIGRvIG5vdCBtZWV0IGJpdHJhdGUsIGRlZmF1bHQgYXVkaW8sIHN0ZXJlbyBvciBjaGFubmVscyBwcmVmZXJlbmNlLCAxMDgwcCBvciBsb3dlciwgMzBmcHMgb3IgbG93ZXIsIG9yIFNEUi9IRFIgc2VsZWN0aW9uIGlmIHByZXNlbnRcbiAgICAgIHZhciBjYW5kaWRhdGVUaWVyID0gY29kZWNUaWVyc1tjYW5kaWRhdGVdO1xuICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgdmlkZW9SYW5nZXMgPSBoYXNDdXJyZW50VmlkZW9SYW5nZSA/IGFsbG93ZWRWaWRlb1Jhbmdlcy5maWx0ZXIoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVUaWVyLnZpZGVvUmFuZ2VzW3JhbmdlXSA+IDA7XG4gICAgICB9KSA6IFtdO1xuICAgICAgaWYgKGhhc011bHRpcGxlU2V0cykge1xuICAgICAgICBpZiAoY2FuZGlkYXRlVGllci5taW5CaXRyYXRlID4gY3VycmVudEJ3KSB7XG4gICAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBcIm1pbiBiaXRyYXRlIG9mIFwiICsgY2FuZGlkYXRlVGllci5taW5CaXRyYXRlICsgXCIgPiBjdXJyZW50IGVzdGltYXRlIG9mIFwiICsgY3VycmVudEJ3KTtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYW5kaWRhdGVUaWVyLmhhc0RlZmF1bHRBdWRpbykge1xuICAgICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgXCJubyByZW5kaXRpb25zIHdpdGggZGVmYXVsdCBvciBhdXRvLXNlbGVjdCBzb3VuZCBmb3VuZFwiKTtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1ZGlvQ29kZWNQcmVmZXJlbmNlICYmIGNhbmRpZGF0ZS5pbmRleE9mKGF1ZGlvQ29kZWNQcmVmZXJlbmNlLnN1YnN0cmluZygwLCA0KSkgJSA1ICE9PSAwKSB7XG4gICAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBcImF1ZGlvIGNvZGVjIHByZWZlcmVuY2UgXFxcIlwiICsgYXVkaW9Db2RlY1ByZWZlcmVuY2UgKyBcIlxcXCIgbm90IGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbm5lbHNQcmVmZXJlbmNlICYmICFwcmVmZXJTdGVyZW8pIHtcbiAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVRpZXIuY2hhbm5lbHNbY2hhbm5lbHNQcmVmZXJlbmNlXSkge1xuICAgICAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBcIm5vIHJlbmRpdGlvbnMgd2l0aCBcIiArIGNoYW5uZWxzUHJlZmVyZW5jZSArIFwiIGNoYW5uZWwgc291bmQgZm91bmQgKGNoYW5uZWxzIG9wdGlvbnM6IFwiICsgT2JqZWN0LmtleXMoY2FuZGlkYXRlVGllci5jaGFubmVscykgKyBcIilcIik7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCghYXVkaW9Db2RlY1ByZWZlcmVuY2UgfHwgcHJlZmVyU3RlcmVvKSAmJiBoYXNTdGVyZW8gJiYgY2FuZGlkYXRlVGllci5jaGFubmVsc1snMiddID09PSAwKSB7XG4gICAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBcIm5vIHJlbmRpdGlvbnMgd2l0aCBzdGVyZW8gc291bmQgZm91bmRcIik7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5kaWRhdGVUaWVyLm1pbkhlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgXCJtaW4gcmVzb2x1dGlvbiBvZiBcIiArIGNhbmRpZGF0ZVRpZXIubWluSGVpZ2h0ICsgXCIgPiBtYXhpbXVtIG9mIFwiICsgbWF4SGVpZ2h0KTtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmRpZGF0ZVRpZXIubWluRnJhbWVyYXRlID4gbWF4RnJhbWVyYXRlKSB7XG4gICAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBcIm1pbiBmcmFtZXJhdGUgb2YgXCIgKyBjYW5kaWRhdGVUaWVyLm1pbkZyYW1lcmF0ZSArIFwiID4gbWF4aW11bSBvZiBcIiArIG1heEZyYW1lcmF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmlkZW9SYW5nZXMuc29tZShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlVGllci52aWRlb1Jhbmdlc1tyYW5nZV0gPiAwO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgXCJubyB2YXJpYW50cyB3aXRoIFZJREVPLVJBTkdFIG9mIFwiICsgc3RyaW5naWZ5KHZpZGVvUmFuZ2VzKSArIFwiIGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW9Db2RlY1ByZWZlcmVuY2UgJiYgY2FuZGlkYXRlLmluZGV4T2YodmlkZW9Db2RlY1ByZWZlcmVuY2Uuc3Vic3RyaW5nKDAsIDQpKSAlIDUgIT09IDApIHtcbiAgICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIFwidmlkZW8gY29kZWMgcHJlZmVyZW5jZSBcXFwiXCIgKyB2aWRlb0NvZGVjUHJlZmVyZW5jZSArIFwiXFxcIiBub3QgZm91bmRcIik7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5kaWRhdGVUaWVyLm1heFNjb3JlIDwgc2VsZWN0ZWRTY29yZSkge1xuICAgICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgXCJtYXggc2NvcmUgb2YgXCIgKyBjYW5kaWRhdGVUaWVyLm1heFNjb3JlICsgXCIgPCBzZWxlY3RlZCBtYXggb2YgXCIgKyBzZWxlY3RlZFNjb3JlKTtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjYW5kaWF0ZXMgd2l0aCBsZXNzIHByZWZlcnJlZCBjb2RlY3Mgb3IgbW9yZSBlcnJvcnNcbiAgICAgIGlmIChzZWxlY3RlZCAmJiAoY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGNhbmRpZGF0ZSkgPj0gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKHNlbGVjdGVkKSB8fCBjYW5kaWRhdGVUaWVyLmZyYWdtZW50RXJyb3IgPiBjb2RlY1RpZXJzW3NlbGVjdGVkXS5mcmFnbWVudEVycm9yKSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBtaW5JbmRleCA9IGNhbmRpZGF0ZVRpZXIubWluSW5kZXg7XG4gICAgICBzZWxlY3RlZFNjb3JlID0gY2FuZGlkYXRlVGllci5tYXhTY29yZTtcbiAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfSwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZWNTZXQ6IGNvZGVjU2V0LFxuICAgICAgdmlkZW9SYW5nZXM6IHZpZGVvUmFuZ2VzLFxuICAgICAgcHJlZmVySERSOiBwcmVmZXJIRFIsXG4gICAgICBtaW5GcmFtZXJhdGU6IG1pbkZyYW1lcmF0ZSxcbiAgICAgIG1pbkJpdHJhdGU6IG1pbkJpdHJhdGUsXG4gICAgICBtaW5JbmRleDogbWluSW5kZXhcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNvZGVTZXQsIHJlYXNvbikge1xuICAgIGxvZ2dlci5sb2coXCJbYWJyXSBzdGFydCBjYW5kaWRhdGVzIHdpdGggXFxcIlwiICsgY29kZVNldCArIFwiXFxcIiBpZ25vcmVkIGJlY2F1c2UgXCIgKyByZWFzb24pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF1ZGlvVHJhY2tzQnlHcm91cChhbGxBdWRpb1RyYWNrcykge1xuICAgIHJldHVybiBhbGxBdWRpb1RyYWNrcy5yZWR1Y2UoZnVuY3Rpb24gKGF1ZGlvVHJhY2tzQnlHcm91cCwgdHJhY2spIHtcbiAgICAgIHZhciB0cmFja0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1t0cmFjay5ncm91cElkXTtcbiAgICAgIGlmICghdHJhY2tHcm91cCkge1xuICAgICAgICB0cmFja0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1t0cmFjay5ncm91cElkXSA9IHtcbiAgICAgICAgICB0cmFja3M6IFtdLFxuICAgICAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgICAgICAyOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYXNEZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBoYXNBdXRvU2VsZWN0OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdHJhY2tHcm91cC50cmFja3MucHVzaCh0cmFjayk7XG4gICAgICB2YXIgY2hhbm5lbHNLZXkgPSB0cmFjay5jaGFubmVscyB8fCAnMic7XG4gICAgICB0cmFja0dyb3VwLmNoYW5uZWxzW2NoYW5uZWxzS2V5XSA9ICh0cmFja0dyb3VwLmNoYW5uZWxzW2NoYW5uZWxzS2V5XSB8fCAwKSArIDE7XG4gICAgICB0cmFja0dyb3VwLmhhc0RlZmF1bHQgPSB0cmFja0dyb3VwLmhhc0RlZmF1bHQgfHwgdHJhY2suZGVmYXVsdDtcbiAgICAgIHRyYWNrR3JvdXAuaGFzQXV0b1NlbGVjdCA9IHRyYWNrR3JvdXAuaGFzQXV0b1NlbGVjdCB8fCB0cmFjay5hdXRvc2VsZWN0O1xuICAgICAgaWYgKHRyYWNrR3JvdXAuaGFzRGVmYXVsdCkge1xuICAgICAgICBhdWRpb1RyYWNrc0J5R3JvdXAuaGFzRGVmYXVsdEF1ZGlvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFja0dyb3VwLmhhc0F1dG9TZWxlY3QpIHtcbiAgICAgICAgYXVkaW9UcmFja3NCeUdyb3VwLmhhc0F1dG9TZWxlY3RBdWRpbyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXVkaW9UcmFja3NCeUdyb3VwO1xuICAgIH0sIHtcbiAgICAgIGhhc0RlZmF1bHRBdWRpbzogZmFsc2UsXG4gICAgICBoYXNBdXRvU2VsZWN0QXVkaW86IGZhbHNlLFxuICAgICAgZ3JvdXBzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENvZGVjVGllcnMobGV2ZWxzLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsKSB7XG4gICAgcmV0dXJuIGxldmVscy5zbGljZShtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCArIDEpLnJlZHVjZShmdW5jdGlvbiAodGllcnMsIGxldmVsLCBpbmRleCkge1xuICAgICAgaWYgKCFsZXZlbC5jb2RlY1NldCkge1xuICAgICAgICByZXR1cm4gdGllcnM7XG4gICAgICB9XG4gICAgICB2YXIgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICAgIHZhciB0aWVyID0gdGllcnNbbGV2ZWwuY29kZWNTZXRdO1xuICAgICAgaWYgKCF0aWVyKSB7XG4gICAgICAgIHRpZXJzW2xldmVsLmNvZGVjU2V0XSA9IHRpZXIgPSB7XG4gICAgICAgICAgbWluQml0cmF0ZTogSW5maW5pdHksXG4gICAgICAgICAgbWluSGVpZ2h0OiBJbmZpbml0eSxcbiAgICAgICAgICBtaW5GcmFtZXJhdGU6IEluZmluaXR5LFxuICAgICAgICAgIG1pbkluZGV4OiBpbmRleCxcbiAgICAgICAgICBtYXhTY29yZTogMCxcbiAgICAgICAgICB2aWRlb1Jhbmdlczoge1xuICAgICAgICAgICAgU0RSOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGFubmVsczoge1xuICAgICAgICAgICAgJzInOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYXNEZWZhdWx0QXVkaW86ICFhdWRpb0dyb3VwcyxcbiAgICAgICAgICBmcmFnbWVudEVycm9yOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aWVyLm1pbkJpdHJhdGUgPSBNYXRoLm1pbih0aWVyLm1pbkJpdHJhdGUsIGxldmVsLmJpdHJhdGUpO1xuICAgICAgdmFyIGxlc3NlcldpZHRoT3JIZWlnaHQgPSBNYXRoLm1pbihsZXZlbC5oZWlnaHQsIGxldmVsLndpZHRoKTtcbiAgICAgIHRpZXIubWluSGVpZ2h0ID0gTWF0aC5taW4odGllci5taW5IZWlnaHQsIGxlc3NlcldpZHRoT3JIZWlnaHQpO1xuICAgICAgdGllci5taW5GcmFtZXJhdGUgPSBNYXRoLm1pbih0aWVyLm1pbkZyYW1lcmF0ZSwgbGV2ZWwuZnJhbWVSYXRlKTtcbiAgICAgIHRpZXIubWluSW5kZXggPSBNYXRoLm1pbih0aWVyLm1pbkluZGV4LCBpbmRleCk7XG4gICAgICB0aWVyLm1heFNjb3JlID0gTWF0aC5tYXgodGllci5tYXhTY29yZSwgbGV2ZWwuc2NvcmUpO1xuICAgICAgdGllci5mcmFnbWVudEVycm9yICs9IGxldmVsLmZyYWdtZW50RXJyb3I7XG4gICAgICB0aWVyLnZpZGVvUmFuZ2VzW2xldmVsLnZpZGVvUmFuZ2VdID0gKHRpZXIudmlkZW9SYW5nZXNbbGV2ZWwudmlkZW9SYW5nZV0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGF1ZGlvR3JvdXBzKSB7XG4gICAgICAgIGF1ZGlvR3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgIGlmICghYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdWRpb0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1thdWRpb0dyb3VwSWRdO1xuICAgICAgICAgIGlmICghYXVkaW9Hcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEZWZhdWx0IGF1ZGlvIGlzIGFueSBncm91cCB3aXRoIERFRkFVTFQ9WUVTLCBvciBpZiBtaXNzaW5nIHRoZW4gYW55IGdyb3VwIHdpdGggQVVUT1NFTEVDVD1ZRVMsIG9yIGFsbCB2YXJpYW50c1xuICAgICAgICAgIHRpZXIuaGFzRGVmYXVsdEF1ZGlvID0gdGllci5oYXNEZWZhdWx0QXVkaW8gfHwgYXVkaW9UcmFja3NCeUdyb3VwLmhhc0RlZmF1bHRBdWRpbyA/IGF1ZGlvR3JvdXAuaGFzRGVmYXVsdCA6IGF1ZGlvR3JvdXAuaGFzQXV0b1NlbGVjdCB8fCAhYXVkaW9UcmFja3NCeUdyb3VwLmhhc0RlZmF1bHRBdWRpbyAmJiAhYXVkaW9UcmFja3NCeUdyb3VwLmhhc0F1dG9TZWxlY3RBdWRpbztcbiAgICAgICAgICBPYmplY3Qua2V5cyhhdWRpb0dyb3VwLmNoYW5uZWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVscykge1xuICAgICAgICAgICAgdGllci5jaGFubmVsc1tjaGFubmVsc10gPSAodGllci5jaGFubmVsc1tjaGFubmVsc10gfHwgMCkgKyBhdWRpb0dyb3VwLmNoYW5uZWxzW2NoYW5uZWxzXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGllcnM7XG4gICAgfSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEJhc2ljU2VsZWN0aW9uT3B0aW9uKG9wdGlvbikge1xuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gb3B0aW9uO1xuICAgIH1cbiAgICB2YXIgX3JlZiA9IG9wdGlvbixcbiAgICAgIGxhbmcgPSBfcmVmLmxhbmcsXG4gICAgICBhc3NvY0xhbmcgPSBfcmVmLmFzc29jTGFuZyxcbiAgICAgIGNoYXJhY3RlcmlzdGljcyA9IF9yZWYuY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgY2hhbm5lbHMgPSBfcmVmLmNoYW5uZWxzLFxuICAgICAgYXVkaW9Db2RlYyA9IF9yZWYuYXVkaW9Db2RlYztcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZzogbGFuZyxcbiAgICAgIGFzc29jTGFuZzogYXNzb2NMYW5nLFxuICAgICAgY2hhcmFjdGVyaXN0aWNzOiBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICBjaGFubmVsczogY2hhbm5lbHMsXG4gICAgICBhdWRpb0NvZGVjOiBhdWRpb0NvZGVjXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdPcHRpb24ob3B0aW9uLCB0cmFja3MsIG1hdGNoUHJlZGljYXRlKSB7XG4gICAgaWYgKCdhdHRycycgaW4gb3B0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSB0cmFja3MuaW5kZXhPZihvcHRpb24pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICBpZiAobWF0Y2hlc09wdGlvbihvcHRpb24sIHRyYWNrLCBtYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaGVzT3B0aW9uKG9wdGlvbiwgdHJhY2ssIG1hdGNoUHJlZGljYXRlKSB7XG4gICAgdmFyIGdyb3VwSWQgPSBvcHRpb24uZ3JvdXBJZCxcbiAgICAgIG5hbWUgPSBvcHRpb24ubmFtZSxcbiAgICAgIGxhbmcgPSBvcHRpb24ubGFuZyxcbiAgICAgIGFzc29jTGFuZyA9IG9wdGlvbi5hc3NvY0xhbmcsXG4gICAgICBpc0RlZmF1bHQgPSBvcHRpb24uZGVmYXVsdDtcbiAgICB2YXIgZm9yY2VkID0gb3B0aW9uLmZvcmNlZDtcbiAgICByZXR1cm4gKGdyb3VwSWQgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5ncm91cElkID09PSBncm91cElkKSAmJiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLm5hbWUgPT09IG5hbWUpICYmIChsYW5nID09PSB1bmRlZmluZWQgfHwgbGFuZ3VhZ2VzTWF0Y2gobGFuZywgdHJhY2subGFuZykpICYmIChsYW5nID09PSB1bmRlZmluZWQgfHwgdHJhY2suYXNzb2NMYW5nID09PSBhc3NvY0xhbmcpICYmIChpc0RlZmF1bHQgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5kZWZhdWx0ID09PSBpc0RlZmF1bHQpICYmIChmb3JjZWQgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5mb3JjZWQgPT09IGZvcmNlZCkgJiYgKCEoJ2NoYXJhY3RlcmlzdGljcycgaW4gb3B0aW9uKSB8fCBjaGFyYWN0ZXJpc3RpY3NNYXRjaChvcHRpb24uY2hhcmFjdGVyaXN0aWNzIHx8ICcnLCB0cmFjay5jaGFyYWN0ZXJpc3RpY3MpKSAmJiAobWF0Y2hQcmVkaWNhdGUgPT09IHVuZGVmaW5lZCB8fCBtYXRjaFByZWRpY2F0ZShvcHRpb24sIHRyYWNrKSk7XG4gIH1cbiAgZnVuY3Rpb24gbGFuZ3VhZ2VzTWF0Y2gobGFuZ3VhZ2VBLCBsYW5ndWFnZUIpIHtcbiAgICBpZiAobGFuZ3VhZ2VCID09PSB2b2lkIDApIHtcbiAgICAgIGxhbmd1YWdlQiA9ICctLSc7XG4gICAgfVxuICAgIGlmIChsYW5ndWFnZUEubGVuZ3RoID09PSBsYW5ndWFnZUIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbGFuZ3VhZ2VBID09PSBsYW5ndWFnZUI7XG4gICAgfVxuICAgIHJldHVybiBsYW5ndWFnZUEuc3RhcnRzV2l0aChsYW5ndWFnZUIpIHx8IGxhbmd1YWdlQi5zdGFydHNXaXRoKGxhbmd1YWdlQSk7XG4gIH1cbiAgZnVuY3Rpb24gY2hhcmFjdGVyaXN0aWNzTWF0Y2goY2hhcmFjdGVyaXN0aWNzQSwgY2hhcmFjdGVyaXN0aWNzQikge1xuICAgIGlmIChjaGFyYWN0ZXJpc3RpY3NCID09PSB2b2lkIDApIHtcbiAgICAgIGNoYXJhY3RlcmlzdGljc0IgPSAnJztcbiAgICB9XG4gICAgdmFyIGFyckEgPSBjaGFyYWN0ZXJpc3RpY3NBLnNwbGl0KCcsJyk7XG4gICAgdmFyIGFyckIgPSBjaGFyYWN0ZXJpc3RpY3NCLnNwbGl0KCcsJyk7XG4gICAgLy8gRXhwZWN0cyBlYWNoIGl0ZW0gdG8gYmUgdW5pcXVlOlxuICAgIHJldHVybiBhcnJBLmxlbmd0aCA9PT0gYXJyQi5sZW5ndGggJiYgIWFyckEuc29tZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBhcnJCLmluZGV4T2YoZWwpID09PSAtMTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhdWRpb01hdGNoUHJlZGljYXRlKG9wdGlvbiwgdHJhY2spIHtcbiAgICB2YXIgYXVkaW9Db2RlYyA9IG9wdGlvbi5hdWRpb0NvZGVjLFxuICAgICAgY2hhbm5lbHMgPSBvcHRpb24uY2hhbm5lbHM7XG4gICAgcmV0dXJuIChhdWRpb0NvZGVjID09PSB1bmRlZmluZWQgfHwgKHRyYWNrLmF1ZGlvQ29kZWMgfHwgJycpLnN1YnN0cmluZygwLCA0KSA9PT0gYXVkaW9Db2RlYy5zdWJzdHJpbmcoMCwgNCkpICYmIChjaGFubmVscyA9PT0gdW5kZWZpbmVkIHx8IGNoYW5uZWxzID09PSAodHJhY2suY2hhbm5lbHMgfHwgJzInKSk7XG4gIH1cbiAgZnVuY3Rpb24gZmluZENsb3Nlc3RMZXZlbFdpdGhBdWRpb0dyb3VwKG9wdGlvbiwgbGV2ZWxzLCBhbGxBdWRpb1RyYWNrcywgc2VhcmNoSW5kZXgsIG1hdGNoUHJlZGljYXRlKSB7XG4gICAgdmFyIGN1cnJlbnRMZXZlbCA9IGxldmVsc1tzZWFyY2hJbmRleF07XG4gICAgLy8gQXJlIHRoZXJlIHZhcmlhbnRzIHdpdGggc2FtZSBVUkkgYXMgY3VycmVudCBsZXZlbD9cbiAgICAvLyBJZiBzbywgZmluZCBhIG1hdGNoIHRoYXQgZG9lcyBub3QgcmVxdWlyZSBhbnkgbGV2ZWwgVVJJIGNoYW5nZVxuICAgIHZhciB2YXJpYW50cyA9IGxldmVscy5yZWR1Y2UoZnVuY3Rpb24gKHZhcmlhbnRNYXAsIGxldmVsLCBpbmRleCkge1xuICAgICAgdmFyIHVyaSA9IGxldmVsLnVyaTtcbiAgICAgIHZhciByZW5kaXRpb25zID0gdmFyaWFudE1hcFt1cmldIHx8ICh2YXJpYW50TWFwW3VyaV0gPSBbXSk7XG4gICAgICByZW5kaXRpb25zLnB1c2goaW5kZXgpO1xuICAgICAgcmV0dXJuIHZhcmlhbnRNYXA7XG4gICAgfSwge30pO1xuICAgIHZhciByZW5kaXRpb25zID0gdmFyaWFudHNbY3VycmVudExldmVsLnVyaV07XG4gICAgaWYgKHJlbmRpdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgc2VhcmNoSW5kZXggPSBNYXRoLm1heC5hcHBseShNYXRoLCByZW5kaXRpb25zKTtcbiAgICB9XG4gICAgLy8gRmluZCBiZXN0IG1hdGNoXG4gICAgdmFyIGN1cnJlbnRWaWRlb1JhbmdlID0gY3VycmVudExldmVsLnZpZGVvUmFuZ2U7XG4gICAgdmFyIGN1cnJlbnRGcmFtZVJhdGUgPSBjdXJyZW50TGV2ZWwuZnJhbWVSYXRlO1xuICAgIHZhciBjdXJyZW50VmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC5jb2RlY1NldC5zdWJzdHJpbmcoMCwgNCk7XG4gICAgdmFyIG1hdGNoaW5nVmlkZW8gPSBzZWFyY2hEb3duQW5kVXBMaXN0KGxldmVscywgc2VhcmNoSW5kZXgsIGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgaWYgKGxldmVsLnZpZGVvUmFuZ2UgIT09IGN1cnJlbnRWaWRlb1JhbmdlIHx8IGxldmVsLmZyYW1lUmF0ZSAhPT0gY3VycmVudEZyYW1lUmF0ZSB8fCBsZXZlbC5jb2RlY1NldC5zdWJzdHJpbmcoMCwgNCkgIT09IGN1cnJlbnRWaWRlb0NvZGVjKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvR3JvdXBzO1xuICAgICAgdmFyIHRyYWNrcyA9IGFsbEF1ZGlvVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuICFhdWRpb0dyb3VwcyB8fCBhdWRpb0dyb3Vwcy5pbmRleE9mKHRyYWNrLmdyb3VwSWQpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbmRNYXRjaGluZ09wdGlvbihvcHRpb24sIHRyYWNrcywgbWF0Y2hQcmVkaWNhdGUpID4gLTE7XG4gICAgfSk7XG4gICAgaWYgKG1hdGNoaW5nVmlkZW8gPiAtMSkge1xuICAgICAgcmV0dXJuIG1hdGNoaW5nVmlkZW87XG4gICAgfVxuICAgIHJldHVybiBzZWFyY2hEb3duQW5kVXBMaXN0KGxldmVscywgc2VhcmNoSW5kZXgsIGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgdmFyIGF1ZGlvR3JvdXBzID0gbGV2ZWwuYXVkaW9Hcm91cHM7XG4gICAgICB2YXIgdHJhY2tzID0gYWxsQXVkaW9UcmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gIWF1ZGlvR3JvdXBzIHx8IGF1ZGlvR3JvdXBzLmluZGV4T2YodHJhY2suZ3JvdXBJZCkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkgPiAtMTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZWFyY2hEb3duQW5kVXBMaXN0KGFyciwgc2VhcmNoSW5kZXgsIHByZWRpY2F0ZSkge1xuICAgIGZvciAodmFyIGkgPSBzZWFyY2hJbmRleDsgaSA+IC0xOyBpLS0pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSBzZWFyY2hJbmRleCArIDE7IF9pIDwgYXJyLmxlbmd0aDsgX2krKykge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJbX2ldKSkge1xuICAgICAgICByZXR1cm4gX2k7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmdW5jdGlvbiB1c2VBbHRlcm5hdGVBdWRpbyhhdWRpb1RyYWNrVXJsLCBobHMpIHtcbiAgICB2YXIgX2hscyRsb2FkTGV2ZWxPYmo7XG4gICAgcmV0dXJuICEhYXVkaW9UcmFja1VybCAmJiBhdWRpb1RyYWNrVXJsICE9PSAoKF9obHMkbG9hZExldmVsT2JqID0gaGxzLmxvYWRMZXZlbE9iaikgPT0gbnVsbCA/IHZvaWQgMCA6IF9obHMkbG9hZExldmVsT2JqLnVyaSk7XG4gIH1cblxuICB2YXIgQWJyQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvZ2dlcikge1xuICAgIGZ1bmN0aW9uIEFickNvbnRyb2xsZXIoX2hscykge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfTG9nZ2VyLmNhbGwodGhpcywgJ2FicicsIF9obHMubG9nZ2VyKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgX3RoaXMubGFzdExldmVsTG9hZFNlYyA9IDA7XG4gICAgICBfdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gLTE7XG4gICAgICBfdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuICAgICAgX3RoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICAgIF90aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSAnJztcbiAgICAgIF90aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCA9IG51bGw7XG4gICAgICBfdGhpcy5jb2RlY1RpZXJzID0gbnVsbDtcbiAgICAgIF90aGlzLnRpbWVyID0gLTE7XG4gICAgICBfdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICBfdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgICBfdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICAgIF90aGlzLnJlYnVmZmVyTm90aWNlID0gLTE7XG4gICAgICBfdGhpcy5zdXBwb3J0ZWRDYWNoZSA9IHt9O1xuICAgICAgX3RoaXMuYndFc3RpbWF0b3IgPSB2b2lkIDA7XG4gICAgICAvKlxuICAgICAgICAgIFRoaXMgbWV0aG9kIG1vbml0b3JzIHRoZSBkb3dubG9hZCByYXRlIG9mIHRoZSBjdXJyZW50IGZyYWdtZW50LCBhbmQgd2lsbCBkb3duc3dpdGNoIGlmIHRoYXQgZnJhZ21lbnQgd2lsbCBub3QgbG9hZFxuICAgICAgICAgIHF1aWNrbHkgZW5vdWdoIHRvIHByZXZlbnQgdW5kZXJidWZmZXJpbmdcbiAgICAgICAgKi9cbiAgICAgIF90aGlzLl9hYmFuZG9uUnVsZXNDaGVjayA9IGZ1bmN0aW9uIChsZXZlbExvYWRlZCkge1xuICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgdmFyIF90aGlzMiA9IF90aGlzLFxuICAgICAgICAgIGZyYWcgPSBfdGhpczIuZnJhZ0N1cnJlbnQsXG4gICAgICAgICAgcGFydCA9IF90aGlzMi5wYXJ0Q3VycmVudCxcbiAgICAgICAgICBobHMgPSBfdGhpczIuaGxzO1xuICAgICAgICB2YXIgYXV0b0xldmVsRW5hYmxlZCA9IGhscy5hdXRvTGV2ZWxFbmFibGVkLFxuICAgICAgICAgIG1lZGlhID0gaGxzLm1lZGlhO1xuICAgICAgICBpZiAoIWZyYWcgfHwgIW1lZGlhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247XG4gICAgICAgIHZhciB0aW1lTG9hZGluZyA9IG5vdyAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgICAgIHZhciBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgICAgICB2YXIgbG9hZGluZ0ZyYWdGb3JMZXZlbCA9IGZyYWcubGV2ZWw7XG4gICAgICAgIHZhciBjdXJyZW50QXV0b0xldmVsID0gX3RoaXMuX25leHRBdXRvTGV2ZWw7XG4gICAgICAgIC8vIElmIGZyYWcgbG9hZGluZyBpcyBhYm9ydGVkLCBjb21wbGV0ZSwgb3IgZnJvbSBsb3dlc3QgbGV2ZWwsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgICAgICBpZiAoc3RhdHMuYWJvcnRlZCB8fCBzdGF0cy5sb2FkZWQgJiYgc3RhdHMubG9hZGVkID09PSBzdGF0cy50b3RhbCB8fCBsb2FkaW5nRnJhZ0ZvckxldmVsIDw9IG1pbkF1dG9MZXZlbCkge1xuICAgICAgICAgIF90aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAgICAgIF90aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBvbmx5IHJ1bnMgaWYgd2UncmUgaW4gQUJSIG1vZGVcbiAgICAgICAgaWYgKCFhdXRvTGV2ZWxFbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTXVzdCBiZSBsb2FkaW5nL2xvYWRlZCBhIG5ldyBsZXZlbCBvciBiZSBpbiBhIHBsYXlpbmcgc3RhdGVcbiAgICAgICAgdmFyIGZyYWdCbG9ja2luZ1N3aXRjaCA9IGN1cnJlbnRBdXRvTGV2ZWwgPiAtMSAmJiBjdXJyZW50QXV0b0xldmVsICE9PSBsb2FkaW5nRnJhZ0ZvckxldmVsO1xuICAgICAgICB2YXIgbGV2ZWxDaGFuZ2UgPSAhIWxldmVsTG9hZGVkIHx8IGZyYWdCbG9ja2luZ1N3aXRjaDtcbiAgICAgICAgaWYgKCFsZXZlbENoYW5nZSAmJiAobWVkaWEucGF1c2VkIHx8ICFtZWRpYS5wbGF5YmFja1JhdGUgfHwgIW1lZGlhLnJlYWR5U3RhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXJJbmZvID0gaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICAgICAgaWYgKCFsZXZlbENoYW5nZSAmJiBidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0dGZiRXN0aW1hdGUgPSBfdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgICAgICAgdmFyIHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKG1lZGlhLnBsYXliYWNrUmF0ZSk7XG4gICAgICAgIC8vIFRvIG1haW50YWluIHN0YWJsZSBhZGFwdGl2ZSBwbGF5YmFjaywgb25seSBiZWdpbiBtb25pdG9yaW5nIGZyYWcgbG9hZGluZyBhZnRlciBoYWxmIG9yIG1vcmUgb2YgaXRzIHBsYXliYWNrIGR1cmF0aW9uIGhhcyBwYXNzZWRcbiAgICAgICAgaWYgKHRpbWVMb2FkaW5nIDw9IE1hdGgubWF4KHR0ZmJFc3RpbWF0ZSwgMTAwMCAqIChkdXJhdGlvbiAvIChwbGF5YmFja1JhdGUgKiAyKSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuICAgICAgICB2YXIgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8ubGVuIC8gcGxheWJhY2tSYXRlIDogMDtcbiAgICAgICAgdmFyIHR0ZmIgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICAgICAgdmFyIGxvYWRlZEZpcnN0Qnl0ZSA9IHN0YXRzLmxvYWRlZCAmJiB0dGZiID4gLTE7XG4gICAgICAgIHZhciBid0VzdGltYXRlID0gX3RoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgICAgICB2YXIgbGV2ZWxzID0gaGxzLmxldmVscztcbiAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2xvYWRpbmdGcmFnRm9yTGV2ZWxdO1xuICAgICAgICB2YXIgZXhwZWN0ZWRMZW4gPSBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoZHVyYXRpb24gKiAoZnJhZy5iaXRyYXRlIHx8IGxldmVsLmF2ZXJhZ2VCaXRyYXRlKSAvIDgpKTtcbiAgICAgICAgdmFyIHRpbWVTdHJlYW1pbmcgPSBsb2FkZWRGaXJzdEJ5dGUgPyB0aW1lTG9hZGluZyAtIHR0ZmIgOiB0aW1lTG9hZGluZztcbiAgICAgICAgaWYgKHRpbWVTdHJlYW1pbmcgPCAxICYmIGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgICAgIHRpbWVTdHJlYW1pbmcgPSBNYXRoLm1pbih0aW1lTG9hZGluZywgc3RhdHMubG9hZGVkICogOCAvIGJ3RXN0aW1hdGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2FkUmF0ZSA9IGxvYWRlZEZpcnN0Qnl0ZSA/IHN0YXRzLmxvYWRlZCAqIDEwMDAgLyB0aW1lU3RyZWFtaW5nIDogMDtcbiAgICAgICAgLy8gZnJhZ0xvYWREZWxheSBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGJ1ZmZlciB0aGUgcmVtYWluZGVyIG9mIHRoZSBmcmFnbWVudFxuICAgICAgICB2YXIgdHRmYlNlY29uZHMgPSB0dGZiRXN0aW1hdGUgLyAxMDAwO1xuICAgICAgICB2YXIgZnJhZ0xvYWRlZERlbGF5ID0gbG9hZFJhdGUgPyAoZXhwZWN0ZWRMZW4gLSBzdGF0cy5sb2FkZWQpIC8gbG9hZFJhdGUgOiBleHBlY3RlZExlbiAqIDggLyBid0VzdGltYXRlICsgdHRmYlNlY29uZHM7XG4gICAgICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiB0aGUgdGltZSB0byBmaW5pc2ggbG9hZGluZyB0aGUgY3VycmVudCBmcmFnbWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIGFtb3VudCBvZiBidWZmZXIgbGVmdFxuICAgICAgICBpZiAoZnJhZ0xvYWRlZERlbGF5IDw9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYndlID0gbG9hZFJhdGUgPyBsb2FkUmF0ZSAqIDggOiBid0VzdGltYXRlO1xuICAgICAgICB2YXIgbGl2ZSA9ICgoX3JlZiA9IChsZXZlbExvYWRlZCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxMb2FkZWQuZGV0YWlscykgfHwgX3RoaXMuaGxzLmxhdGVzdExldmVsRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWYubGl2ZSkgPT09IHRydWU7XG4gICAgICAgIHZhciBhYnJCYW5kV2lkdGhVcEZhY3RvciA9IF90aGlzLmhscy5jb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG4gICAgICAgIHZhciBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHZhciBuZXh0TG9hZExldmVsO1xuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBsYXJnZXN0IG9uZSB0aGF0IGF2b2lkcyByZWJ1ZmZlcmluZ1xuICAgICAgICBmb3IgKG5leHRMb2FkTGV2ZWwgPSBsb2FkaW5nRnJhZ0ZvckxldmVsIC0gMTsgbmV4dExvYWRMZXZlbCA+IG1pbkF1dG9MZXZlbDsgbmV4dExvYWRMZXZlbC0tKSB7XG4gICAgICAgICAgLy8gY29tcHV0ZSB0aW1lIHRvIGxvYWQgbmV4dCBmcmFnbWVudCBhdCBsb3dlciBsZXZlbFxuICAgICAgICAgIC8vIDggPSBiaXRzIHBlciBieXRlIChicHMvQnBzKVxuICAgICAgICAgIHZhciBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLm1heEJpdHJhdGU7XG4gICAgICAgICAgdmFyIHJlcXVpcmVzTGV2ZWxMb2FkID0gIWxldmVsc1tuZXh0TG9hZExldmVsXS5kZXRhaWxzIHx8IGxpdmU7XG4gICAgICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gX3RoaXMuZ2V0VGltZVRvTG9hZEZyYWcodHRmYlNlY29uZHMsIGJ3ZSwgZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlLCByZXF1aXJlc0xldmVsTG9hZCk7XG4gICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IE1hdGgubWluKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgZHVyYXRpb24gKyB0dGZiU2Vjb25kcykpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZCBvZiBjb250aW51aW5nXG4gICAgICAgIC8vIHRvIGxvYWQgdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPj0gZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZXN0aW1hdGVkIGxvYWQgdGltZSBvZiBuZXcgc2VnbWVudCBpcyBjb21wbGV0ZWx5IHVucmVhc29uYWJsZSwgaWdub3JlIGFuZCBkbyBub3QgZW1lcmdlbmN5IHN3aXRjaCBkb3duXG4gICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPiBkdXJhdGlvbiAqIDEwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBoYXMgYmVlbiBsb2FkaW5nIHByb2dyZXNzLCBzYW1wbGUgYmFuZHdpZHRoIHVzaW5nIGxvYWRpbmcgdGltZSBvZmZzZXQgYnkgbWluaW11bSBUVEZCIHRpbWVcbiAgICAgICAgICBfdGhpcy5id0VzdGltYXRvci5zYW1wbGUodGltZUxvYWRpbmcgLSBNYXRoLm1pbih0dGZiRXN0aW1hdGUsIHR0ZmIpLCBzdGF0cy5sb2FkZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIG5vIGxvYWRpbmcgcHJvZ3Jlc3MsIHNhbXBsZSBUVEZCXG4gICAgICAgICAgX3RoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQih0aW1lTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRMb2FkTGV2ZWxCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLm1heEJpdHJhdGU7XG4gICAgICAgIGlmIChfdGhpcy5nZXRCd0VzdGltYXRlKCkgKiBhYnJCYW5kV2lkdGhVcEZhY3RvciA+IG5leHRMb2FkTGV2ZWxCaXRyYXRlKSB7XG4gICAgICAgICAgX3RoaXMucmVzZXRFc3RpbWF0b3IobmV4dExvYWRMZXZlbEJpdHJhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZXN0U3dpdGNoTGV2ZWwgPSBfdGhpcy5maW5kQmVzdExldmVsKG5leHRMb2FkTGV2ZWxCaXRyYXRlLCBtaW5BdXRvTGV2ZWwsIG5leHRMb2FkTGV2ZWwsIDAsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgMSwgMSk7XG4gICAgICAgIGlmIChiZXN0U3dpdGNoTGV2ZWwgPiAtMSkge1xuICAgICAgICAgIG5leHRMb2FkTGV2ZWwgPSBiZXN0U3dpdGNoTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgbGV2ZWwgXCIgKyBsb2FkaW5nRnJhZ0ZvckxldmVsICsgXCIgaXMgbG9hZGluZyB0b28gc2xvd2x5O1xcbiAgICAgIEZyYWdtZW50IGR1cmF0aW9uOiBcIiArIGZyYWcuZHVyYXRpb24udG9GaXhlZCgzKSArIFwiXFxuICAgICAgVGltZSB0byB1bmRlcmJ1ZmZlcjogXCIgKyBidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgzKSArIFwiIHNcXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciBjdXJyZW50IGZyYWdtZW50OiBcIiArIGZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDMpICsgXCIgc1xcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGRvd24gc3dpdGNoIGZyYWdtZW50OiBcIiArIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDMpICsgXCIgc1xcbiAgICAgIFRURkIgZXN0aW1hdGU6IFwiICsgKHR0ZmIgfCAwKSArIFwiIG1zXFxuICAgICAgQ3VycmVudCBCVyBlc3RpbWF0ZTogXCIgKyAoaXNGaW5pdGVOdW1iZXIoYndFc3RpbWF0ZSkgPyBid0VzdGltYXRlIHwgMCA6ICdVbmtub3duJykgKyBcIiBicHNcXG4gICAgICBOZXcgQlcgZXN0aW1hdGU6IFwiICsgKF90aGlzLmdldEJ3RXN0aW1hdGUoKSB8IDApICsgXCIgYnBzXFxuICAgICAgU3dpdGNoaW5nIHRvIGxldmVsIFwiICsgbmV4dExvYWRMZXZlbCArIFwiIEAgXCIgKyAobmV4dExvYWRMZXZlbEJpdHJhdGUgfCAwKSArIFwiIGJwc1wiKTtcbiAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBobHMubmV4dEF1dG9MZXZlbCA9IG5leHRMb2FkTGV2ZWw7XG4gICAgICAgIF90aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgdmFyIGFib3J0QW5kU3dpdGNoID0gZnVuY3Rpb24gYWJvcnRBbmRTd2l0Y2goKSB7XG4gICAgICAgICAgLy8gQXJlIG5leHRMb2FkTGV2ZWwgZGV0YWlscyBhdmFpbGFibGUgb3IgaXMgc3RyZWFtLWNvbnRyb2xsZXIgc3RpbGwgaW4gXCJXQUlUSU5HX0xFVkVMXCIgc3RhdGU/XG4gICAgICAgICAgX3RoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgIGlmIChfdGhpcy5mcmFnQ3VycmVudCA9PT0gZnJhZyAmJiBfdGhpcy5obHMubG9hZExldmVsID09PSBuZXh0TG9hZExldmVsICYmIG5leHRMb2FkTGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICB2YXIgX2J1ZmZlclN0YXJ2YXRpb25EZWxheSA9IF90aGlzLmdldFN0YXJ2YXRpb25EZWxheSgpO1xuICAgICAgICAgICAgX3RoaXMud2FybihcIkFib3J0aW5nIGluZmxpZ2h0IHJlcXVlc3QgXCIgKyAobmV4dExvYWRMZXZlbCA+IDAgPyAnYW5kIHN3aXRjaGluZyBkb3duJyA6ICcnKSArIFwiXFxuICAgICAgRnJhZ21lbnQgZHVyYXRpb246IFwiICsgZnJhZy5kdXJhdGlvbi50b0ZpeGVkKDMpICsgXCIgc1xcbiAgICAgIFRpbWUgdG8gdW5kZXJidWZmZXI6IFwiICsgX2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDMpICsgXCIgc1wiKTtcbiAgICAgICAgICAgIGZyYWcuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgICAgX3RoaXMuZnJhZ0N1cnJlbnQgPSBfdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobmV4dExvYWRMZXZlbCA+IG1pbkF1dG9MZXZlbCkge1xuICAgICAgICAgICAgICB2YXIgbG93ZXN0U3dpdGNoTGV2ZWwgPSBfdGhpcy5maW5kQmVzdExldmVsKF90aGlzLmhscy5sZXZlbHNbbWluQXV0b0xldmVsXS5iaXRyYXRlLCBtaW5BdXRvTGV2ZWwsIG5leHRMb2FkTGV2ZWwsIDAsIF9idWZmZXJTdGFydmF0aW9uRGVsYXksIDEsIDEpO1xuICAgICAgICAgICAgICBpZiAobG93ZXN0U3dpdGNoTGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbG93ZXN0U3dpdGNoTGV2ZWwgPSBtaW5BdXRvTGV2ZWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMuaGxzLm5leHRMb2FkTGV2ZWwgPSBfdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IGxvd2VzdFN3aXRjaExldmVsO1xuICAgICAgICAgICAgICBfdGhpcy5yZXNldEVzdGltYXRvcihfdGhpcy5obHMubGV2ZWxzW2xvd2VzdFN3aXRjaExldmVsXS5iaXRyYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChmcmFnQmxvY2tpbmdTd2l0Y2ggfHwgZnJhZ0xvYWRlZERlbGF5ID4gZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ICogMikge1xuICAgICAgICAgIGFib3J0QW5kU3dpdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKGFib3J0QW5kU3dpdGNoLCBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgIHN0YXRzOiBzdGF0c1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5obHMgPSBfaGxzO1xuICAgICAgX3RoaXMuYndFc3RpbWF0b3IgPSBfdGhpcy5pbml0RXN0aW1hdG9yKCk7XG4gICAgICBfdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHNMb29zZShBYnJDb250cm9sbGVyLCBfTG9nZ2VyKTtcbiAgICB2YXIgX3Byb3RvID0gQWJyQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlc2V0RXN0aW1hdG9yID0gZnVuY3Rpb24gcmVzZXRFc3RpbWF0b3IoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkge1xuICAgICAgaWYgKGFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHtcbiAgICAgICAgdGhpcy5sb2coXCJzZXR0aW5nIGluaXRpYWwgYndlIHRvIFwiICsgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gICAgICAgIHRoaXMuaGxzLmNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlID0gYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3IgPSB0aGlzLmluaXRFc3RpbWF0b3IoKTtcbiAgICB9O1xuICAgIF9wcm90by5pbml0RXN0aW1hdG9yID0gZnVuY3Rpb24gaW5pdEVzdGltYXRvcigpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICByZXR1cm4gbmV3IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IoY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QsIGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcbiAgICB9O1xuICAgIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1BWF9BVVRPX0xFVkVMX1VQREFURUQsIHRoaXMub25NYXhBdXRvTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoIWhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQVhfQVVUT19MRVZFTF9VUERBVEVELCB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmhscyA9IHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrID0gdGhpcy5zdXBwb3J0ZWRDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gLTE7XG4gICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAwO1xuICAgICAgdGhpcy5zdXBwb3J0ZWRDYWNoZSA9IHt9O1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5vbkxldmVsc1VwZGF0ZWQoKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxzVXBkYXRlZCgpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPiAtMSAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IHRoaXMuZnJhZ0N1cnJlbnQubGV2ZWw7XG4gICAgICB9XG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCgpO1xuICAgICAgdGhpcy5jb2RlY1RpZXJzID0gbnVsbDtcbiAgICAgIHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5vbk1heEF1dG9MZXZlbFVwZGF0ZWQgPSBmdW5jdGlvbiBvbk1heEF1dG9MZXZlbFVwZGF0ZWQoKSB7XG4gICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSAnJztcbiAgICB9O1xuICAgIF9wcm90by5vbkZyYWdMb2FkaW5nID0gZnVuY3Rpb24gb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgdmFyIF9kYXRhJHBhcnQ7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICB0aGlzLnBhcnRDdXJyZW50ID0gKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpICE9IG51bGwgPyBfZGF0YSRwYXJ0IDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2ssIDEwMCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbFN3aXRjaGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICAgIC8vIFJlc2V0IGxhc3QgbG9hZGVkIGxldmVsIHNvIHRoYXQgYSBuZXcgc2VsZWN0aW9uIGNhbiBiZSBtYWRlIGFmdGVyIGNhbGxpbmcgcmVjb3Zlck1lZGlhRXJyb3JcbiAgICAgICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAtMTtcbiAgICAgICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgICAgICAgcGFydCA9IHRoaXMucGFydEN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoZnJhZyAmJiBmcmFnQ3VycmVudCAmJiBmcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJiBmcmFnLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCkge1xuICAgICAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgICAgICAgICAgdmFyIHRpbWVMb2FkaW5nID0gbm93IC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgICAgICAgICAgdmFyIHR0ZmIgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICAgICAgICAgICAgdmFyIGxvYWRlZEZpcnN0Qnl0ZSA9IHN0YXRzLmxvYWRlZCAmJiB0dGZiID4gLTE7XG4gICAgICAgICAgICAgIGlmIChsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHRmYkVzdGltYXRlID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZSh0aW1lTG9hZGluZyAtIE1hdGgubWluKHR0ZmJFc3RpbWF0ZSwgdHRmYiksIHN0YXRzLmxvYWRlZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGVUVEZCKHRpbWVMb2FkaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldFRpbWVUb0xvYWRGcmFnID0gZnVuY3Rpb24gZ2V0VGltZVRvTG9hZEZyYWcodGltZVRvRmlyc3RCeXRlU2VjLCBiYW5kd2lkdGgsIGZyYWdTaXplQml0cywgaXNTd2l0Y2gpIHtcbiAgICAgIHZhciBmcmFnTG9hZFNlYyA9IHRpbWVUb0ZpcnN0Qnl0ZVNlYyArIGZyYWdTaXplQml0cyAvIGJhbmR3aWR0aDtcbiAgICAgIHZhciBwbGF5bGlzdExvYWRTZWMgPSBpc1N3aXRjaCA/IHRpbWVUb0ZpcnN0Qnl0ZVNlYyArIHRoaXMubGFzdExldmVsTG9hZFNlYyA6IDA7XG4gICAgICByZXR1cm4gZnJhZ0xvYWRTZWMgKyBwbGF5bGlzdExvYWRTZWM7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICB2YXIgbG9hZGluZyA9IGRhdGEuc3RhdHMubG9hZGluZztcbiAgICAgIHZhciB0aW1lTG9hZGluZ01zID0gbG9hZGluZy5lbmQgLSBsb2FkaW5nLmZpcnN0O1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKHRpbWVMb2FkaW5nTXMpKSB7XG4gICAgICAgIHRoaXMubGFzdExldmVsTG9hZFNlYyA9IHRpbWVMb2FkaW5nTXMgLyAxMDAwO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZGV0YWlscy5saXZlKSB7XG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd0xpdmUsIGNvbmZpZy5hYnJFd21hRmFzdExpdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGltZXIgPiAtMSkge1xuICAgICAgICB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjayhkYXRhLmxldmVsSW5mbyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZGVkKGV2ZW50LCBfcmVmMikge1xuICAgICAgdmFyIGZyYWcgPSBfcmVmMi5mcmFnLFxuICAgICAgICBwYXJ0ID0gX3JlZjIucGFydDtcbiAgICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGVUVEZCKHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlnbm9yZUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICBpZiAoZnJhZy5sZXZlbCA9PT0gdGhpcy5fbmV4dEF1dG9MZXZlbCkge1xuICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG5cbiAgICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmFick1heFdpdGhSZWFsQml0cmF0ZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgdmFyIGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgc3RhdHMubG9hZGVkO1xuICAgICAgICB2YXIgbG9hZGVkRHVyYXRpb24gPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmR1cmF0aW9uIDogMCkgKyBkdXJhdGlvbjtcbiAgICAgICAgbGV2ZWwubG9hZGVkID0ge1xuICAgICAgICAgIGJ5dGVzOiBsb2FkZWRCeXRlcyxcbiAgICAgICAgICBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgbGV2ZWwucmVhbEJpdHJhdGUgPSBNYXRoLnJvdW5kKDggKiBsb2FkZWRCeXRlcyAvIGxvYWRlZER1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHZhciBmcmFnQnVmZmVyZWREYXRhID0ge1xuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKEV2ZW50cy5GUkFHX0JVRkZFUkVELCBmcmFnQnVmZmVyZWREYXRhKTtcbiAgICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkIGZvciBwbGF5YmFja1xuICAgICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuICAgICAgdmFyIHN0YXRzID0gcGFydCAhPSBudWxsICYmIHBhcnQuc3RhdHMubG9hZGVkID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBVc2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBwYXJzaW5nIGFuZCByZXF1ZXN0IGluc3RlYWQgb2YgYnVmZmVyaW5nIGFuZCByZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nO1xuICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgYnVmZmVyIGFwcGVuZGluZyBvbmx5IGhhcHBlbnMgb25jZSBtZWRpYSBpcyBhdHRhY2hlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoXG4gICAgICAvLyBpcyB1c2VkLiBJZiB3ZSB1c2VkIGJ1ZmZlcmluZyBpbiB0aGF0IGNhc2UsIG91ciBCVyBlc3RpbWF0ZSBzYW1wbGUgd2lsbCBiZSB2ZXJ5IGxhcmdlLlxuICAgICAgdmFyIHByb2Nlc3NpbmdNcyA9IHN0YXRzLnBhcnNpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5zdGFydCAtIE1hdGgubWluKHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0LCB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpKTtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHByb2Nlc3NpbmdNcywgc3RhdHMubG9hZGVkKTtcbiAgICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLmdldEJ3RXN0aW1hdGUoKTtcbiAgICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IHByb2Nlc3NpbmdNcyAvIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSAwO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmlnbm9yZUZyYWdtZW50ID0gZnVuY3Rpb24gaWdub3JlRnJhZ21lbnQoZnJhZykge1xuICAgICAgLy8gT25seSBjb3VudCBub24tYWx0LWF1ZGlvIGZyYWdzIHdoaWNoIHdlcmUgYWN0dWFsbHkgYnVmZmVyZWQgaW4gb3VyIEJXIGNhbGN1bGF0aW9uc1xuICAgICAgcmV0dXJuIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFyVGltZXIgPSBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgICAgaWYgKHRoaXMudGltZXIgPiAtMSkge1xuICAgICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZXRBdXRvTGV2ZWxLZXkgPSBmdW5jdGlvbiBnZXRBdXRvTGV2ZWxLZXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCd0VzdGltYXRlKCkgKyBcIl9cIiArIHRoaXMuZ2V0U3RhcnZhdGlvbkRlbGF5KCkudG9GaXhlZCgyKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXROZXh0QUJSQXV0b0xldmVsID0gZnVuY3Rpb24gZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIHtcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICAgIHBhcnRDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoaGxzLmxldmVscy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gaGxzLmxvYWRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHZhciBtYXhBdXRvTGV2ZWwgPSBobHMubWF4QXV0b0xldmVsLFxuICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgICAgdmFyIGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG4gICAgICB2YXIgYXZnYncgPSB0aGlzLmdldEJ3RXN0aW1hdGUoKTtcbiAgICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgICB2YXIgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gdGhpcy5nZXRTdGFydmF0aW9uRGVsYXkoKTtcbiAgICAgIHZhciBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3I7XG4gICAgICB2YXIgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcblxuICAgICAgLy8gRmlyc3QsIGxvb2sgdG8gc2VlIGlmIHdlIGNhbiBmaW5kIGEgbGV2ZWwgbWF0Y2hpbmcgd2l0aCBvdXIgYXZnIGJhbmR3aWR0aCBBTkQgdGhhdCBjb3VsZCBhbHNvIGd1YXJhbnRlZSBubyByZWJ1ZmZlcmluZyBhdCBhbGxcbiAgICAgIGlmIChidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgdmFyIF9iZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIDAsIGJ3RmFjdG9yLCBid1VwRmFjdG9yKTtcbiAgICAgICAgaWYgKF9iZXN0TGV2ZWwgPj0gMCkge1xuICAgICAgICAgIHRoaXMucmVidWZmZXJOb3RpY2UgPSAtMTtcbiAgICAgICAgICByZXR1cm4gX2Jlc3RMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIGdldCByaWQgb2YgcmVidWZmZXJpbmcuLi4gdHJ5IHRvIGZpbmQgbGV2ZWwgdGhhdCB3aWxsIGd1YXJhbnRlZSBsZXNzIHRoYW4gbWF4U3RhcnZhdGlvbkRlbGF5IG9mIHJlYnVmZmVyaW5nXG4gICAgICB2YXIgbWF4U3RhcnZhdGlvbkRlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXkpIDogY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheTtcbiAgICAgIGlmICghYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcbiAgICAgICAgdmFyIGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcbiAgICAgICAgICAvLyBtYXggdmlkZW8gbG9hZGluZyBkZWxheSB1c2VkIGluICBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uIDpcbiAgICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxuICAgICAgICAgIC8vIGNhcCBtYXhMb2FkaW5nRGVsYXkgYW5kIGVuc3VyZSBpdCBpcyBub3QgYmlnZ2VyICd0aGFuIGJpdHJhdGUgdGVzdCcgZnJhZyBkdXJhdGlvblxuICAgICAgICAgIHZhciBtYXhMb2FkaW5nRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heExvYWRpbmdEZWxheSkgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xuICAgICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA9IG1heExvYWRpbmdEZWxheSAtIGJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgICAgdGhpcy5pbmZvKFwiYml0cmF0ZSB0ZXN0IHRvb2sgXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBiaXRyYXRlVGVzdERlbGF5KSArIFwibXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byBcIiArIE1hdGgucm91bmQoMTAwMCAqIG1heFN0YXJ2YXRpb25EZWxheSkgKyBcIiBtc1wiKTtcbiAgICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yKTtcbiAgICAgIGlmICh0aGlzLnJlYnVmZmVyTm90aWNlICE9PSBiZXN0TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5yZWJ1ZmZlck5vdGljZSA9IGJlc3RMZXZlbDtcbiAgICAgICAgdGhpcy5pbmZvKChidWZmZXJTdGFydmF0aW9uRGVsYXkgPyAncmVidWZmZXJpbmcgZXhwZWN0ZWQnIDogJ2J1ZmZlciBpcyBlbXB0eScpICsgXCIsIG9wdGltYWwgcXVhbGl0eSBsZXZlbCBcIiArIGJlc3RMZXZlbCk7XG4gICAgICB9XG4gICAgICBpZiAoYmVzdExldmVsID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGJlc3RMZXZlbDtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBzZWUgaWYgbWluIGF1dG8gbGV2ZWwgd291bGQgYmUgYSBiZXR0ZXIgb3B0aW9uXG4gICAgICB2YXIgbWluTGV2ZWwgPSBobHMubGV2ZWxzW21pbkF1dG9MZXZlbF07XG4gICAgICB2YXIgYXV0b0xldmVsID0gaGxzLmxvYWRMZXZlbE9iajtcbiAgICAgIGlmIChhdXRvTGV2ZWwgJiYgKG1pbkxldmVsID09IG51bGwgPyB2b2lkIDAgOiBtaW5MZXZlbC5iaXRyYXRlKSA8IGF1dG9MZXZlbC5iaXRyYXRlKSB7XG4gICAgICAgIHJldHVybiBtaW5BdXRvTGV2ZWw7XG4gICAgICB9XG4gICAgICAvLyBvciBpZiBiaXRyYXRlIGlzIG5vdCBsb3dlciwgY29udGludWUgdG8gdXNlIGxvYWRMZXZlbFxuICAgICAgcmV0dXJuIGhscy5sb2FkTGV2ZWw7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0U3RhcnZhdGlvbkRlbGF5ID0gZnVuY3Rpb24gZ2V0U3RhcnZhdGlvbkRlbGF5KCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIG1lZGlhID0gaGxzLm1lZGlhO1xuICAgICAgaWYgKCFtZWRpYSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICAvLyBwbGF5YmFja1JhdGUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBwbGF5YmFjayByYXRlOyBpZiBtZWRpYS5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xuICAgICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cbiAgICAgIHZhciBwbGF5YmFja1JhdGUgPSBtZWRpYSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDAgPyBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpIDogMS4wO1xuICAgICAgdmFyIGJ1ZmZlckluZm8gPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgICAgcmV0dXJuIChidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAwKSAvIHBsYXliYWNrUmF0ZTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRCd0VzdGltYXRlID0gZnVuY3Rpb24gZ2V0QndFc3RpbWF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiB0aGlzLmhscy5jb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcbiAgICB9O1xuICAgIF9wcm90by5maW5kQmVzdExldmVsID0gZnVuY3Rpb24gZmluZEJlc3RMZXZlbChjdXJyZW50QncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIG1heFN0YXJ2YXRpb25EZWxheSwgYndGYWN0b3IsIGJ3VXBGYWN0b3IpIHtcbiAgICAgIHZhciBfdGhpcyRobHMkbGF0ZXN0TGV2ZWwsXG4gICAgICAgIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgbWF4RmV0Y2hEdXJhdGlvbiA9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSArIG1heFN0YXJ2YXRpb25EZWxheTtcbiAgICAgIHZhciBsYXN0TG9hZGVkRnJhZ0xldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsO1xuICAgICAgdmFyIHNlbGVjdGlvbkJhc2VMZXZlbCA9IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPT09IC0xID8gdGhpcy5obHMuZmlyc3RMZXZlbCA6IGxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICBwYXJ0Q3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQ7XG4gICAgICB2YXIgX3RoaXMkaGxzID0gdGhpcy5obHMsXG4gICAgICAgIGxldmVscyA9IF90aGlzJGhscy5sZXZlbHMsXG4gICAgICAgIGFsbEF1ZGlvVHJhY2tzID0gX3RoaXMkaGxzLmFsbEF1ZGlvVHJhY2tzLFxuICAgICAgICBsb2FkTGV2ZWwgPSBfdGhpcyRobHMubG9hZExldmVsLFxuICAgICAgICBjb25maWcgPSBfdGhpcyRobHMuY29uZmlnO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbc2VsZWN0aW9uQmFzZUxldmVsXTtcbiAgICAgIHZhciBsaXZlID0gISEoKF90aGlzJGhscyRsYXRlc3RMZXZlbCA9IHRoaXMuaGxzLmxhdGVzdExldmVsRGV0YWlscykgIT0gbnVsbCAmJiBfdGhpcyRobHMkbGF0ZXN0TGV2ZWwubGl2ZSk7XG4gICAgICB2YXIgZmlyc3RTZWxlY3Rpb24gPSBsb2FkTGV2ZWwgPT09IC0xIHx8IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPT09IC0xO1xuICAgICAgdmFyIGN1cnJlbnRDb2RlY1NldDtcbiAgICAgIHZhciBjdXJyZW50VmlkZW9SYW5nZSA9ICdTRFInO1xuICAgICAgdmFyIGN1cnJlbnRGcmFtZVJhdGUgPSAobGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmZyYW1lUmF0ZSkgfHwgMDtcbiAgICAgIHZhciBhdWRpb1ByZWZlcmVuY2UgPSBjb25maWcuYXVkaW9QcmVmZXJlbmNlLFxuICAgICAgICB2aWRlb1ByZWZlcmVuY2UgPSBjb25maWcudmlkZW9QcmVmZXJlbmNlO1xuICAgICAgdmFyIGF1ZGlvVHJhY2tzQnlHcm91cCA9IHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwIHx8ICh0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCA9IGdldEF1ZGlvVHJhY2tzQnlHcm91cChhbGxBdWRpb1RyYWNrcykpO1xuICAgICAgdmFyIG1pblN0YXJ0SW5kZXggPSAtMTtcbiAgICAgIGlmIChmaXJzdFNlbGVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5maXJzdFNlbGVjdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdFNlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZWNUaWVycyA9IHRoaXMuY29kZWNUaWVycyB8fCAodGhpcy5jb2RlY1RpZXJzID0gZ2V0Q29kZWNUaWVycyhsZXZlbHMsIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwpKTtcbiAgICAgICAgdmFyIHN0YXJ0VGllciA9IGdldFN0YXJ0Q29kZWNUaWVyKGNvZGVjVGllcnMsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSwgdmlkZW9QcmVmZXJlbmNlKTtcbiAgICAgICAgdmFyIGNvZGVjU2V0ID0gc3RhcnRUaWVyLmNvZGVjU2V0LFxuICAgICAgICAgIHZpZGVvUmFuZ2VzID0gc3RhcnRUaWVyLnZpZGVvUmFuZ2VzLFxuICAgICAgICAgIG1pbkZyYW1lcmF0ZSA9IHN0YXJ0VGllci5taW5GcmFtZXJhdGUsXG4gICAgICAgICAgbWluQml0cmF0ZSA9IHN0YXJ0VGllci5taW5CaXRyYXRlLFxuICAgICAgICAgIG1pbkluZGV4ID0gc3RhcnRUaWVyLm1pbkluZGV4LFxuICAgICAgICAgIHByZWZlckhEUiA9IHN0YXJ0VGllci5wcmVmZXJIRFI7XG4gICAgICAgIG1pblN0YXJ0SW5kZXggPSBtaW5JbmRleDtcbiAgICAgICAgY3VycmVudENvZGVjU2V0ID0gY29kZWNTZXQ7XG4gICAgICAgIGN1cnJlbnRWaWRlb1JhbmdlID0gcHJlZmVySERSID8gdmlkZW9SYW5nZXNbdmlkZW9SYW5nZXMubGVuZ3RoIC0gMV0gOiB2aWRlb1Jhbmdlc1swXTtcbiAgICAgICAgY3VycmVudEZyYW1lUmF0ZSA9IG1pbkZyYW1lcmF0ZTtcbiAgICAgICAgY3VycmVudEJ3ID0gTWF0aC5tYXgoY3VycmVudEJ3LCBtaW5CaXRyYXRlKTtcbiAgICAgICAgdGhpcy5sb2coXCJwaWNrZWQgc3RhcnQgdGllciBcIiArIHN0cmluZ2lmeShzdGFydFRpZXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRDb2RlY1NldCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5jb2RlY1NldDtcbiAgICAgICAgY3VycmVudFZpZGVvUmFuZ2UgPSBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWwudmlkZW9SYW5nZTtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50RnJhZ0R1cmF0aW9uID0gcGFydEN1cnJlbnQgPyBwYXJ0Q3VycmVudC5kdXJhdGlvbiA6IGZyYWdDdXJyZW50ID8gZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwO1xuICAgICAgdmFyIHR0ZmJFc3RpbWF0ZVNlYyA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCkgLyAxMDAwO1xuICAgICAgdmFyIGxldmVsc1NraXBwZWQgPSBbXTtcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgIHZhciBfbGV2ZWxJbmZvJHN1cHBvcnRlZFI7XG4gICAgICAgICAgdmFyIGxldmVsSW5mbyA9IGxldmVsc1tpXTtcbiAgICAgICAgICB2YXIgdXBTd2l0Y2ggPSBpID4gc2VsZWN0aW9uQmFzZUxldmVsO1xuICAgICAgICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbmZpZy51c2VNZWRpYUNhcGFiaWxpdGllcyAmJiAhbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCAmJiAhbGV2ZWxJbmZvLnN1cHBvcnRlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHZhciBtZWRpYUNhcGFiaWxpdGllcyA9IG5hdmlnYXRvci5tZWRpYUNhcGFiaWxpdGllcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG1lZGlhQ2FwYWJpbGl0aWVzID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYUNhcGFiaWxpdGllcy5kZWNvZGluZ0luZm8pID09PSAnZnVuY3Rpb24nICYmIHJlcXVpcmVzTWVkaWFDYXBhYmlsaXRpZXNEZWNvZGluZ0luZm8obGV2ZWxJbmZvLCBhdWRpb1RyYWNrc0J5R3JvdXAsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50RnJhbWVSYXRlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgbGV2ZWxJbmZvLnN1cHBvcnRlZFByb21pc2UgPSBnZXRNZWRpYURlY29kaW5nSW5mb1Byb21pc2UobGV2ZWxJbmZvLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1lZGlhQ2FwYWJpbGl0aWVzLCBfdGhpczMuc3VwcG9ydGVkQ2FjaGUpO1xuICAgICAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkZWNvZGluZ0luZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzMy5obHMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCA9IGRlY29kaW5nSW5mbztcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhscy5sZXZlbHM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGV2ZWxzLmluZGV4T2YobGV2ZWxJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjb2RpbmdJbmZvLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczMud2FybihcIk1lZGlhQ2FwYWJpbGl0aWVzIGRlY29kaW5nSW5mbyBlcnJvcjogXFxcIlwiICsgZGVjb2RpbmdJbmZvLmVycm9yICsgXCJcXFwiIGZvciBsZXZlbCBcIiArIGluZGV4ICsgXCIgXCIgKyBzdHJpbmdpZnkoZGVjb2RpbmdJbmZvKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZGVjb2RpbmdJbmZvLnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLndhcm4oXCJVbnN1cHBvcnRlZCBNZWRpYUNhcGFiaWxpdGllcyBkZWNvZGluZ0luZm8gcmVzdWx0IGZvciBsZXZlbCBcIiArIGluZGV4ICsgXCIgXCIgKyBzdHJpbmdpZnkoZGVjb2RpbmdJbmZvKSk7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSAmJiBsZXZlbHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMubG9nKFwiUmVtb3ZpbmcgdW5zdXBwb3J0ZWQgbGV2ZWwgXCIgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMy5obHMucmVtb3ZlTGV2ZWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLmhscy5sb2FkTGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLmhscy5uZXh0TG9hZExldmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjb2RpbmdJbmZvLmRlY29kaW5nSW5mb1Jlc3VsdHMuc29tZShmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZm8uc21vb3RoID09PSBmYWxzZSB8fCBpbmZvLnBvd2VyRWZmaWNpZW50ID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLmxvZyhcIk1lZGlhQ2FwYWJpbGl0aWVzIGRlY29kaW5nSW5mbyBmb3IgbGV2ZWwgXCIgKyBpbmRleCArIFwiIG5vdCBzbW9vdGggb3IgcG93ZXJFZmZpY2llbnQ6IFwiICsgc3RyaW5naWZ5KGRlY29kaW5nSW5mbykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLndhcm4oXCJFcnJvciBoYW5kbGluZyBNZWRpYUNhcGFiaWxpdGllcyBkZWNvZGluZ0luZm86IFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgPSBTVVBQT1JURURfSU5GT19ERUZBVUxUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNraXAgY2FuZGlkYXRlcyB3aGljaCBjaGFuZ2UgY29kZWMtZmFtaWx5IG9yIHZpZGVvLXJhbmdlLFxuICAgICAgICAgIC8vIGFuZCB3aGljaCBkZWNyZWFzZSBvciBpbmNyZWFzZSBmcmFtZS1yYXRlIGZvciB1cCBhbmQgZG93bi1zd2l0Y2ggcmVzcGVjdGZ1bGx5XG4gICAgICAgICAgaWYgKGN1cnJlbnRDb2RlY1NldCAmJiBsZXZlbEluZm8uY29kZWNTZXQgIT09IGN1cnJlbnRDb2RlY1NldCB8fCBjdXJyZW50VmlkZW9SYW5nZSAmJiBsZXZlbEluZm8udmlkZW9SYW5nZSAhPT0gY3VycmVudFZpZGVvUmFuZ2UgfHwgdXBTd2l0Y2ggJiYgY3VycmVudEZyYW1lUmF0ZSA+IGxldmVsSW5mby5mcmFtZVJhdGUgfHwgIXVwU3dpdGNoICYmIGN1cnJlbnRGcmFtZVJhdGUgPiAwICYmIGN1cnJlbnRGcmFtZVJhdGUgPCBsZXZlbEluZm8uZnJhbWVSYXRlIHx8IChfbGV2ZWxJbmZvJHN1cHBvcnRlZFIgPSBsZXZlbEluZm8uc3VwcG9ydGVkUmVzdWx0KSAhPSBudWxsICYmIChfbGV2ZWxJbmZvJHN1cHBvcnRlZFIgPSBfbGV2ZWxJbmZvJHN1cHBvcnRlZFIuZGVjb2RpbmdJbmZvUmVzdWx0cykgIT0gbnVsbCAmJiBfbGV2ZWxJbmZvJHN1cHBvcnRlZFIuc29tZShmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIGluZm8uc21vb3RoID09PSBmYWxzZTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdFNlbGVjdGlvbiB8fCBpICE9PSBtaW5TdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgIGxldmVsc1NraXBwZWQucHVzaChpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICAgICAgICB2YXIgYXZnRHVyYXRpb24gPSAocGFydEN1cnJlbnQgPyBsZXZlbERldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0IDogbGV2ZWxEZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbERldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uKSB8fCBjdXJyZW50RnJhZ0R1cmF0aW9uO1xuICAgICAgICAgIHZhciBhZGp1c3RlZGJ3O1xuICAgICAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAgICAgLy8gaHR0cHM6Ly9hbmRyb2lkLmdvb2dsZXNvdXJjZS5jb20vcGxhdGZvcm0vZnJhbWV3b3Jrcy9hdi8rL21hc3Rlci9tZWRpYS9saWJzdGFnZWZyaWdodC9odHRwbGl2ZS9MaXZlU2Vzc2lvbi5jcHBcbiAgICAgICAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICAgICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAgICAgLy8gYmUgZXZlbiBtb3JlIGNvbnNlcnZhdGl2ZSAoNzAlKSB0byBhdm9pZCBvdmVyZXN0aW1hdGluZyBhbmQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAvLyBzd2l0Y2hpbmcgYmFjay5cbiAgICAgICAgICBpZiAoIXVwU3dpdGNoKSB7XG4gICAgICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVzZSBhdmVyYWdlIGJpdHJhdGUgd2hlbiBzdGFydmF0aW9uIGRlbGF5IChidWZmZXIgbGVuZ3RoKSBpcyBndCBvciBlcSB0d28gc2VnbWVudCBkdXJhdGlvbnMgYW5kIHJlYnVmZmVyaW5nIGlzIG5vdCBleHBlY3RlZCAobWF4U3RhcnZhdGlvbkRlbGF5ID4gMClcbiAgICAgICAgICB2YXIgYml0cmF0ZSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gJiYgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID49IGN1cnJlbnRGcmFnRHVyYXRpb24gKiAyICYmIG1heFN0YXJ2YXRpb25EZWxheSA9PT0gMCA/IGxldmVsSW5mby5hdmVyYWdlQml0cmF0ZSA6IGxldmVsSW5mby5tYXhCaXRyYXRlO1xuICAgICAgICAgIHZhciBmZXRjaER1cmF0aW9uID0gX3RoaXMzLmdldFRpbWVUb0xvYWRGcmFnKHR0ZmJFc3RpbWF0ZVNlYywgYWRqdXN0ZWRidywgYml0cmF0ZSAqIGF2Z0R1cmF0aW9uLCBsZXZlbERldGFpbHMgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgdmFyIGNhblN3aXRjaFdpdGhpblRvbGVyYW5jZSA9XG4gICAgICAgICAgLy8gaWYgYWRqdXN0ZWQgYncgaXMgZ3JlYXRlciB0aGFuIGxldmVsIGJpdHJhdGUgQU5EXG4gICAgICAgICAgYWRqdXN0ZWRidyA+PSBiaXRyYXRlICYmIChcbiAgICAgICAgICAvLyBubyBsZXZlbCBjaGFuZ2UsIG9yIG5ldyBsZXZlbCBoYXMgbm8gZXJyb3IgaGlzdG9yeVxuICAgICAgICAgIGkgPT09IGxhc3RMb2FkZWRGcmFnTGV2ZWwgfHwgbGV2ZWxJbmZvLmxvYWRFcnJvciA9PT0gMCAmJiBsZXZlbEluZm8uZnJhZ21lbnRFcnJvciA9PT0gMCkgJiYgKFxuICAgICAgICAgIC8vIGZyYWdtZW50IGZldGNoRHVyYXRpb24gdW5rbm93biBPUiBsaXZlIHN0cmVhbSBPUiBmcmFnbWVudCBmZXRjaER1cmF0aW9uIGxlc3MgdGhhbiBtYXggYWxsb3dlZCBmZXRjaCBkdXJhdGlvbiwgdGhlbiB0aGlzIGxldmVsIG1hdGNoZXNcbiAgICAgICAgICAvLyB3ZSBkb24ndCBhY2NvdW50IGZvciBtYXggRmV0Y2ggRHVyYXRpb24gZm9yIGxpdmUgc3RyZWFtcywgdGhpcyBpcyB0byBhdm9pZCBzd2l0Y2hpbmcgZG93biB3aGVuIG5lYXIgdGhlIGVkZ2Ugb2YgbGl2ZSBzbGlkaW5nIHdpbmRvdyAuLi5cbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBzdGFydExldmVsID0gLTEgKGJpdHJhdGVUZXN0KSBvbiBsaXZlIHN0cmVhbXMgOiBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIG5vdCBleGl0IGxvb3Agc28gdGhhdCBmaW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICAgICAgZmV0Y2hEdXJhdGlvbiA8PSB0dGZiRXN0aW1hdGVTZWMgfHwgIWlzRmluaXRlTnVtYmVyKGZldGNoRHVyYXRpb24pIHx8IGxpdmUgJiYgIV90aGlzMy5iaXRyYXRlVGVzdERlbGF5IHx8IGZldGNoRHVyYXRpb24gPCBtYXhGZXRjaER1cmF0aW9uKTtcbiAgICAgICAgICBpZiAoY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB2YXIgZm9yY2VkQXV0b0xldmVsID0gX3RoaXMzLmZvcmNlZEF1dG9MZXZlbDtcbiAgICAgICAgICAgIGlmIChpICE9PSBsb2FkTGV2ZWwgJiYgKGZvcmNlZEF1dG9MZXZlbCA9PT0gLTEgfHwgZm9yY2VkQXV0b0xldmVsICE9PSBsb2FkTGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbHNTa2lwcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF90aGlzMy50cmFjZShcIlNraXBwZWQgbGV2ZWwocykgXCIgKyBsZXZlbHNTa2lwcGVkLmpvaW4oJywnKSArIFwiIG9mIFwiICsgbWF4QXV0b0xldmVsICsgXCIgbWF4IHdpdGggQ09ERUNTIGFuZCBWSURFTy1SQU5HRTpcXFwiXCIgKyBsZXZlbHNbbGV2ZWxzU2tpcHBlZFswXV0uY29kZWNzICsgXCJcXFwiIFwiICsgbGV2ZWxzW2xldmVsc1NraXBwZWRbMF1dLnZpZGVvUmFuZ2UgKyBcIjsgbm90IGNvbXBhdGlibGUgd2l0aCBcXFwiXCIgKyBjdXJyZW50Q29kZWNTZXQgKyBcIlxcXCIgXCIgKyBjdXJyZW50VmlkZW9SYW5nZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMzLmluZm8oXCJzd2l0Y2ggY2FuZGlkYXRlOlwiICsgc2VsZWN0aW9uQmFzZUxldmVsICsgXCItPlwiICsgaSArIFwiIGFkanVzdGVkYncoXCIgKyBNYXRoLnJvdW5kKGFkanVzdGVkYncpICsgXCIpLWJpdHJhdGU9XCIgKyBNYXRoLnJvdW5kKGFkanVzdGVkYncgLSBiaXRyYXRlKSArIFwiIHR0ZmI6XCIgKyB0dGZiRXN0aW1hdGVTZWMudG9GaXhlZCgxKSArIFwiIGF2Z0R1cmF0aW9uOlwiICsgYXZnRHVyYXRpb24udG9GaXhlZCgxKSArIFwiIG1heEZldGNoRHVyYXRpb246XCIgKyBtYXhGZXRjaER1cmF0aW9uLnRvRml4ZWQoMSkgKyBcIiBmZXRjaER1cmF0aW9uOlwiICsgZmV0Y2hEdXJhdGlvbi50b0ZpeGVkKDEpICsgXCIgZmlyc3RTZWxlY3Rpb246XCIgKyBmaXJzdFNlbGVjdGlvbiArIFwiIGNvZGVjU2V0OlwiICsgbGV2ZWxJbmZvLmNvZGVjU2V0ICsgXCIgdmlkZW9SYW5nZTpcIiArIGxldmVsSW5mby52aWRlb1JhbmdlICsgXCIgaGxzLmxvYWRMZXZlbDpcIiArIGxvYWRMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmZpcnN0U2VsZWN0aW9uID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2OiBpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3JldDtcbiAgICAgIGZvciAodmFyIGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgICAgX3JldCA9IF9sb29wKCk7XG4gICAgICAgIGlmIChfcmV0ID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKF9yZXQpIHJldHVybiBfcmV0LnY7XG4gICAgICB9XG4gICAgICAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgX3Byb3RvLmRlcml2ZU5leHRBdXRvTGV2ZWwgPSBmdW5jdGlvbiBkZXJpdmVOZXh0QXV0b0xldmVsKG5leHRMZXZlbCkge1xuICAgICAgdmFyIF90aGlzJGhsczIgPSB0aGlzLmhscyxcbiAgICAgICAgbWF4QXV0b0xldmVsID0gX3RoaXMkaGxzMi5tYXhBdXRvTGV2ZWwsXG4gICAgICAgIG1pbkF1dG9MZXZlbCA9IF90aGlzJGhsczIubWluQXV0b0xldmVsO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG5leHRMZXZlbCwgbWluQXV0b0xldmVsKSwgbWF4QXV0b0xldmVsKTtcbiAgICB9O1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQWJyQ29udHJvbGxlciwgW3tcbiAgICAgIGtleTogXCJmaXJzdEF1dG9MZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRobHMzID0gdGhpcy5obHMsXG4gICAgICAgICAgbWF4QXV0b0xldmVsID0gX3RoaXMkaGxzMy5tYXhBdXRvTGV2ZWwsXG4gICAgICAgICAgbWluQXV0b0xldmVsID0gX3RoaXMkaGxzMy5taW5BdXRvTGV2ZWw7XG4gICAgICAgIHZhciBid0VzdGltYXRlID0gdGhpcy5nZXRCd0VzdGltYXRlKCk7XG4gICAgICAgIHZhciBtYXhTdGFydERlbGF5ID0gdGhpcy5obHMuY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheTtcbiAgICAgICAgdmFyIGFickF1dG9MZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChid0VzdGltYXRlLCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgMCwgbWF4U3RhcnREZWxheSwgMSwgMSk7XG4gICAgICAgIGlmIChhYnJBdXRvTGV2ZWwgPiAtMSkge1xuICAgICAgICAgIHJldHVybiBhYnJBdXRvTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0TGV2ZWwgPSB0aGlzLmhscy5maXJzdExldmVsO1xuICAgICAgICB2YXIgY2xhbXBlZCA9IE1hdGgubWluKE1hdGgubWF4KGZpcnN0TGV2ZWwsIG1pbkF1dG9MZXZlbCksIG1heEF1dG9MZXZlbCk7XG4gICAgICAgIHRoaXMud2FybihcIkNvdWxkIG5vdCBmaW5kIGJlc3Qgc3RhcnRpbmcgYXV0byBsZXZlbC4gRGVmYXVsdGluZyB0byBmaXJzdCBpbiBwbGF5bGlzdCBcIiArIGZpcnN0TGV2ZWwgKyBcIiBjbGFtcGVkIHRvIFwiICsgY2xhbXBlZCk7XG4gICAgICAgIHJldHVybiBjbGFtcGVkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JjZWRBdXRvTGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0QXV0b0xldmVsS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICAgICAgfVxuXG4gICAgICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXG4gICAgfSwge1xuICAgICAga2V5OiBcIm5leHRBdXRvTGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgZm9yY2VkQXV0b0xldmVsID0gdGhpcy5mb3JjZWRBdXRvTGV2ZWw7XG4gICAgICAgIHZhciBid0VzdGltYXRvciA9IHRoaXMuYndFc3RpbWF0b3I7XG4gICAgICAgIHZhciB1c2VFc3RpbWF0ZSA9IGJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCk7XG4gICAgICAgIHZhciBsb2FkZWRGaXJzdEZyYWcgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPiAtMTtcbiAgICAgICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcbiAgICAgICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEgJiYgKCF1c2VFc3RpbWF0ZSB8fCAhbG9hZGVkRmlyc3RGcmFnIHx8IHRoaXMubmV4dEF1dG9MZXZlbEtleSA9PT0gdGhpcy5nZXRBdXRvTGV2ZWxLZXkoKSkpIHtcbiAgICAgICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tcHV0ZSBuZXh0IGxldmVsIHVzaW5nIEFCUiBsb2dpY1xuICAgICAgICB2YXIgbmV4dEFCUkF1dG9MZXZlbCA9IHVzZUVzdGltYXRlICYmIGxvYWRlZEZpcnN0RnJhZyA/IHRoaXMuZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIDogdGhpcy5maXJzdEF1dG9MZXZlbDtcblxuICAgICAgICAvLyB1c2UgZm9yY2VkIGF1dG8gbGV2ZWwgd2hpbGUgaXQgaGFzbid0IGVycm9yZWQgbW9yZSB0aGFuIEFCUiBzZWxlY3Rpb25cbiAgICAgICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgICAgIGlmIChsZXZlbHMubGVuZ3RoID4gTWF0aC5tYXgoZm9yY2VkQXV0b0xldmVsLCBuZXh0QUJSQXV0b0xldmVsKSAmJiBsZXZlbHNbZm9yY2VkQXV0b0xldmVsXS5sb2FkRXJyb3IgPD0gbGV2ZWxzW25leHRBQlJBdXRvTGV2ZWxdLmxvYWRFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYXZlIHJlc3VsdCB1bnRpbCBzdGF0ZSBoYXMgY2hhbmdlZFxuICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dEFCUkF1dG9MZXZlbDtcbiAgICAgICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gdGhpcy5nZXRBdXRvTGV2ZWxLZXkoKTtcbiAgICAgICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dExldmVsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZGVyaXZlTmV4dEF1dG9MZXZlbChuZXh0TGV2ZWwpO1xuICAgICAgICBpZiAodGhpcy5fbmV4dEF1dG9MZXZlbCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSAnJztcbiAgICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oTG9nZ2VyKTtcblxuICB2YXIgQmluYXJ5U2VhcmNoID0ge1xuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBhbiBpdGVtIGluIGFuIGFycmF5IHdoaWNoIG1hdGNoZXMgYSBjZXJ0YWluIGNvbmRpdGlvbi5cbiAgICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIGNvbXBhcmlzb25GblxuICAgICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBvYmplY3QgaWYgZm91bmQsIG90aGVyd2lzZSByZXR1cm5zIG51bGxcbiAgICAgKi9cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIHNlYXJjaChsaXN0LCBjb21wYXJpc29uRm4pIHtcbiAgICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgICB2YXIgbWF4SW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IG51bGw7XG4gICAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuICAgICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GbihjdXJyZW50RWxlbWVudCk7XG4gICAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaXJzdCBmcmFnbWVudCB3aG9zZSBlbmRQZHQgdmFsdWUgZXhjZWVkcyB0aGUgZ2l2ZW4gUERULCBvciBudWxsLlxuICAgKiBAcGFyYW0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAgICogQHBhcmFtIFBEVFZhbHVlIC0gVGhlIFBEVCB2YWx1ZSB3aGljaCBtdXN0IGJlIGV4Y2VlZGVkXG4gICAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICAgKi9cbiAgZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICAgIGlmIChQRFRWYWx1ZSA9PT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShmcmFnbWVudHMpIHx8ICFmcmFnbWVudHMubGVuZ3RoIHx8ICFpc0Zpbml0ZU51bWJlcihQRFRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICAgIHZhciBzdGFydFBEVCA9IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgaWYgKFBEVFZhbHVlIDwgKHN0YXJ0UERUIHx8IDApKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVuZFBEVCA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lO1xuICAgIGlmIChQRFRWYWx1ZSA+PSAoZW5kUERUIHx8IDApKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgc2VnID0gMDsgc2VnIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytzZWcpIHtcbiAgICAgIHZhciBmcmFnID0gZnJhZ21lbnRzW3NlZ107XG4gICAgICBpZiAocGR0V2l0aGluVG9sZXJhbmNlVGVzdChQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZykpIHtcbiAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAgICogVGhpcyBtZXRob2QgY29tcGVuc2F0ZXMgZm9yIHNtYWxsIGJ1ZmZlciBnYXBzIGJ5IGFwcGx5aW5nIGEgdG9sZXJhbmNlIHRvIHRoZSBzdGFydCBvZiBhbnkgY2FuZGlkYXRlIGZyYWdtZW50LCB0aHVzXG4gICAqIGJyZWFraW5nIGFueSB0cmFwcyB3aGljaCB3b3VsZCBjYXVzZSB0aGUgc2FtZSBmcmFnbWVudCB0byBiZSBjb250aW51b3VzbHkgc2VsZWN0ZWQgd2l0aGluIGEgc21hbGwgcmFuZ2UuXG4gICAqIEBwYXJhbSBmcmFnUHJldmlvdXMgLSBUaGUgbGFzdCBmcmFnIHN1Y2Nlc3NmdWxseSBhcHBlbmRlZFxuICAgKiBAcGFyYW0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAgICogQHBhcmFtIGJ1ZmZlckVuZCAtIFRoZSBlbmQgb2YgdGhlIGNvbnRpZ3VvdXMgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAgICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gICAqIEByZXR1cm5zIGEgbWF0Y2hpbmcgZnJhZ21lbnQgb3IgbnVsbFxuICAgKi9cbiAgZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgbmV4dEZyYWdMb29rdXBUb2xlcmFuY2UpIHtcbiAgICBpZiAoYnVmZmVyRW5kID09PSB2b2lkIDApIHtcbiAgICAgIGJ1ZmZlckVuZCA9IDA7XG4gICAgfVxuICAgIGlmIChtYXhGcmFnTG9va1VwVG9sZXJhbmNlID09PSB2b2lkIDApIHtcbiAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwO1xuICAgIH1cbiAgICBpZiAobmV4dEZyYWdMb29rdXBUb2xlcmFuY2UgPT09IHZvaWQgMCkge1xuICAgICAgbmV4dEZyYWdMb29rdXBUb2xlcmFuY2UgPSAwLjAwNTtcbiAgICB9XG4gICAgdmFyIGZyYWdOZXh0ID0gbnVsbDtcbiAgICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1sxICsgZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuXSB8fCBudWxsO1xuICAgICAgLy8gY2hlY2sgZm9yIGJ1ZmZlci1lbmQgcm91bmRpbmcgZXJyb3JcbiAgICAgIHZhciBidWZmZXJFZGdlRXJyb3IgPSBmcmFnUHJldmlvdXMuZW5kRFRTIC0gYnVmZmVyRW5kO1xuICAgICAgaWYgKGJ1ZmZlckVkZ2VFcnJvciA+IDAgJiYgYnVmZmVyRWRnZUVycm9yIDwgMC4wMDAwMDE1KSB7XG4gICAgICAgIGJ1ZmZlckVuZCArPSAwLjAwMDAwMTU7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ05leHQgJiYgZnJhZ1ByZXZpb3VzLmxldmVsICE9PSBmcmFnTmV4dC5sZXZlbCAmJiBmcmFnTmV4dC5lbmQgPD0gZnJhZ1ByZXZpb3VzLmVuZCkge1xuICAgICAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1syICsgZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuXSB8fCBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYnVmZmVyRW5kID09PSAwICYmIGZyYWdtZW50c1swXS5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZ05leHQgPSBmcmFnbWVudHNbMF07XG4gICAgfVxuICAgIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgICBpZiAoZnJhZ05leHQgJiYgKCghZnJhZ1ByZXZpb3VzIHx8IGZyYWdQcmV2aW91cy5sZXZlbCA9PT0gZnJhZ05leHQubGV2ZWwpICYmIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdOZXh0KSA9PT0gMCB8fCBmcmFnbWVudFdpdGhpbkZhc3RTdGFydFN3aXRjaChmcmFnTmV4dCwgZnJhZ1ByZXZpb3VzLCBNYXRoLm1pbihuZXh0RnJhZ0xvb2t1cFRvbGVyYW5jZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpKSkge1xuICAgICAgcmV0dXJuIGZyYWdOZXh0O1xuICAgIH1cbiAgICAvLyBXZSBtaWdodCBiZSBzZWVraW5nIHBhc3QgdGhlIHRvbGVyYW5jZSBzbyBmaW5kIHRoZSBiZXN0IG1hdGNoXG4gICAgdmFyIGZvdW5kRnJhZ21lbnQgPSBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0LmJpbmQobnVsbCwgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSk7XG4gICAgaWYgKGZvdW5kRnJhZ21lbnQgJiYgKGZvdW5kRnJhZ21lbnQgIT09IGZyYWdQcmV2aW91cyB8fCAhZnJhZ05leHQpKSB7XG4gICAgICByZXR1cm4gZm91bmRGcmFnbWVudDtcbiAgICB9XG4gICAgLy8gSWYgbm8gbWF0Y2ggd2FzIGZvdW5kIHJldHVybiB0aGUgbmV4dCBmcmFnbWVudCBhZnRlciBmcmFnUHJldmlvdXMsIG9yIG51bGxcbiAgICByZXR1cm4gZnJhZ05leHQ7XG4gIH1cbiAgZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5GYXN0U3RhcnRTd2l0Y2goZnJhZ05leHQsIGZyYWdQcmV2aW91cywgbmV4dEZyYWdMb29rdXBUb2xlcmFuY2UpIHtcbiAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWdQcmV2aW91cy5zdGFydCA9PT0gMCAmJiBmcmFnUHJldmlvdXMubGV2ZWwgPCBmcmFnTmV4dC5sZXZlbCAmJiAoZnJhZ1ByZXZpb3VzLmVuZFBUUyB8fCAwKSA+IDApIHtcbiAgICAgIHZhciBmaXJzdER1cmF0aW9uID0gZnJhZ1ByZXZpb3VzLnRhZ0xpc3QucmVkdWNlKGZ1bmN0aW9uIChkdXJhdGlvbiwgdGFnKSB7XG4gICAgICAgIGlmICh0YWdbMF0gPT09ICdJTkYnKSB7XG4gICAgICAgICAgZHVyYXRpb24gKz0gcGFyc2VGbG9hdCh0YWdbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICAgIH0sIG5leHRGcmFnTG9va3VwVG9sZXJhbmNlKTtcbiAgICAgIHJldHVybiBmcmFnTmV4dC5zdGFydCA8PSBmaXJzdER1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlTbidzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAgICogQHBhcmFtIGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gICAqIEBwYXJhbSBidWZmZXJFbmQgLSBUaGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gICAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gICAqIEByZXR1cm5zIDAgaWYgaXQgbWF0Y2hlcywgMSBpZiB0b28gbG93LCAtMSBpZiB0b28gaGlnaFxuICAgKi9cbiAgZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlKSB7XG4gICAgaWYgKGJ1ZmZlckVuZCA9PT0gdm9pZCAwKSB7XG4gICAgICBidWZmZXJFbmQgPSAwO1xuICAgIH1cbiAgICBpZiAobWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMDtcbiAgICB9XG4gICAgLy8gZWFnZXJseSBhY2NlcHQgYW4gYWNjdXJhdGUgbWF0Y2ggKG5vIHRvbGVyYW5jZSlcbiAgICBpZiAoY2FuZGlkYXRlLnN0YXJ0IDw9IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gPiBidWZmZXJFbmQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gICAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAgIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAgIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgIC8vIGxvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gICAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgICB2YXIgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKTtcbiAgICBpZiAoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9IGJ1ZmZlckVuZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgICAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVBkdCdzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAgICogVGhpcyBmdW5jdGlvbiB0ZXN0cyB0aGUgY2FuZGlkYXRlJ3MgcHJvZ3JhbSBkYXRlIHRpbWUgdmFsdWVzLCBhcyByZXByZXNlbnRlZCBpbiBVbml4IHRpbWVcbiAgICogQHBhcmFtIGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gICAqIEBwYXJhbSBwZHRCdWZmZXJFbmQgLSBUaGUgVW5peCB0aW1lIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlXG4gICAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gICAqIEByZXR1cm5zIHRydWUgaWYgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBmdW5jdGlvbiBwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KHBkdEJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlKSB7XG4gICAgdmFyIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSkgKiAxMDAwO1xuXG4gICAgLy8gZW5kUHJvZ3JhbURhdGVUaW1lIGNhbiBiZSBudWxsLCBkZWZhdWx0IHRvIHplcm9cbiAgICB2YXIgZW5kUHJvZ3JhbURhdGVUaW1lID0gY2FuZGlkYXRlLmVuZFByb2dyYW1EYXRlVGltZSB8fCAwO1xuICAgIHJldHVybiBlbmRQcm9ncmFtRGF0ZVRpbWUgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBwZHRCdWZmZXJFbmQ7XG4gIH1cbiAgZnVuY3Rpb24gZmluZE5lYXJlc3RXaXRoQ0MoZGV0YWlscywgY2MsIHBvcykge1xuICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICBpZiAoZGV0YWlscy5zdGFydENDIDw9IGNjICYmIGRldGFpbHMuZW5kQ0MgPj0gY2MpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgICB2YXIgZnJhZ21lbnRIaW50ID0gZGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gICAgICAgIGlmIChmcmFnbWVudEhpbnQpIHtcbiAgICAgICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0KGZyYWdtZW50SGludCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsb3Nlc3Q7XG4gICAgICAgIEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZS5jYyA8IGNjKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZS5jYyA+IGNjKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsb3Nlc3QgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZS5lbmQgPD0gcG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZS5zdGFydCA+IHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9zZXN0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUaW1lb3V0RXJyb3IoZXJyb3IpIHtcbiAgICBzd2l0Y2ggKGVycm9yLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVDpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpc0tleUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmRldGFpbHMuc3RhcnRzV2l0aCgna2V5Jyk7XG4gIH1cbiAgZnVuY3Rpb24gaXNVbnVzYWJsZUtleUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzS2V5RXJyb3IoZXJyb3IpICYmICEhZXJyb3IuZnJhZyAmJiAhZXJyb3IuZnJhZy5kZWNyeXB0ZGF0YTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSZXRyeUNvbmZpZyhsb2FkUG9saWN5LCBlcnJvcikge1xuICAgIHZhciBpc1RpbWVvdXQgPSBpc1RpbWVvdXRFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGxvYWRQb2xpY3kuZGVmYXVsdFsoaXNUaW1lb3V0ID8gJ3RpbWVvdXQnIDogJ2Vycm9yJykgKyBcIlJldHJ5XCJdO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHJldHJ5Q291bnQpIHtcbiAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBtYXggcmV0cnkgZGVsYXlcbiAgICB2YXIgYmFja29mZkZhY3RvciA9IHJldHJ5Q29uZmlnLmJhY2tvZmYgPT09ICdsaW5lYXInID8gMSA6IE1hdGgucG93KDIsIHJldHJ5Q291bnQpO1xuICAgIHJldHVybiBNYXRoLm1pbihiYWNrb2ZmRmFjdG9yICogcmV0cnlDb25maWcucmV0cnlEZWxheU1zLCByZXRyeUNvbmZpZy5tYXhSZXRyeURlbGF5TXMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMobG9kZXJDb25maWcpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGxvZGVyQ29uZmlnKSwge1xuICAgICAgZXJyb3JSZXRyeTogbnVsbCxcbiAgICAgIHRpbWVvdXRSZXRyeTogbnVsbFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBpc1RpbWVvdXQsIGxvYWRlclJlc3BvbnNlKSB7XG4gICAgaWYgKCFyZXRyeUNvbmZpZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaHR0cFN0YXR1cyA9IGxvYWRlclJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZXJSZXNwb25zZS5jb2RlO1xuICAgIHZhciByZXRyeSA9IHJldHJ5Q291bnQgPCByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSAmJiAocmV0cnlGb3JIdHRwU3RhdHVzKGh0dHBTdGF0dXMpIHx8ICEhaXNUaW1lb3V0KTtcbiAgICByZXR1cm4gcmV0cnlDb25maWcuc2hvdWxkUmV0cnkgPyByZXRyeUNvbmZpZy5zaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgaXNUaW1lb3V0LCBsb2FkZXJSZXNwb25zZSwgcmV0cnkpIDogcmV0cnk7XG4gIH1cbiAgZnVuY3Rpb24gcmV0cnlGb3JIdHRwU3RhdHVzKGh0dHBTdGF0dXMpIHtcbiAgICAvLyBEbyBub3QgcmV0cnkgb24gc3RhdHVzIDR4eCwgc3RhdHVzIDAgKENPUlMgZXJyb3IpLCBvciB1bmRlZmluZWQgKGRlY3J5cHQvZ2FwL3BhcnNlIGVycm9yKVxuICAgIHJldHVybiBvZmZsaW5lSHR0cFN0YXR1cyhodHRwU3RhdHVzKSB8fCAhIWh0dHBTdGF0dXMgJiYgKGh0dHBTdGF0dXMgPCA0MDAgfHwgaHR0cFN0YXR1cyA+IDQ5OSk7XG4gIH1cbiAgZnVuY3Rpb24gb2ZmbGluZUh0dHBTdGF0dXMoaHR0cFN0YXR1cykge1xuICAgIHJldHVybiBodHRwU3RhdHVzID09PSAwICYmIG5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlO1xuICB9XG5cbiAgdmFyIE5ldHdvcmtFcnJvckFjdGlvbiA9IHtcbiAgICBEb05vdGhpbmc6IDAsXG4gICAgU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDogMixcbiAgICBSZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseTogMyxcbiAgICBSZXRyeVJlcXVlc3Q6IDVcbiAgfTtcbiAgdmFyIEVycm9yQWN0aW9uRmxhZ3MgPSB7XG4gICAgTm9uZTogMCxcbiAgICBNb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDogMSxcbiAgICBNb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUDogMixcbiAgICBNb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nS2V5OiA0fTtcbiAgdmFyIEVycm9yQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvZ2dlcikge1xuICAgIGZ1bmN0aW9uIEVycm9yQ29udHJvbGxlcihobHMpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX0xvZ2dlci5jYWxsKHRoaXMsICdlcnJvci1jb250cm9sbGVyJywgaGxzLmxvZ2dlcikgfHwgdGhpcztcbiAgICAgIF90aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIF90aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgICAgX3RoaXMuaGxzID0gaGxzO1xuICAgICAgX3RoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoRXJyb3JDb250cm9sbGVyLCBfTG9nZ2VyKTtcbiAgICB2YXIgX3Byb3RvID0gRXJyb3JDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmICghaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvck91dCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmhscyA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9O1xuICAgIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRWYXJpYW50TGV2ZWxJbmRleCA9IGZ1bmN0aW9uIGdldFZhcmlhbnRMZXZlbEluZGV4KGZyYWcpIHtcbiAgICAgIGlmICgoZnJhZyA9PSBudWxsID8gdm9pZCAwIDogZnJhZy50eXBlKSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgICByZXR1cm4gZnJhZy5sZXZlbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldFZhcmlhbnRJbmRleCgpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFZhcmlhbnRJbmRleCA9IGZ1bmN0aW9uIGdldFZhcmlhbnRJbmRleCgpIHtcbiAgICAgIHZhciBfaGxzJGxvYWRMZXZlbE9iajtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgaWYgKChfaGxzJGxvYWRMZXZlbE9iaiA9IGhscy5sb2FkTGV2ZWxPYmopICE9IG51bGwgJiYgX2hscyRsb2FkTGV2ZWxPYmouZGV0YWlscyB8fCBjdXJyZW50TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBobHMubG9hZExldmVsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICB9O1xuICAgIF9wcm90by52YXJpYW50SGFzS2V5ID0gZnVuY3Rpb24gdmFyaWFudEhhc0tleShsZXZlbCwga2V5SW5FcnJvcikge1xuICAgICAgaWYgKGxldmVsKSB7XG4gICAgICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICAgICAgaWYgKChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpICE9IG51bGwgJiYgX2xldmVsJGRldGFpbHMuaGFzS2V5KGtleUluRXJyb3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF1ZGlvR3JvdXBzSWRzID0gbGV2ZWwuYXVkaW9Hcm91cHM7XG4gICAgICAgIGlmIChhdWRpb0dyb3Vwc0lkcykge1xuICAgICAgICAgIHZhciBhdWRpb1RyYWNrcyA9IHRoaXMuaGxzLmFsbEF1ZGlvVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBhdWRpb0dyb3Vwc0lkcy5pbmRleE9mKHRyYWNrLmdyb3VwSWQpID49IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGF1ZGlvVHJhY2tzLnNvbWUoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RyYWNrJGRldGFpbHM7XG4gICAgICAgICAgICByZXR1cm4gKF90cmFjayRkZXRhaWxzID0gdHJhY2suZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmFjayRkZXRhaWxzLmhhc0tleShrZXlJbkVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbFVwZGF0ZWQoKSB7XG4gICAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgX2RhdGEkZnJhZztcbiAgICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0O1xuICAgICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICAgICAgLy8gaWdub3JlIGVtcHR5IHNlZ21lbnQgZXJyb3JzIG1hcmtlZCBhcyBnYXBcbiAgICAgICAgICBpZiAoKF9kYXRhJGZyYWcgPSBkYXRhLmZyYWcpICE9IG51bGwgJiYgX2RhdGEkZnJhZy5nYXApIHtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSBjcmVhdGVEb05vdGhpbmdFcnJvckFjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFN3aXRjaCBsZXZlbCBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGFsbG93IHJldHJ5IGNvdW50IHRvIHJlYWNoIG1heCBlcnJvciByZXRyaWVzXG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uYWN0aW9uID0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2RhdGEkY29udGV4dDtcbiAgICAgICAgICAgIC8vIE9ubHkgcmV0cnkgd2hlbiBlbXB0eSBhbmQgbGl2ZVxuICAgICAgICAgICAgdmFyIGxldmVsSW5kZXggPSBkYXRhLnBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGRhdGEubGV2ZWwgOiBobHMubG9hZExldmVsO1xuICAgICAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SICYmICEhKChfZGF0YSRjb250ZXh0ID0gZGF0YS5jb250ZXh0KSAhPSBudWxsICYmIChfZGF0YSRjb250ZXh0ID0gX2RhdGEkY29udGV4dC5sZXZlbERldGFpbHMpICE9IG51bGwgJiYgX2RhdGEkY29udGV4dC5saXZlKSkge1xuICAgICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFc2NhbGF0ZSB0byBmYXRhbCBpZiBub3QgcmV0cnlpbmcgb3Igc3dpdGNoaW5nXG4gICAgICAgICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgaWYgKHR5cGVvZiAoY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5sZXZlbCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgY29udGV4dC5sZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5TVUJUSVRMRV9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IGhscy5sb2FkTGV2ZWxPYmo7XG4gICAgICAgICAgICBpZiAobGV2ZWwgJiYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBsZXZlbC5oYXNBdWRpb0dyb3VwKGNvbnRleHQuZ3JvdXBJZCkgfHwgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGxldmVsLmhhc1N1YnRpdGxlR3JvdXAoY29udGV4dC5ncm91cElkKSkpIHtcbiAgICAgICAgICAgICAgLy8gUGVyZm9ybSBQYXRod2F5IHN3aXRjaCBvciBSZWR1bmRhbnQgZmFpbG92ZXIgaWYgcG9zc2libGUgZm9yIGZhc3Rlc3QgcmVjb3ZlcnlcbiAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGFsbG93IHBsYXlsaXN0IHJldHJ5IGNvdW50IHRvIHJlYWNoIG1heCBlcnJvciByZXRyaWVzXG4gICAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBobHMubG9hZExldmVsKTtcbiAgICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5hY3Rpb24gPSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDtcbiAgICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5mbGFncyA9IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRDpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nS2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICAgIC8vIEJ1ZmZlci1jb250cm9sbGVyIGNhbiBzZXQgZXJyb3JBY3Rpb24gd2hlbiBhcHBlbmQgZXJyb3JzIGNhbiBiZSBpZ25vcmVkIG9yIHJlc29sdmVkIGxvY2FsbHlcbiAgICAgICAgICBpZiAoIWRhdGEuZXJyb3JBY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfZGF0YSRsZXZlbDtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIChfZGF0YSRsZXZlbCA9IGRhdGEubGV2ZWwpICE9IG51bGwgPyBfZGF0YSRsZXZlbCA6IGhscy5sb2FkTGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRTpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX05VREdFX09OX1NUQUxMOlxuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSBjcmVhdGVEb05vdGhpbmdFcnJvckFjdGlvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnR5cGUgPT09IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUikge1xuICAgICAgICAvLyBEbyBub3QgcmV0cnkgbGV2ZWwuIFNob3VsZCBiZSBmYXRhbCBpZiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV88RVJST1I+IG5vdCBoYW5kbGVkIHdpdGggZWFybHkgcmV0dXJuIGFib3ZlLlxuICAgICAgICBkYXRhLmxldmVsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IGNyZWF0ZURvTm90aGluZ0Vycm9yQWN0aW9uKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHZhciByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKGhscy5jb25maWcucGxheWxpc3RMb2FkUG9saWN5LCBkYXRhKTtcbiAgICAgIHZhciByZXRyeUNvdW50ID0gdGhpcy5wbGF5bGlzdEVycm9yKys7XG4gICAgICB2YXIgcmV0cnkgPSBzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgaXNUaW1lb3V0RXJyb3IoZGF0YSksIGRhdGEucmVzcG9uc2UpO1xuICAgICAgaWYgKHJldHJ5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0LFxuICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmUsXG4gICAgICAgICAgcmV0cnlDb25maWc6IHJldHJ5Q29uZmlnLFxuICAgICAgICAgIHJldHJ5Q291bnQ6IHJldHJ5Q291bnRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICBpZiAocmV0cnlDb25maWcpIHtcbiAgICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb25maWcgPSByZXRyeUNvbmZpZztcbiAgICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb3VudCA9IHJldHJ5Q291bnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3JBY3Rpb247XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAvLyBTaGFyZSBmcmFnbWVudCBlcnJvciBjb3VudCBhY2Nyb3NzIG1lZGlhIG9wdGlvbnMgKG1haW4sIGF1ZGlvLCBzdWJzKVxuICAgICAgLy8gVGhpcyBhbGxvd3MgZm9yIGxldmVsIGJhc2VkIHJlbmRpdGlvbiBzd2l0Y2hpbmcgd2hlbiBtZWRpYSBvcHRpb24gYXNzZXRzIGZhaWxcbiAgICAgIHZhciB2YXJpYW50TGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICAgIHZhciBsZXZlbCA9IGhscy5sZXZlbHNbdmFyaWFudExldmVsSW5kZXhdO1xuICAgICAgdmFyIF9obHMkY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgZnJhZ0xvYWRQb2xpY3kgPSBfaGxzJGNvbmZpZy5mcmFnTG9hZFBvbGljeSxcbiAgICAgICAga2V5TG9hZFBvbGljeSA9IF9obHMkY29uZmlnLmtleUxvYWRQb2xpY3k7XG4gICAgICB2YXIgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhpc0tleUVycm9yKGRhdGEpID8ga2V5TG9hZFBvbGljeSA6IGZyYWdMb2FkUG9saWN5LCBkYXRhKTtcbiAgICAgIHZhciBmcmFnbWVudEVycm9ycyA9IGhscy5sZXZlbHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGxldmVsKSB7XG4gICAgICAgIHJldHVybiBhY2MgKyBsZXZlbC5mcmFnbWVudEVycm9yO1xuICAgICAgfSwgMCk7XG4gICAgICAvLyBTd2l0Y2ggbGV2ZWxzIHdoZW4gb3V0IG9mIHJldHJpZWQgb3IgbGV2ZWwgaW5kZXggb3V0IG9mIGJvdW5kc1xuICAgICAgaWYgKGxldmVsKSB7XG4gICAgICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCkge1xuICAgICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW51c2FibGVLZXlFcnJvcihkYXRhKSkge1xuICAgICAgICAgIHZhciByZXRyeSA9IHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCBmcmFnbWVudEVycm9ycywgaXNUaW1lb3V0RXJyb3IoZGF0YSksIGRhdGEucmVzcG9uc2UpO1xuICAgICAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0LFxuICAgICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgICAgICByZXRyeUNvbmZpZzogcmV0cnlDb25maWcsXG4gICAgICAgICAgICAgIHJldHJ5Q291bnQ6IGZyYWdtZW50RXJyb3JzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVhY2ggbWF4IHJldHJ5IGNvdW50LCBvciBNaXNzaW5nIGxldmVsIHJlZmVyZW5jZVxuICAgICAgLy8gU3dpdGNoIHRvIHZhbGlkIGluZGV4XG4gICAgICB2YXIgZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIHZhcmlhbnRMZXZlbEluZGV4KTtcbiAgICAgIC8vIEFkZCByZXRyeSBkZXRhaWxzIHRvIGFsbG93IHNraXBwaW5nIG9mIEZSQUdfUEFSU0lOR19FUlJPUlxuICAgICAgaWYgKHJldHJ5Q29uZmlnKSB7XG4gICAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q29uZmlnID0gcmV0cnlDb25maWc7XG4gICAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q291bnQgPSBmcmFnbWVudEVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvckFjdGlvbjtcbiAgICB9O1xuICAgIF9wcm90by5nZXRMZXZlbFN3aXRjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmIChsZXZlbEluZGV4ID09PSBudWxsIHx8IGxldmVsSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbEluZGV4ID0gaGxzLmxvYWRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICAgIGlmIChsZXZlbCkge1xuICAgICAgICB2YXIgX2RhdGEkZnJhZzIsIF9kYXRhJGNvbnRleHQyO1xuICAgICAgICB2YXIgZXJyb3JEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IrKztcbiAgICAgICAgaWYgKGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpIHtcbiAgICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VhcmNoIGZvciBuZXh0IGxldmVsIHRvIHJldHJ5XG4gICAgICAgIHZhciBuZXh0TGV2ZWwgPSAtMTtcbiAgICAgICAgdmFyIGxldmVscyA9IGhscy5sZXZlbHMsXG4gICAgICAgICAgbG9hZExldmVsID0gaGxzLmxvYWRMZXZlbCxcbiAgICAgICAgICBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsLFxuICAgICAgICAgIG1heEF1dG9MZXZlbCA9IGhscy5tYXhBdXRvTGV2ZWw7XG4gICAgICAgIGlmICghaGxzLmF1dG9MZXZlbEVuYWJsZWQgJiYgIWhscy5jb25maWcucHJlc2VydmVNYW51YWxMZXZlbE9uRXJyb3IpIHtcbiAgICAgICAgICBobHMubG9hZExldmVsID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyYWdFcnJvclR5cGUgPSAoX2RhdGEkZnJhZzIgPSBkYXRhLmZyYWcpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRmcmFnMi50eXBlO1xuICAgICAgICAvLyBGaW5kIGFsdGVybmF0ZSBhdWRpbyBjb2RlYyBpZiBhdmFpbGFibGUgb24gYXVkaW8gY29kZWMgZXJyb3JcbiAgICAgICAgdmFyIGlzQXVkaW9Db2RlY0Vycm9yID0gZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gJiYgZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SIHx8IGRhdGEuc291cmNlQnVmZmVyTmFtZSA9PT0gJ2F1ZGlvJyAmJiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiB8fCBlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SKTtcbiAgICAgICAgdmFyIGZpbmRBdWRpb0NvZGVjQWx0ZXJuYXRlID0gaXNBdWRpb0NvZGVjRXJyb3IgJiYgbGV2ZWxzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IF9yZWYuYXVkaW9Db2RlYztcbiAgICAgICAgICByZXR1cm4gbGV2ZWwuYXVkaW9Db2RlYyAhPT0gYXVkaW9Db2RlYztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZpbmQgYWx0ZXJuYXRlIHZpZGVvIGNvZGVjIGlmIGF2YWlsYWJsZSBvbiB2aWRlbyBjb2RlYyBlcnJvclxuICAgICAgICB2YXIgaXNWaWRlb0NvZGVjRXJyb3IgPSBkYXRhLnNvdXJjZUJ1ZmZlck5hbWUgPT09ICd2aWRlbycgJiYgKGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IgfHwgZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUik7XG4gICAgICAgIHZhciBmaW5kVmlkZW9Db2RlY0FsdGVybmF0ZSA9IGlzVmlkZW9Db2RlY0Vycm9yICYmIGxldmVscy5zb21lKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgIHZhciBjb2RlY1NldCA9IF9yZWYyLmNvZGVjU2V0LFxuICAgICAgICAgICAgYXVkaW9Db2RlYyA9IF9yZWYyLmF1ZGlvQ29kZWM7XG4gICAgICAgICAgcmV0dXJuIGxldmVsLmNvZGVjU2V0ICE9PSBjb2RlY1NldCAmJiBsZXZlbC5hdWRpb0NvZGVjID09PSBhdWRpb0NvZGVjO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9yZWYzID0gKF9kYXRhJGNvbnRleHQyID0gZGF0YS5jb250ZXh0KSAhPSBudWxsID8gX2RhdGEkY29udGV4dDIgOiB7fSxcbiAgICAgICAgICBwbGF5bGlzdEVycm9yVHlwZSA9IF9yZWYzLnR5cGUsXG4gICAgICAgICAgcGxheWxpc3RFcnJvckdyb3VwSWQgPSBfcmVmMy5ncm91cElkO1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSAoaSArIGxvYWRMZXZlbCkgJSBsZXZlbHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSAhPT0gbG9hZExldmVsICYmIGNhbmRpZGF0ZSA+PSBtaW5BdXRvTGV2ZWwgJiYgY2FuZGlkYXRlIDw9IG1heEF1dG9MZXZlbCAmJiBsZXZlbHNbY2FuZGlkYXRlXS5sb2FkRXJyb3IgPT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIF9sZXZlbCRhdWRpb0dyb3VwcywgX2xldmVsJHN1YnRpdGxlR3JvdXBzO1xuICAgICAgICAgICAgICB2YXIgbGV2ZWxDYW5kaWRhdGUgPSBsZXZlbHNbY2FuZGlkYXRlXTtcbiAgICAgICAgICAgICAgLy8gU2tpcCBsZXZlbCBzd2l0Y2ggaWYgR0FQIHRhZyBpcyBmb3VuZCBpbiBuZXh0IGxldmVsIGF0IHNhbWUgcG9zaXRpb25cbiAgICAgICAgICAgICAgaWYgKGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQICYmIGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gJiYgZGF0YS5mcmFnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsc1tjYW5kaWRhdGVdLmRldGFpbHM7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgdmFyIGZyYWdDYW5kaWRhdGUgPSBmaW5kRnJhZ21lbnRCeVBUUyhkYXRhLmZyYWcsIGxldmVsRGV0YWlscy5mcmFnbWVudHMsIGRhdGEuZnJhZy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICBpZiAoZnJhZ0NhbmRpZGF0ZSAhPSBudWxsICYmIGZyYWdDYW5kaWRhdGUuZ2FwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGF5bGlzdEVycm9yVHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBsZXZlbENhbmRpZGF0ZS5oYXNBdWRpb0dyb3VwKHBsYXlsaXN0RXJyb3JHcm91cElkKSB8fCBwbGF5bGlzdEVycm9yVHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBsZXZlbENhbmRpZGF0ZS5oYXNTdWJ0aXRsZUdyb3VwKHBsYXlsaXN0RXJyb3JHcm91cElkKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBhdWRpby9zdWJzIHBsYXlsaXN0IGVycm9ycyBmaW5kIGFub3RoZXIgZ3JvdXAgSUQgb3IgZmFsbHRocm91Z2ggdG8gcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPICYmIChfbGV2ZWwkYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcykgIT0gbnVsbCAmJiBfbGV2ZWwkYXVkaW9Hcm91cHMuc29tZShmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbENhbmRpZGF0ZS5oYXNBdWRpb0dyb3VwKGdyb3VwSWQpO1xuICAgICAgICAgICAgICB9KSB8fCBmcmFnRXJyb3JUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSAmJiAoX2xldmVsJHN1YnRpdGxlR3JvdXBzID0gbGV2ZWwuc3VidGl0bGVHcm91cHMpICE9IG51bGwgJiYgX2xldmVsJHN1YnRpdGxlR3JvdXBzLnNvbWUoZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGV2ZWxDYW5kaWRhdGUuaGFzU3VidGl0bGVHcm91cChncm91cElkKTtcbiAgICAgICAgICAgICAgfSkgfHwgZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUgJiYgbGV2ZWwuYXVkaW9Db2RlYyA9PT0gbGV2ZWxDYW5kaWRhdGUuYXVkaW9Db2RlYyB8fCBmaW5kVmlkZW9Db2RlY0FsdGVybmF0ZSAmJiBsZXZlbC5jb2RlY1NldCA9PT0gbGV2ZWxDYW5kaWRhdGUuY29kZWNTZXQgfHwgIWZpbmRBdWRpb0NvZGVjQWx0ZXJuYXRlICYmIGxldmVsLmNvZGVjU2V0ICE9PSBsZXZlbENhbmRpZGF0ZS5jb2RlY1NldCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciB2aWRlby9hdWRpby9zdWJzIGZyYWcgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV4dExldmVsID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICByZXR1cm4gMTsgLy8gYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIF9yZXQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZXZlbHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgX3JldCA9IF9sb29wKCk7XG4gICAgICAgICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChfcmV0ID09PSAxKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dExldmVsID4gLTEgJiYgaGxzLmxvYWRMZXZlbCAhPT0gbmV4dExldmVsKSB7XG4gICAgICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgICAgIG5leHRBdXRvTGV2ZWw6IG5leHRMZXZlbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE5vIGxldmVscyB0byBzd2l0Y2ggLyBNYW51YWwgbGV2ZWwgc2VsZWN0aW9uIC8gTGV2ZWwgbm90IGZvdW5kXG4gICAgICAvLyBSZXNvbHZlIHdpdGggUGF0aHdheSBzd2l0Y2gsIFJlZHVuZGFudCBmYWlsLW92ZXIsIG9yIHN0YXkgb24gbG93ZXN0IExldmVsXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdFxuICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yT3V0ID0gZnVuY3Rpb24gb25FcnJvck91dChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9kYXRhJGVycm9yQWN0aW9uO1xuICAgICAgc3dpdGNoICgoX2RhdGEkZXJyb3JBY3Rpb24gPSBkYXRhLmVycm9yQWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZXJyb3JBY3Rpb24uYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDpcbiAgICAgICAgICB0aGlzLnNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSk7XG4gICAgICAgICAgaWYgKCFkYXRhLmVycm9yQWN0aW9uLnJlc29sdmVkICYmIGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQKSB7XG4gICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9NZWRpYVNvdXJjZSByZWFkeVN0YXRlOiBlbmRlZC8udGVzdChkYXRhLmVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJNZWRpYVNvdXJjZSBlbmRlZCBhZnRlciBcXFwiXCIgKyBkYXRhLnNvdXJjZUJ1ZmZlck5hbWUgKyBcIlxcXCIgc291cmNlQnVmZmVyIGFwcGVuZCBlcnJvci4gQXR0ZW1wdGluZyB0byByZWNvdmVyIGZyb20gbWVkaWEgZXJyb3IuXCIpO1xuICAgICAgICAgICAgdGhpcy5obHMucmVjb3Zlck1lZGlhRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICB0aGlzLmhscy5zdG9wTG9hZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCA9IGZ1bmN0aW9uIHNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICAgIGlmICghZXJyb3JBY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZsYWdzID0gZXJyb3JBY3Rpb24uZmxhZ3M7XG4gICAgICB2YXIgbmV4dEF1dG9MZXZlbCA9IGVycm9yQWN0aW9uLm5leHRBdXRvTGV2ZWw7XG4gICAgICBzd2l0Y2ggKGZsYWdzKSB7XG4gICAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Ob25lOlxuICAgICAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YSwgbmV4dEF1dG9MZXZlbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IGhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgICAgICAgICB2YXIgcmVzdHJpY3RlZEhkY3BMZXZlbCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICAgICAgZXJyb3JBY3Rpb24uaGRjcExldmVsID0gcmVzdHJpY3RlZEhkY3BMZXZlbDtcbiAgICAgICAgICAgIGlmIChyZXN0cmljdGVkSGRjcExldmVsID09PSAnTk9ORScpIHtcbiAgICAgICAgICAgICAgdGhpcy53YXJuKFwiSERDUCBwb2xpY3kgcmVzdGljdGVkIG91dHB1dCB3aXRoIEhEQ1AtTEVWRUw9Tk9ORVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdHJpY3RlZEhkY3BMZXZlbCkge1xuICAgICAgICAgICAgICBobHMubWF4SGRjcExldmVsID0gSGRjcExldmVsc1tIZGNwTGV2ZWxzLmluZGV4T2YocmVzdHJpY3RlZEhkY3BMZXZlbCkgLSAxXTtcbiAgICAgICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLndhcm4oXCJSZXN0cmljdGluZyBwbGF5YmFjayB0byBIRENQLUxFVkVMIG9mIFxcXCJcIiArIGhscy5tYXhIZGNwTGV2ZWwgKyBcIlxcXCIgb3IgbG93ZXJcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFsbHRocm91Z2ggd2hlbiBubyBIRENQLUxFVkVMIGF0dHJpYnV0ZSBpcyBmb3VuZFxuICAgICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nS2V5OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBsZXZlbEtleSA9IGRhdGEuZGVjcnlwdGRhdGE7XG4gICAgICAgICAgICBpZiAobGV2ZWxLZXkpIHtcbiAgICAgICAgICAgICAgLy8gUGVuYWxpemUgYWxsIGxldmVscyB3aXRoIGtleVxuICAgICAgICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgICAgICAgICB2YXIgbGV2ZWxDb3VudFdpdGhFcnJvciA9IGxldmVscy5sZW5ndGg7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZXZlbENvdW50V2l0aEVycm9yOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFyaWFudEhhc0tleShsZXZlbHNbaV0sIGxldmVsS2V5KSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9sZXZlbHMkaSRhdWRpb0dyb3VwcywgX2RhdGEkZnJhZzM7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkJhbm5lZCBrZXkgZm91bmQgaW4gbGV2ZWwgXCIgKyBpICsgXCIgKFwiICsgbGV2ZWxzW2ldLmJpdHJhdGUgKyBcImJwcykgb3IgYXVkaW8gZ3JvdXAgXFxcIlwiICsgKChfbGV2ZWxzJGkkYXVkaW9Hcm91cHMgPSBsZXZlbHNbaV0uYXVkaW9Hcm91cHMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWxzJGkkYXVkaW9Hcm91cHMuam9pbignLCcpKSArIFwiXFxcIiAoXCIgKyAoKF9kYXRhJGZyYWczID0gZGF0YS5mcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZnJhZzMudHlwZSkgKyBcIiBmcmFnbWVudCkgXCIgKyBhcnJheVRvSGV4KGxldmVsS2V5LmtleUlkIHx8IFtdKSk7XG4gICAgICAgICAgICAgICAgICBsZXZlbHNbaV0uZnJhZ21lbnRFcnJvcisrO1xuICAgICAgICAgICAgICAgICAgbGV2ZWxzW2ldLmxvYWRFcnJvcisrO1xuICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJSZW1vdmluZyBsZXZlbCBcIiArIGkgKyBcIiB3aXRoIGtleSBlcnJvciAoXCIgKyBkYXRhLmVycm9yICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5obHMucmVtb3ZlTGV2ZWwoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICAgICAgICBpZiAodGhpcy5obHMubGV2ZWxzLmxlbmd0aCA8IGxldmVsQ291bnRXaXRoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUga2V5IGVycm9yIGZvciBhdWRpbyB0cmFjayB3aXRoIHVubWF0Y2hlZCBrZXkgKG1haW4gc2Vzc2lvbiBlcnJvcilcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ0xldmVsS2V5ID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ0xldmVsS2V5ICYmICFsZXZlbEtleS5tYXRjaGVzKGZyYWdMZXZlbEtleSkpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIElmIG5vdCByZXNvbHZlZCBieSBwcmV2aW91cyBhY3Rpb25zIHRyeSB0byBzd2l0Y2ggdG8gbmV4dCBsZXZlbFxuICAgICAgaWYgKCFlcnJvckFjdGlvbi5yZXNvbHZlZCkge1xuICAgICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEsIG5leHRBdXRvTGV2ZWwpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN3aXRjaExldmVsID0gZnVuY3Rpb24gc3dpdGNoTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCkge1xuICAgICAgaWYgKGxldmVsSW5kZXggIT09IHVuZGVmaW5lZCAmJiBkYXRhLmVycm9yQWN0aW9uKSB7XG4gICAgICAgIHRoaXMud2FybihcInN3aXRjaGluZyB0byBsZXZlbCBcIiArIGxldmVsSW5kZXggKyBcIiBhZnRlciBcIiArIGRhdGEuZGV0YWlscyk7XG4gICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBsZXZlbEluZGV4O1xuICAgICAgICBkYXRhLmVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgLy8gU3RyZWFtIGNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoaXMgYnV0IHdvbid0IHN3aXRjaCBvbiBmYWxzZSBzdGFydFxuICAgICAgICB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gdGhpcy5obHMubmV4dEF1dG9MZXZlbDtcbiAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IgJiYgZGF0YS5taW1lVHlwZSAmJiBkYXRhLnNvdXJjZUJ1ZmZlck5hbWUgIT09ICdhdWRpb3ZpZGVvJykge1xuICAgICAgICAgIHZhciBjb2RlYyA9IGdldENvZGVjc0Zvck1pbWVUeXBlKGRhdGEubWltZVR5cGUpO1xuICAgICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGxldmVscy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIGlmIChsZXZlbHNbaV1bZGF0YS5zb3VyY2VCdWZmZXJOYW1lICsgXCJDb2RlY1wiXSA9PT0gY29kZWMpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coXCJSZW1vdmluZyBsZXZlbCBcIiArIGkgKyBcIiBmb3IgXCIgKyBkYXRhLmRldGFpbHMgKyBcIiAoXFxcIlwiICsgY29kZWMgKyBcIlxcXCIgbm90IHN1cHBvcnRlZClcIik7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnJlbW92ZUxldmVsKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVycm9yQ29udHJvbGxlcjtcbiAgfShMb2dnZXIpO1xuICBmdW5jdGlvbiBjcmVhdGVEb05vdGhpbmdFcnJvckFjdGlvbihyZXNvbHZlZCkge1xuICAgIHZhciBlcnJvckFjdGlvbiA9IHtcbiAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZyxcbiAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmVcbiAgICB9O1xuICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JBY3Rpb247XG4gIH1cblxuICB2YXIgRnJhZ21lbnRTdGF0ZSA9IHtcbiAgICBOT1RfTE9BREVEOiBcIk5PVF9MT0FERURcIixcbiAgICBBUFBFTkRJTkc6IFwiQVBQRU5ESU5HXCIsXG4gICAgUEFSVElBTDogXCJQQVJUSUFMXCIsXG4gICAgT0s6IFwiT0tcIlxuICB9O1xuICB2YXIgRnJhZ21lbnRUcmFja2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcmFnbWVudFRyYWNrZXIoaGxzKSB7XG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5oYXNHYXBzID0gZmFsc2U7XG4gICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoaGxzKSB7XG4gICAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgICAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgICAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmIChobHMpIHtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmhscyA9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmZyYWdtZW50cyA9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSB0aGlzLnRpbWVSYW5nZXMgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIEZyYWdtZW50IG9yIFBhcnQgd2l0aCBhbiBhcHBlbmRlZCByYW5nZSB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGVcbiAgICAgKiBPdGhlcndpc2UsIHJldHVybiBudWxsXG4gICAgICovO1xuICAgIF9wcm90by5nZXRBcHBlbmRlZEZyYWcgPSBmdW5jdGlvbiBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgICAgdmFyIGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICAgIGlmIChhY3RpdmVQYXJ0cykge1xuICAgICAgICBmb3IgKHZhciBpID0gYWN0aXZlUGFydHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgdmFyIGFjdGl2ZVBhcnQgPSBhY3RpdmVQYXJ0c1tpXTtcbiAgICAgICAgICBpZiAoIWFjdGl2ZVBhcnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWN0aXZlUGFydC5zdGFydCA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8PSBhY3RpdmVQYXJ0LmVuZCAmJiBhY3RpdmVQYXJ0LmxvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZVBhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgYnVmZmVyZWQgRnJhZ21lbnQgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgICAqIEEgYnVmZmVyZWQgRnJhZ21lbnQgaXMgb25lIHdob3NlIGxvYWRpbmcsIHBhcnNpbmcgYW5kIGFwcGVuZGluZyBpcyBkb25lIChjb21wbGV0ZWQgb3IgXCJwYXJ0aWFsXCIgbWVhbmluZyBhYm9ydGVkKS5cbiAgICAgKiBJZiBub3QgZm91bmQgYW55IEZyYWdtZW50LCByZXR1cm4gbnVsbFxuICAgICAqLztcbiAgICBfcHJvdG8uZ2V0QnVmZmVyZWRGcmFnID0gZnVuY3Rpb24gZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBsZXZlbFR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyYWdBdFBvcyhwb3NpdGlvbiwgbGV2ZWxUeXBlLCB0cnVlKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRGcmFnQXRQb3MgPSBmdW5jdGlvbiBnZXRGcmFnQXRQb3MocG9zaXRpb24sIGxldmVsVHlwZSwgYnVmZmVyZWQpIHtcbiAgICAgIHZhciBmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cztcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5c1tpXV07XG4gICAgICAgIGlmICgoZnJhZ21lbnRFbnRpdHkgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSkgPT09IGxldmVsVHlwZSAmJiAoIWJ1ZmZlcmVkIHx8IGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSkge1xuICAgICAgICAgIHZhciBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgICBpZiAoZnJhZy5zdGFydCA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8PSBmcmFnLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJ0aWFsIGZyYWdtZW50cyBlZmZlY3RlZCBieSBjb2RlZCBmcmFtZSBldmljdGlvbiB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBUaGUgYnJvd3NlciB3aWxsIHVubG9hZCBwYXJ0cyBvZiB0aGUgYnVmZmVyIHRvIGZyZWUgdXAgbWVtb3J5IGZvciBuZXcgYnVmZmVyIGRhdGFcbiAgICAgKiBGcmFnbWVudHMgd2lsbCBuZWVkIHRvIGJlIHJlbG9hZGVkIHdoZW4gdGhlIGJ1ZmZlciBpcyBmcmVlZCB1cCwgcmVtb3ZpbmcgcGFydGlhbCBmcmFnbWVudHMgd2lsbCBhbGxvdyB0aGVtIHRvIHJlbG9hZChzaW5jZSB0aGVyZSBtaWdodCBiZSBwYXJ0cyB0aGF0IGFyZSBzdGlsbCBwbGF5YWJsZSlcbiAgICAgKi87XG4gICAgX3Byb3RvLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMgPSBmdW5jdGlvbiBkZXRlY3RFdmljdGVkRnJhZ21lbnRzKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSwgcGxheWxpc3RUeXBlLCBhcHBlbmRlZFBhcnQsIHJlbW92ZUFwcGVuZGluZykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnRpbWVSYW5nZXMpIHtcbiAgICAgICAgdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dID0gdGltZVJhbmdlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgICAgLy8gZXhjbHVkaW5nIGFueXRoaW5nIG5ld2VyIHRoYW4gYXBwZW5kZWRQYXJ0U25cbiAgICAgIHZhciBhcHBlbmRlZFBhcnRTbiA9IChhcHBlbmRlZFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVuZGVkUGFydC5mcmFnbWVudC5zbikgfHwgLTE7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IF90aGlzLmZyYWdtZW50c1trZXldO1xuICAgICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHBlbmRlZFBhcnRTbiA+PSBmcmFnbWVudEVudGl0eS5ib2R5LnNuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgKCFmcmFnbWVudEVudGl0eS5sb2FkZWQgfHwgcmVtb3ZlQXBwZW5kaW5nKSkge1xuICAgICAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUgPT09IHBsYXlsaXN0VHlwZSkge1xuICAgICAgICAgICAgX3RoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgIGlmICghZXNEYXRhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlc0RhdGEudGltZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBfdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXNEYXRhLnRpbWUuc29tZShmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgIHZhciBpc05vdEJ1ZmZlcmVkID0gIV90aGlzLmlzVGltZUJ1ZmZlcmVkKHRpbWUuc3RhcnRQVFMsIHRpbWUuZW5kUFRTLCB0aW1lUmFuZ2UpO1xuICAgICAgICAgIGlmIChpc05vdEJ1ZmZlcmVkKSB7XG4gICAgICAgICAgICAvLyBVbnJlZ2lzdGVyIHBhcnRpYWwgZnJhZ21lbnQgYXMgaXQgbmVlZHMgdG8gbG9hZCBhZ2FpbiB0byBiZSByZXVzZWRcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNOb3RCdWZmZXJlZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGZyYWdtZW50IHBhc3NlZCBpbiBpcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlciBwcm9wZXJseVxuICAgICAqIFBhcnRpYWxseSBsb2FkZWQgZnJhZ21lbnRzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAgKi87XG4gICAgX3Byb3RvLmRldGVjdFBhcnRpYWxGcmFnbWVudHMgPSBmdW5jdGlvbiBkZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHRpbWVSYW5nZXMgPSB0aGlzLnRpbWVSYW5nZXM7XG4gICAgICBpZiAoIXRpbWVSYW5nZXMgfHwgZGF0YS5mcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSB8fCBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiBmcmFnLmdhcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaXNGcmFnSGludCA9ICFmcmFnLnJlbHVybDtcbiAgICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnRhcnlTdHJlYW0pIHtcbiAgICAgICAgdmFyIHN0cmVhbUluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgICBpZiAoIXN0cmVhbUluZm8pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgIHZhciBwYXJ0aWFsID0gaXNGcmFnSGludCB8fCBzdHJlYW1JbmZvLnBhcnRpYWwgPT09IHRydWU7XG4gICAgICAgIGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dID0gX3RoaXMyLmdldEJ1ZmZlcmVkVGltZXMoZnJhZywgZGF0YS5wYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpO1xuICAgICAgfSk7XG4gICAgICBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGZyYWdtZW50RW50aXR5LnJhbmdlKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5idWZmZXJlZEVuZChmcmFnbWVudEVudGl0eSwgZnJhZyk7XG4gICAgICAgIGlmICghaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICAgIC8vIFJlbW92ZSBvbGRlciBmcmFnbWVudCBwYXJ0cyBmcm9tIGxvb2t1cCBhZnRlciBmcmFnIGlzIHRyYWNrZWQgYXMgYnVmZmVyZWRcbiAgICAgICAgICB0aGlzLnJlbW92ZVBhcnRzKGZyYWcuc24gLSAxLCBmcmFnLnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgZnJhZ21lbnQgaWYgbm90aGluZyB3YXMgYXBwZW5kZWRcbiAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5idWZmZXJlZEVuZCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkRW5kKGZyYWdtZW50RW50aXR5LCBmcmFnKSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgICB2YXIgZW5kTGlzdCA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kTGlzdCA9IGZyYWcuZW5kTGlzdCB8fCBmcmFnbWVudEVudGl0eS5ib2R5LmVuZExpc3Q7XG4gICAgICBpZiAoZW5kTGlzdCkge1xuICAgICAgICB0aGlzLmVuZExpc3RGcmFnbWVudHNbZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlXSA9IGZyYWdtZW50RW50aXR5O1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZVBhcnRzID0gZnVuY3Rpb24gcmVtb3ZlUGFydHMoc25Ub0tlZXAsIGxldmVsVHlwZSkge1xuICAgICAgdmFyIGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXTtcbiAgICAgIGlmICghYWN0aXZlUGFydHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbbGV2ZWxUeXBlXSA9IGZpbHRlclBhcnRzKGFjdGl2ZVBhcnRzLCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgICByZXR1cm4gcGFydC5mcmFnbWVudC5zbiA+PSBzblRvS2VlcDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIGZyYWdCdWZmZXJlZChmcmFnLCBmb3JjZSkge1xuICAgICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSAmJiBmb3JjZSkge1xuICAgICAgICBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgICAgIGJvZHk6IGZyYWcsXG4gICAgICAgICAgYXBwZW5kZWRQVFM6IG51bGwsXG4gICAgICAgICAgbG9hZGVkOiBudWxsLFxuICAgICAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZnJhZy5nYXApIHtcbiAgICAgICAgICB0aGlzLmhhc0dhcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgZnJhZ21lbnRFbnRpdHkubG9hZGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5idWZmZXJlZEVuZChmcmFnbWVudEVudGl0eSwgZnJhZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QnVmZmVyZWRUaW1lcyA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkVGltZXMoZnJhZ21lbnQsIHBhcnQsIHBhcnRpYWwsIHRpbWVSYW5nZSkge1xuICAgICAgdmFyIGJ1ZmZlcmVkID0ge1xuICAgICAgICB0aW1lOiBbXSxcbiAgICAgICAgcGFydGlhbDogcGFydGlhbFxuICAgICAgfTtcbiAgICAgIHZhciBzdGFydFBUUyA9IGZyYWdtZW50LnN0YXJ0O1xuICAgICAgdmFyIGVuZFBUUyA9IGZyYWdtZW50LmVuZDtcbiAgICAgIHZhciBtaW5FbmRQVFMgPSBmcmFnbWVudC5taW5FbmRQVFMgfHwgZW5kUFRTO1xuICAgICAgdmFyIG1heFN0YXJ0UFRTID0gZnJhZ21lbnQubWF4U3RhcnRQVFMgfHwgc3RhcnRQVFM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgICB2YXIgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGlmIChtYXhTdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgbWluRW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgICAvLyBGcmFnbWVudCBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gYnVmZmVyXG4gICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgdGltZVJhbmdlIHRpbWVzIHNpbmNlIGl0J3MgY29tcGxldGVseSBwbGF5YWJsZVxuICAgICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSk7XG4gICAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSk7XG4gICAgICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICBidWZmZXJlZC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCBidWZmZXJcbiAgICAgICAgICAgIC8vIEdldCBwbGF5YWJsZSBzZWN0aW9ucyBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kUFRTOiBlbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvciBhIGNlcnRhaW4gdGltZVxuICAgICAqLztcbiAgICBfcHJvdG8uZ2V0UGFydGlhbEZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0UGFydGlhbEZyYWdtZW50KHRpbWUpIHtcbiAgICAgIHZhciBiZXN0RnJhZ21lbnQgPSBudWxsO1xuICAgICAgdmFyIHRpbWVQYWRkaW5nO1xuICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgIHZhciBlbmRUaW1lO1xuICAgICAgdmFyIGJlc3RPdmVybGFwID0gMDtcbiAgICAgIHZhciBidWZmZXJQYWRkaW5nID0gdGhpcy5idWZmZXJQYWRkaW5nLFxuICAgICAgICBmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cztcbiAgICAgIE9iamVjdC5rZXlzKGZyYWdtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuICAgICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5zdGFydCAtIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kICsgYnVmZmVyUGFkZGluZztcbiAgICAgICAgICBpZiAodGltZSA+PSBzdGFydFRpbWUgJiYgdGltZSA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZyYWdtZW50IHRoYXQgaGFzIHRoZSBtb3N0IHBhZGRpbmcgZnJvbSBzdGFydCBhbmQgZW5kIHRpbWVcbiAgICAgICAgICAgIHRpbWVQYWRkaW5nID0gTWF0aC5taW4odGltZSAtIHN0YXJ0VGltZSwgZW5kVGltZSAtIHRpbWUpO1xuICAgICAgICAgICAgaWYgKGJlc3RPdmVybGFwIDw9IHRpbWVQYWRkaW5nKSB7XG4gICAgICAgICAgICAgIGJlc3RGcmFnbWVudCA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgICAgICAgIGJlc3RPdmVybGFwID0gdGltZVBhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiZXN0RnJhZ21lbnQ7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNFbmRMaXN0QXBwZW5kZWQgPSBmdW5jdGlvbiBpc0VuZExpc3RBcHBlbmRlZCh0eXBlKSB7XG4gICAgICB2YXIgbGFzdEZyYWdtZW50RW50aXR5ID0gdGhpcy5lbmRMaXN0RnJhZ21lbnRzW3R5cGVdO1xuICAgICAgcmV0dXJuIGxhc3RGcmFnbWVudEVudGl0eSAhPT0gdW5kZWZpbmVkICYmIChsYXN0RnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgfHwgaXNQYXJ0aWFsKGxhc3RGcmFnbWVudEVudGl0eSkpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLkFQUEVORElORztcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuUEFSVElBTDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5PSztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRDtcbiAgICB9O1xuICAgIF9wcm90by5pc1RpbWVCdWZmZXJlZCA9IGZ1bmN0aW9uIGlzVGltZUJ1ZmZlcmVkKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xuICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgIHZhciBlbmRUaW1lO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcbiAgICAgIC8vIGRvbid0IHRyYWNrIGZyYWdzIHVzZWQgZm9yIGJpdHJhdGVUZXN0LCB0aGV5J3JlIGlycmVsZXZhbnQuXG4gICAgICBpZiAoZGF0YS5mcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGRhdGEuZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIC8vIEZyYWdtZW50IGVudGl0eSBgbG9hZGVkYCBGcmFnTG9hZGVkRGF0YSBpcyBudWxsIHdoZW4gbG9hZGluZyBwYXJ0c1xuICAgICAgdmFyIGxvYWRlZCA9IGRhdGEucGFydCA/IG51bGwgOiBkYXRhO1xuICAgICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgICBib2R5OiBmcmFnLFxuICAgICAgICBhcHBlbmRlZFBUUzogbnVsbCxcbiAgICAgICAgbG9hZGVkOiBsb2FkZWQsXG4gICAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJBcHBlbmRlZCA9IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0LFxuICAgICAgICB0aW1lUmFuZ2VzID0gZGF0YS50aW1lUmFuZ2VzLFxuICAgICAgICB0eXBlID0gZGF0YS50eXBlO1xuICAgICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBsYXlsaXN0VHlwZSA9IGZyYWcudHlwZTtcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHZhciBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW3BsYXlsaXN0VHlwZV07XG4gICAgICAgIGlmICghYWN0aXZlUGFydHMpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1twbGF5bGlzdFR5cGVdID0gYWN0aXZlUGFydHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgdGhlIGxhdGVzdCB0aW1lUmFuZ2VzIGxvYWRlZCBpbiB0aGUgYnVmZmVyXG4gICAgICB0aGlzLnRpbWVSYW5nZXMgPSB0aW1lUmFuZ2VzO1xuICAgICAgdmFyIHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbdHlwZV07XG4gICAgICB0aGlzLmRldGVjdEV2aWN0ZWRGcmFnbWVudHModHlwZSwgdGltZVJhbmdlLCBwbGF5bGlzdFR5cGUsIHBhcnQpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhkYXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5oYXNGcmFnbWVudCA9IGZ1bmN0aW9uIGhhc0ZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICAgIHJldHVybiAhIXRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIH07XG4gICAgX3Byb3RvLmhhc0ZyYWdtZW50cyA9IGZ1bmN0aW9uIGhhc0ZyYWdtZW50cyh0eXBlKSB7XG4gICAgICB2YXIgZnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cyk7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5c1tpXV07XG4gICAgICAgIGlmICgoZnJhZ21lbnRFbnRpdHkgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSkgPT09IHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmhhc1BhcnRzID0gZnVuY3Rpb24gaGFzUGFydHModHlwZSkge1xuICAgICAgdmFyIF90aGlzJGFjdGl2ZVBhcnRMaXN0cztcbiAgICAgIHJldHVybiAhISgoX3RoaXMkYWN0aXZlUGFydExpc3RzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbdHlwZV0pICE9IG51bGwgJiYgX3RoaXMkYWN0aXZlUGFydExpc3RzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZSA9IGZ1bmN0aW9uIHJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnQsIGVuZCwgcGxheWxpc3RUeXBlLCB3aXRoR2FwT25seSwgdW5idWZmZXJlZE9ubHkpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgaWYgKHdpdGhHYXBPbmx5ICYmICF0aGlzLmhhc0dhcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSBfdGhpczMuZnJhZ21lbnRzW2tleV07XG4gICAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICBpZiAoZnJhZy50eXBlICE9PSBwbGF5bGlzdFR5cGUgfHwgd2l0aEdhcE9ubHkgJiYgIWZyYWcuZ2FwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnLnN0YXJ0IDwgZW5kICYmIGZyYWcuZW5kID4gc3RhcnQgJiYgKGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkIHx8IHVuYnVmZmVyZWRPbmx5KSkge1xuICAgICAgICAgIF90aGlzMy5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlRnJhZ21lbnQgPSBmdW5jdGlvbiByZW1vdmVGcmFnbWVudChmcmFnbWVudCkge1xuICAgICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgICBmcmFnbWVudC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCk7XG4gICAgICB2YXIgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tmcmFnbWVudC50eXBlXTtcbiAgICAgIGlmIChhY3RpdmVQYXJ0cykge1xuICAgICAgICB2YXIgc25Ub1JlbW92ZSA9IGZyYWdtZW50LnNuO1xuICAgICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tmcmFnbWVudC50eXBlXSA9IGZpbHRlclBhcnRzKGFjdGl2ZVBhcnRzLCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0LmZyYWdtZW50LnNuICE9PSBzblRvUmVtb3ZlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICAgIGlmIChmcmFnbWVudC5lbmRMaXN0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVuZExpc3RGcmFnbWVudHNbZnJhZ21lbnQudHlwZV07XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlQWxsRnJhZ21lbnRzID0gZnVuY3Rpb24gcmVtb3ZlQWxsRnJhZ21lbnRzKCkge1xuICAgICAgdmFyIF90aGlzJGhscztcbiAgICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmhhc0dhcHMgPSBmYWxzZTtcbiAgICAgIHZhciBwYXJ0bGlzdCA9IChfdGhpcyRobHMgPSB0aGlzLmhscykgPT0gbnVsbCB8fCAoX3RoaXMkaGxzID0gX3RoaXMkaGxzLmxhdGVzdExldmVsRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscy5wYXJ0TGlzdDtcbiAgICAgIGlmIChwYXJ0bGlzdCkge1xuICAgICAgICBwYXJ0bGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnQuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGcmFnbWVudFRyYWNrZXI7XG4gIH0oKTtcbiAgZnVuY3Rpb24gaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSB7XG4gICAgdmFyIF9mcmFnbWVudEVudGl0eSRyYW5nZSwgX2ZyYWdtZW50RW50aXR5JHJhbmdlMiwgX2ZyYWdtZW50RW50aXR5JHJhbmdlMztcbiAgICByZXR1cm4gZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgISEoZnJhZ21lbnRFbnRpdHkuYm9keS5nYXAgfHwgKF9mcmFnbWVudEVudGl0eSRyYW5nZSA9IGZyYWdtZW50RW50aXR5LnJhbmdlLnZpZGVvKSAhPSBudWxsICYmIF9mcmFnbWVudEVudGl0eSRyYW5nZS5wYXJ0aWFsIHx8IChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8pICE9IG51bGwgJiYgX2ZyYWdtZW50RW50aXR5JHJhbmdlMi5wYXJ0aWFsIHx8IChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW92aWRlbykgIT0gbnVsbCAmJiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzLnBhcnRpYWwpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZyYWdtZW50S2V5KGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGZyYWdtZW50LnR5cGUgKyBcIl9cIiArIGZyYWdtZW50LmxldmVsICsgXCJfXCIgKyBmcmFnbWVudC5zbjtcbiAgfVxuICBmdW5jdGlvbiBmaWx0ZXJQYXJ0cyhwYXJ0TGlzdCwgcHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHBhcnRMaXN0LmZpbHRlcihmdW5jdGlvbiAocGFydCkge1xuICAgICAgdmFyIGtlZXAgPSBwcmVkaWNhdGUocGFydCk7XG4gICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgcGFydC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2VlcDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBEZWNyeXB0ZXJBZXNNb2RlID0ge1xuICAgIGNiYzogMCxcbiAgICBjdHI6IDFcbiAgfTtcblxuICB2YXIgQUVTQ3J5cHRvID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBRVNDcnlwdG8oc3VidGxlLCBpdiwgYWVzTW9kZSkge1xuICAgICAgdGhpcy5zdWJ0bGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLmFlc0lWID0gdm9pZCAwO1xuICAgICAgdGhpcy5hZXNNb2RlID0gdm9pZCAwO1xuICAgICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgICB0aGlzLmFlc0lWID0gaXY7XG4gICAgICB0aGlzLmFlc01vZGUgPSBhZXNNb2RlO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQUVTQ3J5cHRvLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVjcnlwdCA9IGZ1bmN0aW9uIGRlY3J5cHQoZGF0YSwga2V5KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuYWVzTW9kZSkge1xuICAgICAgICBjYXNlIERlY3J5cHRlckFlc01vZGUuY2JjOlxuICAgICAgICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHtcbiAgICAgICAgICAgIG5hbWU6ICdBRVMtQ0JDJyxcbiAgICAgICAgICAgIGl2OiB0aGlzLmFlc0lWXG4gICAgICAgICAgfSwga2V5LCBkYXRhKTtcbiAgICAgICAgY2FzZSBEZWNyeXB0ZXJBZXNNb2RlLmN0cjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdWJ0bGUuZGVjcnlwdCh7XG4gICAgICAgICAgICBuYW1lOiAnQUVTLUNUUicsXG4gICAgICAgICAgICBjb3VudGVyOiB0aGlzLmFlc0lWLFxuICAgICAgICAgICAgbGVuZ3RoOiA2NFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy82NCA6IE5JU1QgU1A4MDAtMzhBIHN0YW5kYXJkIHN1Z2dlc3RzIHRoYXQgdGhlIGNvdW50ZXIgc2hvdWxkIG9jY3VweSBoYWxmIG9mIHRoZSBjb3VudGVyIGJsb2NrXG4gICAgICAgICAga2V5LCBkYXRhKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQUVTQ3J5cHRvXSBpbnZhbGlkIGFlcyBtb2RlIFwiICsgdGhpcy5hZXNNb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBRVNDcnlwdG87XG4gIH0oKTtcblxuICAvLyBQS0NTN1xuICBmdW5jdGlvbiByZW1vdmVQYWRkaW5nKGFycmF5KSB7XG4gICAgdmFyIG91dHB1dEJ5dGVzID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgICB2YXIgcGFkZGluZ0J5dGVzID0gb3V0cHV0Qnl0ZXMgJiYgbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlcikuZ2V0VWludDgob3V0cHV0Qnl0ZXMgLSAxKTtcbiAgICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgICByZXR1cm4gYXJyYXkuc2xpY2UoMCwgb3V0cHV0Qnl0ZXMgLSBwYWRkaW5nQnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgdmFyIEFFU0RlY3J5cHRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQUVTRGVjcnlwdG9yKCkge1xuICAgICAgdGhpcy5yY29uID0gWzB4MCwgMHgxLCAweDIsIDB4NCwgMHg4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcbiAgICAgIHRoaXMuc3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICAgIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgICB0aGlzLmtleSA9IG5ldyBVaW50MzJBcnJheSgwKTtcbiAgICAgIHRoaXMua3NSb3dzID0gMDtcbiAgICAgIHRoaXMua2V5U2l6ZSA9IDA7XG4gICAgICB0aGlzLmtleVNjaGVkdWxlID0gdm9pZCAwO1xuICAgICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaW5pdFRhYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICAgIHZhciBfcHJvdG8gPSBBRVNEZWNyeXB0b3IucHJvdG90eXBlO1xuICAgIF9wcm90by51aW50OEFycmF5VG9VaW50MzJBcnJheV8gPSBmdW5jdGlvbiB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICAgIHZhciBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIG5ld0FycmF5W2ldID0gdmlldy5nZXRVaW50MzIoaSAqIDQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgIH07XG4gICAgX3Byb3RvLmluaXRUYWJsZSA9IGZ1bmN0aW9uIGluaXRUYWJsZSgpIHtcbiAgICAgIHZhciBzQm94ID0gdGhpcy5zQm94O1xuICAgICAgdmFyIGludlNCb3ggPSB0aGlzLmludlNCb3g7XG4gICAgICB2YXIgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XG4gICAgICB2YXIgc3ViTWl4MCA9IHN1Yk1peFswXTtcbiAgICAgIHZhciBzdWJNaXgxID0gc3ViTWl4WzFdO1xuICAgICAgdmFyIHN1Yk1peDIgPSBzdWJNaXhbMl07XG4gICAgICB2YXIgc3ViTWl4MyA9IHN1Yk1peFszXTtcbiAgICAgIHZhciBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgICB2YXIgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgICAgdmFyIGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB4aSA9IDA7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRbaV0gPSBpIDw8IDEgXiAweDExYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIHZhciBzeCA9IHhpIF4geGkgPDwgMSBeIHhpIDw8IDIgXiB4aSA8PCAzIF4geGkgPDwgNDtcbiAgICAgICAgc3ggPSBzeCA+Pj4gOCBeIHN4ICYgMHhmZiBeIDB4NjM7XG4gICAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgICAgaW52U0JveFtzeF0gPSB4O1xuXG4gICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgICAgdmFyIHgyID0gZFt4XTtcbiAgICAgICAgdmFyIHg0ID0gZFt4Ml07XG4gICAgICAgIHZhciB4OCA9IGRbeDRdO1xuXG4gICAgICAgIC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgIHZhciB0ID0gZFtzeF0gKiAweDEwMSBeIHN4ICogMHgxMDEwMTAwO1xuICAgICAgICBzdWJNaXgwW3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gICAgICAgIHN1Yk1peDFbeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICAgIHN1Yk1peDJbeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgIHQgPSB4OCAqIDB4MTAxMDEwMSBeIHg0ICogMHgxMDAwMSBeIHgyICogMHgxMDEgXiB4ICogMHgxMDEwMTAwO1xuICAgICAgICBpbnZTdWJNaXgwW3N4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgICBpbnZTdWJNaXgxW3N4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgICAgICAgaW52U3ViTWl4MltzeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgICAgICAgaW52U3ViTWl4M1tzeF0gPSB0O1xuXG4gICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICAgIGlmICgheCkge1xuICAgICAgICAgIHggPSB4aSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmV4cGFuZEtleSA9IGZ1bmN0aW9uIGV4cGFuZEtleShrZXlCdWZmZXIpIHtcbiAgICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgICB2YXIga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICAgIHZhciBzYW1lS2V5ID0gdHJ1ZTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IGtleS5sZW5ndGggJiYgc2FtZUtleSkge1xuICAgICAgICBzYW1lS2V5ID0ga2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF07XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgICAgaWYgKHNhbWVLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB2YXIga2V5U2l6ZSA9IHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGg7XG4gICAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFlcyBrZXkgc2l6ZT0nICsga2V5U2l6ZSk7XG4gICAgICB9XG4gICAgICB2YXIga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgICB2YXIga3NSb3c7XG4gICAgICB2YXIgaW52S3NSb3c7XG4gICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLmtleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgICB2YXIgc2JveCA9IHRoaXMuc0JveDtcbiAgICAgIHZhciByY29uID0gdGhpcy5yY29uO1xuICAgICAgdmFyIGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgICAgdmFyIGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICAgIHZhciBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgICAgdmFyIGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgICB2YXIgcHJldjtcbiAgICAgIHZhciB0O1xuICAgICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgICBwcmV2ID0ga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5W2tzUm93XTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gcHJldjtcbiAgICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIFJvdCB3b3JkXG4gICAgICAgICAgdCA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuXG4gICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICB0ID0gc2JveFt0ID4+PiAyNF0gPDwgMjQgfCBzYm94W3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBzYm94W3QgPj4+IDggJiAweGZmXSA8PCA4IHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICAgIHQgXj0gcmNvbltrc1JvdyAvIGtleVNpemUgfCAwXSA8PCAyNDtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT09IDQpIHtcbiAgICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTtcbiAgICAgICAgfVxuICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBwcmV2ID0gKGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KSA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuICAgICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludlN1Yk1peDBbc2JveFt0ID4+PiAyNF1dIF4gaW52U3ViTWl4MVtzYm94W3QgPj4+IDE2ICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94W3QgPj4+IDggJiAweGZmXV0gXiBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcbiAgICAgICAgfVxuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgICA7XG4gICAgX3Byb3RvLm5ldHdvcmtUb0hvc3RPcmRlclN3YXAgPSBmdW5jdGlvbiBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHdvcmQpIHtcbiAgICAgIHJldHVybiB3b3JkIDw8IDI0IHwgKHdvcmQgJiAweGZmMDApIDw8IDggfCAod29yZCAmIDB4ZmYwMDAwKSA+PiA4IHwgd29yZCA+Pj4gMjQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjcnlwdCA9IGZ1bmN0aW9uIGRlY3J5cHQoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJVikge1xuICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZTtcbiAgICAgIHZhciBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuICAgICAgdmFyIGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgICAgdmFyIGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgICB2YXIgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICAgIHZhciBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgICAgdmFyIGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgICB2YXIgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICAgIHZhciBpbml0VmVjdG9yMCA9IGluaXRWZWN0b3JbMF07XG4gICAgICB2YXIgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgICAgdmFyIGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICAgIHZhciBpbml0VmVjdG9yMyA9IGluaXRWZWN0b3JbM107XG4gICAgICB2YXIgaW5wdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0QXJyYXlCdWZmZXIpO1xuICAgICAgdmFyIG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuICAgICAgdmFyIHQwLCB0MSwgdDIsIHQzO1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgICAgdmFyIGlucHV0V29yZHMwLCBpbnB1dFdvcmRzMSwgaW5wdXRXb3JkczIsIGlucHV0V29yZHMzO1xuICAgICAgdmFyIGtzUm93LCBpO1xuICAgICAgdmFyIHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IGlucHV0SW50MzIubGVuZ3RoKSB7XG4gICAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgICAgaW5wdXRXb3JkczEgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDFdKTtcbiAgICAgICAgaW5wdXRXb3JkczIgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDJdKTtcbiAgICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcbiAgICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgICBzMSA9IGlucHV0V29yZHMzIF4gaW52S2V5U2NoZWR1bGVbMV07XG4gICAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuICAgICAgICBrc1JvdyA9IDQ7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByb3VuZHMgb2YgZGVjcnlwdGlvblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgICAgdDAgPSBpbnZTdWJNaXgwW3MwID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MxID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MyID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbczIgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczMgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgICB0MiA9IGludlN1Yk1peDBbczIgPj4+IDI0XSBeIGludlN1Yk1peDFbczMgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczAgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgICB0MyA9IGludlN1Yk1peDBbczMgPj4+IDI0XSBeIGludlN1Yk1peDFbczAgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczEgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgICBzMCA9IHQwO1xuICAgICAgICAgIHMxID0gdDE7XG4gICAgICAgICAgczIgPSB0MjtcbiAgICAgICAgICBzMyA9IHQzO1xuICAgICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICAgIHQwID0gaW52U0JPWFtzMCA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMSA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMiA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgdDEgPSBpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MyID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MzID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPSBpbnZTQk9YW3MyID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MzID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MwID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSBpbnZTQk9YW3MzID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MwID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MxID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcblxuICAgICAgICAvLyBXcml0ZVxuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXRdID0gc3dhcFdvcmQodDAgXiBpbml0VmVjdG9yMCk7XG4gICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XG4gICAgICAgIG91dHB1dEludDMyW29mZnNldCArIDNdID0gc3dhcFdvcmQodDEgXiBpbml0VmVjdG9yMyk7XG5cbiAgICAgICAgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG4gICAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICAgIGluaXRWZWN0b3IxID0gaW5wdXRXb3JkczE7XG4gICAgICAgIGluaXRWZWN0b3IyID0gaW5wdXRXb3JkczI7XG4gICAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0SW50MzIuYnVmZmVyO1xuICAgIH07XG4gICAgcmV0dXJuIEFFU0RlY3J5cHRvcjtcbiAgfSgpO1xuXG4gIHZhciBGYXN0QUVTS2V5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYXN0QUVTS2V5KHN1YnRsZSwga2V5LCBhZXNNb2RlKSB7XG4gICAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgICAgdGhpcy5hZXNNb2RlID0gdm9pZCAwO1xuICAgICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuYWVzTW9kZSA9IGFlc01vZGU7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBGYXN0QUVTS2V5LnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZXhwYW5kS2V5ID0gZnVuY3Rpb24gZXhwYW5kS2V5KCkge1xuICAgICAgdmFyIHN1YnRsZUFsZ29OYW1lID0gZ2V0U3VidGxlQWxnb05hbWUodGhpcy5hZXNNb2RlKTtcbiAgICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7XG4gICAgICAgIG5hbWU6IHN1YnRsZUFsZ29OYW1lXG4gICAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmFzdEFFU0tleTtcbiAgfSgpO1xuICBmdW5jdGlvbiBnZXRTdWJ0bGVBbGdvTmFtZShhZXNNb2RlKSB7XG4gICAgc3dpdGNoIChhZXNNb2RlKSB7XG4gICAgICBjYXNlIERlY3J5cHRlckFlc01vZGUuY2JjOlxuICAgICAgICByZXR1cm4gJ0FFUy1DQkMnO1xuICAgICAgY2FzZSBEZWNyeXB0ZXJBZXNNb2RlLmN0cjpcbiAgICAgICAgcmV0dXJuICdBRVMtQ1RSJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltGYXN0QUVTS2V5XSBpbnZhbGlkIGFlcyBtb2RlIFwiICsgYWVzTW9kZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIENIVU5LX1NJWkUgPSAxNjsgLy8gMTYgYnl0ZXMsIDEyOCBiaXRzXG4gIHZhciBEZWNyeXB0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlY3J5cHRlcihjb25maWcsIF90ZW1wKSB7XG4gICAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBfcmVmJHJlbW92ZVBLQ1M3UGFkZGkgPSBfcmVmLnJlbW92ZVBLQ1M3UGFkZGluZyxcbiAgICAgICAgcmVtb3ZlUEtDUzdQYWRkaW5nID0gX3JlZiRyZW1vdmVQS0NTN1BhZGRpID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRyZW1vdmVQS0NTN1BhZGRpO1xuICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gdm9pZCAwO1xuICAgICAgdGhpcy5zdWJ0bGUgPSBudWxsO1xuICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgICB0aGlzLmZhc3RBZXNLZXkgPSBudWxsO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgICB0aGlzLnVzZVNvZnR3YXJlID0gdm9pZCAwO1xuICAgICAgdGhpcy5lbmFibGVTb2Z0d2FyZUFFUyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZW5hYmxlU29mdHdhcmVBRVMgPSBjb25maWcuZW5hYmxlU29mdHdhcmVBRVM7XG4gICAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZztcbiAgICAgIC8vIGJ1aWx0IGluIGRlY3J5cHRvciBleHBlY3RzIFBLQ1M3IHBhZGRpbmdcbiAgICAgIGlmIChyZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgYnJvd3NlckNyeXB0byA9IHNlbGYuY3J5cHRvO1xuICAgICAgICAgIGlmIChicm93c2VyQ3J5cHRvKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8qIG5vLW9wICovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudXNlU29mdHdhcmUgPSAhdGhpcy5zdWJ0bGU7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBEZWNyeXB0ZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgICAgdGhpcy5rZXkgPSBudWxsO1xuICAgICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRJViA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmlzU3luYyA9IGZ1bmN0aW9uIGlzU3luYygpIHtcbiAgICAgIHJldHVybiB0aGlzLnVzZVNvZnR3YXJlO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICB2YXIgY3VycmVudFJlc3VsdCA9IHRoaXMuY3VycmVudFJlc3VsdCxcbiAgICAgICAgcmVtYWluZGVyRGF0YSA9IHRoaXMucmVtYWluZGVyRGF0YTtcbiAgICAgIGlmICghY3VycmVudFJlc3VsdCB8fCByZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGN1cnJlbnRSZXN1bHQpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgaWYgKHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQYWRkaW5nKGRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRJViA9IG51bGw7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIpIHtcbiAgICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjcnlwdCA9IGZ1bmN0aW9uIGRlY3J5cHQoZGF0YSwga2V5LCBpdiwgYWVzTW9kZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnVzZVNvZnR3YXJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIGRhdGFWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpID8gZGF0YSA6IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgIF90aGlzLnNvZnR3YXJlRGVjcnlwdChkYXRhVmlldywga2V5LCBpdiwgYWVzTW9kZSk7XG4gICAgICAgICAgdmFyIGRlY3J5cHRSZXN1bHQgPSBfdGhpcy5mbHVzaCgpO1xuICAgICAgICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXNvbHZlKGRlY3J5cHRSZXN1bHQuYnVmZmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignW3NvZnR3YXJlRGVjcnlwdF0gRmFpbGVkIHRvIGRlY3J5cHQgZGF0YScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShkYXRhKSwga2V5LCBpdiwgYWVzTW9kZSk7XG4gICAgfVxuXG4gICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICAgIDtcbiAgICBfcHJvdG8uc29mdHdhcmVEZWNyeXB0ID0gZnVuY3Rpb24gc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYsIGFlc01vZGUpIHtcbiAgICAgIHZhciBjdXJyZW50SVYgPSB0aGlzLmN1cnJlbnRJVixcbiAgICAgICAgY3VycmVudFJlc3VsdCA9IHRoaXMuY3VycmVudFJlc3VsdCxcbiAgICAgICAgcmVtYWluZGVyRGF0YSA9IHRoaXMucmVtYWluZGVyRGF0YTtcbiAgICAgIGlmIChhZXNNb2RlICE9PSBEZWNyeXB0ZXJBZXNNb2RlLmNiYyB8fCBrZXkuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1NvZnR3YXJlRGVjcnlwdDogY2FuIG9ubHkgaGFuZGxlIEFFUy0xMjgtQ0JDJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dPbmNlKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgICAgLy8gVGhlIG91dHB1dCBpcyBzdGFnZ2VyZWQgZHVyaW5nIHByb2dyZXNzaXZlIHBhcnNpbmcgLSB0aGUgY3VycmVudCByZXN1bHQgaXMgY2FjaGVkLCBhbmQgZW1pdHRlZCBvbiB0aGUgbmV4dCBjYWxsXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gb3JkZXIgdG8gc3RyaXAgUEtDUzcgcGFkZGluZywgd2hpY2ggaXMgZm91bmQgYXQgdGhlIGVuZCBvZiBlYWNoIHNlZ21lbnQuIFdlIG9ubHkga25vdyB3ZSd2ZSByZWFjaGVkXG4gICAgICAvLyB0aGUgZW5kIG9uIGZsdXNoKCksIGJ1dCBieSB0aGF0IHRpbWUgd2UgaGF2ZSBhbHJlYWR5IHJlY2VpdmVkIGFsbCBieXRlcyBmb3IgdGhlIHNlZ21lbnQuXG4gICAgICAvLyBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBXZWJDcnlwdG9cblxuICAgICAgaWYgKHJlbWFpbmRlckRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkocmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEJ5dGUgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNiAoQUVTLTEyOCA9IDEyOCBiaXQgYmxvY2tzID0gMTYgYnl0ZXMpXG4gICAgICB2YXIgY3VycmVudENodW5rID0gdGhpcy5nZXRWYWxpZENodW5rKGRhdGEpO1xuICAgICAgaWYgKCFjdXJyZW50Q2h1bmsubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRJVikge1xuICAgICAgICBpdiA9IGN1cnJlbnRJVjtcbiAgICAgIH1cbiAgICAgIHZhciBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXI7XG4gICAgICBpZiAoIXNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICAgIHNvZnR3YXJlRGVjcnlwdGVyID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG5ldyBBRVNEZWNyeXB0b3IoKTtcbiAgICAgIH1cbiAgICAgIHNvZnR3YXJlRGVjcnlwdGVyLmV4cGFuZEtleShrZXkpO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1cnJlbnRSZXN1bHQ7XG4gICAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBzb2Z0d2FyZURlY3J5cHRlci5kZWNyeXB0KGN1cnJlbnRDaHVuay5idWZmZXIsIDAsIGl2KTtcbiAgICAgIHRoaXMuY3VycmVudElWID0gY3VycmVudENodW5rLnNsaWNlKC0xNikuYnVmZmVyO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLndlYkNyeXB0b0RlY3J5cHQgPSBmdW5jdGlvbiB3ZWJDcnlwdG9EZWNyeXB0KGRhdGEsIGtleSwgaXYsIGFlc01vZGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMua2V5ICE9PSBrZXkgfHwgIXRoaXMuZmFzdEFlc0tleSkge1xuICAgICAgICBpZiAoIXRoaXMuc3VidGxlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdiwgYWVzTW9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleSh0aGlzLnN1YnRsZSwga2V5LCBhZXNNb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkudGhlbihmdW5jdGlvbiAoYWVzS2V5KSB7XG4gICAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgICBpZiAoIV90aGlzMi5zdWJ0bGUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd3ZWIgY3J5cHRvIG5vdCBpbml0aWFsaXplZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczIubG9nT25jZSgnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICAgIHZhciBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKF90aGlzMi5zdWJ0bGUsIG5ldyBVaW50OEFycmF5KGl2KSwgYWVzTW9kZSk7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZGVjcnlwdChkYXRhLmJ1ZmZlciwgYWVzS2V5KTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJbZGVjcnlwdGVyXTogV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEksIFwiICsgZXJyLm5hbWUgKyBcIjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBfdGhpczIub25XZWJDcnlwdG9FcnJvcihkYXRhLCBrZXksIGl2LCBhZXNNb2RlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLm9uV2ViQ3J5cHRvRXJyb3IgPSBmdW5jdGlvbiBvbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYsIGFlc01vZGUpIHtcbiAgICAgIHZhciBlbmFibGVTb2Z0d2FyZUFFUyA9IHRoaXMuZW5hYmxlU29mdHdhcmVBRVM7XG4gICAgICBpZiAoZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgICAgdGhpcy51c2VTb2Z0d2FyZSA9IHRydWU7XG4gICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYsIGFlc01vZGUpO1xuICAgICAgICB2YXIgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgaWYgKGRlY3J5cHRSZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gZGVjcnlwdFJlc3VsdC5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViQ3J5cHRvJyArIChlbmFibGVTb2Z0d2FyZUFFUyA/ICcgYW5kIHNvZnR3YXJlRGVjcnlwdCcgOiAnJykgKyAnOiBmYWlsZWQgdG8gZGVjcnlwdCBkYXRhJyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0VmFsaWRDaHVuayA9IGZ1bmN0aW9uIGdldFZhbGlkQ2h1bmsoZGF0YSkge1xuICAgICAgdmFyIGN1cnJlbnRDaHVuayA9IGRhdGE7XG4gICAgICB2YXIgc3BsaXRQb2ludCA9IGRhdGEubGVuZ3RoIC0gZGF0YS5sZW5ndGggJSBDSFVOS19TSVpFO1xuICAgICAgaWYgKHNwbGl0UG9pbnQgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGN1cnJlbnRDaHVuayA9IGRhdGEuc2xpY2UoMCwgc3BsaXRQb2ludCk7XG4gICAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGEuc2xpY2Uoc3BsaXRQb2ludCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudENodW5rO1xuICAgIH07XG4gICAgX3Byb3RvLmxvZ09uY2UgPSBmdW5jdGlvbiBsb2dPbmNlKG1zZykge1xuICAgICAgaWYgKCF0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZyhcIltkZWNyeXB0ZXJdOiBcIiArIG1zZyk7XG4gICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNyeXB0ZXI7XG4gIH0oKTtcblxuICB2YXIgTUlOX0NIVU5LX1NJWkUgPSBNYXRoLnBvdygyLCAxNyk7IC8vIDEyOGtiXG4gIHZhciBGcmFnbWVudExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnJhZ21lbnRMb2FkZXIoY29uZmlnKSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgIHRoaXMucGFydExvYWRUaW1lb3V0ID0gLTE7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICAvLyBBYm9ydCB0aGUgbG9hZGVyIGZvciBjdXJyZW50IGZyYWdtZW50LiBPbmx5IG9uZSBtYXkgbG9hZCBhdCBhbnkgZ2l2ZW4gdGltZVxuICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGZyYWcsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgdXJsID0gZnJhZy51cmw7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIkZyYWdtZW50IGRvZXMgbm90IGhhdmUgYSBcIiArICh1cmwgPyAncGFydCBsaXN0JyA6ICd1cmwnKSksXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgdmFyIEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgICAgdmFyIERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChfdGhpcy5sb2FkZXIpIHtcbiAgICAgICAgICBfdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICAgIGlmIChmcmFnLnRhZ0xpc3Quc29tZShmdW5jdGlvbiAodGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ3NbMF0gPT09ICdHQVAnO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZWplY3QoY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGVtcG9yYXJ5IHRyZWF0bWVudCBhcyBHQVAgdGFnXG4gICAgICAgICAgICBmcmFnLmdhcCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9hZGVyID0gX3RoaXMubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnKTtcbiAgICAgICAgZnJhZy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgIHZhciBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCk7XG4gICAgICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgICAgbG9hZFBvbGljeTogbG9hZFBvbGljeSxcbiAgICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICAgIGhpZ2hXYXRlck1hcms6IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgPyBJbmZpbml0eSA6IE1JTl9DSFVOS19TSVpFXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFzc2lnbiBmcmFnIHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgICAgZnJhZy5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHtcbiAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQucmVzZXRJViAmJiBmcmFnLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgICAgICAgIGZyYWcuZGVjcnlwdGRhdGEuaXYgPSBuZXcgVWludDhBcnJheShwYXlsb2FkLnNsaWNlKDAsIDE2KSk7XG4gICAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLnNsaWNlKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfSwgcmVzcG9uc2UpLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiSFRUUCBFcnJvciBcIiArIHJlc3BvbnNlLmNvZGUgKyBcIiBcIiArIHJlc3BvbnNlLnRleHQpLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICAgIHN0YXRzOiBzdGF0c1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25BYm9ydDogZnVuY3Rpb24gb25BYm9ydChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIF90aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignQWJvcnRlZCcpLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICAgIHN0YXRzOiBzdGF0c1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25UaW1lb3V0OiBmdW5jdGlvbiBvblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiVGltZW91dCBhZnRlciBcIiArIGxvYWRlckNvbmZpZy50aW1lb3V0ICsgXCJtc1wiKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgY2FsbGJhY2tzLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkUGFydCA9IGZ1bmN0aW9uIGxvYWRQYXJ0KGZyYWcsIHBhcnQsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgdmFyIEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgICAgdmFyIERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChfdGhpczIubG9hZGVyKSB7XG4gICAgICAgICAgX3RoaXMyLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWcuZ2FwIHx8IHBhcnQuZ2FwKSB7XG4gICAgICAgICAgcmVqZWN0KGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnLCBwYXJ0KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2FkZXIgPSBfdGhpczIubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnLCBwYXJ0KTtcbiAgICAgICAgZnJhZy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgIC8vIFNob3VsZCB3ZSBkZWZpbmUgYW5vdGhlciBsb2FkIHBvbGljeSBmb3IgcGFydHM/XG4gICAgICAgIHZhciBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCk7XG4gICAgICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgICAgbG9hZFBvbGljeTogbG9hZFBvbGljeSxcbiAgICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICAgIGhpZ2hXYXRlck1hcms6IE1JTl9DSFVOS19TSVpFXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFzc2lnbiBwYXJ0IHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgICAgcGFydC5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgICAgX3RoaXMyLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgICBfdGhpczIudXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KTtcbiAgICAgICAgICAgIHZhciBwYXJ0TG9hZGVkRGF0YSA9IHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgICByZXNvbHZlKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykge1xuICAgICAgICAgICAgX3RoaXMyLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgICByZXNwb25zZTogX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH0sIHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIkhUVFAgRXJyb3IgXCIgKyByZXNwb25zZS5jb2RlICsgXCIgXCIgKyByZXNwb25zZS50ZXh0KSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQWJvcnQ6IGZ1bmN0aW9uIG9uQWJvcnQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgICBmcmFnLnN0YXRzLmFib3J0ZWQgPSBwYXJ0LnN0YXRzLmFib3J0ZWQ7XG4gICAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdBYm9ydGVkJyksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHM6IHN0YXRzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblRpbWVvdXQ6IGZ1bmN0aW9uIG9uVGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIF90aGlzMi5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiVGltZW91dCBhZnRlciBcIiArIGxvYWRlckNvbmZpZy50aW1lb3V0ICsgXCJtc1wiKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlU3RhdHNGcm9tUGFydCA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCkge1xuICAgICAgdmFyIGZyYWdTdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICB2YXIgcGFydFN0YXRzID0gcGFydC5zdGF0cztcbiAgICAgIHZhciBwYXJ0VG90YWwgPSBwYXJ0U3RhdHMudG90YWw7XG4gICAgICBmcmFnU3RhdHMubG9hZGVkICs9IHBhcnRTdGF0cy5sb2FkZWQ7XG4gICAgICBpZiAocGFydFRvdGFsKSB7XG4gICAgICAgIHZhciBlc3RUb3RhbFBhcnRzID0gTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uIC8gcGFydC5kdXJhdGlvbik7XG4gICAgICAgIHZhciBlc3RMb2FkZWRQYXJ0cyA9IE1hdGgubWluKE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIHBhcnRUb3RhbCksIGVzdFRvdGFsUGFydHMpO1xuICAgICAgICB2YXIgZXN0UmVtYWluaW5nUGFydHMgPSBlc3RUb3RhbFBhcnRzIC0gZXN0TG9hZGVkUGFydHM7XG4gICAgICAgIHZhciBlc3RSZW1haW5pbmdCeXRlcyA9IGVzdFJlbWFpbmluZ1BhcnRzICogTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gZXN0TG9hZGVkUGFydHMpO1xuICAgICAgICBmcmFnU3RhdHMudG90YWwgPSBmcmFnU3RhdHMubG9hZGVkICsgZXN0UmVtYWluaW5nQnl0ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnU3RhdHMudG90YWwgPSBNYXRoLm1heChmcmFnU3RhdHMubG9hZGVkLCBmcmFnU3RhdHMudG90YWwpO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWdMb2FkaW5nID0gZnJhZ1N0YXRzLmxvYWRpbmc7XG4gICAgICB2YXIgcGFydExvYWRpbmcgPSBwYXJ0U3RhdHMubG9hZGluZztcbiAgICAgIGlmIChmcmFnTG9hZGluZy5zdGFydCkge1xuICAgICAgICAvLyBhZGQgdG8gZnJhZ21lbnQgbG9hZGVyIGxhdGVuY3lcbiAgICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgKz0gcGFydExvYWRpbmcuZmlyc3QgLSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdMb2FkaW5nLnN0YXJ0ID0gcGFydExvYWRpbmcuc3RhcnQ7XG4gICAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ID0gcGFydExvYWRpbmcuZmlyc3Q7XG4gICAgICB9XG4gICAgICBmcmFnTG9hZGluZy5lbmQgPSBwYXJ0TG9hZGluZy5lbmQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRMb2FkZXIgPSBmdW5jdGlvbiByZXNldExvYWRlcihmcmFnLCBsb2FkZXIpIHtcbiAgICAgIGZyYWcubG9hZGVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucGFydExvYWRUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBGcmFnbWVudExvYWRlcjtcbiAgfSgpO1xuICBmdW5jdGlvbiBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQpIHtcbiAgICBpZiAocGFydCA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNlZ21lbnQgPSBwYXJ0IHx8IGZyYWc7XG4gICAgdmFyIGxvYWRlckNvbnRleHQgPSB7XG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgcGFydDogcGFydCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgIHVybDogc2VnbWVudC51cmwsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgICByYW5nZUVuZDogMFxuICAgIH07XG4gICAgdmFyIHN0YXJ0ID0gc2VnbWVudC5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgICB2YXIgZW5kID0gc2VnbWVudC5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0KSAmJiBpc0Zpbml0ZU51bWJlcihlbmQpKSB7XG4gICAgICB2YXIgX2ZyYWckZGVjcnlwdGRhdGE7XG4gICAgICB2YXIgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICAgIHZhciBieXRlUmFuZ2VFbmQgPSBlbmQ7XG4gICAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyAmJiBpc01ldGhvZEZ1bGxTZWdtZW50QWVzQ2JjKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRkZWNyeXB0ZGF0YS5tZXRob2QpKSB7XG4gICAgICAgIC8vIE1BUCBzZWdtZW50IGVuY3J5cHRlZCB3aXRoIG1ldGhvZCAnQUVTLTEyOCcgb3IgJ0FFUy0yNTYnIChjYmMpLCB3aGVuIHNlcnZlZCB3aXRoIEhUVFAgUmFuZ2UsXG4gICAgICAgIC8vIGhhcyB0aGUgdW5lbmNyeXB0ZWQgc2l6ZSBzcGVjaWZpZWQgaW4gdGhlIHJhbmdlLlxuICAgICAgICAvLyBSZWY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaGxzLXJmYzgyMTZiaXMtMDgjc2VjdGlvbi02LjMuNlxuICAgICAgICB2YXIgZnJhZ21lbnRMZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgICAgaWYgKGZyYWdtZW50TGVuICUgMTYpIHtcbiAgICAgICAgICBieXRlUmFuZ2VFbmQgPSBlbmQgKyAoMTYgLSBmcmFnbWVudExlbiAlIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgICAgICBsb2FkZXJDb250ZXh0LnJlc2V0SVYgPSB0cnVlO1xuICAgICAgICAgIGJ5dGVSYW5nZVN0YXJ0ID0gc3RhcnQgLSAxNjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZVN0YXJ0ID0gYnl0ZVJhbmdlU3RhcnQ7XG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gYnl0ZVJhbmdlRW5kO1xuICAgIH1cbiAgICByZXR1cm4gbG9hZGVyQ29udGV4dDtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZywgcGFydCkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkdBUCBcIiArIChmcmFnLmdhcCA/ICd0YWcnIDogJ2F0dHJpYnV0ZScpICsgXCIgZm91bmRcIik7XG4gICAgdmFyIGVycm9yRGF0YSA9IHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19HQVAsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICB9O1xuICAgIGlmIChwYXJ0KSB7XG4gICAgICBlcnJvckRhdGEucGFydCA9IHBhcnQ7XG4gICAgfVxuICAgIChwYXJ0ID8gcGFydCA6IGZyYWcpLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgTG9hZEVycm9yKGVycm9yRGF0YSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNNZXRob2RGdWxsU2VnbWVudEFlc0NiYyhtZXRob2QpIHtcbiAgICByZXR1cm4gbWV0aG9kID09PSAnQUVTLTEyOCcgfHwgbWV0aG9kID09PSAnQUVTLTI1Nic7XG4gIH1cbiAgdmFyIExvYWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gICAgZnVuY3Rpb24gTG9hZEVycm9yKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczM7XG4gICAgICBfdGhpczMgPSBfRXJyb3IuY2FsbCh0aGlzLCBkYXRhLmVycm9yLm1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICBfdGhpczMuZGF0YSA9IHZvaWQgMDtcbiAgICAgIF90aGlzMy5kYXRhID0gZGF0YTtcbiAgICAgIHJldHVybiBfdGhpczM7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKExvYWRFcnJvciwgX0Vycm9yKTtcbiAgICByZXR1cm4gTG9hZEVycm9yO1xuICB9KC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICogU3ViLWNsYXNzIHNwZWNpYWxpemF0aW9uIG9mIEV2ZW50SGFuZGxlciBiYXNlIGNsYXNzLlxuICAgKlxuICAgKiBUYXNrTG9vcCBhbGxvd3MgdG8gc2NoZWR1bGUgYSB0YXNrIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCAob3B0aW9ubmFseSByZXBlYXRlZGx5KSBvbiB0aGUgbWFpbiBsb29wLFxuICAgKiBzY2hlZHVsZWQgYXN5bmNocm9uZW91c2x5LCBhdm9pZGluZyByZWN1cnNpdmUgY2FsbHMgaW4gdGhlIHNhbWUgdGljay5cbiAgICpcbiAgICogVGhlIHRhc2sgaXRzZWxmIGlzIGltcGxlbWVudGVkIGluIGBkb1RpY2tgLiBJdCBjYW4gYmUgcmVxdWVzdGVkIGFuZCBjYWxsZWQgZm9yIHNpbmdsZSBleGVjdXRpb25cbiAgICogdXNpbmcgdGhlIGB0aWNrYCBtZXRob2QuXG4gICAqXG4gICAqIEl0IHdpbGwgYmUgYXNzdXJlZCB0aGF0IHRoZSB0YXNrIGV4ZWN1dGlvbiBtZXRob2QgKGB0aWNrYCkgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBtYWluIGxvb3AgXCJ0aWNrXCIsXG4gICAqIG5vIG1hdHRlciBob3cgb2Z0ZW4gaXQgZ2V0cyByZXF1ZXN0ZWQgZm9yIGV4ZWN1dGlvbi4gRXhlY3V0aW9uIGluIGZ1cnRoZXIgdGlja3Mgd2lsbCBiZSBzY2hlZHVsZWQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIElmIGZ1cnRoZXIgZXhlY3V0aW9uIHJlcXVlc3RzIGhhdmUgYWxyZWFkeSBiZWVuIHNjaGVkdWxlZCBvbiB0aGUgbmV4dCB0aWNrLCBpdCBjYW4gYmUgY2hlY2tlZCB3aXRoIGBoYXNOZXh0VGlja2AsXG4gICAqIGFuZCBjYW5jZWxsZWQgd2l0aCBgY2xlYXJOZXh0VGlja2AuXG4gICAqXG4gICAqIFRoZSB0YXNrIGNhbiBiZSBzY2hlZHVsZWQgYXMgYW4gaW50ZXJ2YWwgcmVwZWF0ZWRseSB3aXRoIGEgcGVyaW9kIGFzIHBhcmFtZXRlciAoc2VlIGBzZXRJbnRlcnZhbGAsIGBjbGVhckludGVydmFsYCkuXG4gICAqXG4gICAqIFN1Yi1jbGFzc2VzIG5lZWQgdG8gaW1wbGVtZW50IHRoZSBgZG9UaWNrYCBtZXRob2Qgd2hpY2ggd2lsbCBlZmZlY3RpdmVseSBoYXZlIHRoZSB0YXNrIGV4ZWN1dGlvbiByb3V0aW5lLlxuICAgKlxuICAgKiBGdXJ0aGVyIGV4cGxhbmF0aW9uczpcbiAgICpcbiAgICogVGhlIGJhc2VjbGFzcyBoYXMgYSBgdGlja2AgbWV0aG9kIHRoYXQgd2lsbCBzY2hlZHVsZSB0aGUgZG9UaWNrIGNhbGwuIEl0IG1heSBiZSBjYWxsZWQgc3luY2hyb25lb3VzbHlcbiAgICogb25seSBmb3IgYSBzdGFjay1kZXB0aCBvZiBvbmUuIE9uIHJlLWVudHJhbnQgY2FsbHMsIHN1Yi1zZXF1ZW50IGNhbGxzIGFyZSBzY2hlZHVsZWQgZm9yIG5leHQgbWFpbiBsb29wIHRpY2tzLlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXNrIGV4ZWN1dGlvbiAoYHRpY2tgIG1ldGhvZCkgaXMgY2FsbGVkIGluIHJlLWVudHJhbnQgd2F5IHRoaXMgaXMgZGV0ZWN0ZWQgYW5kXG4gICAqIHdlIGFyZSBsaW1pdGluZyB0aGUgdGFzayBleGVjdXRpb24gcGVyIGNhbGwgc3RhY2sgdG8gZXhhY3RseSBvbmUsIGJ1dCBzY2hlZHVsaW5nL3Bvc3QtcG9uaW5nIGZ1cnRoZXJcbiAgICogdGFzayBwcm9jZXNzaW5nIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gKGFsc28ga25vd24gYXMgXCJuZXh0IHRpY2tcIiBpbiB0aGUgTm9kZS9KUyBydW50aW1lIGxpbmdvKS5cbiAgICovXG4gIHZhciBUYXNrTG9vcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvZ2dlcikge1xuICAgIGZ1bmN0aW9uIFRhc2tMb29wKGxhYmVsLCBsb2dnZXIpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX0xvZ2dlci5jYWxsKHRoaXMsIGxhYmVsLCBsb2dnZXIpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5fYm91bmRUaWNrID0gdm9pZCAwO1xuICAgICAgX3RoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgICBfdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICAgIF90aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICAgIF90aGlzLl9ib3VuZFRpY2sgPSBfdGhpcy50aWNrLmJpbmQoX3RoaXMpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHNMb29zZShUYXNrTG9vcCwgX0xvZ2dlcik7XG4gICAgdmFyIF9wcm90byA9IFRhc2tMb29wLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3llZCA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3llZCgpIHt9O1xuICAgIF9wcm90by5oYXNJbnRlcnZhbCA9IGZ1bmN0aW9uIGhhc0ludGVydmFsKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fdGlja0ludGVydmFsO1xuICAgIH07XG4gICAgX3Byb3RvLmhhc05leHRUaWNrID0gZnVuY3Rpb24gaGFzTmV4dFRpY2soKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl90aWNrVGltZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1pbGxpcyAtIEludGVydmFsIHRpbWUgKG1zKVxuICAgICAqIEBldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIGhhcyBiZWVuIHNjaGVkdWxlZCwgZmFsc2Ugd2hlbiBhbHJlYWR5IHNjaGVkdWxlZCAobm8gZWZmZWN0KVxuICAgICAqLztcbiAgICBfcHJvdG8uc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiBzZXRJbnRlcnZhbChtaWxsaXMpIHtcbiAgICAgIGlmICghdGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMuX2JvdW5kVGljaywgbWlsbGlzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgICAqLztcbiAgICBfcHJvdG8uY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWwoKSB7XG4gICAgICBpZiAodGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICAgKi87XG4gICAgX3Byb3RvLmNsZWFyTmV4dFRpY2sgPSBmdW5jdGlvbiBjbGVhck5leHRUaWNrKCkge1xuICAgICAgaWYgKHRoaXMuX3RpY2tUaW1lcikge1xuICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLl90aWNrVGltZXIpO1xuICAgICAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGNhbGwgdGhlIHN1YmNsYXNzIGRvVGljayBpbXBsZW1lbnRhdGlvbiBpbiB0aGlzIG1haW4gbG9vcCB0aWNrXG4gICAgICogb3IgaW4gdGhlIG5leHQgb25lICh2aWEgc2V0VGltZW91dCgsMCkpIGluIGNhc2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICAgKiBpbiB0aGlzIHRpY2sgKGluIGNhc2UgdGhpcyBpcyBhIHJlLWVudHJhbnQgY2FsbCkuXG4gICAgICovO1xuICAgIF9wcm90by50aWNrID0gZnVuY3Rpb24gdGljaygpIHtcbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQrKztcbiAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID09PSAxKSB7XG4gICAgICAgIHRoaXMuZG9UaWNrKCk7XG4gICAgICAgIC8vIHJlLWVudHJhbnQgY2FsbCB0byB0aWNrIGZyb20gcHJldmlvdXMgZG9UaWNrIGNhbGwgc3RhY2tcbiAgICAgICAgLy8gLT4gc2NoZWR1bGUgYSBjYWxsIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gdG8gcHJvY2VzcyB0aGlzIHRhc2sgcHJvY2Vzc2luZyByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID4gMSkge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSBvbmx5IG9uZSB0aW1lciBleGlzdHMgYXQgYW55IHRpbWUgYXQgbWF4XG4gICAgICAgICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udGlja0ltbWVkaWF0ZSA9IGZ1bmN0aW9uIHRpY2tJbW1lZGlhdGUoKSB7XG4gICAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICAgIHRoaXMuX3RpY2tUaW1lciA9IHNlbGYuc2V0VGltZW91dCh0aGlzLl9ib3VuZFRpY2ssIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBzdWJjbGFzcyB0byBpbXBsZW1lbnQgdGFzayBsb2dpY1xuICAgICAqIEBhYnN0cmFjdFxuICAgICAqLztcbiAgICBfcHJvdG8uZG9UaWNrID0gZnVuY3Rpb24gZG9UaWNrKCkge307XG4gICAgcmV0dXJuIFRhc2tMb29wO1xuICB9KExvZ2dlcik7XG5cbiAgdmFyIENodW5rTWV0YWRhdGEgPSBmdW5jdGlvbiBDaHVua01ldGFkYXRhKGxldmVsLCBzbiwgaWQsIHNpemUsIHBhcnQsIHBhcnRpYWwpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaXplID0gMDtcbiAgICB9XG4gICAgaWYgKHBhcnQgPT09IHZvaWQgMCkge1xuICAgICAgcGFydCA9IC0xO1xuICAgIH1cbiAgICBpZiAocGFydGlhbCA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJ0aWFsID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubGV2ZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5zbiA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0aWFsID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNtdXhpbmcgPSBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpO1xuICAgIHRoaXMuYnVmZmVyaW5nID0ge1xuICAgICAgYXVkaW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgICB2aWRlbzogZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKSxcbiAgICAgIGF1ZGlvdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKClcbiAgICB9O1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLnNuID0gc247XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICB9O1xuICBmdW5jdGlvbiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBleGVjdXRlU3RhcnQ6IDAsXG4gICAgICBleGVjdXRlRW5kOiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBtZXRob2RzIGRlYWxpbmcgd2l0aCBidWZmZXIgbGVuZ3RoIHJldHJpZXZhbCBmb3IgZXhhbXBsZS5cbiAgICpcbiAgICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQWxzbyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L2J1ZmZlcmVkXG4gICAqL1xuXG4gIHZhciBub29wQnVmZmVyZWQgPSB7XG4gICAgbGVuZ3RoOiAwLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIHZhciBCdWZmZXJIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlckhlbHBlcigpIHt9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgYG1lZGlhYCdzIGJ1ZmZlcmVkIGluY2x1ZGUgYHBvc2l0aW9uYFxuICAgICAqL1xuICAgIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkID0gZnVuY3Rpb24gaXNCdWZmZXJlZChtZWRpYSwgcG9zaXRpb24pIHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB2YXIgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICBmb3IgKHZhciBpID0gYnVmZmVyZWQubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGJ1ZmZlcmVkLnN0YXJ0KGkpICYmIHBvc2l0aW9uIDw9IGJ1ZmZlcmVkLmVuZChpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBCdWZmZXJIZWxwZXIuYnVmZmVyZWRSYW5nZXMgPSBmdW5jdGlvbiBidWZmZXJlZFJhbmdlcyhtZWRpYSkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHZhciB0aW1lUmFuZ2VzID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlckhlbHBlci50aW1lUmFuZ2VzVG9BcnJheSh0aW1lUmFuZ2VzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEJ1ZmZlckhlbHBlci50aW1lUmFuZ2VzVG9BcnJheSA9IGZ1bmN0aW9uIHRpbWVSYW5nZXNUb0FycmF5KHRpbWVSYW5nZXMpIHtcbiAgICAgIHZhciBidWZmZXJlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lUmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICAgIHN0YXJ0OiB0aW1lUmFuZ2VzLnN0YXJ0KGkpLFxuICAgICAgICAgIGVuZDogdGltZVJhbmdlcy5lbmQoaSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyZWQ7XG4gICAgfTtcbiAgICBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyA9IGZ1bmN0aW9uIGJ1ZmZlckluZm8obWVkaWEsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdmFyIGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkUmFuZ2VzKG1lZGlhKTtcbiAgICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlbjogMCxcbiAgICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgICAgZW5kOiBwb3MsXG4gICAgICAgIGJ1ZmZlcmVkSW5kZXg6IC0xXG4gICAgICB9O1xuICAgIH07XG4gICAgQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyA9IGZ1bmN0aW9uIGJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgIHBvcyA9IE1hdGgubWF4KDAsIHBvcyk7XG4gICAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID4gMSkge1xuICAgICAgICBidWZmZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0IHx8IGIuZW5kIC0gYS5lbmQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlcmVkSW5kZXggPSAtMTtcbiAgICAgIHZhciBidWZmZXJlZDIgPSBbXTtcbiAgICAgIGlmIChtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgICAvLyBidWZmZXIgdGltZSByYW5nZSByZXByZXNlbnRhdGlvbnMgdGhhdCBkaXNjYXJkcyB0aG9zZSBob2xlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBvcyA+PSBidWZmZXJlZFtpXS5zdGFydCAmJiBwb3MgPD0gYnVmZmVyZWRbaV0uZW5kKSB7XG4gICAgICAgICAgICBidWZmZXJlZEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgICAgICB2YXIgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcbiAgICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB2YWx1ZVxuICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyZWQyID0gYnVmZmVyZWQ7XG4gICAgICB9XG4gICAgICB2YXIgYnVmZmVyTGVuID0gMDtcbiAgICAgIHZhciBuZXh0U3RhcnQ7XG5cbiAgICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIChwb3MpXG4gICAgICB2YXIgYnVmZmVyU3RhcnQgPSBwb3M7XG4gICAgICB2YXIgYnVmZmVyRW5kID0gcG9zO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJ1ZmZlcmVkMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gYnVmZmVyZWQyW19pXS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IGJ1ZmZlcmVkMltfaV0uZW5kO1xuICAgICAgICAvLyBsb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG4gICAgICAgIGlmIChidWZmZXJlZEluZGV4ID09PSAtMSAmJiBwb3MgPj0gc3RhcnQgJiYgcG9zIDw9IGVuZCkge1xuICAgICAgICAgIGJ1ZmZlcmVkSW5kZXggPSBfaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xuICAgICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xuICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgICAgfSBlbHNlIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPCBzdGFydCkge1xuICAgICAgICAgIG5leHRTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZW46IGJ1ZmZlckxlbixcbiAgICAgICAgc3RhcnQ6IGJ1ZmZlclN0YXJ0IHx8IDAsXG4gICAgICAgIGVuZDogYnVmZmVyRW5kIHx8IDAsXG4gICAgICAgIG5leHRTdGFydDogbmV4dFN0YXJ0LFxuICAgICAgICBidWZmZXJlZDogYnVmZmVyZWQsXG4gICAgICAgIGJ1ZmZlcmVkSW5kZXg6IGJ1ZmZlcmVkSW5kZXhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2FmZSBtZXRob2QgdG8gZ2V0IGJ1ZmZlcmVkIHByb3BlcnR5LlxuICAgICAqIFNvdXJjZUJ1ZmZlci5idWZmZXJlZCBtYXkgdGhyb3cgaWYgU291cmNlQnVmZmVyIGlzIHJlbW92ZWQgZnJvbSBpdCdzIE1lZGlhU291cmNlXG4gICAgICovO1xuICAgIEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZCA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkKG1lZGlhKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbWVkaWEuYnVmZmVyZWQgfHwgbm9vcEJ1ZmZlcmVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIubG9nKCdmYWlsZWQgdG8gZ2V0IG1lZGlhLmJ1ZmZlcmVkJywgZSk7XG4gICAgICAgIHJldHVybiBub29wQnVmZmVyZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVySGVscGVyO1xuICB9KCk7XG5cbiAgdmFyIFZBUklBQkxFX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xce1xcJChbYS16QS1aMC05LV9dKylcXH0vZztcbiAgZnVuY3Rpb24gaGFzVmFyaWFibGVSZWZlcmVuY2VzKHN0cikge1xuICAgIHJldHVybiBWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWC50ZXN0KHN0cik7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHZhbHVlKSB7XG4gICAgaWYgKHBhcnNlZC52YXJpYWJsZUxpc3QgIT09IG51bGwgfHwgcGFyc2VkLmhhc1ZhcmlhYmxlUmVmcykge1xuICAgICAgdmFyIHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWCwgZnVuY3Rpb24gKHZhcmlhYmxlUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZU5hbWUgPSB2YXJpYWJsZVJlZmVyZW5jZS5zdWJzdHJpbmcoMiwgdmFyaWFibGVSZWZlcmVuY2UubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciB2YXJpYWJsZVZhbHVlID0gdmFyaWFibGVMaXN0ID09IG51bGwgPyB2b2lkIDAgOiB2YXJpYWJsZUxpc3RbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgaWYgKHZhcmlhYmxlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKFwiTWlzc2luZyBwcmVjZWRpbmcgRVhULVgtREVGSU5FIHRhZyBmb3IgVmFyaWFibGUgUmVmZXJlbmNlOiBcXFwiXCIgKyB2YXJpYWJsZU5hbWUgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIHJldHVybiB2YXJpYWJsZVJlZmVyZW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVmFyaWFibGVEZWZpbml0aW9uKHBhcnNlZCwgYXR0ciwgcGFyZW50VXJsKSB7XG4gICAgdmFyIHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gICAgaWYgKCF2YXJpYWJsZUxpc3QpIHtcbiAgICAgIHBhcnNlZC52YXJpYWJsZUxpc3QgPSB2YXJpYWJsZUxpc3QgPSB7fTtcbiAgICB9XG4gICAgdmFyIE5BTUU7XG4gICAgdmFyIFZBTFVFO1xuICAgIGlmICgnUVVFUllQQVJBTScgaW4gYXR0cikge1xuICAgICAgTkFNRSA9IGF0dHIuUVVFUllQQVJBTTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZWFyY2hQYXJhbXMgPSBuZXcgc2VsZi5VUkwocGFyZW50VXJsKS5zZWFyY2hQYXJhbXM7XG4gICAgICAgIGlmIChzZWFyY2hQYXJhbXMuaGFzKE5BTUUpKSB7XG4gICAgICAgICAgVkFMVUUgPSBzZWFyY2hQYXJhbXMuZ2V0KE5BTUUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJcIiArIE5BTUUgKyBcIlxcXCIgZG9lcyBub3QgbWF0Y2ggYW55IHF1ZXJ5IHBhcmFtZXRlciBpbiBVUkk6IFxcXCJcIiArIHBhcmVudFVybCArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoXCJFWFQtWC1ERUZJTkUgUVVFUllQQVJBTTogXCIgKyBlcnJvci5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE5BTUUgPSBhdHRyLk5BTUU7XG4gICAgICBWQUxVRSA9IGF0dHIuVkFMVUU7XG4gICAgfVxuICAgIGlmIChOQU1FIGluIHZhcmlhYmxlTGlzdCkge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoXCJFWFQtWC1ERUZJTkUgZHVwbGljYXRlIFZhcmlhYmxlIE5hbWUgZGVjbGFyYXRpb25zOiBcXFwiXCIgKyBOQU1FICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyaWFibGVMaXN0W05BTUVdID0gVkFMVUUgfHwgJyc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIGF0dHIsIHNvdXJjZVZhcmlhYmxlTGlzdCkge1xuICAgIHZhciBJTVBPUlQgPSBhdHRyLklNUE9SVDtcbiAgICBpZiAoc291cmNlVmFyaWFibGVMaXN0ICYmIElNUE9SVCBpbiBzb3VyY2VWYXJpYWJsZUxpc3QpIHtcbiAgICAgIHZhciB2YXJpYWJsZUxpc3QgPSBwYXJzZWQudmFyaWFibGVMaXN0O1xuICAgICAgaWYgKCF2YXJpYWJsZUxpc3QpIHtcbiAgICAgICAgcGFyc2VkLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdCA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyaWFibGVMaXN0W0lNUE9SVF0gPSBzb3VyY2VWYXJpYWJsZUxpc3RbSU1QT1JUXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoXCJFWFQtWC1ERUZJTkUgSU1QT1JUIGF0dHJpYnV0ZSBub3QgZm91bmQgaW4gTXVsdGl2YXJpYW50IFBsYXlsaXN0OiBcXFwiXCIgKyBJTVBPUlQgKyBcIlxcXCJcIikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbiAgdmFyIEFUVFJfTElTVF9SRUdFWCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2Fub25naWwvbm9kZS1tM3U4cGFyc2UvYmxvYi9tYXN0ZXIvYXR0cmxpc3QuanNcbiAgdmFyIEF0dHJMaXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdHRyTGlzdChhdHRycywgcGFyc2VkKSB7XG4gICAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgICBhdHRycyA9IEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QoYXR0cnMsIHBhcnNlZCk7XG4gICAgICB9XG4gICAgICBfZXh0ZW5kcyh0aGlzLCBhdHRycyk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBBdHRyTGlzdC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRlY2ltYWxJbnRlZ2VyID0gZnVuY3Rpb24gZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG4gICAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50VmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8uaGV4YWRlY2ltYWxJbnRlZ2VyID0gZnVuY3Rpb24gaGV4YWRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgICBpZiAodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gKHRoaXNbYXR0ck5hbWVdIHx8ICcweCcpLnNsaWNlKDIpO1xuICAgICAgICBzdHJpbmdWYWx1ZSA9IChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgIHZhbHVlW2ldID0gcGFyc2VJbnQoc3RyaW5nVmFsdWUuc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5oZXhhZGVjaW1hbEludGVnZXJBc051bWJlciA9IGZ1bmN0aW9uIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyKGF0dHJOYW1lKSB7XG4gICAgICB2YXIgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTYpO1xuICAgICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludFZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY2ltYWxGbG9hdGluZ1BvaW50ID0gZnVuY3Rpb24gZGVjaW1hbEZsb2F0aW5nUG9pbnQoYXR0ck5hbWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgICB9O1xuICAgIF9wcm90by5vcHRpb25hbEZsb2F0ID0gZnVuY3Rpb24gb3B0aW9uYWxGbG9hdChhdHRyTmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzW2F0dHJOYW1lXTtcbiAgICAgIHJldHVybiB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLmVudW1lcmF0ZWRTdHJpbmcgPSBmdW5jdGlvbiBlbnVtZXJhdGVkU3RyaW5nKGF0dHJOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpc1thdHRyTmFtZV07XG4gICAgfTtcbiAgICBfcHJvdG8uZW51bWVyYXRlZFN0cmluZ0xpc3QgPSBmdW5jdGlvbiBlbnVtZXJhdGVkU3RyaW5nTGlzdChhdHRyTmFtZSwgZGljdCkge1xuICAgICAgdmFyIGF0dHJWYWx1ZSA9IHRoaXNbYXR0ck5hbWVdO1xuICAgICAgcmV0dXJuIChhdHRyVmFsdWUgPyBhdHRyVmFsdWUuc3BsaXQoL1sgLF0rLykgOiBbXSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0W2lkZW50aWZpZXIudG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgZGljdCk7XG4gICAgfTtcbiAgICBfcHJvdG8uYm9vbCA9IGZ1bmN0aW9uIGJvb2woYXR0ck5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXSA9PT0gJ1lFUyc7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjaW1hbFJlc29sdXRpb24gPSBmdW5jdGlvbiBkZWNpbWFsUmVzb2x1dGlvbihhdHRyTmFtZSkge1xuICAgICAgdmFyIHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcbiAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUludChyZXNbMl0sIDEwKVxuICAgICAgfTtcbiAgICB9O1xuICAgIEF0dHJMaXN0LnBhcnNlQXR0ckxpc3QgPSBmdW5jdGlvbiBwYXJzZUF0dHJMaXN0KGlucHV0LCBwYXJzZWQpIHtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgdmFyIHF1b3RlID0gJ1wiJztcbiAgICAgIEFUVFJfTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdO1xuICAgICAgICB2YXIgcXVvdGVkU3RyaW5nID0gdmFsdWUuaW5kZXhPZihxdW90ZSkgPT09IDAgJiYgdmFsdWUubGFzdEluZGV4T2YocXVvdGUpID09PSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgaGV4YWRlY2ltYWxTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgICBpZiAocXVvdGVkU3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdJVic6XG4gICAgICAgICAgICBjYXNlICdTQ1RFMzUtQ01EJzpcbiAgICAgICAgICAgIGNhc2UgJ1NDVEUzNS1JTic6XG4gICAgICAgICAgICBjYXNlICdTQ1RFMzUtT1VUJzpcbiAgICAgICAgICAgICAgaGV4YWRlY2ltYWxTZXF1ZW5jZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWQgJiYgKHF1b3RlZFN0cmluZyB8fCBoZXhhZGVjaW1hbFNlcXVlbmNlKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlID0gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWhleGFkZWNpbWFsU2VxdWVuY2UgJiYgIXF1b3RlZFN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnQ0xPU0VELUNBUFRJT05TJzpcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnTk9ORScpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnQUxMT1dFRC1DUEMnOlxuICAgICAgICAgICAgY2FzZSAnQ0xBU1MnOlxuICAgICAgICAgICAgY2FzZSAnQVNTT0MtTEFOR1VBR0UnOlxuICAgICAgICAgICAgY2FzZSAnQVVESU8nOlxuICAgICAgICAgICAgY2FzZSAnQllURVJBTkdFJzpcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5ORUxTJzpcbiAgICAgICAgICAgIGNhc2UgJ0NIQVJBQ1RFUklTVElDUyc6XG4gICAgICAgICAgICBjYXNlICdDT0RFQ1MnOlxuICAgICAgICAgICAgY2FzZSAnREFUQS1JRCc6XG4gICAgICAgICAgICBjYXNlICdFTkQtREFURSc6XG4gICAgICAgICAgICBjYXNlICdHUk9VUC1JRCc6XG4gICAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgICBjYXNlICdJTVBPUlQnOlxuICAgICAgICAgICAgY2FzZSAnSU5TVFJFQU0tSUQnOlxuICAgICAgICAgICAgY2FzZSAnS0VZRk9STUFUJzpcbiAgICAgICAgICAgIGNhc2UgJ0tFWUZPUk1BVFZFUlNJT05TJzpcbiAgICAgICAgICAgIGNhc2UgJ0xBTkdVQUdFJzpcbiAgICAgICAgICAgIGNhc2UgJ05BTUUnOlxuICAgICAgICAgICAgY2FzZSAnUEFUSFdBWS1JRCc6XG4gICAgICAgICAgICBjYXNlICdRVUVSWVBBUkFNJzpcbiAgICAgICAgICAgIGNhc2UgJ1JFQ0VOVExZLVJFTU9WRUQtREFURVJBTkdFUyc6XG4gICAgICAgICAgICBjYXNlICdTRVJWRVItVVJJJzpcbiAgICAgICAgICAgIGNhc2UgJ1NUQUJMRS1SRU5ESVRJT04tSUQnOlxuICAgICAgICAgICAgY2FzZSAnU1RBQkxFLVZBUklBTlQtSUQnOlxuICAgICAgICAgICAgY2FzZSAnU1RBUlQtREFURSc6XG4gICAgICAgICAgICBjYXNlICdTVUJUSVRMRVMnOlxuICAgICAgICAgICAgY2FzZSAnU1VQUExFTUVOVEFMLUNPREVDUyc6XG4gICAgICAgICAgICBjYXNlICdVUkknOlxuICAgICAgICAgICAgY2FzZSAnVkFMVUUnOlxuICAgICAgICAgICAgY2FzZSAnVklERU8nOlxuICAgICAgICAgICAgY2FzZSAnWC1BU1NFVC1MSVNUJzpcbiAgICAgICAgICAgIGNhc2UgJ1gtQVNTRVQtVVJJJzpcbiAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgYXJlIG5vdCBjaGVja2luZyB0YWc6YXR0cmlidXRlIGNvbWJpbmF0aW9uLCBqdXN0IHdhcm4gcmF0aGVyIHRoYW4gaWdub3JpbmcgYXR0cmlidXRlXG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKGlucHV0ICsgXCI6IGF0dHJpYnV0ZSBcIiArIG5hbWUgKyBcIiBpcyBtaXNzaW5nIHF1b3Rlc1wiKTtcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdHRyTGlzdCwgW3tcbiAgICAgIGtleTogXCJjbGllbnRBdHRyc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5maWx0ZXIoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci5zdWJzdHJpbmcoMCwgMikgPT09ICdYLSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xuXG4gIC8vIEF2b2lkIGV4cG9ydGluZyBjb25zdCBlbnVtIHNvIHRoYXQgdGhlc2UgdmFsdWVzIGNhbiBiZSBpbmxpbmVkXG5cbiAgdmFyIENMQVNTX0lOVEVSU1RJVElBTCA9ICdjb20uYXBwbGUuaGxzLmludGVyc3RpdGlhbCc7XG4gIGZ1bmN0aW9uIGlzRGF0ZVJhbmdlQ3VlQXR0cmlidXRlKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIGF0dHJOYW1lICE9PSBcIklEXCIgJiYgYXR0ck5hbWUgIT09IFwiQ0xBU1NcIiAmJiBhdHRyTmFtZSAhPT0gXCJDVUVcIiAmJiBhdHRyTmFtZSAhPT0gXCJTVEFSVC1EQVRFXCIgJiYgYXR0ck5hbWUgIT09IFwiRFVSQVRJT05cIiAmJiBhdHRyTmFtZSAhPT0gXCJFTkQtREFURVwiICYmIGF0dHJOYW1lICE9PSBcIkVORC1PTi1ORVhUXCI7XG4gIH1cbiAgZnVuY3Rpb24gaXNTQ1RFMzVBdHRyaWJ1dGUoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gYXR0ck5hbWUgPT09IFwiU0NURTM1LU9VVFwiIHx8IGF0dHJOYW1lID09PSBcIlNDVEUzNS1JTlwiIHx8IGF0dHJOYW1lID09PSBcIlNDVEUzNS1DTURcIjtcbiAgfVxuICB2YXIgRGF0ZVJhbmdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRlUmFuZ2UoZGF0ZVJhbmdlQXR0ciwgZGF0ZVJhbmdlV2l0aFNhbWVJZCwgdGFnQ291bnQpIHtcbiAgICAgIHZhciBfZGF0ZVJhbmdlV2l0aFNhbWVJZCQ7XG4gICAgICBpZiAodGFnQ291bnQgPT09IHZvaWQgMCkge1xuICAgICAgICB0YWdDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmF0dHIgPSB2b2lkIDA7XG4gICAgICB0aGlzLnRhZ0FuY2hvciA9IHZvaWQgMDtcbiAgICAgIHRoaXMudGFnT3JkZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9zdGFydERhdGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9lbmREYXRlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fZGF0ZUF0RW5kID0gdm9pZCAwO1xuICAgICAgdGhpcy5fY3VlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnRhZ0FuY2hvciA9IChkYXRlUmFuZ2VXaXRoU2FtZUlkID09IG51bGwgPyB2b2lkIDAgOiBkYXRlUmFuZ2VXaXRoU2FtZUlkLnRhZ0FuY2hvcikgfHwgbnVsbDtcbiAgICAgIHRoaXMudGFnT3JkZXIgPSAoX2RhdGVSYW5nZVdpdGhTYW1lSWQkID0gZGF0ZVJhbmdlV2l0aFNhbWVJZCA9PSBudWxsID8gdm9pZCAwIDogZGF0ZVJhbmdlV2l0aFNhbWVJZC50YWdPcmRlcikgIT0gbnVsbCA/IF9kYXRlUmFuZ2VXaXRoU2FtZUlkJCA6IHRhZ0NvdW50O1xuICAgICAgaWYgKGRhdGVSYW5nZVdpdGhTYW1lSWQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzQXR0ciA9IGRhdGVSYW5nZVdpdGhTYW1lSWQuYXR0cjtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByZXZpb3VzQXR0cikge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0ZVJhbmdlQXR0ciwga2V5KSAmJiBkYXRlUmFuZ2VBdHRyW2tleV0gIT09IHByZXZpb3VzQXR0cltrZXldKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIkRBVEVSQU5HRSB0YWcgYXR0cmlidXRlOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgZG9lcyBub3QgbWF0Y2ggZm9yIHRhZ3Mgd2l0aCBJRDogXFxcIlwiICsgZGF0ZVJhbmdlQXR0ci5JRCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1lcmdlIERhdGVSYW5nZSB0YWdzIHdpdGggdGhlIHNhbWUgSURcbiAgICAgICAgZGF0ZVJhbmdlQXR0ciA9IF9leHRlbmRzKG5ldyBBdHRyTGlzdCh7fSksIHByZXZpb3VzQXR0ciwgZGF0ZVJhbmdlQXR0cik7XG4gICAgICB9XG4gICAgICB0aGlzLmF0dHIgPSBkYXRlUmFuZ2VBdHRyO1xuICAgICAgaWYgKGRhdGVSYW5nZVdpdGhTYW1lSWQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnREYXRlID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5fc3RhcnREYXRlO1xuICAgICAgICB0aGlzLl9jdWUgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkLl9jdWU7XG4gICAgICAgIHRoaXMuX2VuZERhdGUgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkLl9lbmREYXRlO1xuICAgICAgICB0aGlzLl9kYXRlQXRFbmQgPSBkYXRlUmFuZ2VXaXRoU2FtZUlkLl9kYXRlQXRFbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGFydERhdGUgPSBuZXcgRGF0ZShkYXRlUmFuZ2VBdHRyW1wiU1RBUlQtREFURVwiXSk7XG4gICAgICB9XG4gICAgICBpZiAoXCJFTkQtREFURVwiIGluIHRoaXMuYXR0cikge1xuICAgICAgICB2YXIgZW5kRGF0ZSA9IChkYXRlUmFuZ2VXaXRoU2FtZUlkID09IG51bGwgPyB2b2lkIDAgOiBkYXRlUmFuZ2VXaXRoU2FtZUlkLmVuZERhdGUpIHx8IG5ldyBEYXRlKHRoaXMuYXR0cltcIkVORC1EQVRFXCJdKTtcbiAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGVuZERhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgIHRoaXMuX2VuZERhdGUgPSBlbmREYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoRGF0ZVJhbmdlLCBbe1xuICAgICAga2V5OiBcImlkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ci5JRDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xhc3NcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyLkNMQVNTO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjdWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX2N1ZSA9IHRoaXMuX2N1ZTtcbiAgICAgICAgaWYgKF9jdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jdWUgPSB0aGlzLmF0dHIuZW51bWVyYXRlZFN0cmluZ0xpc3QodGhpcy5hdHRyLkNVRSA/ICdDVUUnIDogJ1gtQ1VFJywge1xuICAgICAgICAgICAgcHJlOiBmYWxzZSxcbiAgICAgICAgICAgIHBvc3Q6IGZhbHNlLFxuICAgICAgICAgICAgb25jZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2N1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhcnRUaW1lXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHRhZ0FuY2hvciA9IHRoaXMudGFnQW5jaG9yO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1vcHRpb25hbC1jaGFpblxuICAgICAgICBpZiAodGFnQW5jaG9yID09PSBudWxsIHx8IHRhZ0FuY2hvci5wcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihcIkV4cGVjdGVkIHRhZ0FuY2hvciBGcmFnbWVudCB3aXRoIFBEVCBzZXQgZm9yIERhdGVSYW5nZSBcXFwiXCIgKyB0aGlzLmlkICsgXCJcXFwiOiBcIiArIHRhZ0FuY2hvcik7XG4gICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnQW5jaG9yLnN0YXJ0ICsgKHRoaXMuc3RhcnREYXRlLmdldFRpbWUoKSAtIHRhZ0FuY2hvci5wcm9ncmFtRGF0ZVRpbWUpIC8gMTAwMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhcnREYXRlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0RGF0ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW5kRGF0ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBkYXRlQXRFbmQgPSB0aGlzLl9lbmREYXRlIHx8IHRoaXMuX2RhdGVBdEVuZDtcbiAgICAgICAgaWYgKGRhdGVBdEVuZCkge1xuICAgICAgICAgIHJldHVybiBkYXRlQXRFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVBdEVuZCA9IG5ldyBEYXRlKHRoaXMuX3N0YXJ0RGF0ZS5nZXRUaW1lKCkgKyBkdXJhdGlvbiAqIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmIChcIkRVUkFUSU9OXCIgaW4gdGhpcy5hdHRyKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiRFVSQVRJT05cIik7XG4gICAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLl9lbmREYXRlLmdldFRpbWUoKSAtIHRoaXMuX3N0YXJ0RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGxhbm5lZER1cmF0aW9uXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKFwiUExBTk5FRC1EVVJBVElPTlwiIGluIHRoaXMuYXR0cikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIuZGVjaW1hbEZsb2F0aW5nUG9pbnQoXCJQTEFOTkVELURVUkFUSU9OXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbmRPbk5leHRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyLmJvb2woXCJFTkQtT04tTkVYVFwiKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNJbnRlcnN0aXRpYWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzcyA9PT0gQ0xBU1NfSU5URVJTVElUSUFMO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc1ZhbGlkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5pZCAmJiAhdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgJiYgaXNGaW5pdGVOdW1iZXIodGhpcy5zdGFydERhdGUuZ2V0VGltZSgpKSAmJiAodGhpcy5kdXJhdGlvbiA9PT0gbnVsbCB8fCB0aGlzLmR1cmF0aW9uID49IDApICYmICghdGhpcy5lbmRPbk5leHQgfHwgISF0aGlzLmNsYXNzKSAmJiAoIXRoaXMuYXR0ci5DVUUgfHwgIXRoaXMuY3VlLnByZSAmJiAhdGhpcy5jdWUucG9zdCB8fCB0aGlzLmN1ZS5wcmUgIT09IHRoaXMuY3VlLnBvc3QpICYmICghdGhpcy5pc0ludGVyc3RpdGlhbCB8fCAnWC1BU1NFVC1VUkknIGluIHRoaXMuYXR0ciB8fCAnWC1BU1NFVC1MSVNUJyBpbiB0aGlzLmF0dHIpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xuXG4gIHZhciBERUZBVUxUX1RBUkdFVF9EVVJBVElPTiA9IDEwO1xuXG4gIC8qKlxuICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIE1lZGlhIFBsYXlsaXN0LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsLmRldGFpbHN9LlxuICAgKi9cbiAgdmFyIExldmVsRGV0YWlscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV2ZWxEZXRhaWxzKGJhc2VVcmwpIHtcbiAgICAgIHRoaXMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuYWxpZ25lZFNsaWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdm9pZCAwO1xuICAgICAgdGhpcy5lbmRDQyA9IDA7XG4gICAgICB0aGlzLmVuZFNOID0gMDtcbiAgICAgIHRoaXMuZnJhZ21lbnRzID0gdm9pZCAwO1xuICAgICAgdGhpcy5mcmFnbWVudEhpbnQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnBhcnRMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlVGFnQ291bnQgPSAwO1xuICAgICAgdGhpcy5saXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IC0xO1xuICAgICAgdGhpcy5hZ2VIZWFkZXIgPSAwO1xuICAgICAgdGhpcy5hZHZhbmNlZERhdGVUaW1lID0gdm9pZCAwO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgdGhpcy5taXNzZXMgPSAwO1xuICAgICAgdGhpcy5zdGFydENDID0gMDtcbiAgICAgIHRoaXMuc3RhcnRTTiA9IDA7XG4gICAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgICB0aGlzLnRhcmdldGR1cmF0aW9uID0gMDtcbiAgICAgIHRoaXMudG90YWxkdXJhdGlvbiA9IDA7XG4gICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgICAgdGhpcy51cmwgPSB2b2lkIDA7XG4gICAgICB0aGlzLm0zdTggPSAnJztcbiAgICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgICB0aGlzLmNhbkJsb2NrUmVsb2FkID0gZmFsc2U7XG4gICAgICB0aGlzLmNhblNraXBVbnRpbCA9IDA7XG4gICAgICB0aGlzLmNhblNraXBEYXRlUmFuZ2VzID0gZmFsc2U7XG4gICAgICB0aGlzLnNraXBwZWRTZWdtZW50cyA9IDA7XG4gICAgICB0aGlzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSB2b2lkIDA7XG4gICAgICB0aGlzLnBhcnRIb2xkQmFjayA9IDA7XG4gICAgICB0aGlzLmhvbGRCYWNrID0gMDtcbiAgICAgIHRoaXMucGFydFRhcmdldCA9IDA7XG4gICAgICB0aGlzLnByZWxvYWRIaW50ID0gdm9pZCAwO1xuICAgICAgdGhpcy5yZW5kaXRpb25SZXBvcnRzID0gdm9pZCAwO1xuICAgICAgdGhpcy50dW5lSW5Hb2FsID0gMDtcbiAgICAgIHRoaXMuZGVsdGFVcGRhdGVGYWlsZWQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmRyaWZ0U3RhcnRUaW1lID0gMDtcbiAgICAgIHRoaXMuZHJpZnRFbmRUaW1lID0gMDtcbiAgICAgIHRoaXMuZHJpZnRTdGFydCA9IDA7XG4gICAgICB0aGlzLmRyaWZ0RW5kID0gMDtcbiAgICAgIHRoaXMuZW5jcnlwdGVkRnJhZ21lbnRzID0gdm9pZCAwO1xuICAgICAgdGhpcy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG51bGw7XG4gICAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLmhhc1ZhcmlhYmxlUmVmcyA9IGZhbHNlO1xuICAgICAgdGhpcy5hcHBsaWVkVGltZWxpbmVPZmZzZXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmZyYWdtZW50cyA9IFtdO1xuICAgICAgdGhpcy5lbmNyeXB0ZWRGcmFnbWVudHMgPSBbXTtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHt9O1xuICAgICAgdGhpcy51cmwgPSBiYXNlVXJsO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTGV2ZWxEZXRhaWxzLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVsb2FkZWQgPSBmdW5jdGlvbiByZWxvYWRlZChwcmV2aW91cykge1xuICAgICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgICB0aGlzLmFkdmFuY2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBhcnRTbkRpZmYgPSB0aGlzLmxhc3RQYXJ0U24gLSBwcmV2aW91cy5sYXN0UGFydFNuO1xuICAgICAgdmFyIHBhcnRJbmRleERpZmYgPSB0aGlzLmxhc3RQYXJ0SW5kZXggLSBwcmV2aW91cy5sYXN0UGFydEluZGV4O1xuICAgICAgdGhpcy51cGRhdGVkID0gdGhpcy5lbmRTTiAhPT0gcHJldmlvdXMuZW5kU04gfHwgISFwYXJ0SW5kZXhEaWZmIHx8ICEhcGFydFNuRGlmZiB8fCAhdGhpcy5saXZlO1xuICAgICAgdGhpcy5hZHZhbmNlZCA9IHRoaXMuZW5kU04gPiBwcmV2aW91cy5lbmRTTiB8fCBwYXJ0U25EaWZmID4gMCB8fCBwYXJ0U25EaWZmID09PSAwICYmIHBhcnRJbmRleERpZmYgPiAwO1xuICAgICAgaWYgKHRoaXMudXBkYXRlZCB8fCB0aGlzLmFkdmFuY2VkKSB7XG4gICAgICAgIHRoaXMubWlzc2VzID0gTWF0aC5mbG9vcihwcmV2aW91cy5taXNzZXMgKiAwLjYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5taXNzZXMgPSBwcmV2aW91cy5taXNzZXMgKyAxO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmhhc0tleSA9IGZ1bmN0aW9uIGhhc0tleShsZXZlbEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdGVkRnJhZ21lbnRzLnNvbWUoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgdmFyIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgICAgaWYgKCFkZWNyeXB0ZGF0YSkge1xuICAgICAgICAgIGZyYWcuc2V0S2V5Rm9ybWF0KGxldmVsS2V5LmtleUZvcm1hdCk7XG4gICAgICAgICAgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIWRlY3J5cHRkYXRhICYmIGxldmVsS2V5Lm1hdGNoZXMoZGVjcnlwdGRhdGEpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKExldmVsRGV0YWlscywgW3tcbiAgICAgIGtleTogXCJoYXNQcm9ncmFtRGF0ZVRpbWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnByb2dyYW1EYXRlVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsZXZlbFRhcmdldER1cmF0aW9uXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIHx8IHRoaXMudGFyZ2V0ZHVyYXRpb24gfHwgREVGQVVMVF9UQVJHRVRfRFVSQVRJT047XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRyaWZ0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHJ1blRpbWUgPSB0aGlzLmRyaWZ0RW5kVGltZSAtIHRoaXMuZHJpZnRTdGFydFRpbWU7XG4gICAgICAgIGlmIChydW5UaW1lID4gMCkge1xuICAgICAgICAgIHZhciBydW5EdXJhdGlvbiA9IHRoaXMuZHJpZnRFbmQgLSB0aGlzLmRyaWZ0U3RhcnQ7XG4gICAgICAgICAgcmV0dXJuIHJ1bkR1cmF0aW9uICogMTAwMCAvIHJ1blRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVkZ2VcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0RW5kIHx8IHRoaXMuZnJhZ21lbnRFbmQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhcnRFbmRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkcGFydExpc3Q7XG4gICAgICAgIGlmICgoX3RoaXMkcGFydExpc3QgPSB0aGlzLnBhcnRMaXN0KSAhPSBudWxsICYmIF90aGlzJHBhcnRMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50RW5kO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmcmFnbWVudEVuZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmcmFnbWVudFN0YXJ0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWdlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWR2YW5jZWREYXRlVGltZSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heChEYXRlLm5vdygpIC0gdGhpcy5hZHZhbmNlZERhdGVUaW1lLCAwKSAvIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxhc3RQYXJ0SW5kZXhcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkcGFydExpc3QyO1xuICAgICAgICBpZiAoKF90aGlzJHBhcnRMaXN0MiA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXhQYXJ0SW5kZXhcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgcGFydExpc3QgPSB0aGlzLnBhcnRMaXN0O1xuICAgICAgICBpZiAocGFydExpc3QpIHtcbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5sYXN0UGFydEluZGV4O1xuICAgICAgICAgIGlmIChsYXN0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcGFydExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgIGlmIChwYXJ0TGlzdFtpXS5pbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0TGlzdFtpXS5pbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhc3RJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxhc3RQYXJ0U25cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkcGFydExpc3QzO1xuICAgICAgICBpZiAoKF90aGlzJHBhcnRMaXN0MyA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZnJhZ21lbnQuc247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kU047XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4cGlyZWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5saXZlICYmIHRoaXMuYWdlICYmIHRoaXMubWlzc2VzIDwgMykge1xuICAgICAgICAgIHZhciBwbGF5bGlzdFdpbmRvd0R1cmF0aW9uID0gdGhpcy5wYXJ0RW5kIC0gdGhpcy5mcmFnbWVudFN0YXJ0O1xuICAgICAgICAgIHJldHVybiB0aGlzLmFnZSA+IE1hdGgubWF4KHBsYXlsaXN0V2luZG93RHVyYXRpb24sIHRoaXMudG90YWxkdXJhdGlvbikgKyB0aGlzLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIGFycmF5VmFsdWVzTWF0Y2goYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAhYS5zb21lKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IGJbaV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIG9wdGlvbmFsQXJyYXlWYWx1ZXNNYXRjaChhLCBiKSB7XG4gICAgaWYgKCFhICYmICFiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVZhbHVlc01hdGNoKGEsIGIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGdWxsU2VnbWVudEVuY3J5cHRpb24obWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZCA9PT0gJ0FFUy0xMjgnIHx8IG1ldGhvZCA9PT0gJ0FFUy0yNTYnIHx8IG1ldGhvZCA9PT0gJ0FFUy0yNTYtQ1RSJztcbiAgfVxuICBmdW5jdGlvbiBnZXRBZXNNb2RlRnJvbUZ1bGxTZWdtZW50TWV0aG9kKG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdBRVMtMTI4JzpcbiAgICAgIGNhc2UgJ0FFUy0yNTYnOlxuICAgICAgICByZXR1cm4gRGVjcnlwdGVyQWVzTW9kZS5jYmM7XG4gICAgICBjYXNlICdBRVMtMjU2LUNUUic6XG4gICAgICAgIHJldHVybiBEZWNyeXB0ZXJBZXNNb2RlLmN0cjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZnVsbCBzZWdtZW50IG1ldGhvZCBcIiArIG1ldGhvZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmFzZTY0RGVjb2RlKGJhc2U2NGVuY29kZWRTdHIpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoYmFzZTY0ZW5jb2RlZFN0ciksIGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gYnJlYWtpbmcgdXAgdGhvc2UgdHdvIHR5cGVzIGluIG9yZGVyIHRvIGNsYXJpZnkgd2hhdCBpcyBoYXBwZW5pbmcgaW4gdGhlIGRlY29kaW5nIHBhdGguXG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcbiAgLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbiAgLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gICAqXG4gICAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gICAqIFZlcnNpb246IDEuMFxuICAgKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XG4gICAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gc3RyVG9VdGY4YXJyYXkoc3RyKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSksIGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0S2V5SWRCeXRlcyhzdHIpIHtcbiAgICB2YXIga2V5SWRieXRlcyA9IHN0clRvVXRmOGFycmF5KHN0cikuc3ViYXJyYXkoMCwgMTYpO1xuICAgIHZhciBwYWRkZWRrZXlJZGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIHBhZGRlZGtleUlkYnl0ZXMuc2V0KGtleUlkYnl0ZXMsIDE2IC0ga2V5SWRieXRlcy5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWRrZXlJZGJ5dGVzO1xuICB9XG4gIGZ1bmN0aW9uIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWQpIHtcbiAgICB2YXIgc3dhcCA9IGZ1bmN0aW9uIHN3YXAoYXJyYXksIGZyb20sIHRvKSB7XG4gICAgICB2YXIgY3VyID0gYXJyYXlbZnJvbV07XG4gICAgICBhcnJheVtmcm9tXSA9IGFycmF5W3RvXTtcbiAgICAgIGFycmF5W3RvXSA9IGN1cjtcbiAgICB9O1xuICAgIHN3YXAoa2V5SWQsIDAsIDMpO1xuICAgIHN3YXAoa2V5SWQsIDEsIDIpO1xuICAgIHN3YXAoa2V5SWQsIDQsIDUpO1xuICAgIHN3YXAoa2V5SWQsIDYsIDcpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHVyaSkge1xuICAgIC8vIGRhdGE6WzxtZWRpYSB0eXBlXVs7YXR0cmlidXRlPXZhbHVlXVs7YmFzZTY0XSw8ZGF0YT5cbiAgICB2YXIgY29sb25zcGxpdCA9IHVyaS5zcGxpdCgnOicpO1xuICAgIHZhciBrZXlkYXRhID0gbnVsbDtcbiAgICBpZiAoY29sb25zcGxpdFswXSA9PT0gJ2RhdGEnICYmIGNvbG9uc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgc2VtaWNvbG9uc3BsaXQgPSBjb2xvbnNwbGl0WzFdLnNwbGl0KCc7Jyk7XG4gICAgICB2YXIgY29tbWFzcGxpdCA9IHNlbWljb2xvbnNwbGl0W3NlbWljb2xvbnNwbGl0Lmxlbmd0aCAtIDFdLnNwbGl0KCcsJyk7XG4gICAgICBpZiAoY29tbWFzcGxpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdmFyIGlzYmFzZTY0ID0gY29tbWFzcGxpdFswXSA9PT0gJ2Jhc2U2NCc7XG4gICAgICAgIHZhciBkYXRhID0gY29tbWFzcGxpdFsxXTtcbiAgICAgICAgaWYgKGlzYmFzZTY0KSB7XG4gICAgICAgICAgc2VtaWNvbG9uc3BsaXQuc3BsaWNlKC0xLCAxKTsgLy8gcmVtb3ZlIGZyb20gcHJvY2Vzc2luZ1xuICAgICAgICAgIGtleWRhdGEgPSBiYXNlNjREZWNvZGUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ZGF0YSA9IGdldEtleUlkQnl0ZXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleWRhdGE7XG4gIH1cblxuICAvKiogcmV0dXJucyBgdW5kZWZpbmVkYCBpcyBgc2VsZmAgaXMgbWlzc2luZywgZS5nLiBpbiBub2RlICovXG4gIHZhciBvcHRpb25hbFNlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3IvcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG4gICAqL1xuICB2YXIgS2V5U3lzdGVtcyA9IHtcbiAgICBDTEVBUktFWTogXCJvcmcudzMuY2xlYXJrZXlcIixcbiAgICBGQUlSUExBWTogXCJjb20uYXBwbGUuZnBzXCIsXG4gICAgUExBWVJFQURZOiBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCIsXG4gICAgV0lERVZJTkU6IFwiY29tLndpZGV2aW5lLmFscGhhXCJcbiAgfTtcblxuICAvLyBQbGF5bGlzdCAjRVhULVgtS0VZIEtFWUZPUk1BVCB2YWx1ZXNcbiAgdmFyIEtleVN5c3RlbUZvcm1hdHMgPSB7XG4gICAgQ0xFQVJLRVk6IFwib3JnLnczLmNsZWFya2V5XCIsXG4gICAgRkFJUlBMQVk6IFwiY29tLmFwcGxlLnN0cmVhbWluZ2tleWRlbGl2ZXJ5XCIsXG4gICAgUExBWVJFQURZOiBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCIsXG4gICAgV0lERVZJTkU6IFwidXJuOnV1aWQ6ZWRlZjhiYTktNzlkNi00YWNlLWEzYzgtMjdkY2Q1MWQyMWVkXCJcbiAgfTtcbiAgZnVuY3Rpb24ga2V5U3lzdGVtRm9ybWF0VG9LZXlTeXN0ZW1Eb21haW4oZm9ybWF0KSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgICAgcmV0dXJuIEtleVN5c3RlbXMuRkFJUlBMQVk7XG4gICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICByZXR1cm4gS2V5U3lzdGVtcy5QTEFZUkVBRFk7XG4gICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICAgIHJldHVybiBLZXlTeXN0ZW1zLldJREVWSU5FO1xuICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgICByZXR1cm4gS2V5U3lzdGVtcy5DTEVBUktFWTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQoa2V5U3lzdGVtKSB7XG4gICAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgICAgIGNhc2UgS2V5U3lzdGVtcy5GQUlSUExBWTpcbiAgICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk7XG4gICAgICBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk7XG4gICAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FO1xuICAgICAgY2FzZSBLZXlTeXN0ZW1zLkNMRUFSS0VZOlxuICAgICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5DTEVBUktFWTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyhjb25maWcpIHtcbiAgICB2YXIgZHJtU3lzdGVtcyA9IGNvbmZpZy5kcm1TeXN0ZW1zLFxuICAgICAgd2lkZXZpbmVMaWNlbnNlVXJsID0gY29uZmlnLndpZGV2aW5lTGljZW5zZVVybDtcbiAgICB2YXIga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGRybVN5c3RlbXMgPyBbS2V5U3lzdGVtcy5GQUlSUExBWSwgS2V5U3lzdGVtcy5XSURFVklORSwgS2V5U3lzdGVtcy5QTEFZUkVBRFksIEtleVN5c3RlbXMuQ0xFQVJLRVldLmZpbHRlcihmdW5jdGlvbiAoa2V5U3lzdGVtKSB7XG4gICAgICByZXR1cm4gISFkcm1TeXN0ZW1zW2tleVN5c3RlbV07XG4gICAgfSkgOiBbXTtcbiAgICBpZiAoIWtleVN5c3RlbXNUb0F0dGVtcHRbS2V5U3lzdGVtcy5XSURFVklORV0gJiYgd2lkZXZpbmVMaWNlbnNlVXJsKSB7XG4gICAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0LnB1c2goS2V5U3lzdGVtcy5XSURFVklORSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTeXN0ZW1zVG9BdHRlbXB0O1xuICB9XG4gIHZhciByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSBmdW5jdGlvbiAoX29wdGlvbmFsU2VsZiRuYXZpZ2F0KSB7XG4gICAgaWYgKG9wdGlvbmFsU2VsZiAhPSBudWxsICYmIChfb3B0aW9uYWxTZWxmJG5hdmlnYXQgPSBvcHRpb25hbFNlbGYubmF2aWdhdG9yKSAhPSBudWxsICYmIF9vcHRpb25hbFNlbGYkbmF2aWdhdC5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgIHJldHVybiBzZWxmLm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MuYmluZChzZWxmLm5hdmlnYXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgICB2YXIgaW5pdERhdGFUeXBlcztcbiAgICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgICAgY2FzZSBLZXlTeXN0ZW1zLkZBSVJQTEFZOlxuICAgICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJywgJ3NpbmYnXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgICBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJ107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlTeXN0ZW1zLkNMRUFSS0VZOlxuICAgICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJywgJ2tleWlkcyddO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24ga2V5LXN5c3RlbTogXCIgKyBrZXlTeXN0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoaW5pdERhdGFUeXBlcywgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7XG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICBpbml0RGF0YVR5cGVzOiBpbml0RGF0YVR5cGVzLFxuICAgICAgcGVyc2lzdGVudFN0YXRlOiBkcm1TeXN0ZW1PcHRpb25zLnBlcnNpc3RlbnRTdGF0ZSB8fCAnb3B0aW9uYWwnLFxuICAgICAgZGlzdGluY3RpdmVJZGVudGlmaWVyOiBkcm1TeXN0ZW1PcHRpb25zLmRpc3RpbmN0aXZlSWRlbnRpZmllciB8fCAnb3B0aW9uYWwnLFxuICAgICAgc2Vzc2lvblR5cGVzOiBkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlcyB8fCBbZHJtU3lzdGVtT3B0aW9ucy5zZXNzaW9uVHlwZSB8fCAndGVtcG9yYXJ5J10sXG4gICAgICBhdWRpb0NhcGFiaWxpdGllczogYXVkaW9Db2RlY3MubWFwKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImF1ZGlvL21wNDsgY29kZWNzPVwiICsgY29kZWMsXG4gICAgICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy5hdWRpb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICAgICAgZW5jcnlwdGlvblNjaGVtZTogZHJtU3lzdGVtT3B0aW9ucy5hdWRpb0VuY3J5cHRpb25TY2hlbWUgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICB2aWRlb0NhcGFiaWxpdGllczogdmlkZW9Db2RlY3MubWFwKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnRUeXBlOiBcInZpZGVvL21wNDsgY29kZWNzPVwiICsgY29kZWMsXG4gICAgICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy52aWRlb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICAgICAgZW5jcnlwdGlvblNjaGVtZTogZHJtU3lzdGVtT3B0aW9ucy52aWRlb0VuY3J5cHRpb25TY2hlbWUgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICAgIHJldHVybiBbYmFzZUNvbmZpZ107XG4gIH1cbiAgZnVuY3Rpb24gaXNQZXJzaXN0ZW50U2Vzc2lvblR5cGUoZHJtU3lzdGVtT3B0aW9ucykge1xuICAgIHZhciBfZHJtU3lzdGVtT3B0aW9ucyRzZXM7XG4gICAgcmV0dXJuICEhZHJtU3lzdGVtT3B0aW9ucyAmJiAoZHJtU3lzdGVtT3B0aW9ucy5zZXNzaW9uVHlwZSA9PT0gJ3BlcnNpc3RlbnQtbGljZW5zZScgfHwgISEoKF9kcm1TeXN0ZW1PcHRpb25zJHNlcyA9IGRybVN5c3RlbU9wdGlvbnMuc2Vzc2lvblR5cGVzKSAhPSBudWxsICYmIF9kcm1TeXN0ZW1PcHRpb25zJHNlcy5zb21lKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gJ3BlcnNpc3RlbnQtbGljZW5zZSc7XG4gICAgfSkpKTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVBsYXlSZWFkeVdSTShrZXlCeXRlcykge1xuICAgIHZhciBrZXlCeXRlc1V0ZjE2ID0gbmV3IFVpbnQxNkFycmF5KGtleUJ5dGVzLmJ1ZmZlciwga2V5Qnl0ZXMuYnl0ZU9mZnNldCwga2V5Qnl0ZXMuYnl0ZUxlbmd0aCAvIDIpO1xuICAgIHZhciBrZXlCeXRlU3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBBcnJheS5mcm9tKGtleUJ5dGVzVXRmMTYpKTtcblxuICAgIC8vIFBhcnNlIFBsYXlyZWFkeSBXUk1IZWFkZXIgWE1MXG4gICAgdmFyIHhtbEtleUJ5dGVzID0ga2V5Qnl0ZVN0ci5zdWJzdHJpbmcoa2V5Qnl0ZVN0ci5pbmRleE9mKCc8JyksIGtleUJ5dGVTdHIubGVuZ3RoKTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgIHZhciB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbEtleUJ5dGVzLCAndGV4dC94bWwnKTtcbiAgICB2YXIga2V5RGF0YSA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnS0lEJylbMF07XG4gICAgaWYgKGtleURhdGEpIHtcbiAgICAgIHZhciBrZXlJZCA9IGtleURhdGEuY2hpbGROb2Rlc1swXSA/IGtleURhdGEuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgOiBrZXlEYXRhLmdldEF0dHJpYnV0ZSgnVkFMVUUnKTtcbiAgICAgIGlmIChrZXlJZCkge1xuICAgICAgICB2YXIga2V5SWRBcnJheSA9IGJhc2U2NERlY29kZShrZXlJZCkuc3ViYXJyYXkoMCwgMTYpO1xuICAgICAgICAvLyBLSUQgdmFsdWUgaW4gUFJPIGlzIGEgYmFzZTY0LWVuY29kZWQgbGl0dGxlIGVuZGlhbiBHVUlEIGludGVycHJldGF0aW9uIG9mIFVVSURcbiAgICAgICAgLy8gS0lEIHZhbHVlIGluIOKAmHRlbmPigJkgaXMgYSBiaWcgZW5kaWFuIFVVSUQgR1VJRCBpbnRlcnByZXRhdGlvbiBvZiBVVUlEXG4gICAgICAgIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWRBcnJheSk7XG4gICAgICAgIHJldHVybiBrZXlJZEFycmF5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBrZXlVcmlUb0tleUlkTWFwID0ge307XG4gIHZhciBMZXZlbEtleSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV2ZWxLZXkobWV0aG9kLCB1cmksIGZvcm1hdCwgZm9ybWF0dmVyc2lvbnMsIGl2LCBrZXlJZCkge1xuICAgICAgaWYgKGZvcm1hdHZlcnNpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgZm9ybWF0dmVyc2lvbnMgPSBbMV07XG4gICAgICB9XG4gICAgICBpZiAoaXYgPT09IHZvaWQgMCkge1xuICAgICAgICBpdiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnVyaSA9IHZvaWQgMDtcbiAgICAgIHRoaXMubWV0aG9kID0gdm9pZCAwO1xuICAgICAgdGhpcy5rZXlGb3JtYXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmtleUZvcm1hdFZlcnNpb25zID0gdm9pZCAwO1xuICAgICAgdGhpcy5lbmNyeXB0ZWQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmlzQ29tbW9uRW5jcnlwdGlvbiA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaXYgPSBudWxsO1xuICAgICAgdGhpcy5rZXkgPSBudWxsO1xuICAgICAgdGhpcy5rZXlJZCA9IG51bGw7XG4gICAgICB0aGlzLnBzc2ggPSBudWxsO1xuICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICAgIHRoaXMua2V5Rm9ybWF0ID0gZm9ybWF0O1xuICAgICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyA9IGZvcm1hdHZlcnNpb25zO1xuICAgICAgdGhpcy5pdiA9IGl2O1xuICAgICAgdGhpcy5lbmNyeXB0ZWQgPSBtZXRob2QgPyBtZXRob2QgIT09ICdOT05FJyA6IGZhbHNlO1xuICAgICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB0aGlzLmVuY3J5cHRlZCAmJiAhaXNGdWxsU2VnbWVudEVuY3J5cHRpb24obWV0aG9kKTtcbiAgICAgIGlmIChrZXlJZCAhPSBudWxsICYmIGtleUlkLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgdGhpcy5rZXlJZCA9IG5ldyBVaW50OEFycmF5KGhleFRvQXJyYXlCdWZmZXIoa2V5SWQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgTGV2ZWxLZXkuY2xlYXJLZXlVcmlUb0tleUlkTWFwID0gZnVuY3Rpb24gY2xlYXJLZXlVcmlUb0tleUlkTWFwKCkge1xuICAgICAga2V5VXJpVG9LZXlJZE1hcCA9IHt9O1xuICAgIH07XG4gICAgTGV2ZWxLZXkuc2V0S2V5SWRGb3JVcmkgPSBmdW5jdGlvbiBzZXRLZXlJZEZvclVyaSh1cmksIGtleUlkKSB7XG4gICAgICBrZXlVcmlUb0tleUlkTWFwW3VyaV0gPSBrZXlJZDtcbiAgICB9O1xuICAgIExldmVsS2V5LmFkZEtleUlkRm9yVXJpID0gZnVuY3Rpb24gYWRkS2V5SWRGb3JVcmkodXJpKSB7XG4gICAgICB2YXIgdmFsID0gT2JqZWN0LmtleXMoa2V5VXJpVG9LZXlJZE1hcCkubGVuZ3RoICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICB2YXIga2V5SWQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICB2YXIgZHYgPSBuZXcgRGF0YVZpZXcoa2V5SWQuYnVmZmVyLCAxMiwgNCk7IC8vIEp1c3Qgc2V0IHRoZSBsYXN0IDQgYnl0ZXNcbiAgICAgIGR2LnNldFVpbnQzMigwLCB2YWwpO1xuICAgICAga2V5VXJpVG9LZXlJZE1hcFt1cmldID0ga2V5SWQ7XG4gICAgICByZXR1cm4ga2V5SWQ7XG4gICAgfTtcbiAgICB2YXIgX3Byb3RvID0gTGV2ZWxLZXkucHJvdG90eXBlO1xuICAgIF9wcm90by5tYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyhrZXkpIHtcbiAgICAgIHJldHVybiBrZXkudXJpID09PSB0aGlzLnVyaSAmJiBrZXkubWV0aG9kID09PSB0aGlzLm1ldGhvZCAmJiBrZXkuZW5jcnlwdGVkID09PSB0aGlzLmVuY3J5cHRlZCAmJiBrZXkua2V5Rm9ybWF0ID09PSB0aGlzLmtleUZvcm1hdCAmJiBhcnJheVZhbHVlc01hdGNoKGtleS5rZXlGb3JtYXRWZXJzaW9ucywgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucykgJiYgb3B0aW9uYWxBcnJheVZhbHVlc01hdGNoKGtleS5pdiwgdGhpcy5pdikgJiYgb3B0aW9uYWxBcnJheVZhbHVlc01hdGNoKGtleS5rZXlJZCwgdGhpcy5rZXlJZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICAgIC8vIElmIGl0J3MgU2VnbWVudCBlbmNyeXB0aW9uIG9yIE5vIGVuY3J5cHRpb24sIGp1c3Qgc2VsZWN0IHRoYXQga2V5IHN5c3RlbVxuICAgICAgaWYgKHRoaXMubWV0aG9kKSB7XG4gICAgICAgIGlmIChpc0Z1bGxTZWdtZW50RW5jcnlwdGlvbih0aGlzLm1ldGhvZCkgfHwgdGhpcy5tZXRob2QgPT09ICdOT05FJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgIC8vIE1haW50YWluIHN1cHBvcnQgZm9yIGNsZWFyIFNBTVBMRS1BRVMgd2l0aCBNUEVHLTMgVFNcbiAgICAgICAgICByZXR1cm4gdGhpcy5tZXRob2QgPT09ICdTQU1QTEUtQUVTJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMua2V5Rm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk6XG4gICAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgICAgICAgICByZXR1cm4gWydTQU1QTEUtQUVTJywgJ1NBTVBMRS1BRVMtQ0VOQycsICdTQU1QTEUtQUVTLUNUUiddLmluZGV4T2YodGhpcy5tZXRob2QpICE9PSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5nZXREZWNyeXB0RGF0YSA9IGZ1bmN0aW9uIGdldERlY3J5cHREYXRhKHNuLCBsZXZlbEtleXMpIHtcbiAgICAgIGlmICghdGhpcy5lbmNyeXB0ZWQgfHwgIXRoaXMudXJpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRnVsbFNlZ21lbnRFbmNyeXB0aW9uKHRoaXMubWV0aG9kKSkge1xuICAgICAgICB2YXIgaXYgPSB0aGlzLml2O1xuICAgICAgICBpZiAoIWl2KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBmZXRjaGluZyBkZWNyeXB0aW9uIGRhdGEgZm9yIGEgaW5pdGlhbGl6YXRpb24gc2VnbWVudFxuICAgICAgICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgd2FzIGVuY3J5cHRlZCB3aXRoIEFFUy0xMjgvMjU2XG4gICAgICAgICAgICAvLyBJdCBtdXN0IGhhdmUgYW4gSVYgZGVmaW5lZC4gV2UgY2Fubm90IHN1YnN0aXR1dGUgdGhlIFNlZ21lbnQgTnVtYmVyIGluLlxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVxcXCJcIiArIHRoaXMubWV0aG9kICsgXCJcXFwiIC0gY29tcGxpYW5jZSBpc3N1ZVwiKTtcblxuICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgc24gdG8gcmVzdWx0aW5nIHZhbHVlIGZyb20gaW1wbGljaXQgY29udmVyc2lvbnMgJ2luaXRTZWdtZW50JyB2YWx1ZXMgZm9yIElWIGdlbmVyYXRpb24uXG4gICAgICAgICAgICBzbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl2ID0gY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSh0aGlzLm1ldGhvZCwgdGhpcy51cmksICdpZGVudGl0eScsIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMsIGl2KTtcbiAgICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2V5SWQpIHtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUga2V5IGlkIGlzIGNoYW5nZWQgaW4gS0VZX0xPQURJTkcgZXZlbnQgaGFuZGxlciAjNzU0MiNpc3N1ZWNvbW1lbnQtMzMwNTIwMzkyOVxuICAgICAgICB2YXIgYXNzaWduZWRLZXlJZCA9IGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldO1xuICAgICAgICBpZiAoYXNzaWduZWRLZXlJZCAmJiAhYXJyYXlWYWx1ZXNNYXRjaCh0aGlzLmtleUlkLCBhc3NpZ25lZEtleUlkKSkge1xuICAgICAgICAgIExldmVsS2V5LnNldEtleUlkRm9yVXJpKHRoaXMudXJpLCB0aGlzLmtleUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wc3NoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gS2V5IGJ5dGVzIGFyZSBzaWduYWxsZWQgdGhlIEtFWUlEIGF0dHJpYnV0ZSwgdHlwaWNhbGx5IG9ubHkgZm91bmQgb24gV2lkZVZpbmUgS0VZIHRhZ3NcbiAgICAgIC8vIEluaXRpYWxpemUga2V5SWQgaWYgcG9zc2libGVcbiAgICAgIHZhciBrZXlCeXRlcyA9IGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHRoaXMudXJpKTtcbiAgICAgIGlmIChrZXlCeXRlcykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMua2V5Rm9ybWF0KSB7XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgICAgICAgLy8gU2V0dGluZyBgcHNzaGAgb24gdGhpcyBMZXZlbEtleS9EZWNyeXB0RGF0YSBhbGxvd3MgSExTLmpzIHRvIGdlbmVyYXRlIGEgc2Vzc2lvbiB1c2luZ1xuICAgICAgICAgICAgLy8gdGhlIHBsYXlsaXN0LWtleSBiZWZvcmUgdGhlIFwiZW5jcnlwdGVkXCIgZXZlbnQuIChDb21tZW50IG91dCB0byBvbmx5IHVzZSBcImVuY3J5cHRlZFwiIHBhdGguKVxuICAgICAgICAgICAgdGhpcy5wc3NoID0ga2V5Qnl0ZXM7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIFdpZGV2aW5lLCBpZiBLRVlJRCBpcyBub3QgaW4gdGhlIHBsYXlsaXN0LCBhc3N1bWUgb25seSB0d28gZmllbGRzIGluIHRoZSBwc3NoIEtFWSB0YWcgVVJJLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmtleUlkKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHRzID0gcGFyc2VNdWx0aVBzc2goa2V5Qnl0ZXMuYnVmZmVyKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wc3NoRGF0YSRraWRzO1xuICAgICAgICAgICAgICAgIHZhciBwc3NoRGF0YSA9IHJlc3VsdHNbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZCA9IChfcHNzaERhdGEka2lkcyA9IHBzc2hEYXRhLmtpZHMpICE9IG51bGwgJiYgX3Bzc2hEYXRhJGtpZHMubGVuZ3RoID8gcHNzaERhdGEua2lkc1swXSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5rZXlJZCkge1xuICAgICAgICAgICAgICB0aGlzLmtleUlkID0gZ2V0S2V5SWRGcm9tUGxheVJlYWR5S2V5KGxldmVsS2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgUGxheVJlYWR5S2V5U3lzdGVtVVVJRCA9IG5ldyBVaW50OEFycmF5KFsweDlhLCAweDA0LCAweGYwLCAweDc5LCAweDk4LCAweDQwLCAweDQyLCAweDg2LCAweGFiLCAweDkyLCAweGU2LCAweDViLCAweGUwLCAweDg4LCAweDVmLCAweDk1XSk7XG5cbiAgICAgICAgICAgICAgLy8gU2V0dGluZyBgcHNzaGAgb24gdGhpcyBMZXZlbEtleS9EZWNyeXB0RGF0YSBhbGxvd3MgSExTLmpzIHRvIGdlbmVyYXRlIGEgc2Vzc2lvbiB1c2luZ1xuICAgICAgICAgICAgICAvLyB0aGUgcGxheWxpc3Qta2V5IGJlZm9yZSB0aGUgXCJlbmNyeXB0ZWRcIiBldmVudC4gKENvbW1lbnQgb3V0IHRvIG9ubHkgdXNlIFwiZW5jcnlwdGVkXCIgcGF0aC4pXG4gICAgICAgICAgICAgIHRoaXMucHNzaCA9IG1wNHBzc2goUGxheVJlYWR5S2V5U3lzdGVtVVVJRCwgbnVsbCwga2V5Qnl0ZXMpO1xuICAgICAgICAgICAgICB0aGlzLmtleUlkID0gcGFyc2VQbGF5UmVhZHlXUk0oa2V5Qnl0ZXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIga2V5ZGF0YSA9IGtleUJ5dGVzLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgICAgICAgICAgaWYgKGtleWRhdGEubGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgICAgIHZhciBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICAgICAgcGFkZGVkLnNldChrZXlkYXRhLCAxNiAtIGtleWRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBrZXlkYXRhID0gcGFkZGVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlkYXRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yOiBnZXQga2V5SWQgZnJvbSBvdGhlciBLRVkgdGFnIG9yIFVSSSBsb29rdXBcbiAgICAgIGlmICghdGhpcy5rZXlJZCB8fCB0aGlzLmtleUlkLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgIHZhciBrZXlJZDtcbiAgICAgICAga2V5SWQgPSBnZXRLZXlJZEZyb21XaWRldmluZUtleShsZXZlbEtleXMpO1xuICAgICAgICBpZiAoIWtleUlkKSB7XG4gICAgICAgICAga2V5SWQgPSBnZXRLZXlJZEZyb21QbGF5UmVhZHlLZXkobGV2ZWxLZXlzKTtcbiAgICAgICAgICBpZiAoIWtleUlkKSB7XG4gICAgICAgICAgICBrZXlJZCA9IGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5SWQpIHtcbiAgICAgICAgICB0aGlzLmtleUlkID0ga2V5SWQ7XG4gICAgICAgICAgTGV2ZWxLZXkuc2V0S2V5SWRGb3JVcmkodGhpcy51cmksIGtleUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gTGV2ZWxLZXk7XG4gIH0oKTtcbiAgZnVuY3Rpb24gZ2V0S2V5SWRGcm9tV2lkZXZpbmVLZXkobGV2ZWxLZXlzKSB7XG4gICAgdmFyIHdpZGV2aW5lS2V5ID0gbGV2ZWxLZXlzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbEtleXNbS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORV07XG4gICAgaWYgKHdpZGV2aW5lS2V5KSB7XG4gICAgICByZXR1cm4gd2lkZXZpbmVLZXkua2V5SWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldEtleUlkRnJvbVBsYXlSZWFkeUtleShsZXZlbEtleXMpIHtcbiAgICB2YXIgcGxheVJlYWR5S2V5ID0gbGV2ZWxLZXlzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbEtleXNbS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFldO1xuICAgIGlmIChwbGF5UmVhZHlLZXkpIHtcbiAgICAgIHZhciBwbGF5UmVhZHlLZXlCeXRlcyA9IGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHBsYXlSZWFkeUtleS51cmkpO1xuICAgICAgaWYgKHBsYXlSZWFkeUtleUJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVBsYXlSZWFkeVdSTShwbGF5UmVhZHlLZXlCeXRlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGkgPSAxMjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHVpbnQ4Vmlld1tpXSA9IHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpICYgMHhmZjtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgfVxuXG4gIHZhciBNQVNURVJfUExBWUxJU1RfUkVHRVggPSAvI0VYVC1YLVNUUkVBTS1JTkY6KFteXFxyXFxuXSopKD86W1xcclxcbl0oPzojW15cXHJcXG5dKik/KSooW15cXHJcXG5dKyl8I0VYVC1YLShTRVNTSU9OLURBVEF8U0VTU0lPTi1LRVl8REVGSU5FfENPTlRFTlQtU1RFRVJJTkd8U1RBUlQpOihbXlxcclxcbl0qKVtcXHJcXG5dKy9nO1xuICB2YXIgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG4gIHZhciBJU19NRURJQV9QTEFZTElTVCA9IC9eI0VYVCg/OklORnwtWC1UQVJHRVREVVJBVElPTik6L207IC8vIEhhbmRsZSBlbXB0eSBNZWRpYSBQbGF5bGlzdCAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG5cbiAgdmFyIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFsvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSxcbiAgLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuICAvKD8hIykgKihcXFNbXlxcclxcbl0qKS8uc291cmNlLFxuICAvLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuICAvIy4qLy5zb3VyY2UgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcbiAgXS5qb2luKCd8JyksICdnJyk7XG4gIHZhciBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gbmV3IFJlZ0V4cChbLyNFWFQtWC0oUFJPR1JBTS1EQVRFLVRJTUV8QllURVJBTkdFfERBVEVSQU5HRXxERUZJTkV8S0VZfE1BUHxQQVJUfFBBUlQtSU5GfFBMQVlMSVNULVRZUEV8UFJFTE9BRC1ISU5UfFJFTkRJVElPTi1SRVBPUlR8U0VSVkVSLUNPTlRST0x8U0tJUHxTVEFSVCk6KC4rKS8uc291cmNlLCAvI0VYVC1YLShCSVRSQVRFfERJU0NPTlRJTlVJVFktU0VRVUVOQ0V8TUVESUEtU0VRVUVOQ0V8VEFSR0VURFVSQVRJT058VkVSU0lPTik6ICooXFxkKykvLnNvdXJjZSwgLyNFWFQtWC0oRElTQ09OVElOVUlUWXxFTkRMSVNUfEdBUHxJTkRFUEVOREVOVC1TRUdNRU5UUykvLnNvdXJjZSwgLygjKShbXjpdKik6KC4qKS8uc291cmNlLCAvKCMpKC4qKSg/Oi4qKVxccj9cXG4/Ly5zb3VyY2VdLmpvaW4oJ3wnKSk7XG4gIHZhciBNM1U4UGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNM1U4UGFyc2VyKCkge31cbiAgICBNM1U4UGFyc2VyLmZpbmRHcm91cCA9IGZ1bmN0aW9uIGZpbmRHcm91cChncm91cHMsIG1lZGlhR3JvdXBJZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBpZiAoZ3JvdXAuaWQgPT09IG1lZGlhR3JvdXBJZCkge1xuICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgTTNVOFBhcnNlci5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICAgIHJldHVybiB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCwge1xuICAgICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgTTNVOFBhcnNlci5pc01lZGlhUGxheWxpc3QgPSBmdW5jdGlvbiBpc01lZGlhUGxheWxpc3Qoc3RyKSB7XG4gICAgICByZXR1cm4gSVNfTUVESUFfUExBWUxJU1QudGVzdChzdHIpO1xuICAgIH07XG4gICAgTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0ID0gZnVuY3Rpb24gcGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwpIHtcbiAgICAgIHZhciBoYXNWYXJpYWJsZVJlZnMgPSBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyaW5nKSA7XG4gICAgICB2YXIgcGFyc2VkID0ge1xuICAgICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICAgIGxldmVsczogW10sXG4gICAgICAgIHBsYXlsaXN0UGFyc2luZ0Vycm9yOiBudWxsLFxuICAgICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgICAgc2Vzc2lvbktleXM6IG51bGwsXG4gICAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgICAgdmFyaWFibGVMaXN0OiBudWxsLFxuICAgICAgICBoYXNWYXJpYWJsZVJlZnM6IGhhc1ZhcmlhYmxlUmVmc1xuICAgICAgfTtcbiAgICAgIHZhciBsZXZlbHNXaXRoS25vd25Db2RlY3MgPSBbXTtcbiAgICAgIE1BU1RFUl9QTEFZTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgICAgaWYgKCFzdHJpbmcuc3RhcnRzV2l0aCgnI0VYVE0zVScpKSB7XG4gICAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignbm8gRVhUTTNVIGRlbGltaXRlcicpO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgICAgdmFyIF9sZXZlbCR1bmtub3duQ29kZWNzO1xuICAgICAgICAgIC8vICcjRVhULVgtU1RSRUFNLUlORicgaXMgZm91bmQsIHBhcnNlIGxldmVsIHRhZyAgaW4gZ3JvdXAgMVxuICAgICAgICAgIHZhciBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0sIHBhcnNlZCk7XG4gICAgICAgICAgdmFyIHVyaSA9IHN1YnN0aXR1dGVWYXJpYWJsZXMocGFyc2VkLCByZXN1bHRbMl0pIDtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB7XG4gICAgICAgICAgICBhdHRyczogYXR0cnMsXG4gICAgICAgICAgICBiaXRyYXRlOiBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJykgfHwgYXR0cnMuZGVjaW1hbEludGVnZXIoJ0FWRVJBR0UtQkFORFdJRFRIJyksXG4gICAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FLFxuICAgICAgICAgICAgdXJsOiBNM1U4UGFyc2VyLnJlc29sdmUodXJpLCBiYXNldXJsKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgICAgIGlmIChyZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICBsZXZlbC53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0Q29kZWNzKGF0dHJzLkNPREVDUywgbGV2ZWwpO1xuICAgICAgICAgIHZhciBzdXBwbGVtZW50YWxDb2RlY3MgPSBhdHRyc1snU1VQUExFTUVOVEFMLUNPREVDUyddO1xuICAgICAgICAgIGlmIChzdXBwbGVtZW50YWxDb2RlY3MpIHtcbiAgICAgICAgICAgIGxldmVsLnN1cHBsZW1lbnRhbCA9IHt9O1xuICAgICAgICAgICAgc2V0Q29kZWNzKHN1cHBsZW1lbnRhbENvZGVjcywgbGV2ZWwuc3VwcGxlbWVudGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoKF9sZXZlbCR1bmtub3duQ29kZWNzID0gbGV2ZWwudW5rbm93bkNvZGVjcykgIT0gbnVsbCAmJiBfbGV2ZWwkdW5rbm93bkNvZGVjcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICBsZXZlbHNXaXRoS25vd25Db2RlY3MucHVzaChsZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlZC5sZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHJlc3VsdFszXTtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHJlc3VsdFs0XTtcbiAgICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAnU0VTU0lPTi1EQVRBJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICNFWFQtWC1TRVNTSU9OLURBVEFcbiAgICAgICAgICAgICAgICB2YXIgc2Vzc2lvbkF0dHJzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMsIHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJZCA9IHNlc3Npb25BdHRyc1snREFUQS1JRCddO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhSWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuc2Vzc2lvbkRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25EYXRhID0ge307XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbkRhdGFbZGF0YUlkXSA9IHNlc3Npb25BdHRycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1NFU1NJT04tS0VZJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICNFWFQtWC1TRVNTSU9OLUtFWVxuICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uS2V5ID0gcGFyc2VLZXkoYXR0cmlidXRlcywgYmFzZXVybCwgcGFyc2VkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbktleS5lbmNyeXB0ZWQgJiYgc2Vzc2lvbktleS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnNlc3Npb25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25LZXlzLnB1c2goc2Vzc2lvbktleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiW0tleXNdIElnbm9yaW5nIGludmFsaWQgRVhULVgtU0VTU0lPTi1LRVkgdGFnOiBcXFwiXCIgKyBhdHRyaWJ1dGVzICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnREVGSU5FJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICNFWFQtWC1ERUZJTkVcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMsIHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICBhZGRWYXJpYWJsZURlZmluaXRpb24ocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQ09OVEVOVC1TVEVFUklORyc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAjRVhULVgtQ09OVEVOVC1TVEVFUklOR1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMsIHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkLmNvbnRlbnRTdGVlcmluZyA9IHtcbiAgICAgICAgICAgICAgICAgIHVyaTogTTNVOFBhcnNlci5yZXNvbHZlKGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXNbJ1NFUlZFUi1VUkknXSwgYmFzZXVybCksXG4gICAgICAgICAgICAgICAgICBwYXRod2F5SWQ6IGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXNbJ1BBVEhXQVktSUQnXSB8fCAnLidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAjRVhULVgtU1RBUlRcbiAgICAgICAgICAgICAgICBwYXJzZWQuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpbHRlciBvdXQgbGV2ZWxzIHdpdGggdW5rbm93biBjb2RlY3MgaWYgaXQgZG9lcyBub3QgcmVtb3ZlIGFsbCBsZXZlbHNcbiAgICAgIHZhciBzdHJpcFVua25vd25Db2RlY0xldmVscyA9IGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPiAwICYmIGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPCBwYXJzZWQubGV2ZWxzLmxlbmd0aDtcbiAgICAgIHBhcnNlZC5sZXZlbHMgPSBzdHJpcFVua25vd25Db2RlY0xldmVscyA/IGxldmVsc1dpdGhLbm93bkNvZGVjcyA6IHBhcnNlZC5sZXZlbHM7XG4gICAgICBpZiAocGFyc2VkLmxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdubyBsZXZlbHMgZm91bmQgaW4gbWFuaWZlc3QnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfTtcbiAgICBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYSA9IGZ1bmN0aW9uIHBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIGJhc2V1cmwsIHBhcnNlZCkge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICB2YXIgbGV2ZWxzID0gcGFyc2VkLmxldmVscztcbiAgICAgIHZhciBncm91cHNCeVR5cGUgPSB7XG4gICAgICAgIEFVRElPOiBsZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXG4gICAgICAgICAgICBhdWRpb0NvZGVjOiBsZXZlbC5hdWRpb0NvZGVjXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIFNVQlRJVExFUzogbGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGxldmVsLmF0dHJzLlNVQlRJVExFUyxcbiAgICAgICAgICAgIHRleHRDb2RlYzogbGV2ZWwudGV4dENvZGVjXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciBpZCA9IDA7XG4gICAgICBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSwgcGFyc2VkKTtcbiAgICAgICAgdmFyIHR5cGUgPSBhdHRycy5UWVBFO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgIHZhciBncm91cHMgPSBncm91cHNCeVR5cGVbdHlwZV07XG4gICAgICAgICAgdmFyIG1lZGlhcyA9IHJlc3VsdHNbdHlwZV0gfHwgW107XG4gICAgICAgICAgcmVzdWx0c1t0eXBlXSA9IG1lZGlhcztcbiAgICAgICAgICB2YXIgbGFuZyA9IGF0dHJzLkxBTkdVQUdFO1xuICAgICAgICAgIHZhciBhc3NvY0xhbmcgPSBhdHRyc1snQVNTT0MtTEFOR1VBR0UnXTtcbiAgICAgICAgICB2YXIgY2hhbm5lbHMgPSBhdHRycy5DSEFOTkVMUztcbiAgICAgICAgICB2YXIgY2hhcmFjdGVyaXN0aWNzID0gYXR0cnMuQ0hBUkFDVEVSSVNUSUNTO1xuICAgICAgICAgIHZhciBpbnN0cmVhbUlkID0gYXR0cnNbJ0lOU1RSRUFNLUlEJ107XG4gICAgICAgICAgdmFyIG1lZGlhID0ge1xuICAgICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICAgIGlkOiBpZCsrLFxuICAgICAgICAgICAgZ3JvdXBJZDogYXR0cnNbJ0dST1VQLUlEJ10gfHwgJycsXG4gICAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FIHx8IGxhbmcgfHwgJycsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGVmYXVsdDogYXR0cnMuYm9vbCgnREVGQVVMVCcpLFxuICAgICAgICAgICAgYXV0b3NlbGVjdDogYXR0cnMuYm9vbCgnQVVUT1NFTEVDVCcpLFxuICAgICAgICAgICAgZm9yY2VkOiBhdHRycy5ib29sKCdGT1JDRUQnKSxcbiAgICAgICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgICAgICB1cmw6IGF0dHJzLlVSSSA/IE0zVThQYXJzZXIucmVzb2x2ZShhdHRycy5VUkksIGJhc2V1cmwpIDogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChhc3NvY0xhbmcpIHtcbiAgICAgICAgICAgIG1lZGlhLmFzc29jTGFuZyA9IGFzc29jTGFuZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYW5uZWxzKSB7XG4gICAgICAgICAgICBtZWRpYS5jaGFubmVscyA9IGNoYW5uZWxzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhcmFjdGVyaXN0aWNzKSB7XG4gICAgICAgICAgICBtZWRpYS5jaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnN0cmVhbUlkKSB7XG4gICAgICAgICAgICBtZWRpYS5pbnN0cmVhbUlkID0gaW5zdHJlYW1JZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdyb3VwcyAhPSBudWxsICYmIGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhdWRpbyBvciB0ZXh0IGdyb3VwcyBzaWduYWxsZWQgaW4gdGhlIG1hbmlmZXN0LCBsZXQncyBsb29rIGZvciBhIG1hdGNoaW5nIGNvZGVjIHN0cmluZyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZmluZCB0aGUgdHJhY2sgc2lnbmFsbGVkLCBsZXRzIHVzZSB0aGUgZmlyc3QgYXVkaW8gZ3JvdXBzIGNvZGVjIHdlIGhhdmVcbiAgICAgICAgICAgIC8vIEFjdGluZyBhcyBhIGJlc3QgZ3Vlc3NcbiAgICAgICAgICAgIHZhciBncm91cENvZGVjID0gTTNVOFBhcnNlci5maW5kR3JvdXAoZ3JvdXBzLCBtZWRpYS5ncm91cElkKSB8fCBncm91cHNbMF07XG4gICAgICAgICAgICBhc3NpZ25Db2RlYyhtZWRpYSwgZ3JvdXBDb2RlYywgJ2F1ZGlvQ29kZWMnKTtcbiAgICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAndGV4dENvZGVjJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlLCBsZXZlbFVybElkLCBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QpIHtcbiAgICAgIHZhciBfTEVWRUxfUExBWUxJU1RfUkVHRVg7XG4gICAgICB2YXIgYmFzZSA9IHtcbiAgICAgICAgdXJsOiBiYXNldXJsXG4gICAgICB9O1xuICAgICAgdmFyIGxldmVsID0gbmV3IExldmVsRGV0YWlscyhiYXNldXJsKTtcbiAgICAgIHZhciBmcmFnbWVudHMgPSBsZXZlbC5mcmFnbWVudHM7XG4gICAgICB2YXIgcHJvZ3JhbURhdGVUaW1lcyA9IFtdO1xuICAgICAgLy8gVGhlIG1vc3QgcmVjZW50IGluaXQgc2VnbWVudCBzZWVuIChhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IHNlZ21lbnRzKVxuICAgICAgdmFyIGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gICAgICB2YXIgY3VycmVudFNOID0gMDtcbiAgICAgIHZhciBjdXJyZW50UGFydCA9IDA7XG4gICAgICB2YXIgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgICB2YXIgZGlzY29udGludWl0eUNvdW50ZXIgPSAwO1xuICAgICAgdmFyIGN1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgIHZhciBwcmV2RnJhZyA9IG51bGw7XG4gICAgICB2YXIgZnJhZyA9IG5ldyBGcmFnbWVudCh0eXBlLCBiYXNlKTtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZXZlbGtleXM7XG4gICAgICB2YXIgZmlyc3RQZHRJbmRleCA9IC0xO1xuICAgICAgdmFyIGNyZWF0ZU5leHRGcmFnID0gZmFsc2U7XG4gICAgICB2YXIgbmV4dEJ5dGVSYW5nZSA9IG51bGw7XG4gICAgICB2YXIgc2VydmVyQ29udHJvbEF0dHJzO1xuICAgICAgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5sYXN0SW5kZXggPSAwO1xuICAgICAgbGV2ZWwubTN1OCA9IHN0cmluZztcbiAgICAgIGxldmVsLmhhc1ZhcmlhYmxlUmVmcyA9IGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHJpbmcpIDtcbiAgICAgIGlmICgoKF9MRVZFTF9QTEFZTElTVF9SRUdFWCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSA9PSBudWxsID8gdm9pZCAwIDogX0xFVkVMX1BMQVlMSVNUX1JFR0VYWzBdKSAhPT0gJyNFWFRNM1UnKSB7XG4gICAgICAgIGxldmVsLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIGZvcm1hdCBpZGVudGlmaWVyICNFWFRNM1UnKTtcbiAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgfVxuICAgICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNyZWF0ZU5leHRGcmFnKSB7XG4gICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2UpO1xuICAgICAgICAgIC8vIHNldHVwIHRoZSBuZXh0IGZyYWdtZW50IGZvciBwYXJ0IGxvYWRpbmdcbiAgICAgICAgICBmcmFnLnBsYXlsaXN0T2Zmc2V0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICBmcmFnLnNldFN0YXJ0KHRvdGFsZHVyYXRpb24pO1xuICAgICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICAgIGlmIChjdXJyZW50Qml0cmF0ZSkge1xuICAgICAgICAgICAgZnJhZy5iaXRyYXRlID0gY3VycmVudEJpdHJhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Qnl0ZVJhbmdlKSB7XG4gICAgICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKG5leHRCeXRlUmFuZ2UpO1xuICAgICAgICAgICAgICBuZXh0Qnl0ZVJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gcmVzdWx0WzFdO1xuICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBJTkZcbiAgICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7XG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIHZhciB0aXRsZSA9ICgnICcgKyByZXN1bHRbMl0pLnNsaWNlKDEpO1xuICAgICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSB8fCBudWxsO1xuICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHRpdGxlID8gWydJTkYnLCBkdXJhdGlvbiwgdGl0bGVdIDogWydJTkYnLCBkdXJhdGlvbl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICAgIC8vIHVybFxuICAgICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihmcmFnLmR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZnJhZy5wbGF5bGlzdE9mZnNldCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgICAgICBmcmFnLnNldFN0YXJ0KHRvdGFsZHVyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhZy5zbiA9IGN1cnJlbnRTTjtcbiAgICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWcpO1xuICAgICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgICAgdmFyIHVyaSA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgICAgZnJhZy5yZWx1cmwgPSBzdWJzdGl0dXRlVmFyaWFibGVzKGxldmVsLCB1cmkpIDtcbiAgICAgICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZywgcHJvZ3JhbURhdGVUaW1lcyk7XG4gICAgICAgICAgICBwcmV2RnJhZyA9IGZyYWc7XG4gICAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICBjdXJyZW50U04rKztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICAgICAgICAgIGNyZWF0ZU5leHRGcmFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignTm8gbWF0Y2hlcyBvbiBzbG93IHJlZ2V4IG1hdGNoIGZvciBsZXZlbCBwbGF5bGlzdCEnKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0W2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIHZhciB0YWcgPSAoJyAnICsgcmVzdWx0W2ldKS5zbGljZSgxKTtcbiAgICAgICAgICB2YXIgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpICsgMV0pLnNsaWNlKDEpO1xuICAgICAgICAgIHZhciB2YWx1ZTIgPSByZXN1bHRbaSArIDJdID8gKCcgJyArIHJlc3VsdFtpICsgMl0pLnNsaWNlKDEpIDogbnVsbDtcbiAgICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAnQllURVJBTkdFJzpcbiAgICAgICAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UodmFsdWUxLCBwcmV2RnJhZyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UodmFsdWUxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BST0dSQU0tREFURS1USU1FJzpcbiAgICAgICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IHZhbHVlMTtcbiAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydQUk9HUkFNLURBVEUtVElNRScsIHZhbHVlMV0pO1xuICAgICAgICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFBkdEluZGV4ID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BMQVlMSVNULVRZUEUnOlxuICAgICAgICAgICAgICBpZiAobGV2ZWwudHlwZSkge1xuICAgICAgICAgICAgICAgIGFzc2lnbk11bHRpcGxlTWVkaWFQbGF5bGlzdFRhZ09jY3VyYW5jZUVycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV2ZWwudHlwZSA9IHZhbHVlMS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgICAgaWYgKGxldmVsLnN0YXJ0U04gIT09IDApIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduTXVzdEFwcGVhckJlZm9yZVNlZ21lbnRzRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50U04gPSBsZXZlbC5zdGFydFNOID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTS0lQJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbC5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgIGFzc2lnbk11bHRpcGxlTWVkaWFQbGF5bGlzdFRhZ09jY3VyYW5jZUVycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBza2lwQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgdmFyIHNraXBwZWRTZWdtZW50cyA9IHNraXBBdHRycy5kZWNpbWFsSW50ZWdlcignU0tJUFBFRC1TRUdNRU5UUycpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihza2lwcGVkU2VnbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICBsZXZlbC5za2lwcGVkU2VnbWVudHMgKz0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHJlc3VsdCBpbiBmcmFnbWVudHNbXSBjb250YWluaW5nIHVuZGVmaW5lZCB2YWx1ZXMsIHdoaWNoIHdlIHdpbGwgZmlsbCBpbiB3aXRoIGBtZXJnZURldGFpbHNgXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IHNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50U04gKz0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHNraXBBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgbGV2ZWwucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IChsZXZlbC5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzIHx8IFtdKS5jb25jYXQocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcy5zcGxpdCgnXFx0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgICBpZiAobGV2ZWwudGFyZ2V0ZHVyYXRpb24gIT09IDApIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25NdWx0aXBsZU1lZGlhUGxheWxpc3RUYWdPY2N1cmFuY2VFcnJvcihsZXZlbCwgdGFnLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldmVsLnRhcmdldGR1cmF0aW9uID0gTWF0aC5tYXgocGFyc2VJbnQodmFsdWUxKSwgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgICAgIGlmIChsZXZlbC52ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXZlbC52ZXJzaW9uID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdJTkRFUEVOREVOVC1TRUdNRU5UUyc6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgICAgIGlmICghbGV2ZWwubGl2ZSkge1xuICAgICAgICAgICAgICAgIGFzc2lnbk11bHRpcGxlTWVkaWFQbGF5bGlzdFRhZ09jY3VyYW5jZUVycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICBpZiAodmFsdWUxIHx8IHZhbHVlMikge1xuICAgICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZJzpcbiAgICAgICAgICAgICAgZGlzY29udGludWl0eUNvdW50ZXIrKztcbiAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydESVMnXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR0FQJzpcbiAgICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbdGFnXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQklUUkFURSc6XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWcsIHZhbHVlMV0pO1xuICAgICAgICAgICAgICBjdXJyZW50Qml0cmF0ZSA9IHBhcnNlSW50KHZhbHVlMSkgKiAxMDAwO1xuICAgICAgICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoY3VycmVudEJpdHJhdGUpKSB7XG4gICAgICAgICAgICAgICAgZnJhZy5iaXRyYXRlID0gY3VycmVudEJpdHJhdGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnREFURVJBTkdFJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlUmFuZ2VBdHRyID0gbmV3IEF0dHJMaXN0KHZhbHVlMSwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRlUmFuZ2UgPSBuZXcgRGF0ZVJhbmdlKGRhdGVSYW5nZUF0dHIsIGxldmVsLmRhdGVSYW5nZXNbZGF0ZVJhbmdlQXR0ci5JRF0sIGxldmVsLmRhdGVSYW5nZVRhZ0NvdW50KTtcbiAgICAgICAgICAgICAgICBsZXZlbC5kYXRlUmFuZ2VUYWdDb3VudCsrO1xuICAgICAgICAgICAgICAgIGlmIChkYXRlUmFuZ2UuaXNWYWxpZCB8fCBsZXZlbC5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsLmRhdGVSYW5nZXNbZGF0ZVJhbmdlLmlkXSA9IGRhdGVSYW5nZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJJZ25vcmluZyBpbnZhbGlkIERBVEVSQU5HRSB0YWc6IFxcXCJcIiArIHZhbHVlMSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGZyYWdtZW50IHRhZyBsaXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoPCB2MS4yLjApXG4gICAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydFWFQtWC1EQVRFUkFOR0UnLCB2YWx1ZTFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnREVGSU5FJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZUF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QodmFsdWUxLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgICBpZiAoJ0lNUE9SVCcgaW4gdmFyaWFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbihsZXZlbCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmFyaWFibGVEZWZpbml0aW9uKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWS1TRVFVRU5DRSc6XG4gICAgICAgICAgICAgIGlmIChsZXZlbC5zdGFydENDICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFzc2lnbk11c3RBcHBlYXJCZWZvcmVTZWdtZW50c0Vycm9yKGxldmVsLCB0YWcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdLRVknOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVsS2V5ID0gcGFyc2VLZXkodmFsdWUxLCBiYXNldXJsLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsZXZlbEtleS5tZXRob2QgPT09ICdOT05FJykge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFsZXZlbGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0ge307XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEtleSA9IGxldmVsa2V5c1tsZXZlbEtleS5rZXlGb3JtYXRdO1xuICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGR1cGxpY2F0ZSBwbGF5bGlzdCBLRVkgdGFnc1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudEtleSAhPSBudWxsICYmIGN1cnJlbnRLZXkubWF0Y2hlcyhsZXZlbEtleSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gX2V4dGVuZHMoe30sIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzW2xldmVsS2V5LmtleUZvcm1hdF0gPSBsZXZlbEtleTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJbS2V5c10gSWdub3JpbmcgdW5zdXBwb3J0ZWQgRVhULVgtS0VZIHRhZzogXFxcIlwiICsgdmFsdWUxICsgXCJcXFwiXCIgKyAoJycgKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHBhcnNlU3RhcnRUaW1lT2Zmc2V0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTUFQJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBtYXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEsIGxldmVsKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBhZnRlciBzZWdtZW50IGR1cmF0aW9uIHRhZy5cbiAgICAgICAgICAgICAgICAgIC8vICAgI0VYVElORjogNi4wXG4gICAgICAgICAgICAgICAgICAvLyAgICNFWFQtWC1NQVA6VVJJPVwiaW5pdC5tcDRcbiAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoaW5pdCwgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gaW5pdDtcbiAgICAgICAgICAgICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSAmJiAhZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBJbml0aWFsIHNlZ21lbnQgdGFnIGlzIGJlZm9yZSBzZWdtZW50IGR1cmF0aW9uIHRhZ1xuICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgRVhULVgtTUFQIGlzIGRlY2xhcmVkIGFmdGVyIEVYVC1YLUJZVEVSQU5HRVxuICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBmcmFnLmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBuZXh0Qnl0ZVJhbmdlID0gZW5kIC0gc3RhcnQgKyBcIkBcIiArIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICAgICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnU0VSVkVSLUNPTlRST0wnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlckNvbnRyb2xBdHRycykge1xuICAgICAgICAgICAgICAgICAgYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VydmVyQ29udHJvbEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgbGV2ZWwuY2FuQmxvY2tSZWxvYWQgPSBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLUJMT0NLLVJFTE9BRCcpO1xuICAgICAgICAgICAgICAgIGxldmVsLmNhblNraXBVbnRpbCA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdDQU4tU0tJUC1VTlRJTCcsIDApO1xuICAgICAgICAgICAgICAgIGxldmVsLmNhblNraXBEYXRlUmFuZ2VzID0gbGV2ZWwuY2FuU2tpcFVudGlsID4gMCAmJiBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLVNLSVAtREFURVJBTkdFUycpO1xuICAgICAgICAgICAgICAgIGxldmVsLnBhcnRIb2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdQQVJULUhPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgICAgIGxldmVsLmhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ0hPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdQQVJULUlORic6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwucGFydFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRJbmZBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICAgIGxldmVsLnBhcnRUYXJnZXQgPSBwYXJ0SW5mQXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1BBUlQtVEFSR0VUJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1BBUlQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3Q7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0TGlzdCkge1xuICAgICAgICAgICAgICAgICAgcGFydExpc3QgPSBsZXZlbC5wYXJ0TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNGcmFnbWVudFBhcnQgPSBjdXJyZW50UGFydCA+IDAgPyBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjdXJyZW50UGFydCsrO1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBuZXcgUGFydChwYXJ0QXR0cnMsIGZyYWcsIGJhc2UsIGluZGV4LCBwcmV2aW91c0ZyYWdtZW50UGFydCk7XG4gICAgICAgICAgICAgICAgcGFydExpc3QucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBmcmFnLmR1cmF0aW9uICs9IHBhcnQuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1BSRUxPQUQtSElOVCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlbG9hZEhpbnRBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEsIGxldmVsKTtcbiAgICAgICAgICAgICAgICBsZXZlbC5wcmVsb2FkSGludCA9IHByZWxvYWRIaW50QXR0cnM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1JFTkRJVElPTi1SRVBPUlQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRpdGlvblJlcG9ydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLnJlbmRpdGlvblJlcG9ydHMgPSBsZXZlbC5yZW5kaXRpb25SZXBvcnRzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGxldmVsLnJlbmRpdGlvblJlcG9ydHMucHVzaChyZW5kaXRpb25SZXBvcnRBdHRycyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwibGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiBcIiArIHJlc3VsdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByZXZGcmFnICYmICFwcmV2RnJhZy5yZWx1cmwpIHtcbiAgICAgICAgZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgICB0b3RhbGR1cmF0aW9uIC09IHByZXZGcmFnLmR1cmF0aW9uO1xuICAgICAgICBpZiAobGV2ZWwucGFydExpc3QpIHtcbiAgICAgICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBwcmV2RnJhZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcsIHByb2dyYW1EYXRlVGltZXMpO1xuICAgICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgIGxldmVsLmZyYWdtZW50SGludCA9IGZyYWc7XG4gICAgICAgIGlmIChsZXZlbGtleXMpIHtcbiAgICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWxldmVsLnRhcmdldGR1cmF0aW9uKSB7XG4gICAgICAgIGxldmVsLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKFwiTWlzc2luZyBUYXJnZXQgRHVyYXRpb25cIik7XG4gICAgICB9XG4gICAgICB2YXIgZnJhZ21lbnRMZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGZpcnN0RnJhZ21lbnQgPSBmcmFnbWVudHNbMF07XG4gICAgICB2YXIgbGFzdEZyYWdtZW50ID0gZnJhZ21lbnRzW2ZyYWdtZW50TGVuZ3RoIC0gMV07XG4gICAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLnNraXBwZWRTZWdtZW50cyAqIGxldmVsLnRhcmdldGR1cmF0aW9uO1xuICAgICAgaWYgKHRvdGFsZHVyYXRpb24gPiAwICYmIGZyYWdtZW50TGVuZ3RoICYmIGxhc3RGcmFnbWVudCkge1xuICAgICAgICBsZXZlbC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uIC8gZnJhZ21lbnRMZW5ndGg7XG4gICAgICAgIHZhciBsYXN0U24gPSBsYXN0RnJhZ21lbnQuc247XG4gICAgICAgIGxldmVsLmVuZFNOID0gbGFzdFNuICE9PSAnaW5pdFNlZ21lbnQnID8gbGFzdFNuIDogMDtcbiAgICAgICAgaWYgKCFsZXZlbC5saXZlKSB7XG4gICAgICAgICAgbGFzdEZyYWdtZW50LmVuZExpc3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYWNrZmlsbCBhbnkgbWlzc2luZyBQRFQgdmFsdWVzXG4gICAgICAgICAqIFwiSWYgdGhlIGZpcnN0IEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZyBpbiBhIFBsYXlsaXN0IGFwcGVhcnMgYWZ0ZXJcbiAgICAgICAgICogb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAgICAgKiBiYWNrd2FyZCBmcm9tIHRoYXQgdGFnICh1c2luZyBFWFRJTkYgZHVyYXRpb25zIGFuZC9vciBtZWRpYVxuICAgICAgICAgKiB0aW1lc3RhbXBzKSB0byBhc3NvY2lhdGUgZGF0ZXMgd2l0aCB0aG9zZSBzZWdtZW50cy5cIlxuICAgICAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAgICAgKiBjb21wdXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmaXJzdFBkdEluZGV4ID4gMCkge1xuICAgICAgICAgIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhmcmFnbWVudHMsIGZpcnN0UGR0SW5kZXgpO1xuICAgICAgICAgIGlmIChmaXJzdEZyYWdtZW50KSB7XG4gICAgICAgICAgICBwcm9ncmFtRGF0ZVRpbWVzLnVuc2hpZnQoZmlyc3RGcmFnbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwuZnJhZ21lbnRIaW50KSB7XG4gICAgICAgIHRvdGFsZHVyYXRpb24gKz0gbGV2ZWwuZnJhZ21lbnRIaW50LmR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgICBpZiAocHJvZ3JhbURhdGVUaW1lcy5sZW5ndGggJiYgbGV2ZWwuZGF0ZVJhbmdlVGFnQ291bnQgJiYgZmlyc3RGcmFnbWVudCkge1xuICAgICAgICBtYXBEYXRlUmFuZ2VzKHByb2dyYW1EYXRlVGltZXMsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIGxldmVsLmVuZENDID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfTtcbiAgICByZXR1cm4gTTNVOFBhcnNlcjtcbiAgfSgpO1xuICBmdW5jdGlvbiBtYXBEYXRlUmFuZ2VzKHByb2dyYW1EYXRlVGltZXMsIGRldGFpbHMpIHtcbiAgICAvLyBNYWtlIHN1cmUgRGF0ZVJhbmdlcyBhcmUgbWFwcGVkIHRvIGEgUHJvZ3JhbURhdGVUaW1lIHRhZyB0aGF0IGFwcGxpZXMgYSBkYXRlIHRvIGEgc2VnbWVudCB0aGF0IG92ZXJsYXBzIHdpdGggaXRzIHN0YXJ0IGRhdGVcbiAgICB2YXIgcHJvZ3JhbURhdGVUaW1lQ291bnQgPSBwcm9ncmFtRGF0ZVRpbWVzLmxlbmd0aDtcbiAgICBpZiAoIXByb2dyYW1EYXRlVGltZUNvdW50KSB7XG4gICAgICBpZiAoZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgdmFyIGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBwcm9ncmFtRGF0ZVRpbWVzLnB1c2gobGFzdEZyYWdtZW50KTtcbiAgICAgICAgcHJvZ3JhbURhdGVUaW1lQ291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIHNlZ21lbnRzIHdpdGggRVhULVgtUFJPR1JBTS1EQVRFLVRJTUUgcmVmZXJlbmNlcyBpbiBwbGF5bGlzdCBoaXN0b3J5XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGxhc3RQcm9ncmFtRGF0ZVRpbWUgPSBwcm9ncmFtRGF0ZVRpbWVzW3Byb2dyYW1EYXRlVGltZUNvdW50IC0gMV07XG4gICAgdmFyIHBsYXlsaXN0RW5kID0gZGV0YWlscy5saXZlID8gSW5maW5pdHkgOiBkZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgdmFyIGRhdGVSYW5nZUlkcyA9IE9iamVjdC5rZXlzKGRldGFpbHMuZGF0ZVJhbmdlcyk7XG4gICAgZm9yICh2YXIgaSA9IGRhdGVSYW5nZUlkcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIHZhciBkYXRlUmFuZ2UgPSBkZXRhaWxzLmRhdGVSYW5nZXNbZGF0ZVJhbmdlSWRzW2ldXTtcbiAgICAgIHZhciBzdGFydERhdGVUaW1lID0gZGF0ZVJhbmdlLnN0YXJ0RGF0ZS5nZXRUaW1lKCk7XG4gICAgICBkYXRlUmFuZ2UudGFnQW5jaG9yID0gbGFzdFByb2dyYW1EYXRlVGltZS5yZWY7XG4gICAgICBmb3IgKHZhciBqID0gcHJvZ3JhbURhdGVUaW1lQ291bnQ7IGotLTspIHtcbiAgICAgICAgdmFyIF9wcm9ncmFtRGF0ZVRpbWVzJGo7XG4gICAgICAgIGlmICgoKF9wcm9ncmFtRGF0ZVRpbWVzJGogPSBwcm9ncmFtRGF0ZVRpbWVzW2pdKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb2dyYW1EYXRlVGltZXMkai5zbikgPCBkZXRhaWxzLnN0YXJ0U04pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhZ0luZGV4ID0gZmluZEZyYWdtZW50V2l0aFN0YXJ0RGF0ZShkZXRhaWxzLCBzdGFydERhdGVUaW1lLCBwcm9ncmFtRGF0ZVRpbWVzLCBqLCBwbGF5bGlzdEVuZCk7XG4gICAgICAgIGlmIChmcmFnSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgZGF0ZVJhbmdlLnRhZ0FuY2hvciA9IGRldGFpbHMuZnJhZ21lbnRzW2ZyYWdJbmRleF0ucmVmO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZpbmRGcmFnbWVudFdpdGhTdGFydERhdGUoZGV0YWlscywgc3RhcnREYXRlVGltZSwgcHJvZ3JhbURhdGVUaW1lcywgaW5kZXgsIGVuZFRpbWUpIHtcbiAgICB2YXIgcGR0RnJhZ21lbnQgPSBwcm9ncmFtRGF0ZVRpbWVzW2luZGV4XTtcbiAgICBpZiAocGR0RnJhZ21lbnQpIHtcbiAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgcmFuZ2UgYmV0d2VlbiBQRFQgdGFnc1xuICAgICAgdmFyIHBkdFN0YXJ0ID0gcGR0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lO1xuICAgICAgaWYgKHN0YXJ0RGF0ZVRpbWUgPj0gcGR0U3RhcnQgfHwgaW5kZXggPT09IDApIHtcbiAgICAgICAgdmFyIF9wcm9ncmFtRGF0ZVRpbWVzO1xuICAgICAgICB2YXIgZHVyYXRpb25CZXR3ZWVuUGR0ID0gKCgoX3Byb2dyYW1EYXRlVGltZXMgPSBwcm9ncmFtRGF0ZVRpbWVzW2luZGV4ICsgMV0pID09IG51bGwgPyB2b2lkIDAgOiBfcHJvZ3JhbURhdGVUaW1lcy5zdGFydCkgfHwgZW5kVGltZSkgLSBwZHRGcmFnbWVudC5zdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0RGF0ZVRpbWUgPD0gcGR0U3RhcnQgKyBkdXJhdGlvbkJldHdlZW5QZHQgKiAxMDAwKSB7XG4gICAgICAgICAgLy8gbWFwIHRvIGZyYWdtZW50IHdpdGggZGF0ZS10aW1lIHJhbmdlXG4gICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBwcm9ncmFtRGF0ZVRpbWVzW2luZGV4XS5zbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgICBpZiAoc3RhcnRJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoID4gcHJvZ3JhbURhdGVUaW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlbmRTZWdtZW50ID0gcHJvZ3JhbURhdGVUaW1lc1tpbmRleCArIDFdIHx8IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBlbmRTZWdtZW50LnNuIC0gZGV0YWlscy5zdGFydFNOO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGVuZEluZGV4OyBpID4gc3RhcnRJbmRleDsgaS0tKSB7XG4gICAgICAgICAgICAgIHZhciBmcmFnU3RhcnREYXRlVGltZSA9IGZyYWdtZW50c1tpXS5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgICAgIGlmIChzdGFydERhdGVUaW1lID49IGZyYWdTdGFydERhdGVUaW1lICYmIHN0YXJ0RGF0ZVRpbWUgPCBmcmFnU3RhcnREYXRlVGltZSArIGZyYWdtZW50c1tpXS5kdXJhdGlvbiAqIDEwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RhcnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VLZXkoa2V5VGFnQXR0cmlidXRlcywgYmFzZXVybCwgcGFyc2VkKSB7XG4gICAgdmFyIF9rZXlBdHRycyRNRVRIT0QsIF9rZXlBdHRycyRLRVlGT1JNQVQ7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyMTYjc2VjdGlvbi00LjMuMi40XG4gICAgdmFyIGtleUF0dHJzID0gbmV3IEF0dHJMaXN0KGtleVRhZ0F0dHJpYnV0ZXMsIHBhcnNlZCk7XG4gICAgdmFyIGRlY3J5cHRtZXRob2QgPSAoX2tleUF0dHJzJE1FVEhPRCA9IGtleUF0dHJzLk1FVEhPRCkgIT0gbnVsbCA/IF9rZXlBdHRycyRNRVRIT0QgOiAnJztcbiAgICB2YXIgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSTtcbiAgICB2YXIgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xuICAgIHZhciBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgPSBrZXlBdHRycy5LRVlGT1JNQVRWRVJTSU9OUztcbiAgICAvLyBGcm9tIFJGQzogVGhpcyBhdHRyaWJ1dGUgaXMgT1BUSU9OQUw7IGl0cyBhYnNlbmNlIGluZGljYXRlcyBhbiBpbXBsaWNpdCB2YWx1ZSBvZiBcImlkZW50aXR5XCIuXG4gICAgdmFyIGRlY3J5cHRrZXlmb3JtYXQgPSAoX2tleUF0dHJzJEtFWUZPUk1BVCA9IGtleUF0dHJzLktFWUZPUk1BVCkgIT0gbnVsbCA/IF9rZXlBdHRycyRLRVlGT1JNQVQgOiAnaWRlbnRpdHknO1xuICAgIGlmIChkZWNyeXB0dXJpICYmIGtleUF0dHJzLklWICYmICFkZWNyeXB0aXYpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgSVY6IFwiICsga2V5QXR0cnMuSVYpO1xuICAgIH1cbiAgICAvLyBJZiBkZWNyeXB0dXJpIGlzIGEgVVJJIHdpdGggYSBzY2hlbWUsIHRoZW4gYmFzZXVybCB3aWxsIGJlIGlnbm9yZWRcbiAgICAvLyBObyB1cmkgaXMgYWxsb3dlZCB3aGVuIE1FVEhPRCBpcyBOT05FXG4gICAgdmFyIHJlc29sdmVkVXJpID0gZGVjcnlwdHVyaSA/IE0zVThQYXJzZXIucmVzb2x2ZShkZWNyeXB0dXJpLCBiYXNldXJsKSA6ICcnO1xuICAgIHZhciBrZXlGb3JtYXRWZXJzaW9ucyA9IChkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgPyBkZWNyeXB0a2V5Zm9ybWF0dmVyc2lvbnMgOiAnMScpLnNwbGl0KCcvJykubWFwKE51bWJlcikuZmlsdGVyKE51bWJlci5pc0Zpbml0ZSk7XG4gICAgcmV0dXJuIG5ldyBMZXZlbEtleShkZWNyeXB0bWV0aG9kLCByZXNvbHZlZFVyaSwgZGVjcnlwdGtleWZvcm1hdCwga2V5Rm9ybWF0VmVyc2lvbnMsIGRlY3J5cHRpdiwga2V5QXR0cnMuS0VZSUQpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUaW1lT2Zmc2V0KHN0YXJ0QXR0cmlidXRlcykge1xuICAgIHZhciBzdGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHN0YXJ0QXR0cmlidXRlcyk7XG4gICAgdmFyIHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgIHJldHVybiBzdGFydFRpbWVPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHNldENvZGVjcyhjb2RlY3NBdHRyaWJ1dGVWYWx1ZSwgbGV2ZWwpIHtcbiAgICB2YXIgY29kZWNzID0gKGNvZGVjc0F0dHJpYnV0ZVZhbHVlIHx8ICcnKS5zcGxpdCgvWyAsXSsvKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pO1xuICAgIFsndmlkZW8nLCAnYXVkaW8nLCAndGV4dCddLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBmaWx0ZXJlZCA9IGNvZGVjcy5maWx0ZXIoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICAgIHJldHVybiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgYWxsIGNvZGVjcyBmb3IgdHlwZVxuICAgICAgICBsZXZlbFt0eXBlICsgXCJDb2RlY1wiXSA9IGZpbHRlcmVkLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBjLnNwbGl0KCcvJylbMF07XG4gICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgICAgLy8gUmVtb3ZlIGtub3duIGNvZGVjcyBzbyB0aGF0IG9ubHkgdW5rbm93bkNvZGVjcyBhcmUgbGVmdCBhZnRlciBpdGVyYXRpbmcgdGhyb3VnaCBlYWNoIHR5cGVcbiAgICAgICAgY29kZWNzID0gY29kZWNzLmZpbHRlcihmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXZlbC51bmtub3duQ29kZWNzID0gY29kZWNzO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cEl0ZW0sIGNvZGVjUHJvcGVydHkpIHtcbiAgICB2YXIgY29kZWNWYWx1ZSA9IGdyb3VwSXRlbVtjb2RlY1Byb3BlcnR5XTtcbiAgICBpZiAoY29kZWNWYWx1ZSkge1xuICAgICAgbWVkaWFbY29kZWNQcm9wZXJ0eV0gPSBjb2RlY1ZhbHVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KSB7XG4gICAgdmFyIGZyYWdQcmV2ID0gZnJhZ21lbnRzW2ZpcnN0UGR0SW5kZXhdO1xuICAgIGZvciAodmFyIGkgPSBmaXJzdFBkdEluZGV4OyBpLS07KSB7XG4gICAgICB2YXIgZnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICAgIC8vIEV4aXQgb24gZGVsdGEtcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gZnJhZ1ByZXYucHJvZ3JhbURhdGVUaW1lIC0gZnJhZy5kdXJhdGlvbiAqIDEwMDA7XG4gICAgICBmcmFnUHJldiA9IGZyYWc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZywgcHJvZ3JhbURhdGVUaW1lcykge1xuICAgIGlmIChmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgcHJvZ3JhbURhdGVUaW1lcy5wdXNoKGZyYWcpO1xuICAgIH0gZWxzZSBpZiAocHJldkZyYWcgIT0gbnVsbCAmJiBwcmV2RnJhZy5wcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gcHJldkZyYWcuZW5kUHJvZ3JhbURhdGVUaW1lO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5cykge1xuICAgIGZyYWcucmVsdXJsID0gbWFwQXR0cnMuVVJJO1xuICAgIGlmIChtYXBBdHRycy5CWVRFUkFOR0UpIHtcbiAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKG1hcEF0dHJzLkJZVEVSQU5HRSk7XG4gICAgfVxuICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgICB9XG4gICAgZnJhZy5pbml0U2VnbWVudCA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKSB7XG4gICAgZnJhZy5sZXZlbGtleXMgPSBsZXZlbGtleXM7XG4gICAgdmFyIGVuY3J5cHRlZEZyYWdtZW50cyA9IGxldmVsLmVuY3J5cHRlZEZyYWdtZW50cztcbiAgICBpZiAoKCFlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoIHx8IGVuY3J5cHRlZEZyYWdtZW50c1tlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoIC0gMV0ubGV2ZWxrZXlzICE9PSBsZXZlbGtleXMpICYmIE9iamVjdC5rZXlzKGxldmVsa2V5cykuc29tZShmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICByZXR1cm4gbGV2ZWxrZXlzW2Zvcm1hdF0uaXNDb21tb25FbmNyeXB0aW9uO1xuICAgIH0pKSB7XG4gICAgICBlbmNyeXB0ZWRGcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXNzaWduTXVsdGlwbGVNZWRpYVBsYXlsaXN0VGFnT2NjdXJhbmNlRXJyb3IobGV2ZWwsIHRhZywgcmVzdWx0KSB7XG4gICAgbGV2ZWwucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoXCIjRVhULVgtXCIgKyB0YWcgKyBcIiBtdXN0IG5vdCBhcHBlYXIgbW9yZSB0aGFuIG9uY2UgKFwiICsgcmVzdWx0WzBdICsgXCIpXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2lnbk11c3RBcHBlYXJCZWZvcmVTZWdtZW50c0Vycm9yKGxldmVsLCB0YWcsIHJlc3VsdCkge1xuICAgIGxldmVsLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKFwiI0VYVC1YLVwiICsgdGFnICsgXCIgbXVzdCBhcHBlYXIgYmVmb3JlIHRoZSBmaXJzdCBNZWRpYSBTZWdtZW50IChcIiArIHJlc3VsdFswXSArIFwiKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21Ub1BUUyhmcmFnRnJvbSwgZnJhZ1RvKSB7XG4gICAgdmFyIGZyYWdUb1BUUyA9IGZyYWdUby5zdGFydFBUUztcbiAgICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcihmcmFnVG9QVFMpKSB7XG4gICAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICAgIHZhciBkdXJhdGlvbiA9IDA7XG4gICAgICB2YXIgZnJhZztcbiAgICAgIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgICAgICBkdXJhdGlvbiA9IGZyYWdUb1BUUyAtIGZyYWdGcm9tLnN0YXJ0O1xuICAgICAgICBmcmFnID0gZnJhZ0Zyb207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkdXJhdGlvbiA9IGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvUFRTO1xuICAgICAgICBmcmFnID0gZnJhZ1RvO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcuZHVyYXRpb24gIT09IGR1cmF0aW9uKSB7XG4gICAgICAgIGZyYWcuc2V0RHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgIH0gZWxzZSBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICAgIHZhciBjb250aWd1b3VzID0gZnJhZ0Zyb20uY2MgPT09IGZyYWdUby5jYztcbiAgICAgIC8vIFRPRE86IFdpdGggcGFydC1sb2FkaW5nIGVuZC9kdXJhdGlvbnMgd2UgbmVlZCB0byBjb25maXJtIHRoZSB3aG9sZSBmcmFnbWVudCBpcyBsb2FkZWQgYmVmb3JlIHVzaW5nIChvciBzZXR0aW5nKSBtaW5FbmRQVFNcbiAgICAgIGlmIChjb250aWd1b3VzICYmIGZyYWdGcm9tLm1pbkVuZFBUUykge1xuICAgICAgICBmcmFnVG8uc2V0U3RhcnQoZnJhZ0Zyb20uc3RhcnQgKyAoZnJhZ0Zyb20ubWluRW5kUFRTIC0gZnJhZ0Zyb20uc3RhcnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdUby5zZXRTdGFydChmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1RvLnNldFN0YXJ0KE1hdGgubWF4KGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uLCAwKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdQVFNEVFMoZGV0YWlscywgZnJhZywgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUywgbG9nZ2VyKSB7XG4gICAgdmFyIHBhcnNlZE1lZGlhRHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgICBpZiAocGFyc2VkTWVkaWFEdXJhdGlvbiA8PSAwKSB7XG4gICAgICBsb2dnZXIud2FybignRnJhZ21lbnQgc2hvdWxkIGhhdmUgYSBwb3NpdGl2ZSBkdXJhdGlvbicsIGZyYWcpO1xuICAgICAgZW5kUFRTID0gc3RhcnRQVFMgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgZW5kRFRTID0gc3RhcnREVFMgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgICB2YXIgbWF4U3RhcnRQVFMgPSBzdGFydFBUUztcbiAgICB2YXIgbWluRW5kUFRTID0gZW5kUFRTO1xuICAgIHZhciBmcmFnU3RhcnRQdHMgPSBmcmFnLnN0YXJ0UFRTO1xuICAgIHZhciBmcmFnRW5kUHRzID0gZnJhZy5lbmRQVFM7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWdTdGFydFB0cykpIHtcbiAgICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgICAgdmFyIGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZ1N0YXJ0UHRzIC0gc3RhcnRQVFMpO1xuICAgICAgaWYgKGRldGFpbHMgJiYgZGVsdGFQVFMgPiBkZXRhaWxzLnRvdGFsZHVyYXRpb24pIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJtZWRpYSB0aW1lc3RhbXBzIGFuZCBwbGF5bGlzdCB0aW1lcyBkaWZmZXIgYnkgXCIgKyBkZWx0YVBUUyArIFwicyBmb3IgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgXCIgKyBkZXRhaWxzLnVybCk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZU51bWJlcihmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsIGZyYWcuZGVsdGFQVFMpO1xuICAgICAgfVxuICAgICAgbWF4U3RhcnRQVFMgPSBNYXRoLm1heChzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgICBzdGFydERUUyA9IGZyYWcuc3RhcnREVFMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKSA6IHN0YXJ0RFRTO1xuICAgICAgbWluRW5kUFRTID0gTWF0aC5taW4oZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICAgIGVuZFBUUyA9IE1hdGgubWF4KGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgICBlbmREVFMgPSBmcmFnLmVuZERUUyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUykgOiBlbmREVFM7XG4gICAgfVxuICAgIHZhciBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcbiAgICBpZiAoZnJhZy5zdGFydCAhPT0gMCkge1xuICAgICAgZnJhZy5zZXRTdGFydChzdGFydFBUUyk7XG4gICAgfVxuICAgIGZyYWcuc2V0RHVyYXRpb24oZW5kUFRTIC0gZnJhZy5zdGFydCk7XG4gICAgZnJhZy5zdGFydFBUUyA9IHN0YXJ0UFRTO1xuICAgIGZyYWcubWF4U3RhcnRQVFMgPSBtYXhTdGFydFBUUztcbiAgICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gICAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gICAgZnJhZy5taW5FbmRQVFMgPSBtaW5FbmRQVFM7XG4gICAgZnJhZy5lbmREVFMgPSBlbmREVFM7XG4gICAgdmFyIHNuID0gZnJhZy5zbjtcbiAgICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxuICAgIGlmICghZGV0YWlscyB8fCBzbiA8IGRldGFpbHMuc3RhcnRTTiB8fCBzbiA+IGRldGFpbHMuZW5kU04pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgZnJhZ0lkeCA9IHNuIC0gZGV0YWlscy5zdGFydFNOO1xuICAgIHZhciBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgICAvLyB1cGRhdGUgZnJhZyByZWZlcmVuY2UgaW4gZnJhZ21lbnRzIGFycmF5XG4gICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgZnJhZ21lbnRzIGFycmF5IG1pZ2h0IG5vdCBjb250YWluIHRoaXMgZnJhZyBvYmplY3QuXG4gICAgLy8gdGhpcyB3aWxsIGhhcHBlbiBpZiBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgYmV0d2VlbiBmcmFnIGxvYWRpbmcgYW5kIGNhbGwgdG8gdXBkYXRlRnJhZ1BUU0RUUygpXG4gICAgLy8gaWYgd2UgZG9uJ3QgdXBkYXRlIGZyYWcsIHdlIHdvbid0IGJlIGFibGUgdG8gcHJvcGFnYXRlIFBUUyBpbmZvIG9uIHRoZSBwbGF5bGlzdFxuICAgIC8vIHJlc3VsdGluZyBpbiBpbnZhbGlkIHNsaWRpbmcgY29tcHV0YXRpb25cbiAgICBmcmFnbWVudHNbZnJhZ0lkeF0gPSBmcmFnO1xuICAgIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcbiAgICBmb3IgKGkgPSBmcmFnSWR4OyBpID4gMDsgaS0tKSB7XG4gICAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSAtIDFdKTtcbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtIHRvIGxhc3QgZnJhZ1xuICAgIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSArIDFdKTtcbiAgICB9XG4gICAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXSwgZGV0YWlscy5mcmFnbWVudEhpbnQpO1xuICAgIH1cbiAgICBkZXRhaWxzLlBUU0tub3duID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gICAgcmV0dXJuIGRyaWZ0O1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRGV0YWlscyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBsb2dnZXIpIHtcbiAgICBpZiAob2xkRGV0YWlscyA9PT0gbmV3RGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUcmFjayB0aGUgbGFzdCBpbml0U2VnbWVudCBwcm9jZXNzZWQuIEluaXRpYWxpemUgaXQgdG8gdGhlIGxhc3Qgb25lIG9uIHRoZSB0aW1lbGluZS5cbiAgICB2YXIgY3VycmVudEluaXRTZWdtZW50ID0gbnVsbDtcbiAgICB2YXIgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gICAgZm9yICh2YXIgaSA9IG9sZEZyYWdtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIG9sZEluaXQgPSBvbGRGcmFnbWVudHNbaV0uaW5pdFNlZ21lbnQ7XG4gICAgICBpZiAob2xkSW5pdCkge1xuICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRJbml0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgICAvLyBwcmV2ZW50IFBUUyBhbmQgZHVyYXRpb24gZnJvbSBiZWluZyBhZGp1c3RlZCBvbiB0aGUgbmV4dCBoaW50XG4gICAgICBkZWxldGUgb2xkRGV0YWlscy5mcmFnbWVudEhpbnQuZW5kUFRTO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBvbGQvbmV3IHBsYXlsaXN0cyBoYXZlIGZyYWdtZW50cyBpbiBjb21tb25cbiAgICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUywgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgICB2YXIgUFRTRnJhZztcbiAgICBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBmdW5jdGlvbiAob2xkRnJhZywgbmV3RnJhZywgbmV3RnJhZ0luZGV4LCBuZXdGcmFnbWVudHMpIHtcbiAgICAgIGlmICgoIW5ld0RldGFpbHMuc3RhcnRDQyB8fCBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykgJiYgbmV3RnJhZy5jYyAhPT0gb2xkRnJhZy5jYykge1xuICAgICAgICB2YXIgY2NPZmZzZXQgPSBvbGRGcmFnLmNjIC0gbmV3RnJhZy5jYztcbiAgICAgICAgZm9yICh2YXIgX2kgPSBuZXdGcmFnSW5kZXg7IF9pIDwgbmV3RnJhZ21lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIG5ld0ZyYWdtZW50c1tfaV0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RGV0YWlscy5lbmRDQyA9IG5ld0ZyYWdtZW50c1tuZXdGcmFnbWVudHMubGVuZ3RoIC0gMV0uY2M7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIob2xkRnJhZy5zdGFydFBUUykgJiYgaXNGaW5pdGVOdW1iZXIob2xkRnJhZy5lbmRQVFMpKSB7XG4gICAgICAgIG5ld0ZyYWcuc2V0U3RhcnQobmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFMpO1xuICAgICAgICBuZXdGcmFnLnN0YXJ0RFRTID0gb2xkRnJhZy5zdGFydERUUztcbiAgICAgICAgbmV3RnJhZy5tYXhTdGFydFBUUyA9IG9sZEZyYWcubWF4U3RhcnRQVFM7XG4gICAgICAgIG5ld0ZyYWcuZW5kUFRTID0gb2xkRnJhZy5lbmRQVFM7XG4gICAgICAgIG5ld0ZyYWcuZW5kRFRTID0gb2xkRnJhZy5lbmREVFM7XG4gICAgICAgIG5ld0ZyYWcubWluRW5kUFRTID0gb2xkRnJhZy5taW5FbmRQVFM7XG4gICAgICAgIG5ld0ZyYWcuc2V0RHVyYXRpb24ob2xkRnJhZy5lbmRQVFMgLSBvbGRGcmFnLnN0YXJ0UFRTKTtcbiAgICAgICAgaWYgKG5ld0ZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIGFueSBzZWdtZW50IGhhcyBzdGFydFBUUyBhbmQgZW5kUFRTXG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBuZXdEZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvbGRGcmFnLmhhc1N0cmVhbXMpIHtcbiAgICAgICAgbmV3RnJhZy5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZEZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICB9XG4gICAgICBuZXdGcmFnLmxvYWRlciA9IG9sZEZyYWcubG9hZGVyO1xuICAgICAgaWYgKG9sZEZyYWcuaGFzU3RhdHMpIHtcbiAgICAgICAgbmV3RnJhZy5zdGF0cyA9IG9sZEZyYWcuc3RhdHM7XG4gICAgICB9XG4gICAgICBpZiAob2xkRnJhZy5pbml0U2VnbWVudCkge1xuICAgICAgICBuZXdGcmFnLmluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbmV3RnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgdmFyIGZyYWdtZW50c1RvQ2hlY2sgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0ZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpIDogbmV3RnJhZ21lbnRzO1xuICAgIGlmIChjdXJyZW50SW5pdFNlZ21lbnQpIHtcbiAgICAgIGZyYWdtZW50c1RvQ2hlY2suZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICB2YXIgX2N1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGZyYWcgJiYgKCFmcmFnLmluaXRTZWdtZW50IHx8IGZyYWcuaW5pdFNlZ21lbnQucmVsdXJsID09PSAoKF9jdXJyZW50SW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfY3VycmVudEluaXRTZWdtZW50LnJlbHVybCkpKSB7XG4gICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgICAgbmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IG5ld0ZyYWdtZW50cy5zb21lKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIHJldHVybiAhZnJhZztcbiAgICAgIH0pO1xuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1tsZXZlbC1oZWxwZXJdIFByZXZpb3VzIHBsYXlsaXN0IG1pc3Npbmcgc2VnbWVudHMgc2tpcHBlZCBpbiBkZWx0YSBwbGF5bGlzdCcpO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50czsgX2kyLS07KSB7XG4gICAgICAgICAgbmV3RnJhZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RGV0YWlscy5zdGFydFNOID0gbmV3RnJhZ21lbnRzWzBdLnNuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgICAgICBuZXdEZXRhaWxzLmRhdGVSYW5nZXMgPSBtZXJnZURhdGVSYW5nZXMob2xkRGV0YWlscy5kYXRlUmFuZ2VzLCBuZXdEZXRhaWxzLCBsb2dnZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmFtRGF0ZVRpbWVzID0gb2xkRGV0YWlscy5mcmFnbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9sZERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lICYmICFuZXdEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDE7IF9pMyA8IGZyYWdtZW50c1RvQ2hlY2subGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50c1RvQ2hlY2tbX2kzXS5wcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWdtZW50c1RvQ2hlY2tbX2kzXSwgZnJhZ21lbnRzVG9DaGVja1tfaTMgLSAxXSwgcHJvZ3JhbURhdGVUaW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hcERhdGVSYW5nZXMocHJvZ3JhbURhdGVUaW1lcywgbmV3RGV0YWlscyk7XG4gICAgICB9XG4gICAgICBuZXdEZXRhaWxzLmVuZENDID0gbmV3RnJhZ21lbnRzW25ld0ZyYWdtZW50cy5sZW5ndGggLSAxXS5jYztcbiAgICB9XG4gICAgaWYgKCFuZXdEZXRhaWxzLnN0YXJ0Q0MpIHtcbiAgICAgIHZhciBfZnJhZ1ByaW9yVG9OZXdTdGFydCQ7XG4gICAgICB2YXIgZnJhZ1ByaW9yVG9OZXdTdGFydCA9IGdldEZyYWdtZW50V2l0aFNOKG9sZERldGFpbHMsIG5ld0RldGFpbHMuc3RhcnRTTiAtIDEpO1xuICAgICAgbmV3RGV0YWlscy5zdGFydENDID0gKF9mcmFnUHJpb3JUb05ld1N0YXJ0JCA9IGZyYWdQcmlvclRvTmV3U3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWdQcmlvclRvTmV3U3RhcnQuY2MpICE9IG51bGwgPyBfZnJhZ1ByaW9yVG9OZXdTdGFydCQgOiBuZXdGcmFnbWVudHNbMF0uY2M7XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgcGFydHNcbiAgICBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZERldGFpbHMucGFydExpc3QsIG5ld0RldGFpbHMucGFydExpc3QsIGZ1bmN0aW9uIChvbGRQYXJ0LCBuZXdQYXJ0KSB7XG4gICAgICBuZXdQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zID0gb2xkUGFydC5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICAgIG5ld1BhcnQuc3RhdHMgPSBvbGRQYXJ0LnN0YXRzO1xuICAgIH0pO1xuXG4gICAgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXG4gICAgaWYgKFBUU0ZyYWcpIHtcbiAgICAgIHVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscywgUFRTRnJhZywgUFRTRnJhZy5zdGFydFBUUywgUFRTRnJhZy5lbmRQVFMsIFBUU0ZyYWcuc3RhcnREVFMsIFBUU0ZyYWcuZW5kRFRTLCBsb2dnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkRnJhZ21lbnRzIHJhbmdlXG4gICAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICAgIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscyk7XG4gICAgfVxuICAgIGlmIChuZXdGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24gPSBuZXdEZXRhaWxzLmVkZ2UgLSBuZXdGcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgfVxuICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnRUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IG9sZERldGFpbHMuZHJpZnRTdGFydDtcbiAgICB2YXIgYWR2YW5jZWREYXRlVGltZSA9IG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgICBpZiAobmV3RGV0YWlscy5hZHZhbmNlZCAmJiBhZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgICB2YXIgZWRnZSA9IG5ld0RldGFpbHMuZWRnZTtcbiAgICAgIGlmICghbmV3RGV0YWlscy5kcmlmdFN0YXJ0KSB7XG4gICAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnQgPSBlZGdlO1xuICAgICAgfVxuICAgICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IGVkZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gb2xkRGV0YWlscy5kcmlmdEVuZFRpbWU7XG4gICAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kID0gb2xkRGV0YWlscy5kcmlmdEVuZDtcbiAgICAgIG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IG9sZERldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgICB9XG4gICAgaWYgKG5ld0RldGFpbHMucmVxdWVzdFNjaGVkdWxlZCA9PT0gLTEpIHtcbiAgICAgIG5ld0RldGFpbHMucmVxdWVzdFNjaGVkdWxlZCA9IG9sZERldGFpbHMucmVxdWVzdFNjaGVkdWxlZDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VEYXRlUmFuZ2VzKG9sZERhdGVSYW5nZXMsIG5ld0RldGFpbHMsIGxvZ2dlcikge1xuICAgIHZhciBkZWx0YURhdGVSYW5nZXMgPSBuZXdEZXRhaWxzLmRhdGVSYW5nZXMsXG4gICAgICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gbmV3RGV0YWlscy5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzO1xuICAgIHZhciBkYXRlUmFuZ2VzID0gX2V4dGVuZHMoe30sIG9sZERhdGVSYW5nZXMpO1xuICAgIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgbWVyZ2VJZHMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VzKTtcbiAgICB2YXIgbWVyZ2VDb3VudCA9IG1lcmdlSWRzLmxlbmd0aDtcbiAgICBpZiAoIW1lcmdlQ291bnQpIHtcbiAgICAgIHJldHVybiBkZWx0YURhdGVSYW5nZXM7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGRlbHRhRGF0ZVJhbmdlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciBtZXJnZWREYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgIHZhciBkYXRlUmFuZ2UgPSBuZXcgRGF0ZVJhbmdlKGRlbHRhRGF0ZVJhbmdlc1tpZF0uYXR0ciwgbWVyZ2VkRGF0ZVJhbmdlKTtcbiAgICAgIGlmIChkYXRlUmFuZ2UuaXNWYWxpZCkge1xuICAgICAgICBkYXRlUmFuZ2VzW2lkXSA9IGRhdGVSYW5nZTtcbiAgICAgICAgaWYgKCFtZXJnZWREYXRlUmFuZ2UpIHtcbiAgICAgICAgICBkYXRlUmFuZ2UudGFnT3JkZXIgKz0gbWVyZ2VDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJJZ25vcmluZyBpbnZhbGlkIFBsYXlsaXN0IERlbHRhIFVwZGF0ZSBEQVRFUkFOR0UgdGFnOiBcXFwiXCIgKyBzdHJpbmdpZnkoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyKSArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0ZVJhbmdlcztcbiAgfVxuICBmdW5jdGlvbiBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZFBhcnRzLCBuZXdQYXJ0cywgaW50ZXJzZWN0aW9uRm4pIHtcbiAgICBpZiAob2xkUGFydHMgJiYgbmV3UGFydHMpIHtcbiAgICAgIHZhciBkZWx0YSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2xkUGFydHMubGVuZ3RoOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBfb2xkUGFydCA9IG9sZFBhcnRzW2ldO1xuICAgICAgICB2YXIgX25ld1BhcnQgPSBuZXdQYXJ0c1tpICsgZGVsdGFdO1xuICAgICAgICBpZiAoX29sZFBhcnQgJiYgX25ld1BhcnQgJiYgX29sZFBhcnQuaW5kZXggPT09IF9uZXdQYXJ0LmluZGV4ICYmIF9vbGRQYXJ0LmZyYWdtZW50LnNuID09PSBfbmV3UGFydC5mcmFnbWVudC5zbikge1xuICAgICAgICAgIGludGVyc2VjdGlvbkZuKF9vbGRQYXJ0LCBfbmV3UGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGEtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBpbnRlcnNlY3Rpb25Gbikge1xuICAgIHZhciBza2lwcGVkU2VnbWVudHMgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cztcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sIG5ld0RldGFpbHMuc3RhcnRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gICAgdmFyIGVuZCA9IChvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IDEgOiAwKSArIChza2lwcGVkU2VnbWVudHMgPyBuZXdEZXRhaWxzLmVuZFNOIDogTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTiwgbmV3RGV0YWlscy5lbmRTTikpIC0gbmV3RGV0YWlscy5zdGFydFNOO1xuICAgIHZhciBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgICB2YXIgbmV3RnJhZ3MgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICB2YXIgb2xkRnJhZ3MgPSBvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IG9sZERldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChvbGREZXRhaWxzLmZyYWdtZW50SGludCkgOiBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIHZhciBfb2xkRnJhZyA9IG9sZEZyYWdzW2RlbHRhICsgaV07XG4gICAgICB2YXIgX25ld0ZyYWcgPSBuZXdGcmFnc1tpXTtcbiAgICAgIGlmIChza2lwcGVkU2VnbWVudHMgJiYgIV9uZXdGcmFnICYmIF9vbGRGcmFnKSB7XG4gICAgICAgIC8vIEZpbGwgaW4gc2tpcHBlZCBzZWdtZW50cyBpbiBkZWx0YSBwbGF5bGlzdFxuICAgICAgICBfbmV3RnJhZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzW2ldID0gX29sZEZyYWc7XG4gICAgICB9XG4gICAgICBpZiAoX29sZEZyYWcgJiYgX25ld0ZyYWcpIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uRm4oX29sZEZyYWcsIF9uZXdGcmFnLCBpLCBuZXdGcmFncyk7XG4gICAgICAgIHZhciB1cmlCZWZvcmUgPSBfb2xkRnJhZy5yZWx1cmw7XG4gICAgICAgIHZhciB1cmlBZnRlciA9IF9uZXdGcmFnLnJlbHVybDtcbiAgICAgICAgaWYgKHVyaUJlZm9yZSAmJiBub3RFcXVhbEFmdGVyU3RyaXBwaW5nUXVlcmllcyh1cmlCZWZvcmUsIHVyaUFmdGVyKSkge1xuICAgICAgICAgIG5ld0RldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBnZXRTZXF1ZW5jZUVycm9yKFwibWVkaWEgc2VxdWVuY2UgbWlzbWF0Y2ggXCIgKyBfbmV3RnJhZy5zbiArIFwiOlwiLCBvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBfb2xkRnJhZywgX25ld0ZyYWcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChfb2xkRnJhZy5jYyAhPT0gX25ld0ZyYWcuY2MpIHtcbiAgICAgICAgICBuZXdEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gZ2V0U2VxdWVuY2VFcnJvcihcImRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgbWlzbWF0Y2ggKFwiICsgX29sZEZyYWcuY2MgKyBcIiE9XCIgKyBfbmV3RnJhZy5jYyArIFwiKVwiLCBvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBfb2xkRnJhZywgX25ld0ZyYWcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTZXF1ZW5jZUVycm9yKG1lc3NhZ2UsIG9sZERldGFpbHMsIG5ld0RldGFpbHMsIG9sZEZyYWcsIG5ld0ZyYWcpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UgKyBcIiBcIiArIG5ld0ZyYWcudXJsICsgXCJcXG5QbGF5bGlzdCBzdGFydGluZyBAXCIgKyBvbGREZXRhaWxzLnN0YXJ0U04gKyBcIlxcblwiICsgb2xkRGV0YWlscy5tM3U4ICsgXCJcXG5cXG5QbGF5bGlzdCBzdGFydGluZyBAXCIgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyBcIlxcblwiICsgbmV3RGV0YWlscy5tM3U4KTtcbiAgfVxuICBmdW5jdGlvbiBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIG1hdGNoaW5nU3RhYmxlVmFyaWFudE9yUmVuZGl0aW9uKSB7XG4gICAgaWYgKG1hdGNoaW5nU3RhYmxlVmFyaWFudE9yUmVuZGl0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIG1hdGNoaW5nU3RhYmxlVmFyaWFudE9yUmVuZGl0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGRlbHRhID0gbmV3RGV0YWlscy5zdGFydFNOICsgbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMgLSBvbGREZXRhaWxzLnN0YXJ0U047XG4gICAgdmFyIG9sZEZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuICAgIHZhciBhZHZhbmNlZE9yU3RhYmxlID0gZGVsdGEgPj0gMDtcbiAgICB2YXIgc2xpZGluZyA9IDA7XG4gICAgaWYgKGFkdmFuY2VkT3JTdGFibGUgJiYgZGVsdGEgPCBvbGRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICBzbGlkaW5nID0gb2xkRnJhZ21lbnRzW2RlbHRhXS5zdGFydDtcbiAgICB9IGVsc2UgaWYgKGFkdmFuY2VkT3JTdGFibGUgJiYgbmV3RGV0YWlscy5zdGFydFNOID09PSBvbGREZXRhaWxzLmVuZFNOICsgMSkge1xuICAgICAgc2xpZGluZyA9IG9sZERldGFpbHMuZnJhZ21lbnRFbmQ7XG4gICAgfSBlbHNlIGlmIChhZHZhbmNlZE9yU3RhYmxlICYmIG1hdGNoaW5nU3RhYmxlVmFyaWFudE9yUmVuZGl0aW9uKSB7XG4gICAgICAvLyBhbGlnbiB3aXRoIGV4cGVjdGVkIHBvc2l0aW9uICh1cGRhdGVkIHBsYXlsaXN0IHN0YXJ0IHNlcXVlbmNlIGlzIHBhc3QgZW5kIHNlcXVlbmNlIG9mIGxhc3QgdXBkYXRlKVxuICAgICAgc2xpZGluZyA9IG9sZERldGFpbHMuZnJhZ21lbnRTdGFydCArIGRlbHRhICogbmV3RGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uO1xuICAgIH0gZWxzZSBpZiAoIW5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzICYmIG5ld0RldGFpbHMuZnJhZ21lbnRTdGFydCA9PT0gMCkge1xuICAgICAgLy8gYWxpZ24gbmV3IHN0YXJ0IHdpdGggb2xkIChwbGF5bGlzdCBzd2l0Y2ggaGFzIGEgc2VxdWVuY2Ugd2l0aCBubyBvdmVybGFwIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZm9yIGFsaWdubWVudClcbiAgICAgIHNsaWRpbmcgPSBvbGREZXRhaWxzLmZyYWdtZW50U3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5ldyBkZXRhaWxzIGFscmVhZHkgaGFzIGEgc2xpZGluZyBvZmZzZXQgb3IgaGFzIHNraXBwZWQgc2VnbWVudHNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRTbGlkaW5nKGRldGFpbHMsIHNsaWRpbmcpIHtcbiAgICBpZiAoc2xpZGluZykge1xuICAgICAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IGRldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZyYWdtZW50c1tpXS5hZGRTdGFydChzbGlkaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgICBkZXRhaWxzLmZyYWdtZW50SGludC5hZGRTdGFydChzbGlkaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsKG5ld0RldGFpbHMsIGRpc3RhbmNlVG9MaXZlRWRnZU1zKSB7XG4gICAgaWYgKGRpc3RhbmNlVG9MaXZlRWRnZU1zID09PSB2b2lkIDApIHtcbiAgICAgIGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gSW5maW5pdHk7XG4gICAgfVxuICAgIHZhciByZWxvYWRJbnRlcnZhbCA9IDEwMDAgKiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmIChuZXdEZXRhaWxzLnVwZGF0ZWQpIHtcbiAgICAgIC8vIFVzZSBsYXN0IHNlZ21lbnQgZHVyYXRpb24gd2hlbiBzaG9ydGVyIHRoYW4gdGFyZ2V0IGR1cmF0aW9uIGFuZCBuZWFyIGxpdmUgZWRnZVxuICAgICAgdmFyIGZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgdmFyIGxpdmVFZGdlTWF4VGFyZ2V0RHVyYXRpb25zID0gNDtcbiAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoICYmIHJlbG9hZEludGVydmFsICogbGl2ZUVkZ2VNYXhUYXJnZXREdXJhdGlvbnMgPiBkaXN0YW5jZVRvTGl2ZUVkZ2VNcykge1xuICAgICAgICB2YXIgbGFzdFNlZ21lbnREdXJhdGlvbiA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZHVyYXRpb24gKiAxMDAwO1xuICAgICAgICBpZiAobGFzdFNlZ21lbnREdXJhdGlvbiA8IHJlbG9hZEludGVydmFsKSB7XG4gICAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBsYXN0U2VnbWVudER1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzdGltYXRlID0gJ21pc3MgaGFsZiBhdmVyYWdlJztcbiAgICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgICByZWxvYWRJbnRlcnZhbCAvPSAyO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RnJhZ21lbnRXaXRoU04oZGV0YWlscywgc24sIGZyYWdDdXJyZW50KSB7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGZyYWdtZW50ID0gZGV0YWlscy5mcmFnbWVudHNbc24gLSBkZXRhaWxzLnN0YXJ0U05dO1xuICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cbiAgICBmcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9XG4gICAgaWYgKHNuIDwgZGV0YWlscy5zdGFydFNOICYmIGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LnNuID09PSBzbikge1xuICAgICAgcmV0dXJuIGZyYWdDdXJyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXRQYXJ0V2l0aChkZXRhaWxzLCBzbiwgcGFydEluZGV4KSB7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmRQYXJ0KGRldGFpbHMucGFydExpc3QsIHNuLCBwYXJ0SW5kZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRQYXJ0KHBhcnRMaXN0LCBzbiwgcGFydEluZGV4KSB7XG4gICAgaWYgKHBhcnRMaXN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gcGFydExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICAgIGlmIChwYXJ0LmluZGV4ID09PSBwYXJ0SW5kZXggJiYgcGFydC5mcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWFzc2lnbkZyYWdtZW50TGV2ZWxJbmRleGVzKGxldmVscykge1xuICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCwgaW5kZXgpIHtcbiAgICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICAgIChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09IG51bGwgfHwgX2xldmVsJGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgIGZyYWdtZW50LmxldmVsID0gaW5kZXg7XG4gICAgICAgIGlmIChmcmFnbWVudC5pbml0U2VnbWVudCkge1xuICAgICAgICAgIGZyYWdtZW50LmluaXRTZWdtZW50LmxldmVsID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG5vdEVxdWFsQWZ0ZXJTdHJpcHBpbmdRdWVyaWVzKHVyaUJlZm9yZSwgdXJpQWZ0ZXIpIHtcbiAgICBpZiAodXJpQmVmb3JlICE9PSB1cmlBZnRlciAmJiB1cmlBZnRlcikge1xuICAgICAgcmV0dXJuIHN0cmlwUXVlcnkodXJpQmVmb3JlKSAhPT0gc3RyaXBRdWVyeSh1cmlBZnRlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBzdHJpcFF1ZXJ5KHVyaSkge1xuICAgIHJldHVybiB1cmkucmVwbGFjZSgvXFw/W14/XSokLywgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIGNjKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIF9mcmFnbWVudHMkaTtcbiAgICAgIGlmICgoKF9mcmFnbWVudHMkaSA9IGZyYWdtZW50c1tpXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnbWVudHMkaS5jYykgPT09IGNjKSB7XG4gICAgICAgIHJldHVybiBmcmFnbWVudHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMocmVmRGV0YWlscywgZGV0YWlscykge1xuICAgIGlmIChyZWZEZXRhaWxzKSB7XG4gICAgICBpZiAoZGV0YWlscy5zdGFydENDIDwgcmVmRGV0YWlscy5lbmRDQyAmJiBkZXRhaWxzLmVuZENDID4gcmVmRGV0YWlscy5zdGFydENDKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnLCBzbGlkaW5nKSB7XG4gICAgdmFyIHN0YXJ0ID0gZnJhZy5zdGFydCArIHNsaWRpbmc7XG4gICAgZnJhZy5zdGFydFBUUyA9IHN0YXJ0O1xuICAgIGZyYWcuc2V0U3RhcnQoc3RhcnQpO1xuICAgIGZyYWcuZW5kUFRTID0gc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nLCBkZXRhaWxzKSB7XG4gICAgLy8gVXBkYXRlIHNlZ21lbnRzXG4gICAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFkanVzdEZyYWdtZW50U3RhcnQoZnJhZ21lbnRzW2ldLCBzbGlkaW5nKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIExMLUhMUyBwYXJ0cyBhdCB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdFxuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgYWRqdXN0RnJhZ21lbnRTdGFydChkZXRhaWxzLmZyYWdtZW50SGludCwgc2xpZGluZyk7XG4gICAgfVxuICAgIGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBsYXN0IGxldmVsLCB0aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIFBUUycgb2YgdGhlIG5ldyBmcmFnbWVudHMgc28gdGhhdCB0aGV5IGZvcm0gYVxuICAgKiBjb250aWd1b3VzIHN0cmVhbSB3aXRoIHRoZSBsYXN0IGZyYWdtZW50cy5cbiAgICogVGhlIFBUUyBvZiBhIGZyYWdtZW50IGxldHMgSGxzLmpzIGtub3cgd2hlcmUgaXQgZml0cyBpbnRvIGEgc3RyZWFtIC0gYnkga25vd2luZyBldmVyeSBQVFMsIHdlIGtub3cgd2hpY2ggZnJhZ21lbnQgdG9cbiAgICogZG93bmxvYWQgYXQgYW55IGdpdmVuIHRpbWUuIFBUUyBpcyBub3JtYWxseSBjb21wdXRlZCB3aGVuIHRoZSBmcmFnbWVudCBpcyBkZW11eGVkLCBzbyB0YWtpbmcgdGhpcyBzdGVwIHNhdmVzIHVzIHRpbWVcbiAgICogYW5kIGFuIGV4dHJhIGRvd25sb2FkLlxuICAgKiBAcGFyYW0gbGFzdExldmVsXG4gICAqIEBwYXJhbSBkZXRhaWxzXG4gICAqL1xuICBmdW5jdGlvbiBhbGlnblN0cmVhbShzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKSB7XG4gICAgaWYgKCFzd2l0Y2hEZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFsaWduRGlzY29udGludWl0aWVzKGRldGFpbHMsIHN3aXRjaERldGFpbHMpO1xuICAgIGlmICghZGV0YWlscy5hbGlnbmVkU2xpZGluZykge1xuICAgICAgLy8gSWYgdGhlIFBUUyB3YXNuJ3QgZmlndXJlZCBvdXQgdmlhIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdGhhdCBtZWFucyB0aGVyZSB3YXMgbm8gQ0MgaW5jcmVhc2Ugd2l0aGluIHRoZSBsZXZlbC5cbiAgICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgICAgLy8gZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAgICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKGRldGFpbHMsIHN3aXRjaERldGFpbHMpO1xuICAgIH1cbiAgICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgIWRldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICAvLyBUcnkgdG8gYWxpZ24gb24gc24gc28gdGhhdCB3ZSBwaWNrIGEgYmV0dGVyIHN0YXJ0IGZyYWdtZW50LlxuICAgICAgLy8gRG8gbm90IHBlcmZvcm0gdGhpcyBvbiBwbGF5bGlzdHMgd2l0aCBkZWx0YSB1cGRhdGVzIGFzIHRoaXMgaXMgb25seSB0byBhbGlnbiBsZXZlbHMgb24gc3dpdGNoXG4gICAgICAvLyBhbmQgYWRqdXN0U2xpZGluZyBvbmx5IGFkanVzdHMgZnJhZ21lbnRzIGFmdGVyIHNraXBwZWRTZWdtZW50cy5cbiAgICAgIGFkanVzdFNsaWRpbmcoc3dpdGNoRGV0YWlscywgZGV0YWlscywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBanVzdCB0aGUgc3RhcnQgb2YgZnJhZ21lbnRzIGluIGBkZXRhaWxzYCBieSB0aGUgZGlmZmVyZW5jZSBpbiB0aW1lIGJldHdlZW4gZnJhZ21lbnRzIG9mIHRoZSBsYXRlc3RcbiAgICogc2hhcmVkIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgY2hhbmdlLlxuICAgKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gICAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICAgKi9cbiAgZnVuY3Rpb24gYWxpZ25EaXNjb250aW51aXRpZXMoZGV0YWlscywgcmVmRGV0YWlscykge1xuICAgIGlmICghc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhyZWZEZXRhaWxzLCBkZXRhaWxzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0Q0MgPSBNYXRoLm1pbihyZWZEZXRhaWxzLmVuZENDLCBkZXRhaWxzLmVuZENDKTtcbiAgICB2YXIgcmVmRnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MocmVmRGV0YWlscy5mcmFnbWVudHMsIHRhcmdldENDKTtcbiAgICB2YXIgZnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MoZGV0YWlscy5mcmFnbWVudHMsIHRhcmdldENDKTtcbiAgICBpZiAoIXJlZkZyYWcgfHwgIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZyhcIkFsaWduaW5nIHBsYXlsaXN0IGF0IHN0YXJ0IG9mIGRpY29udGludWl0eSBzZXF1ZW5jZSBcIiArIHRhcmdldENDKTtcbiAgICB2YXIgZGVsdGEgPSByZWZGcmFnLnN0YXJ0IC0gZnJhZy5zdGFydDtcbiAgICBhZGp1c3RTbGlkaW5nU3RhcnQoZGVsdGEsIGRldGFpbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgYXBwcm9wcmlhdGUgdGltZS1hbGlnbm1lbnQgYmV0d2VlbiByZW5kaXRpb25zIGJhc2VkIG9uIFBEVC5cbiAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoZSB0aW1lbGluZXMgcmVwcmVzZW50ZWQgaW4gYHJlZkRldGFpbHNgIGFyZSBhY2N1cmF0ZSwgaW5jbHVkaW5nIHRoZSBQRFRzXG4gICAqIGZvciB0aGUgbGFzdCBkaXNjb250aW51aXR5IHNlcXVlbmNlIG51bWJlciBzaGFyZWQgYnkgYm90aCBwbGF5bGlzdHMgd2hlbiBwcmVzZW50LFxuICAgKiBhbmQgdXNlcyB0aGUgXCJ3YWxsY2xvY2tcIi9QRFQgdGltZWxpbmUgYXMgYSBjcm9zcy1yZWZlcmVuY2UgdG8gYGRldGFpbHNgLCBhZGp1c3RpbmcgdGhlIHByZXNlbnRhdGlvblxuICAgKiB0aW1lcy90aW1lbGluZXMgb2YgYGRldGFpbHNgIGFjY29yZGluZ2x5LlxuICAgKiBHaXZlbiB0aGUgYXN5bmNocm9ub3VzIG5hdHVyZSBvZiBmZXRjaGVzIGFuZCBpbml0aWFsIGxvYWRzIG9mIGxpdmUgYG1haW5gIGFuZCBhdWRpby9zdWJ0aXRsZSB0cmFja3MsXG4gICAqIHRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBlbnN1cmUgdGhlIFwibG9jYWwgdGltZWxpbmVzXCIgb2YgYXVkaW8vc3VidGl0bGUgdHJhY2tzXG4gICAqIGFyZSBhbGlnbmVkIHRvIHRoZSBtYWluL3ZpZGVvIHRpbWVsaW5lLCB1c2luZyBQRFQgYXMgdGhlIGNyb3NzLXJlZmVyZW5jZS9cImFuY2hvclwiIHRoYXQgc2hvdWxkXG4gICAqIGJlIGNvbnNpc3RlbnQgYWNyb3NzIHBsYXlsaXN0cywgcGVyIHRoZSBITFMgc3BlYy5cbiAgICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVuZGl0aW9uIHlvdSdkIGxpa2UgdG8gdGltZS1hbGlnbiAoZS5nLiBhbiBhdWRpbyByZW5kaXRpb24pLlxuICAgKiBAcGFyYW0gcmVmRGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSByZWZlcmVuY2UgcmVuZGl0aW9uIHdpdGggc3RhcnQgYW5kIFBEVCB0aW1lcyBmb3IgYWxpZ25tZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQoZGV0YWlscywgcmVmRGV0YWlscykge1xuICAgIGlmICghZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIXJlZkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgICB2YXIgcmVmRnJhZ21lbnRzID0gcmVmRGV0YWlscy5mcmFnbWVudHM7XG4gICAgaWYgKCFmcmFnbWVudHMubGVuZ3RoIHx8ICFyZWZGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGEgZGVsdGEgdG8gYXBwbHkgdG8gYWxsIGZyYWdtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGRlbHRhIGluIFBEVCB0aW1lcyBhbmQgc3RhcnQgdGltZXNcbiAgICAvLyBvZiBhIGZyYWdtZW50IGluIHRoZSByZWZlcmVuY2UgZGV0YWlscywgYW5kIGEgZnJhZ21lbnQgaW4gdGhlIHRhcmdldCBkZXRhaWxzIG9mIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkuXG4gICAgLy8gSWYgYSBmcmFnbWVudCBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5IHdhcyBub3QgZm91bmQgdXNlIHRoZSBtaWRkbGUgZnJhZ21lbnQgb2YgYm90aC5cbiAgICB2YXIgcmVmRnJhZztcbiAgICB2YXIgZnJhZztcbiAgICB2YXIgdGFyZ2V0Q0MgPSBNYXRoLm1pbihyZWZEZXRhaWxzLmVuZENDLCBkZXRhaWxzLmVuZENDKTtcbiAgICBpZiAocmVmRGV0YWlscy5zdGFydENDIDwgdGFyZ2V0Q0MgJiYgZGV0YWlscy5zdGFydENDIDwgdGFyZ2V0Q0MpIHtcbiAgICAgIHJlZkZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKHJlZkZyYWdtZW50cywgdGFyZ2V0Q0MpO1xuICAgICAgZnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCB0YXJnZXRDQyk7XG4gICAgfVxuICAgIGlmICghcmVmRnJhZyB8fCAhZnJhZykge1xuICAgICAgcmVmRnJhZyA9IHJlZkZyYWdtZW50c1tNYXRoLmZsb29yKHJlZkZyYWdtZW50cy5sZW5ndGggLyAyKV07XG4gICAgICBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIHJlZkZyYWcuY2MpIHx8IGZyYWdtZW50c1tNYXRoLmZsb29yKGZyYWdtZW50cy5sZW5ndGggLyAyKV07XG4gICAgfVxuICAgIHZhciByZWZQRFQgPSByZWZGcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgICB2YXIgdGFyZ2V0UERUID0gZnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgaWYgKCFyZWZQRFQgfHwgIXRhcmdldFBEVCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGVsdGEgPSAodGFyZ2V0UERUIC0gcmVmUERUKSAvIDEwMDAgLSAoZnJhZy5zdGFydCAtIHJlZkZyYWcuc3RhcnQpO1xuICAgIGFkanVzdFNsaWRpbmdTdGFydChkZWx0YSwgZGV0YWlscyk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqICBUaW1lUmFuZ2VzIHRvIHN0cmluZyBoZWxwZXJcbiAgICovXG5cbiAgdmFyIFRpbWVSYW5nZXMgPSB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKHIpIHtcbiAgICAgIHZhciBsb2cgPSAnJztcbiAgICAgIHZhciBsZW4gPSByLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbG9nICs9IFwiW1wiICsgci5zdGFydChpKS50b0ZpeGVkKDMpICsgXCItXCIgKyByLmVuZChpKS50b0ZpeGVkKDMpICsgXCJdXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nO1xuICAgIH1cbiAgfTtcblxuICB2YXIgU3RhdGUgPSB7XG4gICAgU1RPUFBFRDogJ1NUT1BQRUQnLFxuICAgIElETEU6ICdJRExFJyxcbiAgICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnLFxuICAgIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICAgIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgICBQQVJTSU5HOiAnUEFSU0lORycsXG4gICAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgICBFTkRFRDogJ0VOREVEJyxcbiAgICBFUlJPUjogJ0VSUk9SJyxcbiAgICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gICAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnXG4gIH07XG4gIHZhciBCYXNlU3RyZWFtQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Rhc2tMb29wKSB7XG4gICAgZnVuY3Rpb24gQmFzZVN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgbG9nUHJlZml4LCBwbGF5bGlzdFR5cGUpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX1Rhc2tMb29wLmNhbGwodGhpcywgbG9nUHJlZml4LCBobHMubG9nZ2VyKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgX3RoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgIF90aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgIF90aGlzLmZyYWdtZW50VHJhY2tlciA9IHZvaWQgMDtcbiAgICAgIF90aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgX3RoaXMuX3N0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICAgIF90aGlzLnBsYXlsaXN0VHlwZSA9IHZvaWQgMDtcbiAgICAgIF90aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIF90aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICAgIF90aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICAgIF90aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICBfdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgICAgX3RoaXMubmV4dExvYWRQb3NpdGlvbiA9IDA7XG4gICAgICBfdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgIF90aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgICBfdGhpcy5yZXRyeURhdGUgPSAwO1xuICAgICAgX3RoaXMubGV2ZWxzID0gbnVsbDtcbiAgICAgIF90aGlzLmZyYWdtZW50TG9hZGVyID0gdm9pZCAwO1xuICAgICAgX3RoaXMua2V5TG9hZGVyID0gdm9pZCAwO1xuICAgICAgX3RoaXMubGV2ZWxMYXN0TG9hZGVkID0gbnVsbDtcbiAgICAgIF90aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgICAgX3RoaXMuaW5pdFBUUyA9IFtdO1xuICAgICAgX3RoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgIF90aGlzLmxvYWRpbmdQYXJ0cyA9IGZhbHNlO1xuICAgICAgX3RoaXMubG9vcFNuID0gdm9pZCAwO1xuICAgICAgX3RoaXMub25NZWRpYVNlZWtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSBfdGhpcyxcbiAgICAgICAgICBjb25maWcgPSBfdGhpczIuY29uZmlnLFxuICAgICAgICAgIGZyYWdDdXJyZW50ID0gX3RoaXMyLmZyYWdDdXJyZW50LFxuICAgICAgICAgIG1lZGlhID0gX3RoaXMyLm1lZGlhLFxuICAgICAgICAgIG1lZGlhQnVmZmVyID0gX3RoaXMyLm1lZGlhQnVmZmVyLFxuICAgICAgICAgIHN0YXRlID0gX3RoaXMyLnN0YXRlO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogMDtcbiAgICAgICAgdmFyIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYUJ1ZmZlciA/IG1lZGlhQnVmZmVyIDogbWVkaWEsIGN1cnJlbnRUaW1lLCBjb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgICAgIHZhciBub0Zvd2FyZEJ1ZmZlciA9ICFidWZmZXJJbmZvLmxlbjtcbiAgICAgICAgX3RoaXMubG9nKFwiTWVkaWEgc2Vla2luZyB0byBcIiArIChpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkgPyBjdXJyZW50VGltZS50b0ZpeGVkKDMpIDogY3VycmVudFRpbWUpICsgXCIsIHN0YXRlOiBcIiArIHN0YXRlICsgXCIsIFwiICsgKG5vRm93YXJkQnVmZmVyID8gJ291dCBvZicgOiAnaW4nKSArIFwiIGJ1ZmZlclwiKTtcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgICAgIF90aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICAvLyBTZWVraW5nIHdoaWxlIGZyYWcgbG9hZCBpcyBpbiBwcm9ncmVzc1xuICAgICAgICAgIHZhciB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgICB2YXIgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICAgICAgdmFyIGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgICAgIC8vIGlmIHNlZWtpbmcgb3V0IG9mIGJ1ZmZlcmVkIHJhbmdlIG9yIGludG8gbmV3IG9uZVxuICAgICAgICAgIGlmIChub0Zvd2FyZEJ1ZmZlciB8fCBmcmFnRW5kT2Zmc2V0IDwgYnVmZmVySW5mby5zdGFydCB8fCBmcmFnU3RhcnRPZmZzZXQgPiBidWZmZXJJbmZvLmVuZCkge1xuICAgICAgICAgICAgdmFyIHBhc3RGcmFnbWVudCA9IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldDtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzZWVrIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGN1cnJlbnQgZnJhZ21lbnQgcmFuZ2VcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBwYXN0RnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhc3RGcmFnbWVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2coXCJDYW5jZWxsaW5nIGZyYWdtZW50IGxvYWQgZm9yIHNlZWsgKHNuOiBcIiArIGZyYWdDdXJyZW50LnNuICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgIC8vIFJlbW92ZSBnYXAgZnJhZ21lbnRzXG4gICAgICAgICAgX3RoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoY3VycmVudFRpbWUsIEluZmluaXR5LCBfdGhpcy5wbGF5bGlzdFR5cGUsIHRydWUpO1xuXG4gICAgICAgICAgLy8gRG9uJ3Qgc2V0IGxhc3RDdXJyZW50VGltZSB3aXRoIGJhY2t3YXJkIHNlZWtzIChhbGxvd3MgZm9yIGZyYWcgc2VsZWN0aW9uIHdpdGggc3RyaWN0IHRvbGVyYW5jZXMpXG4gICAgICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IF90aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPiBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIF90aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV90aGlzLmxvYWRpbmdQYXJ0cykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlckVuZCA9IE1hdGgubWF4KGJ1ZmZlckluZm8uZW5kLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkTG9hZFBhcnRzID0gX3RoaXMuc2hvdWxkTG9hZFBhcnRzKF90aGlzLmdldExldmVsRGV0YWlscygpLCBidWZmZXJFbmQpO1xuICAgICAgICAgICAgaWYgKHNob3VsZExvYWRQYXJ0cykge1xuICAgICAgICAgICAgICBfdGhpcy5sb2coXCJMTC1QYXJ0IGxvYWRpbmcgT04gYWZ0ZXIgc2Vla2luZyB0byBcIiArIGN1cnJlbnRUaW1lLnRvRml4ZWQoMikgKyBcIiB3aXRoIGJ1ZmZlciBAXCIgKyBidWZmZXJFbmQudG9GaXhlZCgyKSk7XG4gICAgICAgICAgICAgIF90aGlzLmxvYWRpbmdQYXJ0cyA9IHNob3VsZExvYWRQYXJ0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxuICAgICAgICBpZiAoIV90aGlzLmhscy5oYXNFbm91Z2hUb1N0YXJ0KSB7XG4gICAgICAgICAgX3RoaXMubG9nKFwiU2V0dGluZyBcIiArIChub0Zvd2FyZEJ1ZmZlciA/ICdzdGFydFBvc2l0aW9uJyA6ICduZXh0TG9hZFBvc2l0aW9uJykgKyBcIiB0byBcIiArIGN1cnJlbnRUaW1lICsgXCIgZm9yIHNlZWsgd2l0aG91dCBlbm91Z2ggdG8gc3RhcnRcIik7XG4gICAgICAgICAgX3RoaXMubmV4dExvYWRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgIGlmIChub0Zvd2FyZEJ1ZmZlcikge1xuICAgICAgICAgICAgX3RoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9Gb3dhcmRCdWZmZXIgJiYgX3RoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgICAgICAvLyBBc3luYyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICAgICAgICBfdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy5vbk1lZGlhRW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgICAgICBfdGhpcy5sb2coXCJzZXR0aW5nIHN0YXJ0UG9zaXRpb24gdG8gMCBiZWNhdXNlIG1lZGlhIGVuZGVkXCIpO1xuICAgICAgICBfdGhpcy5zdGFydFBvc2l0aW9uID0gX3RoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICAgIH07XG4gICAgICBfdGhpcy5wbGF5bGlzdFR5cGUgPSBwbGF5bGlzdFR5cGU7XG4gICAgICBfdGhpcy5obHMgPSBobHM7XG4gICAgICBfdGhpcy5mcmFnbWVudExvYWRlciA9IG5ldyBGcmFnbWVudExvYWRlcihobHMuY29uZmlnKTtcbiAgICAgIF90aGlzLmtleUxvYWRlciA9IGtleUxvYWRlcjtcbiAgICAgIF90aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICBfdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKGhscy5jb25maWcpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHNMb29zZShCYXNlU3RyZWFtQ29udHJvbGxlciwgX1Rhc2tMb29wKTtcbiAgICB2YXIgX3Byb3RvID0gQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZG9UaWNrID0gZnVuY3Rpb24gZG9UaWNrKCkge1xuICAgICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgICB9O1xuICAgIF9wcm90by5vblRpY2tFbmQgPSBmdW5jdGlvbiBvblRpY2tFbmQoKSB7fTtcbiAgICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9O1xuICAgIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnbWVudExvYWRlci5hYm9ydCgpO1xuICAgICAgdGhpcy5rZXlMb2FkZXIuYWJvcnQodGhpcy5wbGF5bGlzdFR5cGUpO1xuICAgICAgdmFyIGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgaWYgKGZyYWcgIT0gbnVsbCAmJiBmcmFnLmxvYWRlcikge1xuICAgICAgICBmcmFnLmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucGF1c2VCdWZmZXJpbmcgPSBmdW5jdGlvbiBwYXVzZUJ1ZmZlcmluZygpIHtcbiAgICAgIHRoaXMuYnVmZmVyaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzdW1lQnVmZmVyaW5nID0gZnVuY3Rpb24gcmVzdW1lQnVmZmVyaW5nKCkge1xuICAgICAgdGhpcy5idWZmZXJpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLl9zdHJlYW1FbmRlZCA9IGZ1bmN0aW9uIF9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICAgIC8vIFN0cmVhbSBpcyBuZXZlciBcImVuZGVkXCIgd2hlbiBwbGF5bGlzdCBpcyBsaXZlIG9yIG1lZGlhIGlzIGRldGFjaGVkXG4gICAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gU3RyZWFtIGlzIG5vdCBcImVuZGVkXCIgd2hlbiBub3RoaW5nIGlzIGJ1ZmZlcmVkIHBhc3QgdGhlIHN0YXJ0XG4gICAgICB2YXIgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQgfHwgMDtcbiAgICAgIHZhciB0aW1lbGluZVN0YXJ0ID0gdGhpcy5jb25maWcudGltZWxpbmVPZmZzZXQgfHwgMDtcbiAgICAgIGlmIChidWZmZXJFbmQgPD0gdGltZWxpbmVTdGFydCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBTdHJlYW0gaXMgbm90IFwiZW5kZWRcIiB3aGVuIHRoZXJlIGlzIGEgc2Vjb25kIGJ1ZmZlcmVkIHJhbmdlIHN0YXJ0aW5nIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdFxuICAgICAgdmFyIGJ1ZmZlcmVkUmFuZ2VzID0gYnVmZmVySW5mby5idWZmZXJlZDtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlICYmIGJ1ZmZlcmVkUmFuZ2VzICYmIGJ1ZmZlcmVkUmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGJ1ZmZlckluZm8gYWNjb3VudHMgZm9yIGFueSBnYXBzXG4gICAgICAgIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkUmFuZ2VzLCBidWZmZXJJbmZvLnN0YXJ0LCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0U3RhcnQgPSBidWZmZXJJbmZvLm5leHRTdGFydDtcbiAgICAgIHZhciBoYXNTZWNvbmRCdWZmZXJlZFJhbmdlID0gbmV4dFN0YXJ0ICYmIG5leHRTdGFydCA+IHRpbWVsaW5lU3RhcnQgJiYgbmV4dFN0YXJ0IDwgbGV2ZWxEZXRhaWxzLmVkZ2U7XG4gICAgICBpZiAoaGFzU2Vjb25kQnVmZmVyZWRSYW5nZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBQbGF5aGVhZCBpcyBpbiB1bmJ1ZmZlcmVkIHJlZ2lvbi4gTWFya2luZyBFb1Mgbm93IGNvdWxkIHJlc3VsdCBpbiBTYWZhcmkgZmFpbGluZyB0byBkaXNwYXRjaCBcImVuZGVkXCIgZXZlbnQgZm9sbG93aW5nIHNlZWsgb24gc3RhcnQuXG4gICAgICBpZiAodGhpcy5tZWRpYS5jdXJyZW50VGltZSA8IGJ1ZmZlckluZm8uc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuICAgICAgLy8gU2luY2UgdGhlIGxhc3QgcGFydCBpc24ndCBndWFyYW50ZWVkIHRvIGNvcnJlc3BvbmQgdG8gdGhlIGxhc3QgcGxheWxpc3Qgc2VnbWVudCBmb3IgTG93LUxhdGVuY3kgSExTLFxuICAgICAgLy8gY2hlY2sgaW5zdGVhZCBpZiB0aGUgbGFzdCBwYXJ0IGlzIGJ1ZmZlcmVkLlxuICAgICAgaWYgKHBhcnRMaXN0ICE9IG51bGwgJiYgcGFydExpc3QubGVuZ3RoKSB7XG4gICAgICAgIHZhciBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIC8vIENoZWNraW5nIHRoZSBtaWRwb2ludCBvZiB0aGUgcGFydCBmb3IgcG90ZW50aWFsIG1hcmdpbiBvZiBlcnJvciBhbmQgcmVsYXRlZCBpc3N1ZXMuXG4gICAgICAgIC8vIE5PVEU6IFRlY2huaWNhbGx5IEkgYmVsaWV2ZSBwYXJ0cyBjb3VsZCB5aWVsZCBjb250ZW50IHRoYXQgaXMgPCB0aGUgY29tcHV0ZWQgZHVyYXRpb24gKGluY2x1ZGluZyBwb3RlbnRpYWwgYSBkdXJhdGlvbiBvZiAwKVxuICAgICAgICAvLyBhbmQgc3RpbGwgYmUgc3BlYy1jb21wbGlhbnQsIHNvIHRoZXJlIG1heSBzdGlsbCBiZSBlZGdlIGNhc2VzIGhlcmUuIExpa2V3aXNlLCB0aGVyZSBjb3VsZCBiZSBpc3N1ZXMgaW4gZW5kIG9mIHN0cmVhbVxuICAgICAgICAvLyBwYXJ0IG1pc21hdGNoZXMgZm9yIGluZGVwZW5kZW50IGF1ZGlvIGFuZCB2aWRlbyBwbGF5bGlzdHMvc2VnbWVudHMuXG4gICAgICAgIHZhciBsYXN0UGFydEJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgbGFzdFBhcnQuc3RhcnQgKyBsYXN0UGFydC5kdXJhdGlvbiAvIDIpO1xuICAgICAgICByZXR1cm4gbGFzdFBhcnRCdWZmZXJlZDtcbiAgICAgIH1cbiAgICAgIHZhciBwbGF5bGlzdFR5cGUgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2xldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV0udHlwZTtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5pc0VuZExpc3RBcHBlbmRlZChwbGF5bGlzdFR5cGUpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldExldmVsRGV0YWlscyA9IGZ1bmN0aW9uIGdldExldmVsRGV0YWlscygpIHtcbiAgICAgIGlmICh0aGlzLmxldmVscyAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbExhc3RMb2FkZWQuZGV0YWlscztcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdzZWVraW5nJywgdGhpcy5vbk1lZGlhU2Vla2luZyk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAnZW5kZWQnLCB0aGlzLm9uTWVkaWFFbmRlZCk7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICBpZiAodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciB0cmFuc2ZlcnJpbmdNZWRpYSA9ICEhZGF0YS50cmFuc2Zlck1lZGlhO1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEuZW5kZWQpIHtcbiAgICAgICAgdGhpcy5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3NlZWtpbmcnLCB0aGlzLm9uTWVkaWFTZWVraW5nKTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICdlbmRlZCcsIHRoaXMub25NZWRpYUVuZGVkKTtcbiAgICAgIGlmICh0aGlzLmtleUxvYWRlciAmJiAhdHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgICAgdGhpcy5rZXlMb2FkZXIuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgICB0aGlzLmxvb3BTbiA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0cmFuc2ZlcnJpbmdNZWRpYSkge1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZGluZ1BhcnRzID0gZmFsc2U7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgICB0aGlzLmxldmVscyA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7fTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gZGF0YS5zdGFydFRpbWVPZmZzZXQ7XG4gICAgfTtcbiAgICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICBpZiAodGhpcy50cmFuc211eGVyKSB7XG4gICAgICAgIHRoaXMudHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgICBfVGFza0xvb3AucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3lpbmcuY2FsbCh0aGlzKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gdGhpcy5vbk1lZGlhU2Vla2luZyA9IHRoaXMub25NZWRpYUVuZGVkID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5vbkhhbmRsZXJEZXN0cm95ZWQgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICAgIGlmICh0aGlzLmZyYWdtZW50TG9hZGVyKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2V5TG9hZGVyKSB7XG4gICAgICAgIHRoaXMua2V5TG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRlY3J5cHRlcikge1xuICAgICAgICB0aGlzLmRlY3J5cHRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhscyA9IHRoaXMubG9nID0gdGhpcy53YXJuID0gdGhpcy5kZWNyeXB0ZXIgPSB0aGlzLmtleUxvYWRlciA9IHRoaXMuZnJhZ21lbnRMb2FkZXIgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gICAgICBfVGFza0xvb3AucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3llZC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRGcmFnbWVudCA9IGZ1bmN0aW9uIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2xvYWRGcmFnRm9yUGxheWJhY2sgPSBmdW5jdGlvbiBfbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnbWVudCwgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIHByb2dyZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbiBwcm9ncmVzc0NhbGxiYWNrKGRhdGEpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAgIGlmIChfdGhpczMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgICAgX3RoaXMzLndhcm4oZnJhZy50eXBlICsgXCIgc246IFwiICsgZnJhZy5zbiArIChkYXRhLnBhcnQgPyAnIHBhcnQ6ICcgKyBkYXRhLnBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBcIiArIF90aGlzMy5mcmFnSW5mbyhmcmFnLCBmYWxzZSwgZGF0YS5wYXJ0KSArIFwiKSB3YXMgZHJvcHBlZCBkdXJpbmcgZG93bmxvYWQuXCIpO1xuICAgICAgICAgIF90aGlzMy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCsrO1xuICAgICAgICBfdGhpczMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZ21lbnQsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lLCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUgd2UgcHJvYmFibHkgbmVlZGVkIHRvIGJhY2t0cmFjayBvciBhcmUgd2FpdGluZyBmb3IgbW9yZSBwYXJ0c1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSBfdGhpczMuc3RhdGU7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICBpZiAoX3RoaXMzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HIHx8ICFfdGhpczMuZnJhZ0N1cnJlbnQgJiYgc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICAgIF90aGlzMy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgICBfdGhpczMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdwYXlsb2FkJyBpbiBkYXRhKSB7XG4gICAgICAgICAgX3RoaXMzLmxvZyhcIkxvYWRlZCBcIiArIGZyYWcudHlwZSArIFwiIHNuOiBcIiArIGZyYWcuc24gKyBcIiBvZiBcIiArIF90aGlzMy5wbGF5bGlzdExhYmVsKCkgKyBcIiBcIiArIGZyYWcubGV2ZWwpO1xuICAgICAgICAgIF90aGlzMy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRoZSB3aG9sZSBwYXlsb2FkOyBjb250cm9sbGVycyBub3QgaW1wbGVtZW50aW5nIHByb2dyZXNzaXZlIGxvYWRpbmcgcmVjZWl2ZSBkYXRhIGZyb20gdGhpcyBjYWxsYmFja1xuICAgICAgICBfdGhpczMuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAoX3RoaXMzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEIHx8IF90aGlzMy5zdGF0ZSA9PT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMzLndhcm4oXCJGcmFnIGVycm9yOiBcIiArICgocmVhc29uID09IG51bGwgPyB2b2lkIDAgOiByZWFzb24ubWVzc2FnZSkgfHwgcmVhc29uKSk7XG4gICAgICAgIF90aGlzMy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnbWVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5jbGVhclRyYWNrZXJJZk5lZWRlZCA9IGZ1bmN0aW9uIGNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpIHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYUJ1ZmZlcjtcbiAgICAgIHZhciBmcmFnbWVudFRyYWNrZXIgPSB0aGlzLmZyYWdtZW50VHJhY2tlcjtcbiAgICAgIHZhciBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgICBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLkFQUEVORElORykge1xuICAgICAgICAvLyBMb3dlciB0aGUgbWF4IGJ1ZmZlciBsZW5ndGggYW5kIHRyeSBhZ2FpblxuICAgICAgICB2YXIgcGxheWxpc3RUeXBlID0gZnJhZy50eXBlO1xuICAgICAgICB2YXIgYnVmZmVyZWRJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHBsYXlsaXN0VHlwZSk7XG4gICAgICAgIHZhciBtaW5Gb3J3YXJkQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoZnJhZy5kdXJhdGlvbiwgYnVmZmVyZWRJbmZvID8gYnVmZmVyZWRJbmZvLmxlbiA6IHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgIC8vIElmIGJhY2t0cmFja2luZywgYWx3YXlzIHJlbW92ZSBmcm9tIHRoZSB0cmFja2VyIHdpdGhvdXQgcmVkdWNpbmcgbWF4IGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgdmFyIGJhY2t0cmFja0ZyYWdtZW50ID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudDtcbiAgICAgICAgdmFyIGJhY2t0cmFja2VkID0gYmFja3RyYWNrRnJhZ21lbnQgPyBmcmFnLnNuIC0gYmFja3RyYWNrRnJhZ21lbnQuc24gOiAwO1xuICAgICAgICBpZiAoYmFja3RyYWNrZWQgPT09IDEgfHwgdGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgobWluRm9yd2FyZEJ1ZmZlckxlbmd0aCwgZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKChfdGhpcyRtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYUJ1ZmZlci5idWZmZXJlZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgIC8vIFN0b3AgZ2FwIGZvciBiYWQgdHJhY2tlciAvIGJ1ZmZlciBmbHVzaCBiZWhhdmlvclxuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgICB9IGVsc2UgaWYgKGZyYWdtZW50VHJhY2tlci5oYXNQYXJ0cyhmcmFnLnR5cGUpKSB7XG4gICAgICAgIC8vIEluIGxvdyBsYXRlbmN5IG1vZGUsIHJlbW92ZSBmcmFnbWVudHMgZm9yIHdoaWNoIG9ubHkgc29tZSBwYXJ0cyB3ZXJlIGJ1ZmZlcmVkXG4gICAgICAgIGZyYWdtZW50VHJhY2tlci5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKHtcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgc3RhdHM6IGZyYWcuc3RhdHMsXG4gICAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tMaXZlVXBkYXRlID0gZnVuY3Rpb24gY2hlY2tMaXZlVXBkYXRlKGRldGFpbHMpIHtcbiAgICAgIGlmIChkZXRhaWxzLnVwZGF0ZWQgJiYgIWRldGFpbHMubGl2ZSkge1xuICAgICAgICAvLyBMaXZlIHN0cmVhbSBlbmRlZCwgdXBkYXRlIGZyYWdtZW50IHRyYWNrZXJcbiAgICAgICAgdmFyIGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKHtcbiAgICAgICAgICBmcmFnOiBsYXN0RnJhZ21lbnQsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBzdGF0czogbGFzdEZyYWdtZW50LnN0YXRzLFxuICAgICAgICAgIGlkOiBsYXN0RnJhZ21lbnQudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghZGV0YWlscy5mcmFnbWVudHNbMF0pIHtcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ud2FpdEZvckxpdmUgPSBmdW5jdGlvbiB3YWl0Rm9yTGl2ZShsZXZlbEluZm8pIHtcbiAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICByZXR1cm4gKGRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGRldGFpbHMubGl2ZSkgJiYgZGV0YWlscy50eXBlICE9PSAnRVZFTlQnICYmICh0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWxJbmZvIHx8IGRldGFpbHMuZXhwaXJlZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2hNYWluQnVmZmVyID0gZnVuY3Rpb24gZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIShzdGFydE9mZnNldCAtIGVuZE9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gV2hlbiBhbHRlcm5hdGUgYXVkaW8gaXMgcGxheWluZywgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgYXVkaW8gYnVmZmVyLiBPdGhlcndpc2UsXG4gICAgICAvLyBwYXNzaW5nIGEgbnVsbCB0eXBlIGZsdXNoZXMgYm90aCBidWZmZXJzXG4gICAgICB2YXIgZmx1c2hTY29wZSA9IHtcbiAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRPZmZzZXQ6IGVuZE9mZnNldCxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2xvYWRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIF9sb2FkSW5pdFNlZ21lbnQoZnJhZ21lbnQsIGxldmVsKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZ21lbnQsIGxldmVsKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5mcmFnO1xuICAgICAgICBpZiAoIWZyYWcgfHwgX3RoaXM0LmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhX3RoaXM0LmxldmVscykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGhscyA9IF90aGlzNC5obHM7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgICAgIHZhciBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuICAgICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGlzRnVsbFNlZ21lbnRFbmNyeXB0aW9uKGRlY3J5cHREYXRhLm1ldGhvZCkpIHtcbiAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAvLyBkZWNyeXB0IGluaXQgc2VnbWVudCBkYXRhXG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5kZWNyeXB0ZXIuZGVjcnlwdChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyLCBnZXRBZXNNb2RlRnJvbUZ1bGxTZWdtZW50TWV0aG9kKGRlY3J5cHREYXRhLm1ldGhvZCkpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgIHJlYXNvbjogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZyYWc6IGZyYWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICAgIHZhciBlbmRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICAgIHRzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIHRkZWNyeXB0OiBlbmRUaW1lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkID0gZGVjcnlwdGVkRGF0YTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczQuY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzNC5jb21wbGV0ZUluaXRTZWdtZW50TG9hZChkYXRhKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKF90aGlzNC5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCBfdGhpczQuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzNC53YXJuKHJlYXNvbik7XG4gICAgICAgIF90aGlzNC5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnbWVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5jb21wbGV0ZUluaXRTZWdtZW50TG9hZCA9IGZ1bmN0aW9uIGNvbXBsZXRlSW5pdFNlZ21lbnRMb2FkKGRhdGEpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWxzJyk7XG4gICAgICB9XG4gICAgICB2YXIgc3RhdHMgPSBkYXRhLmZyYWcuc3RhdHM7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIGRhdGEuZnJhZy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5wYXlsb2FkKTtcbiAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgX3Byb3RvLnVuaGFuZGxlZEVuY3J5cHRpb25FcnJvciA9IGZ1bmN0aW9uIHVuaGFuZGxlZEVuY3J5cHRpb25FcnJvcihpbml0U2VnbWVudCwgZnJhZykge1xuICAgICAgdmFyIF90cmFja3MkYXVkaW8sIF90cmFja3MkdmlkZW87XG4gICAgICB2YXIgdHJhY2tzID0gaW5pdFNlZ21lbnQudHJhY2tzO1xuICAgICAgaWYgKHRyYWNrcyAmJiAhZnJhZy5lbmNyeXB0ZWQgJiYgKChfdHJhY2tzJGF1ZGlvID0gdHJhY2tzLmF1ZGlvKSAhPSBudWxsICYmIF90cmFja3MkYXVkaW8uZW5jcnlwdGVkIHx8IChfdHJhY2tzJHZpZGVvID0gdHJhY2tzLnZpZGVvKSAhPSBudWxsICYmIF90cmFja3MkdmlkZW8uZW5jcnlwdGVkKSAmJiAoIXRoaXMuY29uZmlnLmVtZUVuYWJsZWQgfHwgIXRoaXMua2V5TG9hZGVyLmVtZUNvbnRyb2xsZXIpKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkVuY3J5cHRlZCB0cmFjayB3aXRoIG5vIGtleSBpbiBcIiArIHRoaXMuZnJhZ0luZm8oZnJhZykgKyBcIiAobWVkaWEgXCIgKyAobWVkaWEgPyAnYXR0YWNoZWQgbWVkaWFLZXlzOiAnICsgbWVkaWEubWVkaWFLZXlzIDogJ2RldGFjaGVkJykgKyBcIilcIiApO1xuICAgICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIC8vIElnbm9yZSBpZiBtZWRpYSBpcyBkZXRhY2hlZCBvciBtZWRpYUtleXMgYXJlIHNldFxuICAgICAgICBpZiAoIW1lZGlhIHx8IG1lZGlhLm1lZGlhS2V5cykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgZnJhZzogZnJhZ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJhZ0NvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpIHtcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICByZXR1cm4gIWZyYWcgfHwgIWZyYWdDdXJyZW50IHx8IGZyYWcuc24gIT09IGZyYWdDdXJyZW50LnNuIHx8IGZyYWcubGV2ZWwgIT09IGZyYWdDdXJyZW50LmxldmVsO1xuICAgIH07XG4gICAgX3Byb3RvLmZyYWdCdWZmZXJlZENvbXBsZXRlID0gZnVuY3Rpb24gZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgdGhpcy5sb2coXCJCdWZmZXJlZCBcIiArIGZyYWcudHlwZSArIFwiIHNuOiBcIiArIGZyYWcuc24gKyAocGFydCA/ICcgcGFydDogJyArIHBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBcIiArIHRoaXMuZnJhZ0luZm8oZnJhZywgZmFsc2UsIHBhcnQpICsgXCIgPiBidWZmZXI6XCIgKyAobWVkaWEgPyBUaW1lUmFuZ2VzLnRvU3RyaW5nKEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkpIDogJyhkZXRhY2hlZCknKSArIFwiKVwiKTtcbiAgICAgIGlmIChpc01lZGlhRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgICAgdmFyIF90aGlzJGxldmVscztcbiAgICAgICAgaWYgKGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgICAgICB2YXIgZWwgPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZWwpLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWVsW3R5cGVdO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBzZWdtZW50XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsID0gKF90aGlzJGxldmVscyA9IHRoaXMubGV2ZWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgICBpZiAobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5mcmFnbWVudEVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJSZXNldHRpbmcgbGV2ZWwgZnJhZ21lbnQgZXJyb3IgY291bnQgb2YgXCIgKyBsZXZlbC5mcmFnbWVudEVycm9yICsgXCIgb24gZnJhZyBidWZmZXJlZFwiKTtcbiAgICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfTtcbiAgICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWRFbmREYXRhKSB7XG4gICAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZnJhZyA9IGZyYWdMb2FkZWRFbmREYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBmcmFnTG9hZGVkRW5kRGF0YS5wYXJ0LFxuICAgICAgICBwYXJ0c0xvYWRlZCA9IGZyYWdMb2FkZWRFbmREYXRhLnBhcnRzTG9hZGVkO1xuICAgICAgLy8gSWYgd2UgZGlkIG5vdCBsb2FkIHBhcnRzLCBvciBsb2FkZWQgYWxsIHBhcnRzLCB3ZSBoYXZlIGNvbXBsZXRlIChub3QgcGFydGlhbCkgZnJhZ21lbnQgZGF0YVxuICAgICAgdmFyIGNvbXBsZXRlID0gIXBhcnRzTG9hZGVkIHx8IHBhcnRzTG9hZGVkLmxlbmd0aCA9PT0gMCB8fCBwYXJ0c0xvYWRlZC5zb21lKGZ1bmN0aW9uIChmcmFnTG9hZGVkKSB7XG4gICAgICAgIHJldHVybiAhZnJhZ0xvYWRlZDtcbiAgICAgIH0pO1xuICAgICAgdmFyIGNodW5rTWV0YSA9IG5ldyBDaHVua01ldGFkYXRhKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCArIDEsIDAsIHBhcnQgPyBwYXJ0LmluZGV4IDogLTEsICFjb21wbGV0ZSk7XG4gICAgICB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGZyYWcpIHt9O1xuICAgIF9wcm90by5fZG9GcmFnTG9hZCA9IGZ1bmN0aW9uIF9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICB2YXIgX2ZyYWckZGVjcnlwdGRhdGEsXG4gICAgICAgIF90aGlzNSA9IHRoaXM7XG4gICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICB2YXIgZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICBpZiAoIXRoaXMubGV2ZWxzIHx8ICFkZXRhaWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZyYWcgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVsXCIgKyAoZGV0YWlscyA/ICcnIDogJyBkZXRhaWwnKSArIFwic1wiKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlMb2FkaW5nUHJvbWlzZSA9IG51bGw7XG4gICAgICBpZiAoZnJhZy5lbmNyeXB0ZWQgJiYgISgoX2ZyYWckZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhKSAhPSBudWxsICYmIF9mcmFnJGRlY3J5cHRkYXRhLmtleSkpIHtcbiAgICAgICAgdGhpcy5sb2coXCJMb2FkaW5nIGtleSBmb3IgXCIgKyBmcmFnLnNuICsgXCIgb2YgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdLCBcIiArIHRoaXMucGxheWxpc3RMYWJlbCgpICsgXCIgXCIgKyBmcmFnLmxldmVsKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSB0aGlzLmtleUxvYWRlci5sb2FkKGZyYWcpLnRoZW4oZnVuY3Rpb24gKGtleUxvYWRlZERhdGEpIHtcbiAgICAgICAgICBpZiAoIV90aGlzNS5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YS5mcmFnKSkge1xuICAgICAgICAgICAgX3RoaXM1Lmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BREVELCBrZXlMb2FkZWREYXRhKTtcbiAgICAgICAgICAgIGlmIChfdGhpczUuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgICAgICAgIF90aGlzNS5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5TG9hZGVkRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BRElORywge1xuICAgICAgICAgIGZyYWc6IGZyYWdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJjb250ZXh0IGNoYW5nZWQgaW4gS0VZX0xPQURJTkdcIik7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghZnJhZy5lbmNyeXB0ZWQpIHtcbiAgICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSB0aGlzLmtleUxvYWRlci5sb2FkQ2xlYXIoZnJhZywgZGV0YWlscy5lbmNyeXB0ZWRGcmFnbWVudHMsIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKTtcbiAgICAgICAgaWYgKGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJbZW1lXSBibG9ja2luZyBmcmFnIGxvYWQgdW50aWwgbWVkaWEta2V5cyBhY3F1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgaWYgKGlzTWVkaWFGcmFnbWVudChmcmFnKSAmJiAoIWZyYWdQcmV2aW91cyB8fCBmcmFnLnNuICE9PSBmcmFnUHJldmlvdXMuc24pKSB7XG4gICAgICAgIHZhciBzaG91bGRMb2FkUGFydHMgPSB0aGlzLnNob3VsZExvYWRQYXJ0cyhsZXZlbC5kZXRhaWxzLCBmcmFnLmVuZCk7XG4gICAgICAgIGlmIChzaG91bGRMb2FkUGFydHMgIT09IHRoaXMubG9hZGluZ1BhcnRzKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJMTC1QYXJ0IGxvYWRpbmcgXCIgKyAoc2hvdWxkTG9hZFBhcnRzID8gJ09OJyA6ICdPRkYnKSArIFwiIGxvYWRpbmcgc24gXCIgKyAoZnJhZ1ByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBmcmFnUHJldmlvdXMuc24pICsgXCItPlwiICsgZnJhZy5zbik7XG4gICAgICAgICAgdGhpcy5sb2FkaW5nUGFydHMgPSBzaG91bGRMb2FkUGFydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBNYXRoLm1heChmcmFnLnN0YXJ0LCB0YXJnZXRCdWZmZXJUaW1lIHx8IDApO1xuICAgICAgaWYgKHRoaXMubG9hZGluZ1BhcnRzICYmIGlzTWVkaWFGcmFnbWVudChmcmFnKSkge1xuICAgICAgICB2YXIgcGFydExpc3QgPSBkZXRhaWxzLnBhcnRMaXN0O1xuICAgICAgICBpZiAocGFydExpc3QgJiYgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lID4gZGV0YWlscy5mcmFnbWVudEVuZCAmJiBkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgICAgICAgZnJhZyA9IGRldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGFydEluZGV4ID0gdGhpcy5nZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICAgICAgaWYgKHBhcnRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRMaXN0W3BhcnRJbmRleF07XG4gICAgICAgICAgICBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCA9IHBhcnQuZnJhZ21lbnQ7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIkxvYWRpbmcgXCIgKyBmcmFnLnR5cGUgKyBcIiBzbjogXCIgKyBmcmFnLnNuICsgXCIgcGFydDogXCIgKyBwYXJ0LmluZGV4ICsgXCIgKFwiICsgcGFydEluZGV4ICsgXCIvXCIgKyAocGFydExpc3QubGVuZ3RoIC0gMSkgKyBcIikgb2YgXCIgKyB0aGlzLmZyYWdJbmZvKGZyYWcsIGZhbHNlLCBwYXJ0KSArIFwiKSBjYzogXCIgKyBmcmFnLmNjICsgXCIgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdLCB0YXJnZXQ6IFwiICsgcGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpKTtcbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHBhcnQuc3RhcnQgKyBwYXJ0LmR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgIHZhciBfcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHQgPSBrZXlMb2FkaW5nUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChrZXlMb2FkZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlMb2FkZWREYXRhIHx8IF90aGlzNS5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YS5mcmFnKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczUuZG9GcmFnUGFydHNMb2FkKGZyYWcsIHBhcnQsIGxldmVsLCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNS5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfcmVzdWx0ID0gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoZnJhZywgcGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczUuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FESU5HLCB7XG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICAgIHRhcmdldEJ1ZmZlclRpbWU6IHRhcmdldEJ1ZmZlclRpbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gRlJBR19MT0FESU5HIHBhcnRzXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWZyYWcudXJsIHx8IHRoaXMubG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgICAgICAgIC8vIEZyYWdtZW50IGhpbnQgaGFzIG5vIHBhcnRzXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTWVkaWFGcmFnbWVudChmcmFnKSAmJiB0aGlzLmxvYWRpbmdQYXJ0cykge1xuICAgICAgICB2YXIgX2RldGFpbHMkcGFydExpc3Q7XG4gICAgICAgIHRoaXMubG9nKFwiTEwtUGFydCBsb2FkaW5nIE9GRiBhZnRlciBuZXh0IHBhcnQgbWlzcyBAXCIgKyB0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMikgKyBcIiBDaGVjayBidWZmZXIgYXQgc246IFwiICsgZnJhZy5zbiArIFwiIGxvYWRlZCBwYXJ0czogXCIgKyAoKF9kZXRhaWxzJHBhcnRMaXN0ID0gZGV0YWlscy5wYXJ0TGlzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kZXRhaWxzJHBhcnRMaXN0LmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBwLmxvYWRlZDtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIFwiW1wiICsgcC5zdGFydCArIFwiLVwiICsgcC5lbmQgKyBcIl1cIjtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgdGhpcy5sb2FkaW5nUGFydHMgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIWZyYWcudXJsKSB7XG4gICAgICAgIC8vIFNlbGVjdGVkIGZyYWdtZW50IGhpbnQgZm9yIHBhcnQgYnV0IG5vdCBsb2FkaW5nIHBhcnRzXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcIkxvYWRpbmcgXCIgKyBmcmFnLnR5cGUgKyBcIiBzbjogXCIgKyBmcmFnLnNuICsgXCIgb2YgXCIgKyB0aGlzLmZyYWdJbmZvKGZyYWcsIGZhbHNlKSArIFwiKSBjYzogXCIgKyBmcmFnLmNjICsgXCIgXCIgKyAoJ1snICsgZGV0YWlscy5zdGFydFNOICsgJy0nICsgZGV0YWlscy5lbmRTTiArICddJykgKyBcIiwgdGFyZ2V0OiBcIiArIHBhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKSk7XG4gICAgICAvLyBEb24ndCB1cGRhdGUgbmV4dExvYWRQb3NpdGlvbiBmb3IgZnJhZ21lbnRzIHdoaWNoIGFyZSBub3QgYnVmZmVyZWRcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihmcmFnLnNuKSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG5cbiAgICAgIC8vIExvYWQga2V5IGJlZm9yZSBzdHJlYW1pbmcgZnJhZ21lbnQgZGF0YVxuICAgICAgdmFyIGRhdGFPblByb2dyZXNzID0gdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUgJiYgZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRTtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoZGF0YU9uUHJvZ3Jlc3MgJiYga2V5TG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5TG9hZGluZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoa2V5TG9hZGVkRGF0YSkge1xuICAgICAgICAgIGlmICgha2V5TG9hZGVkRGF0YSB8fCBfdGhpczUuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXM1LmZyYWdtZW50TG9hZGVyLmxvYWQoZnJhZywgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbG9hZCB1bmVuY3J5cHRlZCBmcmFnbWVudCBkYXRhIHdpdGggcHJvZ3Jlc3MgZXZlbnQsXG4gICAgICAgIC8vIG9yIGhhbmRsZSBmcmFnbWVudCByZXN1bHQgYWZ0ZXIga2V5IGFuZCBmcmFnbWVudCBhcmUgZmluaXNoZWQgbG9hZGluZ1xuICAgICAgICByZXN1bHQgPSBQcm9taXNlLmFsbChbdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIGRhdGFPblByb2dyZXNzID8gcHJvZ3Jlc3NDYWxsYmFjayA6IHVuZGVmaW5lZCksIGtleUxvYWRpbmdQcm9taXNlXSkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBmcmFnTG9hZGVkRGF0YSA9IF9yZWZbMF07XG4gICAgICAgICAgaWYgKCFkYXRhT25Qcm9ncmVzcyAmJiBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGZyYWdMb2FkZWREYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyYWdMb2FkZWREYXRhO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1LmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BRElORywge1xuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICB0YXJnZXRCdWZmZXJUaW1lOiB0YXJnZXRCdWZmZXJUaW1lXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEZSQUdfTE9BRElOR1wiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLmRvRnJhZ1BhcnRzTG9hZCA9IGZ1bmN0aW9uIGRvRnJhZ1BhcnRzTG9hZChmcmFnLCBmcm9tUGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICAgICAgICB2YXIgcGFydHNMb2FkZWQgPSBbXTtcbiAgICAgICAgdmFyIGluaXRpYWxQYXJ0TGlzdCA9IChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5wYXJ0TGlzdDtcbiAgICAgICAgdmFyIF9sb2FkUGFydCA9IGZ1bmN0aW9uIGxvYWRQYXJ0KHBhcnQpIHtcbiAgICAgICAgICBfdGhpczYuZnJhZ21lbnRMb2FkZXIubG9hZFBhcnQoZnJhZywgcGFydCwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihmdW5jdGlvbiAocGFydExvYWRlZERhdGEpIHtcbiAgICAgICAgICAgIHBhcnRzTG9hZGVkW3BhcnQuaW5kZXhdID0gcGFydExvYWRlZERhdGE7XG4gICAgICAgICAgICB2YXIgbG9hZGVkUGFydCA9IHBhcnRMb2FkZWREYXRhLnBhcnQ7XG4gICAgICAgICAgICBfdGhpczYuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhcnQgPSBnZXRQYXJ0V2l0aChsZXZlbC5kZXRhaWxzLCBmcmFnLnNuLCBwYXJ0LmluZGV4ICsgMSkgfHwgZmluZFBhcnQoaW5pdGlhbFBhcnRMaXN0LCBmcmFnLnNuLCBwYXJ0LmluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAobmV4dFBhcnQpIHtcbiAgICAgICAgICAgICAgX2xvYWRQYXJ0KG5leHRQYXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICAgIHBhcnQ6IGxvYWRlZFBhcnQsXG4gICAgICAgICAgICAgICAgcGFydHNMb2FkZWQ6IHBhcnRzTG9hZGVkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIF9sb2FkUGFydChmcm9tUGFydCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVGcmFnTG9hZEVycm9yID0gZnVuY3Rpb24gaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikge1xuICAgICAgaWYgKCdkYXRhJyBpbiBlcnJvcikge1xuICAgICAgICB2YXIgZGF0YSA9IGVycm9yLmRhdGE7XG4gICAgICAgIGlmIChkYXRhLmZyYWcgJiYgZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRnJhZ0xvYWRBYm9ydGVkKGRhdGEuZnJhZywgZGF0YS5wYXJ0KTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmZyYWcgJiYgZGF0YS50eXBlID09PSBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IpIHtcbiAgICAgICAgICBkYXRhLmZyYWcuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoKTtcbiAgICAgICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGRhdGEuZnJhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLl9oYW5kbGVUcmFuc211eGVyRmx1c2ggPSBmdW5jdGlvbiBfaGFuZGxlVHJhbnNtdXhlckZsdXNoKGNodW5rTWV0YSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICBpZiAoIWNvbnRleHQgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ0N1cnJlbnQgJiYgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWw7XG4gICAgICB2YXIgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGZyYWcuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuZW5kID0gbm93O1xuICAgICAgfVxuICAgICAgLy8gU2VlIGlmIHBhcnQgbG9hZGluZyBzaG91bGQgYmUgZGlzYWJsZWQvZW5hYmxlZCBiYXNlZCBvbiBidWZmZXIgYW5kIHBsYXliYWNrIHBvc2l0aW9uLlxuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICB2YXIgbG9hZGluZ1BhcnRzQXRFZGdlID0gbGV2ZWxEZXRhaWxzICYmIGZyYWcuc24gPiBsZXZlbERldGFpbHMuZW5kU047XG4gICAgICB2YXIgc2hvdWxkTG9hZFBhcnRzID0gbG9hZGluZ1BhcnRzQXRFZGdlIHx8IHRoaXMuc2hvdWxkTG9hZFBhcnRzKGxldmVsRGV0YWlscywgZnJhZy5lbmQpO1xuICAgICAgaWYgKHNob3VsZExvYWRQYXJ0cyAhPT0gdGhpcy5sb2FkaW5nUGFydHMpIHtcbiAgICAgICAgdGhpcy5sb2coXCJMTC1QYXJ0IGxvYWRpbmcgXCIgKyAoc2hvdWxkTG9hZFBhcnRzID8gJ09OJyA6ICdPRkYnKSArIFwiIGFmdGVyIHBhcnNpbmcgc2VnbWVudCBlbmRpbmcgQFwiICsgZnJhZy5lbmQudG9GaXhlZCgyKSk7XG4gICAgICAgIHRoaXMubG9hZGluZ1BhcnRzID0gc2hvdWxkTG9hZFBhcnRzO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgY2h1bmtNZXRhLnBhcnRpYWwpO1xuICAgIH07XG4gICAgX3Byb3RvLnNob3VsZExvYWRQYXJ0cyA9IGZ1bmN0aW9uIHNob3VsZExvYWRQYXJ0cyhkZXRhaWxzLCBidWZmZXJFbmQpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nUGFydHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldGFpbHMucGFydExpc3QpIHtcbiAgICAgICAgICB2YXIgX2RldGFpbHMkZnJhZ21lbnRIaW50O1xuICAgICAgICAgIC8vIEJ1ZmZlciBtdXN0IGJlIGFoZWFkIG9mIGZpcnN0IHBhcnQgKyBkdXJhdGlvbiBvZiBwYXJ0cyBhZnRlciBsYXN0IHNlZ21lbnRcbiAgICAgICAgICAvLyBhbmQgcGxheWJhY2sgbXVzdCBiZSBhdCBvciBwYXN0IHNlZ21lbnQgYWRqYWNlbnQgdG8gcGFydCBsaXN0XG4gICAgICAgICAgdmFyIGZpcnN0UGFydCA9IGRldGFpbHMucGFydExpc3RbMF07XG4gICAgICAgICAgLy8gTG9hZGluZyBvZiBWVFQgc3VidGl0bGUgcGFydHMgaXMgbm90IGltcGxlbWVudGVkIGluIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyICgjNzQ2MClcbiAgICAgICAgICBpZiAoZmlyc3RQYXJ0LmZyYWdtZW50LnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzYWZlUGFydFN0YXJ0ID0gZmlyc3RQYXJ0LmVuZCArICgoKF9kZXRhaWxzJGZyYWdtZW50SGludCA9IGRldGFpbHMuZnJhZ21lbnRIaW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RldGFpbHMkZnJhZ21lbnRIaW50LmR1cmF0aW9uKSB8fCAwKTtcbiAgICAgICAgICBpZiAoYnVmZmVyRW5kID49IHNhZmVQYXJ0U3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgICAgICAgIHZhciBwbGF5aGVhZCA9IHRoaXMuaGxzLmhhc0Vub3VnaFRvU3RhcnQgPyAoKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLmN1cnJlbnRUaW1lKSB8fCB0aGlzLmxhc3RDdXJyZW50VGltZSA6IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAocGxheWhlYWQgPiBmaXJzdFBhcnQuc3RhcnQgLSBmaXJzdFBhcnQuZnJhZ21lbnQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0Q3VycmVudENvbnRleHQgPSBmdW5jdGlvbiBnZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgdmFyIGxldmVsSW5kZXggPSBjaHVua01ldGEubGV2ZWwsXG4gICAgICAgIHNuID0gY2h1bmtNZXRhLnNuLFxuICAgICAgICBwYXJ0SW5kZXggPSBjaHVua01ldGEucGFydDtcbiAgICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVsc1tsZXZlbEluZGV4XSkpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiTGV2ZWxzIG9iamVjdCB3YXMgdW5zZXQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50IFwiICsgc24gKyBcIiBvZiBcIiArIHRoaXMucGxheWxpc3RMYWJlbCgpICsgXCIgXCIgKyBsZXZlbEluZGV4ICsgXCIuIFRoZSBjdXJyZW50IGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLlwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgIHZhciBwYXJ0ID0gcGFydEluZGV4ID4gLTEgPyBnZXRQYXJ0V2l0aChsZXZlbERldGFpbHMsIHNuLCBwYXJ0SW5kZXgpIDogbnVsbDtcbiAgICAgIHZhciBmcmFnID0gcGFydCA/IHBhcnQuZnJhZ21lbnQgOiBnZXRGcmFnbWVudFdpdGhTTihsZXZlbERldGFpbHMsIHNuLCBmcmFnQ3VycmVudCk7XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQgIT09IGZyYWcpIHtcbiAgICAgICAgZnJhZy5zdGF0cyA9IGZyYWdDdXJyZW50LnN0YXRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgbGV2ZWw6IGxldmVsXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmJ1ZmZlckZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIGJ1ZmZlckZyYWdtZW50RGF0YShkYXRhLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEsIG5vQmFja3RyYWNraW5nKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGF0YTEgPSBkYXRhLmRhdGExLFxuICAgICAgICBkYXRhMiA9IGRhdGEuZGF0YTI7XG4gICAgICB2YXIgYnVmZmVyID0gZGF0YTE7XG4gICAgICBpZiAoZGF0YTIpIHtcbiAgICAgICAgLy8gQ29tYmluZSB0aGUgbW9vZiArIG1kYXQgc28gdGhhdCB3ZSBidWZmZXIgd2l0aCBhIHNpbmdsZSBhcHBlbmRcbiAgICAgICAgYnVmZmVyID0gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpO1xuICAgICAgfVxuICAgICAgaWYgKCFidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXRUaW1lc3RhbXAgPSB0aGlzLmluaXRQVFNbZnJhZy5jY107XG4gICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0VGltZXN0YW1wID8gLW9mZnNldFRpbWVzdGFtcC5iYXNlVGltZSAvIG9mZnNldFRpbWVzdGFtcC50aW1lc2NhbGUgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc2VnbWVudCA9IHtcbiAgICAgICAgdHlwZTogZGF0YS50eXBlLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICBkYXRhOiBidWZmZXJcbiAgICAgIH07XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICAgIGlmIChkYXRhLmRyb3BwZWQgJiYgZGF0YS5pbmRlcGVuZGVudCAmJiAhcGFydCkge1xuICAgICAgICBpZiAobm9CYWNrdHJhY2tpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgYnVmZmVyIHNvIHRoYXQgd2UgcmVsb2FkIHByZXZpb3VzIHNlZ21lbnRzIHNlcXVlbnRpYWxseSBpZiByZXF1aXJlZFxuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoQnVmZmVyR2FwID0gZnVuY3Rpb24gZmx1c2hCdWZmZXJHYXAoZnJhZykge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSWYgY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBjbGVhciB0aGUgYmFjayBidWZmZXIgc28gdGhhdCB3ZSBjYW4gYmFja3RyYWNrIGFzIG11Y2ggYXMgbmVlZGVkXG4gICAgICBpZiAoIUJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZy5zdGFydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBiYWNrLWJ1ZmZlciB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjayB0byBhbGxvdyBiYWNrIHRyYWNraW5nXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIHZhciBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICAgIHZhciBmcmFnRHVyYXRpb24gPSBmcmFnLmR1cmF0aW9uO1xuICAgICAgdmFyIHNlZ21lbnRGcmFjdGlvbiA9IE1hdGgubWluKHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgKiAyLCBmcmFnRHVyYXRpb24gKiAwLjI1KTtcbiAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KE1hdGgubWluKGZyYWcuc3RhcnQgLSBzZWdtZW50RnJhY3Rpb24sIGJ1ZmZlckluZm8uZW5kIC0gc2VnbWVudEZyYWN0aW9uKSwgY3VycmVudFRpbWUgKyBzZWdtZW50RnJhY3Rpb24pO1xuICAgICAgaWYgKGZyYWcuc3RhcnQgLSBzdGFydCA+IHNlZ21lbnRGcmFjdGlvbikge1xuICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydCwgZnJhZy5zdGFydCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0RndkQnVmZmVySW5mbyA9IGZ1bmN0aW9uIGdldEZ3ZEJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgdHlwZSkge1xuICAgICAgdmFyIF90aGlzJG1lZGlhMjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihwb3MpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGJhY2t3YXJkU2VlayA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID4gcG9zO1xuICAgICAgdmFyIG1heEJ1ZmZlckhvbGUgPSBiYWNrd2FyZFNlZWsgfHwgKF90aGlzJG1lZGlhMiA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEyLnBhdXNlZCA/IDAgOiB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKGJ1ZmZlcmFibGUsIHBvcywgdHlwZSwgbWF4QnVmZmVySG9sZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0RndkQnVmZmVySW5mb0F0UG9zID0gZnVuY3Rpb24gZ2V0RndkQnVmZmVySW5mb0F0UG9zKGJ1ZmZlcmFibGUsIHBvcywgdHlwZSwgbWF4QnVmZmVySG9sZSkge1xuICAgICAgdmFyIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXJhYmxlLCBwb3MsIG1heEJ1ZmZlckhvbGUpO1xuICAgICAgLy8gV29ya2Fyb3VuZCBmbGF3IGluIGdldHRpbmcgZm9yd2FyZCBidWZmZXIgd2hlbiBtYXhCdWZmZXJIb2xlIGlzIHNtYWxsZXIgdGhhbiBnYXAgYXQgY3VycmVudCBwb3NcbiAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBidWZmZXJlZEZyYWdBdFBvcyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3MsIHR5cGUpO1xuICAgICAgICBpZiAoYnVmZmVyZWRGcmFnQXRQb3MgJiYgKGJ1ZmZlckluZm8ubmV4dFN0YXJ0IDw9IGJ1ZmZlcmVkRnJhZ0F0UG9zLmVuZCB8fCBidWZmZXJlZEZyYWdBdFBvcy5nYXApKSB7XG4gICAgICAgICAgdmFyIGdhcER1cmF0aW9uID0gTWF0aC5tYXgoTWF0aC5taW4oYnVmZmVySW5mby5uZXh0U3RhcnQsIGJ1ZmZlcmVkRnJhZ0F0UG9zLmVuZCkgLSBwb3MsIG1heEJ1ZmZlckhvbGUpO1xuICAgICAgICAgIHJldHVybiBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXJhYmxlLCBwb3MsIGdhcER1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlckluZm87XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TWF4QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0TWF4QnVmZmVyTGVuZ3RoKGxldmVsQml0cmF0ZSkge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgdmFyIG1heEJ1ZkxlbjtcbiAgICAgIGlmIChsZXZlbEJpdHJhdGUpIHtcbiAgICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgoOCAqIGNvbmZpZy5tYXhCdWZmZXJTaXplIC8gbGV2ZWxCaXRyYXRlLCBjb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgICB9O1xuICAgIF9wcm90by5yZWR1Y2VNYXhCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiByZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhyZXNob2xkLCBmcmFnRHVyYXRpb24pIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIHZhciBtaW5MZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbih0aHJlc2hvbGQgLSBmcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpLCBmcmFnRHVyYXRpb24pO1xuICAgICAgdmFyIHJlZHVjZWRMZW5ndGggPSBNYXRoLm1heCh0aHJlc2hvbGQgLSBmcmFnRHVyYXRpb24gKiAzLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC8gMiwgbWluTGVuZ3RoKTtcbiAgICAgIGlmIChyZWR1Y2VkTGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA9IHJlZHVjZWRMZW5ndGg7XG4gICAgICAgIHRoaXMud2FybihcIlJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byBcIiArIHJlZHVjZWRMZW5ndGggKyBcInNcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEFwcGVuZGVkRnJhZyA9IGZ1bmN0aW9uIGdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgcGxheWxpc3RUeXBlKSB7XG4gICAgICBpZiAocGxheWxpc3RUeXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgcGxheWxpc3RUeXBlID0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFnT3JQYXJ0ID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPyB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIHBsYXlsaXN0VHlwZSkgOiBudWxsO1xuICAgICAgaWYgKGZyYWdPclBhcnQgJiYgJ2ZyYWdtZW50JyBpbiBmcmFnT3JQYXJ0KSB7XG4gICAgICAgIHJldHVybiBmcmFnT3JQYXJ0LmZyYWdtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdPclBhcnQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TmV4dEZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0TmV4dEZyYWdtZW50KHBvcywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgICB2YXIgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIHZhciBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghZnJhZ0xlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIHZhciBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHZhciBjYW5Mb2FkUGFydHMgPSBjb25maWcubG93TGF0ZW5jeU1vZGUgJiYgISFsZXZlbERldGFpbHMucGFydExpc3Q7XG4gICAgICB2YXIgZnJhZyA9IG51bGw7XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgdmFyIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplID0gY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuICAgICAgICBpZiAoZnJhZ0xlbiA8IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwiTm90IGVub3VnaCBmcmFnbWVudHMgdG8gc3RhcnQgcGxheWJhY2sgKGhhdmU6IFwiICsgZnJhZ0xlbiArIFwiLCBuZWVkOiBcIiArIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplICsgXCIpXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSByZWFsIGZyYWdtZW50IHN0YXJ0IHRpbWVzIGZvciBhIGxpdmUgc3RyZWFtIGFyZSBvbmx5IGtub3duIGFmdGVyIHRoZSBQVFMgcmFuZ2UgZm9yIHRoYXQgbGV2ZWwgaXMga25vd24uXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGRpc2NvdmVyIHRoZSByYW5nZSwgd2UgbG9hZCB0aGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhhdCBsZXZlbCBhbmQgZGVtdXggaXQuXG4gICAgICAgIC8vIERvIG5vdCBsb2FkIHVzaW5nIGxpdmUgbG9naWMgaWYgdGhlIHN0YXJ0aW5nIGZyYWcgaXMgcmVxdWVzdGVkIC0gd2Ugd2FudCB0byB1c2UgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKCkgc28gdGhhdFxuICAgICAgICAvLyB3ZSBnZXQgdGhlIGZyYWdtZW50IG1hdGNoaW5nIHRoYXQgc3RhcnQgdGltZVxuICAgICAgICBpZiAoIWxldmVsRGV0YWlscy5QVFNLbm93biAmJiAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgdGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSB8fCBwb3MgPCBzdGFydCkge1xuICAgICAgICAgIHZhciBfZnJhZztcbiAgICAgICAgICBpZiAoY2FuTG9hZFBhcnRzICYmICF0aGlzLmxvYWRpbmdQYXJ0cykge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJMTC1QYXJ0IGxvYWRpbmcgT04gZm9yIGluaXRpYWwgbGl2ZSBmcmFnbWVudFwiKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1BhcnRzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZyA9IHRoaXMuZ2V0SW5pdGlhbExpdmVGcmFnbWVudChsZXZlbERldGFpbHMpO1xuICAgICAgICAgIHZhciBtYWluU3RhcnQgPSB0aGlzLmhscy5zdGFydFBvc2l0aW9uO1xuICAgICAgICAgIHZhciBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IGZyYWcgPyAobWFpblN0YXJ0ICE9PSAtMSAmJiBtYWluU3RhcnQgPj0gc3RhcnQgPyBtYWluU3RhcnQgOiBsaXZlU3luY1Bvc2l0aW9uKSB8fCBmcmFnLnN0YXJ0IDogcG9zO1xuICAgICAgICAgIHRoaXMubG9nKFwiU2V0dGluZyBzdGFydFBvc2l0aW9uIHRvIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiIHRvIG1hdGNoIHN0YXJ0IGZyYWcgYXQgbGl2ZSBlZGdlLiBtYWluU3RhcnQ6IFwiICsgbWFpblN0YXJ0ICsgXCIgbGl2ZVN5bmNQb3NpdGlvbjogXCIgKyBsaXZlU3luY1Bvc2l0aW9uICsgXCIgZnJhZy5zdGFydDogXCIgKyAoKF9mcmFnID0gZnJhZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnLnN0YXJ0KSk7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwb3MgPD0gc3RhcnQpIHtcbiAgICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBsb2FkUG9zaXRpb24gYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmVuJ3QgcnVuIGludG8gYW55IHNwZWNpYWwgY2FzZXMgYWxyZWFkeSwganVzdCBsb2FkIHRoZSBmcmFnbWVudCBtb3N0IGNsb3NlbHkgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBwb3NpdGlvblxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmxvYWRpbmdQYXJ0cyA/IGxldmVsRGV0YWlscy5wYXJ0RW5kIDogbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kO1xuICAgICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24ocG9zLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvZ3JhbUZyYWcgPSB0aGlzLmZpbHRlclJlcGxhY2VkUHJpbWFyeShmcmFnLCBsZXZlbERldGFpbHMpO1xuICAgICAgaWYgKCFwcm9ncmFtRnJhZyAmJiBmcmFnKSB7XG4gICAgICAgIHZhciBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgcHJvZ3JhbUZyYWcgPSB0aGlzLmZpbHRlclJlcGxhY2VkUHJpbWFyeShmcmFnbWVudHNbY3VyU05JZHggKyAxXSB8fCBudWxsLCBsZXZlbERldGFpbHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChwcm9ncmFtRnJhZyk7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNMb29wTG9hZGluZyA9IGZ1bmN0aW9uIGlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgICAgdmFyIHRyYWNrZXJTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgICAgcmV0dXJuICh0cmFja2VyU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuT0sgfHwgdHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgISFmcmFnLmdhcCkgJiYgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID4gdGFyZ2V0QnVmZmVyVGltZTtcbiAgICB9O1xuICAgIF9wcm90by5nZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyA9IGZ1bmN0aW9uIGdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGZyYWcsIGxldmVsRGV0YWlscywgYnVmZmVySW5mbywgcGxheWxpc3RUeXBlLCBtYXhCdWZMZW4pIHtcbiAgICAgIHZhciBuZXh0RnJhZ21lbnQgPSBudWxsO1xuICAgICAgaWYgKGZyYWcuZ2FwKSB7XG4gICAgICAgIG5leHRGcmFnbWVudCA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KHRoaXMubmV4dExvYWRQb3NpdGlvbiwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgICAgaWYgKG5leHRGcmFnbWVudCAmJiAhbmV4dEZyYWdtZW50LmdhcCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgICAgIC8vIE1lZGlhIGJ1ZmZlcmVkIGFmdGVyIEdBUCB0YWdzIHNob3VsZCBub3QgbWFrZSB0aGUgbmV4dCBidWZmZXIgdGltZXJhbmdlIGV4Y2VlZCBmb3J3YXJkIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgICB2YXIgbmV4dGJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm9BdFBvcyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsIGJ1ZmZlckluZm8ubmV4dFN0YXJ0LCBwbGF5bGlzdFR5cGUsIDApO1xuICAgICAgICAgIGlmIChuZXh0YnVmZmVySW5mbyAhPT0gbnVsbCAmJiBidWZmZXJJbmZvLmxlbiArIG5leHRidWZmZXJJbmZvLmxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgICAgICAgIC8vIFJldHVybmluZyBoZXJlIG1pZ2h0IHJlc3VsdCBpbiBub3QgZmluZGluZyBhbiBhdWRpbyBhbmQgdmlkZW8gY2FuZGlhdGUgdG8gc2tpcCB0b1xuICAgICAgICAgICAgdmFyIHNuID0gbmV4dEZyYWdtZW50LnNuO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9vcFNuICE9PSBzbikge1xuICAgICAgICAgICAgICB0aGlzLmxvZyhcImJ1ZmZlciBmdWxsIGFmdGVyIGdhcHMgaW4gXFxcIlwiICsgcGxheWxpc3RUeXBlICsgXCJcXFwiIHBsYXlsaXN0IHN0YXJ0aW5nIGF0IHNuOiBcIiArIHNuKTtcbiAgICAgICAgICAgICAgdGhpcy5sb29wU24gPSBzbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sb29wU24gPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gbmV4dEZyYWdtZW50O1xuICAgIH07XG4gICAgX3Byb3RvLmZpbHRlclJlcGxhY2VkUHJpbWFyeSA9IGZ1bmN0aW9uIGZpbHRlclJlcGxhY2VkUHJpbWFyeShmcmFnLCBkZXRhaWxzKSB7XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICB9XG4gICAgICBpZiAoaW50ZXJzdGl0aWFsc0VuYWJsZWQodGhpcy5jb25maWcpICYmIGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgICAgLy8gRG8gbm90IGxvYWQgZnJhZ21lbnRzIG91dHNpZGUgdGhlIGJ1ZmZlcmluZyBzY2hlZHVsZSBzZWdtZW50XG4gICAgICAgIHZhciBpbnRlcnN0aXRpYWxzID0gdGhpcy5obHMuaW50ZXJzdGl0aWFsc01hbmFnZXI7XG4gICAgICAgIHZhciBidWZmZXJpbmdJdGVtID0gaW50ZXJzdGl0aWFscyA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJzdGl0aWFscy5idWZmZXJpbmdJdGVtO1xuICAgICAgICBpZiAoYnVmZmVyaW5nSXRlbSkge1xuICAgICAgICAgIHZhciBidWZmZXJpbmdJbnRlcnN0aXRpYWwgPSBidWZmZXJpbmdJdGVtLmV2ZW50O1xuICAgICAgICAgIGlmIChidWZmZXJpbmdJbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBzdHJlYW0gZnJhZ21lbnRzIHdoaWxlIGJ1ZmZlcmluZyBJbnRlcnN0aXRpYWwgRXZlbnRzIChleGNlcHQgZm9yIG92ZXJsYXAgYXQgdGhlIHN0YXJ0KVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcmluZ0ludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlIHx8IE1hdGguYWJzKGZyYWcuc3RhcnQgLSBidWZmZXJpbmdJdGVtLnN0YXJ0KSA+IDEgfHwgYnVmZmVyaW5nSXRlbS5zdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTGltaXQgZnJhZ21lbnQgbG9hZGluZyB0byBtZWRpYSBpbiBzY2hlZHVsZSBpdGVtXG4gICAgICAgICAgICBpZiAoZnJhZy5lbmQgPD0gYnVmZmVyaW5nSXRlbS5zdGFydCAmJiAoZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5saXZlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgZW5kcyBieSBzY2hlZHVsZSBpdGVtIHN0YXJ0XG4gICAgICAgICAgICAgIC8vIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhZy5zdGFydCA+IGJ1ZmZlcmluZ0l0ZW0uZW5kICYmIGJ1ZmZlcmluZ0l0ZW0ubmV4dEV2ZW50KSB7XG4gICAgICAgICAgICAgIC8vIGZyYWdtZW50IGlzIHBhc3Qgc2NoZWR1bGUgaXRlbSBlbmRcbiAgICAgICAgICAgICAgLy8gYWxsb3cgc29tZSBvdmVyZmxvdyB3aGVuIG5vdCBhcHBlbmRpbmcgaW4gcGxhY2UgdG8gcHJldmVudCBzdGFsbHNcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcmluZ0l0ZW0ubmV4dEV2ZW50LmFwcGVuZEluUGxhY2UgfHwgZnJhZy5zdGFydCAtIGJ1ZmZlcmluZ0l0ZW0uZW5kID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgbG9hZGluZyBvZiBmcmFnbWVudHMgdGhhdCBvdmVybGFwIGNvbXBsZXRlbHkgd2l0aCBhcHBlbmRJblBsYWNlIGludGVyc3RpdGlhbHNcbiAgICAgICAgdmFyIHBsYXllclF1ZXVlID0gaW50ZXJzdGl0aWFscyA9PSBudWxsID8gdm9pZCAwIDogaW50ZXJzdGl0aWFscy5wbGF5ZXJRdWV1ZTtcbiAgICAgICAgaWYgKHBsYXllclF1ZXVlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHBsYXllclF1ZXVlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIGludGVyc3RpdGlhbCA9IHBsYXllclF1ZXVlW2ldLmludGVyc3RpdGlhbDtcbiAgICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSAmJiBmcmFnLnN0YXJ0ID49IGludGVyc3RpdGlhbC5zdGFydFRpbWUgJiYgZnJhZy5lbmQgPD0gaW50ZXJzdGl0aWFsLnJlc3VtZVRpbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9O1xuICAgIF9wcm90by5tYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkID0gZnVuY3Rpb24gbWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmcmFnKSB7XG4gICAgICAvLyBJZiBhbiBpbml0U2VnbWVudCBpcyBwcmVzZW50LCBpdCBtdXN0IGJlIGJ1ZmZlcmVkIGZpcnN0XG4gICAgICBpZiAoZnJhZyAhPSBudWxsICYmIGZyYWcuaW5pdFNlZ21lbnQgJiYgIWZyYWcuaW5pdFNlZ21lbnQuZGF0YSAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgICByZXR1cm4gZnJhZy5pbml0U2VnbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH07XG4gICAgX3Byb3RvLmdldE5leHRQYXJ0ID0gZnVuY3Rpb24gZ2V0TmV4dFBhcnQocGFydExpc3QsIGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIHZhciBuZXh0UGFydCA9IC0xO1xuICAgICAgdmFyIGNvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICAgIHZhciBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRMaXN0W2ldO1xuICAgICAgICBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gaW5kZXBlbmRlbnRBdHRyT21pdHRlZCAmJiAhcGFydC5pbmRlcGVuZGVudDtcbiAgICAgICAgaWYgKG5leHRQYXJ0ID4gLTEgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHBhcnQuc3RhcnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9hZGVkID0gcGFydC5sb2FkZWQ7XG4gICAgICAgIGlmIChsb2FkZWQpIHtcbiAgICAgICAgICBuZXh0UGFydCA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRpZ3VvdXMgfHwgKHBhcnQuaW5kZXBlbmRlbnQgfHwgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCkgJiYgcGFydC5mcmFnbWVudCA9PT0gZnJhZykge1xuICAgICAgICAgIGlmIChwYXJ0LmZyYWdtZW50ICE9PSBmcmFnKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJOZWVkIGJ1ZmZlciBhdCBcIiArIHRhcmdldEJ1ZmZlclRpbWUgKyBcIiBidXQgbmV4dCB1bmxvYWRlZCBwYXJ0IHN0YXJ0cyBhdCBcIiArIHBhcnQuc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0UGFydCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGlndW91cyA9IGxvYWRlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0UGFydDtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkZWRFbmRPZlBhcnRzID0gZnVuY3Rpb24gbG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgICAgdmFyIHBhcnQ7XG4gICAgICBmb3IgKHZhciBpID0gcGFydExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHBhcnQgPSBwYXJ0TGlzdFtpXTtcbiAgICAgICAgaWYgKCFwYXJ0LmxvYWRlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA+IHBhcnQuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qXG4gICAgIFRoaXMgbWV0aG9kIGlzIHVzZWQgZmluZCB0aGUgYmVzdCBtYXRjaGluZyBmaXJzdCBmcmFnbWVudCBmb3IgYSBsaXZlIHBsYXlsaXN0LiBUaGlzIGZyYWdtZW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZVxuICAgICBcInNsaWRpbmdcIiBvZiB0aGUgcGxheWxpc3QsIHdoaWNoIGlzIGl0cyBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgcGxheWJhY2suIEFmdGVyIHNsaWRpbmcgd2UgY2FuIGNvbXB1dGUgdGhlIHJlYWxcbiAgICAgc3RhcnQgYW5kIGVuZCB0aW1lcyBmb3IgZWFjaCBmcmFnbWVudCBpbiB0aGUgcGxheWxpc3QgKGFmdGVyIHdoaWNoIHRoaXMgbWV0aG9kIHdpbGwgbm90IG5lZWQgdG8gYmUgY2FsbGVkKS5cbiAgICAqLztcbiAgICBfcHJvdG8uZ2V0SW5pdGlhbExpdmVGcmFnbWVudCA9IGZ1bmN0aW9uIGdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzKSB7XG4gICAgICB2YXIgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIHZhciBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICAgIHZhciBmcmFnID0gbnVsbDtcbiAgICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAvLyBQcmVmZXIgdXNpbmcgUERULCBiZWNhdXNlIGl0IGNhbiBiZSBhY2N1cmF0ZSBlbm91Z2ggdG8gY2hvb3NlIHRoZSBjb3JyZWN0IGZyYWdtZW50IHdpdGhvdXQga25vd2luZyB0aGUgbGV2ZWwgc2xpZGluZ1xuICAgICAgICAgIHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogXCIgKyBmcmFnUHJldmlvdXMucHJvZ3JhbURhdGVUaW1lKTtcbiAgICAgICAgICBmcmFnID0gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuZW5kUHJvZ3JhbURhdGVUaW1lLCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICAvLyBTTiBkb2VzIG5vdCBuZWVkIHRvIGJlIGFjY3VyYXRlIGJldHdlZW4gcmVuZGl0aW9ucywgYnV0IGRlcGVuZGluZyBvbiB0aGUgcGFja2FnaW5nIGl0IG1heSBiZSBzby5cbiAgICAgICAgICB2YXIgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xuICAgICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgIHZhciBmcmFnTmV4dCA9IGZyYWdtZW50c1t0YXJnZXRTTiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlJ3JlIHN0YXlpbmcgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlLCBzaW5jZSBQVFMgcmVzZXRzIHVwb24gYSBuZXcgcmFuZ2VcbiAgICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMuY2MgPT09IGZyYWdOZXh0LmNjKSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046IFwiICsgZnJhZy5zbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHN0YXkgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlIGlmIGF2YWlsYWJsZTsgb3RoZXJ3aXNlIHRoZSBmcmFnbWVudHMgaW4gdGhlIHBsYXlsaXN0XG4gICAgICAgICAgLy8gd2lsbCBoYXZlIHRoZSB3cm9uZyBzdGFydCB0aW1lc1xuICAgICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgICAgZnJhZyA9IGZpbmROZWFyZXN0V2l0aENDKGxldmVsRGV0YWlscywgZnJhZ1ByZXZpb3VzLmNjLCBmcmFnUHJldmlvdXMuZW5kKTtcbiAgICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIENDOiBcIiArIGZyYWcuc24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluZCBhIG5ldyBzdGFydCBmcmFnbWVudCB3aGVuIGZyYWdQcmV2aW91cyBpcyBudWxsXG4gICAgICAgIHZhciBsaXZlU3RhcnQgPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICBpZiAobGl2ZVN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKGxpdmVTdGFydCwgdGhpcy5iaXRyYXRlVGVzdCA/IGxldmVsRGV0YWlscy5mcmFnbWVudEVuZCA6IGxldmVsRGV0YWlscy5lZGdlLCBsZXZlbERldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9XG5cbiAgICAvKlxuICAgIFRoaXMgbWV0aG9kIGZpbmRzIHRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50IGdpdmVuIHRoZSBwcm92aWRlZCBwb3NpdGlvbi5cbiAgICAgKi87XG4gICAgX3Byb3RvLmdldEZyYWdtZW50QXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldEZyYWdtZW50QXRQb3NpdGlvbihidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICB2YXIgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgICB2YXIgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cyxcbiAgICAgICAgZW5kU04gPSBsZXZlbERldGFpbHMuZW5kU047XG4gICAgICB2YXIgZnJhZ21lbnRIaW50ID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50SGludDtcbiAgICAgIHZhciBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICB2YXIgcGFydExpc3QgPSBsZXZlbERldGFpbHMucGFydExpc3Q7XG4gICAgICB2YXIgbG9hZGluZ1BhcnRzID0gISEodGhpcy5sb2FkaW5nUGFydHMgJiYgcGFydExpc3QgIT0gbnVsbCAmJiBwYXJ0TGlzdC5sZW5ndGggJiYgZnJhZ21lbnRIaW50KTtcbiAgICAgIGlmIChsb2FkaW5nUGFydHMgJiYgIXRoaXMuYml0cmF0ZVRlc3QgJiYgcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV0uZnJhZ21lbnQuc24gPT09IGZyYWdtZW50SGludC5zbikge1xuICAgICAgICAvLyBJbmNsdWRlIGluY29tcGxldGUgZnJhZ21lbnQgd2l0aCBwYXJ0cyBhdCBlbmRcbiAgICAgICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzLmNvbmNhdChmcmFnbWVudEhpbnQpO1xuICAgICAgICBlbmRTTiA9IGZyYWdtZW50SGludC5zbjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFnO1xuICAgICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgICB2YXIgX3RoaXMkbWVkaWEzO1xuICAgICAgICB2YXIgYmFja3dhcmRTZWVrID0gYnVmZmVyRW5kIDwgdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICAgIHZhciBsb29rdXBUb2xlcmFuY2UgPSBiYWNrd2FyZFNlZWsgfHwgYnVmZmVyRW5kID4gZW5kIC0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB8fCAoX3RoaXMkbWVkaWEzID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYTMucGF1c2VkIHx8ICF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA/IDAgOiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHRvbGVyYW5jZSBpZiBpdCB3b3VsZCBwdXQgdGhlIGJ1ZmZlckVuZCBwYXN0IHRoZSBhY3R1YWwgZW5kIG9mIHN0cmVhbVxuICAgICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgICAgZnJhZyA9IGZpbmRGcmFnbWVudEJ5UFRTKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGxvb2t1cFRvbGVyYW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICB2YXIgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAgIC8vIE1vdmUgZnJhZ1ByZXZpb3VzIGZvcndhcmQgdG8gc3VwcG9ydCBmb3JjaW5nIHRoZSBuZXh0IGZyYWdtZW50IHRvIGxvYWRcbiAgICAgICAgLy8gd2hlbiB0aGUgYnVmZmVyIGNhdGNoZXMgdXAgdG8gYSBwcmV2aW91c2x5IGJ1ZmZlcmVkIHJhbmdlLlxuICAgICAgICB2YXIgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgICAgIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuT0sgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgZnJhZy5nYXApIHtcbiAgICAgICAgICBmcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuICYmICghbG9hZGluZ1BhcnRzIHx8IHBhcnRMaXN0WzBdLmZyYWdtZW50LnNuID4gZnJhZy5zbiB8fCAhbGV2ZWxEZXRhaWxzLmxpdmUpKSB7XG4gICAgICAgICAgLy8gRm9yY2UgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZCBpZiB0aGUgcHJldmlvdXMgb25lIHdhcyBhbHJlYWR5IHNlbGVjdGVkLiBUaGlzIGNhbiBvY2Nhc2lvbmFsbHkgaGFwcGVuIHdpdGhcbiAgICAgICAgICAvLyBub24tdW5pZm9ybSBmcmFnbWVudCBkdXJhdGlvbnNcbiAgICAgICAgICB2YXIgc2FtZUxldmVsID0gZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xuICAgICAgICAgIGlmIChzYW1lTGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgICAgICAgaWYgKGZyYWcuc24gPCBlbmRTTiAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShuZXh0RnJhZykgIT09IEZyYWdtZW50U3RhdGUuT0spIHtcbiAgICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9O1xuICAgIF9wcm90by5hbGlnblBsYXlsaXN0cyA9IGZ1bmN0aW9uIGFsaWduUGxheWxpc3RzKGRldGFpbHMsIHByZXZpb3VzRGV0YWlscywgc3dpdGNoRGV0YWlscykge1xuICAgICAgLy8gVE9ETzogSWYgbm90IGZvciBgc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllc2AgcmVxdWlyaW5nIGZyYWdQcmV2aW91cy5jYyxcbiAgICAgIC8vICB0aGlzIGNvdWxkIGFsbCBnbyBpbiBsZXZlbC1oZWxwZXIgbWVyZ2VEZXRhaWxzKClcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICB0aGlzLndhcm4oXCJObyBmcmFnbWVudHMgaW4gbGl2ZSBwbGF5bGlzdFwiKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgc2xpZGluZ1N0YXJ0ID0gZGV0YWlscy5mcmFnbWVudFN0YXJ0O1xuICAgICAgdmFyIGZpcnN0TGV2ZWxMb2FkID0gIXByZXZpb3VzRGV0YWlscztcbiAgICAgIHZhciBhbGlnbmVkID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBpc0Zpbml0ZU51bWJlcihzbGlkaW5nU3RhcnQpO1xuICAgICAgaWYgKGZpcnN0TGV2ZWxMb2FkIHx8ICFhbGlnbmVkICYmICFzbGlkaW5nU3RhcnQpIHtcbiAgICAgICAgYWxpZ25TdHJlYW0oc3dpdGNoRGV0YWlscywgZGV0YWlscyk7XG4gICAgICAgIHZhciBhbGlnbmVkU2xpZGluZ1N0YXJ0ID0gZGV0YWlscy5mcmFnbWVudFN0YXJ0O1xuICAgICAgICB0aGlzLmxvZyhcIkxpdmUgcGxheWxpc3Qgc2xpZGluZzogXCIgKyBhbGlnbmVkU2xpZGluZ1N0YXJ0LnRvRml4ZWQoMikgKyBcIiBzdGFydC1zbjogXCIgKyAocHJldmlvdXNEZXRhaWxzID8gcHJldmlvdXNEZXRhaWxzLnN0YXJ0U04gOiAnbmEnKSArIFwiLT5cIiArIGRldGFpbHMuc3RhcnRTTiArIFwiIGZyYWdtZW50czogXCIgKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gYWxpZ25lZFNsaWRpbmdTdGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGlkaW5nU3RhcnQ7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FpdEZvckNkblR1bmVJbiA9IGZ1bmN0aW9uIHdhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykge1xuICAgICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW4gdG8gZ2V0IGFuIHVwZGF0ZWQgcGxheWxpc3RcbiAgICAgIHZhciBhZHZhbmNlUGFydExpbWl0ID0gMztcbiAgICAgIHJldHVybiBkZXRhaWxzLmxpdmUgJiYgZGV0YWlscy5jYW5CbG9ja1JlbG9hZCAmJiBkZXRhaWxzLnBhcnRUYXJnZXQgJiYgZGV0YWlscy50dW5lSW5Hb2FsID4gTWF0aC5tYXgoZGV0YWlscy5wYXJ0SG9sZEJhY2ssIGRldGFpbHMucGFydFRhcmdldCAqIGFkdmFuY2VQYXJ0TGltaXQpO1xuICAgIH07XG4gICAgX3Byb3RvLnNldFN0YXJ0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRTdGFydFBvc2l0aW9uKGRldGFpbHMsIHNsaWRpbmcpIHtcbiAgICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIGlmIChzdGFydFBvc2l0aW9uIDwgc2xpZGluZykge1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gLTE7XG4gICAgICB9XG4gICAgICB2YXIgdGltZWxpbmVPZmZzZXQgPSB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIC8vIFVzZSBQbGF5bGlzdCBFWFQtWC1TVEFSVDpUSU1FLU9GRlNFVCB3aGVuIHNldFxuICAgICAgICAvLyBQcmlvcml0aXplIE11bHRpdmFyaWFudCBQbGF5bGlzdCBvZmZzZXQgc28gdGhhdCBtYWluLCBhdWRpbywgYW5kIHN1YnRpdGxlIHN0cmVhbS1jb250cm9sbGVyIHN0YXJ0IHRpbWVzIG1hdGNoXG4gICAgICAgIHZhciBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID0gdGhpcy5zdGFydFRpbWVPZmZzZXQgIT09IG51bGw7XG4gICAgICAgIHZhciBzdGFydFRpbWVPZmZzZXQgPSBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID8gdGhpcy5zdGFydFRpbWVPZmZzZXQgOiBkZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCAhPT0gbnVsbCAmJiBpc0Zpbml0ZU51bWJlcihzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHNsaWRpbmcgKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gZGV0YWlscy5lZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFydFBvc2l0aW9uID0gTWF0aC5taW4oTWF0aC5tYXgoc2xpZGluZywgc3RhcnRQb3NpdGlvbiksIHNsaWRpbmcgKyBkZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgICAgIHRoaXMubG9nKFwiU2V0dGluZyBzdGFydFBvc2l0aW9uIHRvIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiIGZvciBzdGFydCB0aW1lIG9mZnNldCBcIiArIHN0YXJ0VGltZU9mZnNldCArIFwiIGZvdW5kIGluIFwiICsgKG9mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPyAnbXVsdGl2YXJpYW50JyA6ICdtZWRpYScpICsgXCIgcGxheWxpc3RcIik7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAvLyBMZWF2ZSB0aGlzLnN0YXJ0UG9zaXRpb24gYXQgLTEsIHNvIHRoYXQgd2UgY2FuIHVzZSBgZ2V0SW5pdGlhbExpdmVGcmFnbWVudGAgbG9naWMgd2hlbiBzdGFydFBvc2l0aW9uIGhhc1xuICAgICAgICAgIC8vIG5vdCBiZWVuIHNwZWNpZmllZCB2aWEgdGhlIGNvbmZpZyBvciBhbiBhcyBhbiBhcmd1bWVudCB0byBzdGFydExvYWQgKCMzNzM2KS5cbiAgICAgICAgICBzdGFydFBvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBzbGlkaW5nO1xuICAgICAgICAgIHRoaXMubG9nKFwiU2V0dGluZyBzdGFydFBvc2l0aW9uIHRvIC0xIHRvIHN0YXJ0IGF0IGxpdmUgZWRnZSBcIiArIHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nKFwic2V0dGluZyBzdGFydFBvc2l0aW9uIHRvIDAgYnkgZGVmYXVsdFwiKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb24gKyB0aW1lbGluZU9mZnNldDtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gKyB0aW1lbGluZU9mZnNldDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRMb2FkUG9zaXRpb24gPSBmdW5jdGlvbiBnZXRMb2FkUG9zaXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMkaGxzO1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgaWYgKChfdGhpcyRobHMgPSB0aGlzLmhscykgIT0gbnVsbCAmJiBfdGhpcyRobHMuaGFzRW5vdWdoVG9TdGFydCAmJiBtZWRpYSkge1xuICAgICAgICBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0TG9hZFBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVGcmFnTG9hZEFib3J0ZWQgPSBmdW5jdGlvbiBoYW5kbGVGcmFnTG9hZEFib3J0ZWQoZnJhZywgcGFydCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNtdXhlciAmJiBmcmFnLnR5cGUgPT09IHRoaXMucGxheWxpc3RUeXBlICYmIGlzTWVkaWFGcmFnbWVudChmcmFnKSAmJiBmcmFnLnN0YXRzLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpcy5sb2coXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyAocGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIFwiICsgdGhpcy5wbGF5bGlzdExhYmVsKCkgKyBcIiBcIiArIGZyYWcubGV2ZWwgKyBcIiB3YXMgYWJvcnRlZFwiKTtcbiAgICAgICAgdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZXNldEZyYWdtZW50TG9hZGluZyA9IGZ1bmN0aW9uIHJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpIHtcbiAgICAgIGlmICghdGhpcy5mcmFnQ3VycmVudCB8fCAhdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgJiYgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnbWVudE9yS2V5TG9hZEVycm9yID0gZnVuY3Rpb24gb25GcmFnbWVudE9yS2V5TG9hZEVycm9yKGZpbHRlclR5cGUsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyRobHMkbGF0ZXN0TGV2ZWw7XG4gICAgICBpZiAoZGF0YS5jaHVua01ldGEgJiYgIWRhdGEuZnJhZykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoZGF0YS5jaHVua01ldGEpO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGRhdGEuZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAvLyBIYW5kbGUgZnJhZyBlcnJvciByZWxhdGVkIHRvIGNhbGxlcidzIGZpbHRlclR5cGVcbiAgICAgIGlmICghZnJhZyB8fCBmcmFnLnR5cGUgIT09IGZpbHRlclR5cGUgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICB2YXIgX3RoaXMkZnJhZ0N1cnJlbnQ7XG4gICAgICAgIHRoaXMud2FybihcIkZyYWcgbG9hZCBlcnJvciBtdXN0IG1hdGNoIGN1cnJlbnQgZnJhZyB0byByZXRyeSBcIiArIGZyYWcudXJsICsgXCIgPiBcIiArICgoX3RoaXMkZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZnJhZ0N1cnJlbnQudXJsKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBnYXBUYWdFbmNvdW50ZXJlZCA9IGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQO1xuICAgICAgaWYgKGdhcFRhZ0VuY291bnRlcmVkKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGtlZXAgcmV0cnlpbmcgdW50aWwgdGhlIGxpbWl0IHdpbGwgYmUgcmVhY2hlZFxuICAgICAgdmFyIGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICAgIGlmICghZXJyb3JBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYWN0aW9uID0gZXJyb3JBY3Rpb24uYWN0aW9uLFxuICAgICAgICBmbGFncyA9IGVycm9yQWN0aW9uLmZsYWdzLFxuICAgICAgICBfZXJyb3JBY3Rpb24kcmV0cnlDb3UgPSBlcnJvckFjdGlvbi5yZXRyeUNvdW50LFxuICAgICAgICByZXRyeUNvdW50ID0gX2Vycm9yQWN0aW9uJHJldHJ5Q291ID09PSB2b2lkIDAgPyAwIDogX2Vycm9yQWN0aW9uJHJldHJ5Q291LFxuICAgICAgICByZXRyeUNvbmZpZyA9IGVycm9yQWN0aW9uLnJldHJ5Q29uZmlnO1xuICAgICAgdmFyIGNvdWxkUmV0cnkgPSAhIXJldHJ5Q29uZmlnO1xuICAgICAgdmFyIHJldHJ5ID0gY291bGRSZXRyeSAmJiBhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3Q7XG4gICAgICB2YXIgbm9BbHRlcm5hdGUgPSBjb3VsZFJldHJ5ICYmICFlcnJvckFjdGlvbi5yZXNvbHZlZCAmJiBmbGFncyA9PT0gRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDtcbiAgICAgIHZhciBsaXZlID0gKF90aGlzJGhscyRsYXRlc3RMZXZlbCA9IHRoaXMuaGxzLmxhdGVzdExldmVsRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscyRsYXRlc3RMZXZlbC5saXZlO1xuICAgICAgaWYgKCFyZXRyeSAmJiBub0FsdGVybmF0ZSAmJiBpc01lZGlhRnJhZ21lbnQoZnJhZykgJiYgIWZyYWcuZW5kTGlzdCAmJiBsaXZlICYmICFpc1VudXNhYmxlS2V5RXJyb3IoZGF0YSkpIHtcbiAgICAgICAgdGhpcy5yZXNldEZyYWdtZW50RXJyb3JzKGZpbHRlclR5cGUpO1xuICAgICAgICB0aGlzLnRyZWF0QXNHYXAoZnJhZyk7XG4gICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoKHJldHJ5IHx8IG5vQWx0ZXJuYXRlKSAmJiByZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkpIHtcbiAgICAgICAgdmFyIF9kYXRhJHJlc3BvbnNlO1xuICAgICAgICB2YXIgb2ZmbGluZVN0YXR1cyA9IG9mZmxpbmVIdHRwU3RhdHVzKChfZGF0YSRyZXNwb25zZSA9IGRhdGEucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRyZXNwb25zZS5jb2RlKTtcbiAgICAgICAgdmFyIGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoKTtcbiAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBpZiAob2ZmbGluZVN0YXR1cykge1xuICAgICAgICAgIHRoaXMubG9nKFwiV2FpdGluZyBmb3IgY29ubmVjdGlvbiAob2ZmbGluZSlcIik7XG4gICAgICAgICAgdGhpcy5yZXRyeURhdGUgPSBJbmZpbml0eTtcbiAgICAgICAgICBkYXRhLnJlYXNvbiA9ICdvZmZsaW5lJztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgXCIgKyBmaWx0ZXJUeXBlICsgXCIgXCIgKyBmcmFnLmxldmVsICsgXCIgZXJyb3JlZCB3aXRoIFwiICsgZGF0YS5kZXRhaWxzICsgXCIsIHJldHJ5aW5nIGxvYWRpbmcgXCIgKyAocmV0cnlDb3VudCArIDEpICsgXCIvXCIgKyByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSArIFwiIGluIFwiICsgZGVsYXkgKyBcIm1zXCIpO1xuICAgICAgfSBlbHNlIGlmIChyZXRyeUNvbmZpZykge1xuICAgICAgICB0aGlzLnJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZSk7XG4gICAgICAgIGlmIChyZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkpIHtcbiAgICAgICAgICAvLyBOZXR3b3JrIHJldHJ5IGlzIHNraXBwZWQgd2hlbiBsZXZlbCBzd2l0Y2ggaXMgcHJlZmVycmVkXG4gICAgICAgICAgaWYgKCFnYXBUYWdFbmNvdW50ZXJlZCAmJiBhY3Rpb24gIT09IE5ldHdvcmtFcnJvckFjdGlvbi5SZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseSkge1xuICAgICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndhcm4oZGF0YS5kZXRhaWxzICsgXCIgcmVhY2hlZCBvciBleGNlZWRlZCBtYXggcmV0cnkgKFwiICsgcmV0cnlDb3VudCArIFwiKVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgIH1cbiAgICAgIC8vIFBlcmZvcm0gbmV4dCBhc3luYyB0aWNrIHNvb25lciB0byBzcGVlZCB1cCBlcnJvciBhY3Rpb24gcmVzb2x1dGlvblxuICAgICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tSZXRyeURhdGUgPSBmdW5jdGlvbiBjaGVja1JldHJ5RGF0ZSgpIHtcbiAgICAgIHZhciBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgIHZhciB3YWl0aW5nRm9yQ29ubmVjdGlvbiA9IHJldHJ5RGF0ZSA9PT0gSW5maW5pdHk7XG4gICAgICBpZiAoIXJldHJ5RGF0ZSB8fCBub3cgPj0gcmV0cnlEYXRlIHx8IHdhaXRpbmdGb3JDb25uZWN0aW9uICYmICFvZmZsaW5lSHR0cFN0YXR1cygwKSkge1xuICAgICAgICBpZiAod2FpdGluZ0ZvckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLmxvZyhcIkNvbm5lY3Rpb24gcmVzdG9yZWQgKG9ubGluZSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZWR1Y2VMZW5ndGhBbmRGbHVzaEJ1ZmZlciA9IGZ1bmN0aW9uIHJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpIHtcbiAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICB2YXIgcGxheWxpc3RUeXBlID0gZGF0YS5wYXJlbnQ7XG4gICAgICAgIHZhciBidWZmZXJlZEluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciwgcGxheWxpc3RUeXBlKTtcbiAgICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICAgIHZhciBidWZmZXJlZCA9IGJ1ZmZlcmVkSW5mbyAmJiBidWZmZXJlZEluZm8ubGVuID4gMC41O1xuICAgICAgICBpZiAoYnVmZmVyZWQpIHtcbiAgICAgICAgICB0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChidWZmZXJlZEluZm8ubGVuLCAoZnJhZyA9PSBudWxsID8gdm9pZCAwIDogZnJhZy5kdXJhdGlvbikgfHwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbHVzaEJ1ZmZlciA9ICFidWZmZXJlZDtcbiAgICAgICAgaWYgKGZsdXNoQnVmZmVyKSB7XG4gICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgIHRoaXMud2FybihcIkJ1ZmZlciBmdWxsIGVycm9yIHdoaWxlIG1lZGlhLmN1cnJlbnRUaW1lIChcIiArIHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCkgKyBcIikgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBcIiArIHBsYXlsaXN0VHlwZSArIFwiIGJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gZmx1c2hCdWZmZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRGcmFnbWVudEVycm9ycyA9IGZ1bmN0aW9uIHJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZSkge1xuICAgICAgaWYgKGZpbHRlclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKSB7XG4gICAgICAgIC8vIFJlc2V0IGN1cnJlbnQgZnJhZ21lbnQgc2luY2UgYXVkaW8gdHJhY2sgYXVkaW8gaXMgZXNzZW50aWFsIGFuZCBtYXkgbm90IGhhdmUgYSBmYWlsLW92ZXIgdHJhY2tcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBGcmFnbWVudCBlcnJvcnMgdGhhdCByZXN1bHQgaW4gYSBsZXZlbCBzd2l0Y2ggb3IgcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgICAgLy8gc2hvdWxkIHJlc2V0IHRoZSBzdHJlYW0gY29udHJvbGxlciBzdGF0ZSB0byBpZGxlXG4gICAgICBpZiAoIXRoaXMuaGxzLmhhc0Vub3VnaFRvU3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFmdGVyQnVmZmVyRmx1c2hlZCA9IGZ1bmN0aW9uIGFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYSwgYnVmZmVyVHlwZSwgcGxheWxpc3RUeXBlKSB7XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWFcbiAgICAgIC8vIChzbyB0aGF0IHdlIHdpbGwgY2hlY2sgYWdhaW5zdCB2aWRlby5idWZmZXJlZCByYW5nZXMgaW4gY2FzZSBvZiBhbHQgYXVkaW8gdHJhY2spXG4gICAgICB2YXIgYnVmZmVyZWRUaW1lUmFuZ2VzID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoYnVmZmVyVHlwZSwgYnVmZmVyZWRUaW1lUmFuZ2VzLCBwbGF5bGlzdFR5cGUpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZXNldExvYWRpbmdTdGF0ZSA9IGZ1bmN0aW9uIHJlc2V0TG9hZGluZ1N0YXRlKCkge1xuICAgICAgdGhpcy5sb2coJ1Jlc2V0IGxvYWRpbmcgc3RhdGUnKTtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQgPSBmdW5jdGlvbiByZXNldFN0YXJ0V2hlbk5vdExvYWRlZCgpIHtcbiAgICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgZmlyc3QgZnJhZyByZXF1ZXN0IGZhaWxlZFxuICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgICAgaWYgKCF0aGlzLmhscy5oYXNFbm91Z2hUb1N0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgICB2YXIgZGV0YWlscyA9IGxldmVsID8gbGV2ZWwuZGV0YWlscyA6IG51bGw7XG4gICAgICAgIGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGFydCBwb3NpdGlvbiBhbmQgcmV0dXJuIHRvIElETEUgdG8gcmVjb3ZlciBsaXZlIHN0YXJ0XG4gICAgICAgICAgdGhpcy5sb2coXCJyZXNldHRpbmcgc3RhcnRQb3NpdGlvbiBmb3IgbGl2ZSBzdGFydFwiKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24oZGV0YWlscywgZGV0YWlscy5mcmFnbWVudFN0YXJ0KTtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRXaGVuTWlzc2luZ0NvbnRleHQgPSBmdW5jdGlvbiByZXNldFdoZW5NaXNzaW5nQ29udGV4dChjaHVua01ldGEpIHtcbiAgICAgIHRoaXMubG9nKFwiTG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIHNuIFwiICsgY2h1bmtNZXRhLnNuICsgXCIgb2YgXCIgKyB0aGlzLnBsYXlsaXN0TGFiZWwoKSArIFwiIFwiICsgKGNodW5rTWV0YS5sZXZlbCA9PT0gLTEgPyAnPHJlbW92ZWQ+JyA6IGNodW5rTWV0YS5sZXZlbCkgKyBcIi4gVGhpcyBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5cIik7XG4gICAgICB0aGlzLnJlbW92ZVVuYnVmZmVyZWRGcmFncygpO1xuICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCgpO1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZVVuYnVmZmVyZWRGcmFncyA9IGZ1bmN0aW9uIHJlbW92ZVVuYnVmZmVyZWRGcmFncyhzdGFydCkge1xuICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShzdGFydCwgSW5maW5pdHksIHRoaXMucGxheWxpc3RUeXBlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlTGV2ZWxUaW1pbmcgPSBmdW5jdGlvbiB1cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgcGFydGlhbCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgICB2YXIgZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgICAgdGhpcy53YXJuKCdsZXZlbC5kZXRhaWxzIHVuZGVmaW5lZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcGFyc2VkID0gT2JqZWN0LmtleXMoZnJhZy5lbGVtZW50YXJ5U3RyZWFtcykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHR5cGUpIHtcbiAgICAgICAgdmFyIGluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgIHZhciBwYXJzZWREdXJhdGlvbiA9IGluZm8uZW5kUFRTIC0gaW5mby5zdGFydFBUUztcbiAgICAgICAgICBpZiAocGFyc2VkRHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgICAgLy8gRGVzdHJveSB0aGUgdHJhbnNtdXhlciBhZnRlciBpdCdzIG5leHQgdGltZSBvZmZzZXQgZmFpbGVkIHRvIGFkdmFuY2UgYmVjYXVzZSBkdXJhdGlvbiB3YXMgPD0gMC5cbiAgICAgICAgICAgIC8vIFRoZSBuZXcgdHJhbnNtdXhlciB3aWxsIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIHRpbWUgb2Zmc2V0IG1hdGNoaW5nIHRoZSBuZXh0IGZyYWdtZW50IHN0YXJ0LFxuICAgICAgICAgICAgLy8gcHJldmVudGluZyB0aGUgdGltZWxpbmUgZnJvbSBzaGlmdGluZy5cbiAgICAgICAgICAgIF90aGlzNy53YXJuKFwiQ291bGQgbm90IHBhcnNlIGZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIFwiICsgdHlwZSArIFwiIGR1cmF0aW9uIHJlbGlhYmx5IChcIiArIHBhcnNlZER1cmF0aW9uICsgXCIpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRyaWZ0ID0gcGFydGlhbCA/IDAgOiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIGluZm8uc3RhcnRQVFMsIGluZm8uZW5kUFRTLCBpbmZvLnN0YXJ0RFRTLCBpbmZvLmVuZERUUywgX3RoaXM3KTtcbiAgICAgICAgICBfdGhpczcuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgZHJpZnQ6IGRyaWZ0LFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBzdGFydDogaW5mby5zdGFydFBUUyxcbiAgICAgICAgICAgIGVuZDogaW5mby5lbmRQVFNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgZmFsc2UpO1xuICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgdmFyIF90aGlzJHRyYW5zbXV4ZXI7XG4gICAgICAgIHZhciBtZWRpYU5vdEZvdW5kID0gKChfdGhpcyR0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhbnNtdXhlci5lcnJvcikgPT09IG51bGw7XG4gICAgICAgIGlmIChsZXZlbC5mcmFnbWVudEVycm9yID09PSAwIHx8IG1lZGlhTm90Rm91bmQgJiYgKGxldmVsLmZyYWdtZW50RXJyb3IgPCAyIHx8IGZyYWcuZW5kTGlzdCkpIHtcbiAgICAgICAgICAvLyBNYXJrIGFuZCB0cmFjayB0aGUgb2RkIChvciBsYXN0KSBlbXB0eSBzZWdtZW50IGFzIGEgZ2FwIHRvIGF2b2lkIHJlbG9hZGluZ1xuICAgICAgICAgIHRoaXMudHJlYXRBc0dhcChmcmFnLCBsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lZGlhTm90Rm91bmQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJGb3VuZCBubyBtZWRpYSBpbiBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBcIiArIHRoaXMucGxheWxpc3RMYWJlbCgpICsgXCIgXCIgKyBmcmFnLmxldmVsICsgXCIgcmVzZXR0aW5nIHRyYW5zbXV4ZXIgdG8gZmFsbGJhY2sgdG8gcGxheWxpc3QgdGltaW5nXCIpO1xuICAgICAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcmVhc29uOiBcIkZvdW5kIG5vIG1lZGlhIGluIG1zbiBcIiArIGZyYWcuc24gKyBcIiBvZiBcIiArIHRoaXMucGxheWxpc3RMYWJlbCgpICsgXCIgXFxcIlwiICsgbGV2ZWwudXJsICsgXCJcXFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIHRoaXMgZXJyb3IgZmFsbHRocm91Z2guIE1hcmtpbmcgcGFyc2VkIHdpbGwgYWxsb3cgYWR2YW5jaW5nIHRvIG5leHQgZnJhZ21lbnQuXG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5sb2coXCJQYXJzZWQgXCIgKyBmcmFnLnR5cGUgKyBcIiBzbjogXCIgKyBmcmFnLnNuICsgKHBhcnQgPyAnIHBhcnQ6ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgXCIgKyB0aGlzLmZyYWdJbmZvKGZyYWcsIGZhbHNlLCBwYXJ0KSArIFwiKVwiKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0VELCB7XG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnBsYXlsaXN0TGFiZWwgPSBmdW5jdGlvbiBwbGF5bGlzdExhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjayc7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJhZ0luZm8gPSBmdW5jdGlvbiBmcmFnSW5mbyhmcmFnLCBwdHMsIHBhcnQpIHtcbiAgICAgIHZhciBfcmVmMiwgX3JlZjM7XG4gICAgICBpZiAocHRzID09PSB2b2lkIDApIHtcbiAgICAgICAgcHRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBsYXlsaXN0TGFiZWwoKSArIFwiIFwiICsgZnJhZy5sZXZlbCArIFwiIChcIiArIChwYXJ0ID8gJ3BhcnQnIDogJ2ZyYWcnKSArIFwiOltcIiArICgoX3JlZjIgPSBwdHMgJiYgIXBhcnQgPyBmcmFnLnN0YXJ0UFRTIDogKHBhcnQgfHwgZnJhZykuc3RhcnQpICE9IG51bGwgPyBfcmVmMiA6IE5hTikudG9GaXhlZCgzKSArIFwiLVwiICsgKChfcmVmMyA9IHB0cyAmJiAhcGFydCA/IGZyYWcuZW5kUFRTIDogKHBhcnQgfHwgZnJhZykuZW5kKSAhPSBudWxsID8gX3JlZjMgOiBOYU4pLnRvRml4ZWQoMykgKyBcIl1cIiArIChwYXJ0ICYmIGZyYWcudHlwZSA9PT0gJ21haW4nID8gJ0lOREVQRU5ERU5UPScgKyAocGFydC5pbmRlcGVuZGVudCA/ICdZRVMnIDogJ05PJykgOiAnJyk7XG4gICAgfTtcbiAgICBfcHJvdG8udHJlYXRBc0dhcCA9IGZ1bmN0aW9uIHRyZWF0QXNHYXAoZnJhZywgbGV2ZWwpIHtcbiAgICAgIGlmIChsZXZlbCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICB9XG4gICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldFRyYW5zbXV4ZXIgPSBmdW5jdGlvbiByZXNldFRyYW5zbXV4ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkdHJhbnNtdXhlcjI7XG4gICAgICAoX3RoaXMkdHJhbnNtdXhlcjIgPSB0aGlzLnRyYW5zbXV4ZXIpID09IG51bGwgfHwgX3RoaXMkdHJhbnNtdXhlcjIucmVzZXQoKTtcbiAgICB9O1xuICAgIF9wcm90by5yZWNvdmVyV29ya2VyRXJyb3IgPSBmdW5jdGlvbiByZWNvdmVyV29ya2VyRXJyb3IoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZXZlbnQgPT09ICdkZW11eGVyV29ya2VyJykge1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgICAgIHRoaXMudHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKCk7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQmFzZVN0cmVhbUNvbnRyb2xsZXIsIFt7XG4gICAgICBrZXk6IFwic3RhcnRQb3NpdGlvblZhbHVlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIG5leHRMb2FkUG9zaXRpb24gPSB0aGlzLm5leHRMb2FkUG9zaXRpb24sXG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IC0xICYmIG5leHRMb2FkUG9zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gbmV4dExvYWRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYnVmZmVyaW5nRW5hYmxlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmluZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5GbGlnaHRGcmFnXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcmFnOiB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRpbWVsaW5lT2Zmc2V0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGNvbmZpZ3VyZWRUaW1lbGluZU9mZnNldCA9IHRoaXMuY29uZmlnLnRpbWVsaW5lT2Zmc2V0O1xuICAgICAgICBpZiAoY29uZmlndXJlZFRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIF90aGlzJGdldExldmVsRGV0YWlscztcbiAgICAgICAgICByZXR1cm4gKChfdGhpcyRnZXRMZXZlbERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZ2V0TGV2ZWxEZXRhaWxzLmFwcGxpZWRUaW1lbGluZU9mZnNldCkgfHwgY29uZmlndXJlZFRpbWVsaW5lT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcmltYXJ5UHJlZmV0Y2hcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoaW50ZXJzdGl0aWFsc0VuYWJsZWQodGhpcy5jb25maWcpKSB7XG4gICAgICAgICAgdmFyIF90aGlzJGhscyRpbnRlcnN0aXRpYTtcbiAgICAgICAgICB2YXIgcGxheWluZ0ludGVyc3RpdGlhbCA9IChfdGhpcyRobHMkaW50ZXJzdGl0aWEgPSB0aGlzLmhscy5pbnRlcnN0aXRpYWxzTWFuYWdlcikgPT0gbnVsbCB8fCAoX3RoaXMkaGxzJGludGVyc3RpdGlhID0gX3RoaXMkaGxzJGludGVyc3RpdGlhLnBsYXlpbmdJdGVtKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzJGludGVyc3RpdGlhLmV2ZW50O1xuICAgICAgICAgIGlmIChwbGF5aW5nSW50ZXJzdGl0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGF0ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0U3RhdGUpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICAgIHRoaXMubG9nKHByZXZpb3VzU3RhdGUgKyBcIi0+XCIgKyBuZXh0U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICB9KFRhc2tMb29wKTtcbiAgZnVuY3Rpb24gaW50ZXJzdGl0aWFsc0VuYWJsZWQoY29uZmlnKSB7XG4gICAgcmV0dXJuICEhY29uZmlnLmludGVyc3RpdGlhbHNDb250cm9sbGVyICYmIGNvbmZpZy5lbmFibGVJbnRlcnN0aXRpYWxQbGF5YmFjayAhPT0gZmFsc2U7XG4gIH1cblxuICB2YXIgQ2h1bmtDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2h1bmtDYWNoZSgpIHtcbiAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ2h1bmtDYWNoZS5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnB1c2ggPSBmdW5jdGlvbiBwdXNoKGNodW5rKSB7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgIHRoaXMuZGF0YUxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHZhciBjaHVua3MgPSB0aGlzLmNodW5rcyxcbiAgICAgICAgZGF0YUxlbmd0aCA9IHRoaXMuZGF0YUxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoIWNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgfSBlbHNlIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IGNodW5rc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmNodW5rcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBDaHVua0NhY2hlO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBmb290ZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYW4gSUQzIGZvb3RlciBpcyBmb3VuZFxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQGdyb3VwIElEM1xuICAgKi9cbiAgZnVuY3Rpb24gaXNJZDNGb290ZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLypcbiAgICAgKiBUaGUgZm9vdGVyIGlzIGEgY29weSBvZiB0aGUgaGVhZGVyLCBidXQgd2l0aCBhIGRpZmZlcmVudCBpZGVudGlmaWVyXG4gICAgICovXG4gICAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDMzICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OSkge1xuICAgICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4ZmYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4ZmYpIHtcbiAgICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGhlYWRlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBAZ3JvdXAgSUQzXG4gICAqL1xuICBmdW5jdGlvbiBpc0lkM0hlYWRlcihkYXRhLCBvZmZzZXQpIHtcbiAgICAvKlxuICAgICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgICAqIFswXSAgICAgPSAnSSdcbiAgICAgKiBbMV0gICAgID0gJ0QnXG4gICAgICogWzJdICAgICA9ICczJ1xuICAgICAqIFszLDRdICAgPSB7VmVyc2lvbn1cbiAgICAgKiBbNV0gICAgID0ge0ZsYWdzfVxuICAgICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAgICpcbiAgICAgKiBBbiBJRDN2MiB0YWcgY2FuIGJlIGRldGVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICAgKiBXaGVyZSB5eSBpcyBsZXNzIHRoYW4gJEZGLCB4eCBpcyB0aGUgJ2ZsYWdzJyBieXRlIGFuZCB6eiBpcyBsZXNzIHRoYW4gJDgwXG4gICAgICovXG4gICAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyBsb29rIGZvciAnSUQzJyBpZGVudGlmaWVyXG4gICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDQ5ICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHgzMykge1xuICAgICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4ZmYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4ZmYpIHtcbiAgICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIElEMyBzaXplXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gcmVhZCBmcm9tXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHJlYWRpbmdcbiAgICpcbiAgICogQHJldHVybnMgVGhlIHNpemVcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBncm91cCBJRDNcbiAgICovXG4gIGZ1bmN0aW9uIHJlYWRJZDNTaXplKGRhdGEsIG9mZnNldCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBzaXplID0gKGRhdGFbb2Zmc2V0XSAmIDB4N2YpIDw8IDIxO1xuICAgIHNpemUgfD0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDdmKSA8PCAxNDtcbiAgICBzaXplIHw9IChkYXRhW29mZnNldCArIDJdICYgMHg3ZikgPDwgNztcbiAgICBzaXplIHw9IGRhdGFbb2Zmc2V0ICsgM10gJiAweDdmO1xuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW55IGFkamFjZW50IElEMyB0YWdzIGZvdW5kIGluIGRhdGEgc3RhcnRpbmcgYXQgb2Zmc2V0LCBhcyBvbmUgYmxvY2sgb2YgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBhbnkgSUQzIHRhZ3MgZm91bmRcbiAgICogb3IgYHVuZGVmaW5lZGAgaWYgbm8gaGVhZGVyIGlzIGZvdW5kIGF0IHRoZSBzdGFydGluZyBvZmZzZXRcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBncm91cCBJRDNcbiAgICovXG4gIGZ1bmN0aW9uIGdldElkM0RhdGEoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdmFyIGZyb250ID0gb2Zmc2V0O1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHdoaWxlIChpc0lkM0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAvLyBJRDMgaGVhZGVyIGlzIDEwIGJ5dGVzXG4gICAgICBsZW5ndGggKz0gMTA7XG4gICAgICB2YXIgc2l6ZSA9IHJlYWRJZDNTaXplKGRhdGEsIG9mZnNldCArIDYpO1xuICAgICAgbGVuZ3RoICs9IHNpemU7XG4gICAgICBpZiAoaXNJZDNGb290ZXIoZGF0YSwgb2Zmc2V0ICsgMTApKSB7XG4gICAgICAgIC8vIElEMyBmb290ZXIgaXMgMTAgYnl0ZXNcbiAgICAgICAgbGVuZ3RoICs9IDEwO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBtYW5pZmVzdENvZGVjKSB7XG4gICAgdmFyIGFkdHNTYW1wbGluZ1JhdGVzID0gWzk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MF07XG4gICAgdmFyIGJ5dGUyID0gZGF0YVtvZmZzZXQgKyAyXTtcbiAgICB2YXIgYWR0c1NhbXBsaW5nSW5kZXggPSBieXRlMiA+PiAyICYgMHhmO1xuICAgIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+IDEyKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6XCIgKyBhZHRzU2FtcGxpbmdJbmRleCk7XG4gICAgICBvYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSAocHJvZmlsZV9PYmplY3RUeXBlKzEpXG4gICAgdmFyIGFkdHNPYmplY3RUeXBlID0gKGJ5dGUyID4+IDYgJiAweDMpICsgMTtcbiAgICB2YXIgY2hhbm5lbENvdW50ID0gZGF0YVtvZmZzZXQgKyAzXSA+PiA2ICYgMHgzIHwgKGJ5dGUyICYgMSkgPDwgMjtcbiAgICB2YXIgY29kZWMgPSAnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGU7XG4gICAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgICBJU08vSUVDIDE0NDk2LTMgLSBUYWJsZSAxLjEzIOKAlCBTeW50YXggb2YgQXVkaW9TcGVjaWZpY0NvbmZpZygpXG4gICAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcbiAgICAgIDA6IE51bGxcbiAgICAgIDE6IEFBQyBNYWluXG4gICAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxuICAgICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcbiAgICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgICBzYW1wbGluZyBmcmVxXG4gICAgICAwOiA5NjAwMCBIelxuICAgICAgMTogODgyMDAgSHpcbiAgICAgIDI6IDY0MDAwIEh6XG4gICAgICAzOiA0ODAwMCBIelxuICAgICAgNDogNDQxMDAgSHpcbiAgICAgIDU6IDMyMDAwIEh6XG4gICAgICA2OiAyNDAwMCBIelxuICAgICAgNzogMjIwNTAgSHpcbiAgICAgIDg6IDE2MDAwIEh6XG4gICAgICA5OiAxMjAwMCBIelxuICAgICAgMTA6IDExMDI1IEh6XG4gICAgICAxMTogODAwMCBIelxuICAgICAgMTI6IDczNTAgSHpcbiAgICAgIDEzOiBSZXNlcnZlZFxuICAgICAgMTQ6IFJlc2VydmVkXG4gICAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XG4gICAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgICBUaGVzZSBhcmUgdGhlIGNoYW5uZWwgY29uZmlndXJhdGlvbnM6XG4gICAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xuICAgICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAgIDI6IDIgY2hhbm5lbHM6IGZyb250LWxlZnQsIGZyb250LXJpZ2h0XG4gICAgKi9cbiAgICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuICAgIHZhciBzYW1wbGVyYXRlID0gYWR0c1NhbXBsaW5nUmF0ZXNbYWR0c1NhbXBsaW5nSW5kZXhdO1xuICAgIHZhciBhYWNTYW1wbGVJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICAgIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSB8fCBhZHRzT2JqZWN0VHlwZSA9PT0gMjkpIHtcbiAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYWJvdmUsIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICBhYWNTYW1wbGVJbmRleCAtPSAzO1xuICAgIH1cbiAgICB2YXIgY29uZmlnID0gW2FkdHNPYmplY3RUeXBlIDw8IDMgfCAoYWFjU2FtcGxlSW5kZXggJiAweDBlKSA+PiAxLCAoYWFjU2FtcGxlSW5kZXggJiAweDAxKSA8PCA3IHwgY2hhbm5lbENvdW50IDw8IDNdO1xuICAgIGxvZ2dlci5sb2coXCJtYW5pZmVzdCBjb2RlYzpcIiArIG1hbmlmZXN0Q29kZWMgKyBcIiwgcGFyc2VkIGNvZGVjOlwiICsgY29kZWMgKyBcIiwgY2hhbm5lbHM6XCIgKyBjaGFubmVsQ291bnQgKyBcIiwgcmF0ZTpcIiArIHNhbXBsZXJhdGUgKyBcIiAoQURUUyBvYmplY3QgdHlwZTpcIiArIGFkdHNPYmplY3RUeXBlICsgXCIgc2FtcGxpbmcgaW5kZXg6XCIgKyBhZHRzU2FtcGxpbmdJbmRleCArIFwiKVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICBzYW1wbGVyYXRlOiBzYW1wbGVyYXRlLFxuICAgICAgY2hhbm5lbENvdW50OiBjaGFubmVsQ291bnQsXG4gICAgICBjb2RlYzogY29kZWMsXG4gICAgICBwYXJzZWRDb2RlYzogY29kZWMsXG4gICAgICBtYW5pZmVzdENvZGVjOiBtYW5pZmVzdENvZGVjXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4kMShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmNikgPT09IDB4ZjA7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5O1xuICB9XG4gIGZ1bmN0aW9uIGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSB8IGRhdGFbb2Zmc2V0ICsgNF0gPDwgMyB8IChkYXRhW29mZnNldCArIDVdICYgMHhlMCkgPj4+IDU7XG4gIH1cbiAgZnVuY3Rpb24gY2FuR2V0RnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCArIDUgPCBkYXRhLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAgIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICAgIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuJDEoZGF0YSwgb2Zmc2V0KTtcbiAgfVxuICBmdW5jdGlvbiBjYW5QYXJzZSQxKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpICYmIGlzSGVhZGVyUGF0dGVybiQxKGRhdGEsIG9mZnNldCkgJiYgZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG4gIH1cbiAgZnVuY3Rpb24gcHJvYmUkMShkYXRhLCBvZmZzZXQpIHtcbiAgICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgQURUUyBmcmFtZSBmb2xsb3dzIGxhc3QgQURUUyBmcmFtZVxuICAgIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcbiAgICAgIHZhciBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQURUUyBmcmFtZSBMZW5ndGhcbiAgICAgIHZhciBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgICAgaWYgKGZyYW1lTGVuZ3RoIDw9IGhlYWRlckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlciQxKGRhdGEsIG5ld09mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpbml0VHJhY2tDb25maWcodHJhY2ssIG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICAgIHZhciBjb25maWcgPSBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9leHRlbmRzKHRyYWNrLCBjb25maWcpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRGcmFtZUR1cmF0aW9uKHNhbXBsZXJhdGUpIHtcbiAgICByZXR1cm4gMTAyNCAqIDkwMDAwIC8gc2FtcGxlcmF0ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICAgIHZhciBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gICAgICB2YXIgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSAtIGhlYWRlckxlbmd0aDtcbiAgICAgIGlmIChmcmFtZUxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofWApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlYWRlckxlbmd0aDogaGVhZGVyTGVuZ3RoLFxuICAgICAgICAgIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhcHBlbmRGcmFtZSQxKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICAgIHZhciBmcmFtZUR1cmF0aW9uID0gZ2V0RnJhbWVEdXJhdGlvbih0cmFjay5zYW1wbGVyYXRlKTtcbiAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICB2YXIgaGVhZGVyID0gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgIHZhciB1bml0O1xuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIHZhciBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aCxcbiAgICAgICAgaGVhZGVyTGVuZ3RoID0gaGVhZGVyLmhlYWRlckxlbmd0aDtcbiAgICAgIHZhciBfbGVuZ3RoID0gaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGg7XG4gICAgICB2YXIgbWlzc2luZyA9IE1hdGgubWF4KDAsIG9mZnNldCArIF9sZW5ndGggLSBkYXRhLmxlbmd0aCk7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUgJHtmcmFtZUluZGV4fSwgcHRzOiR7c3RhbXB9IGxlbmd0aEBvZmZzZXQvdG90YWw6ICR7ZnJhbWVMZW5ndGh9QCR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9IG1pc3Npbmc6ICR7bWlzc2luZ31gKTtcbiAgICAgIGlmIChtaXNzaW5nKSB7XG4gICAgICAgIHVuaXQgPSBuZXcgVWludDhBcnJheShfbGVuZ3RoIC0gaGVhZGVyTGVuZ3RoKTtcbiAgICAgICAgdW5pdC5zZXQoZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIGRhdGEubGVuZ3RoKSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bml0ID0gZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIF9sZW5ndGgpO1xuICAgICAgfVxuICAgICAgdmFyIF9zYW1wbGUgPSB7XG4gICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgIHB0czogc3RhbXBcbiAgICAgIH07XG4gICAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKF9zYW1wbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2FtcGxlOiBfc2FtcGxlLFxuICAgICAgICBsZW5ndGg6IF9sZW5ndGgsXG4gICAgICAgIG1pc3Npbmc6IG1pc3NpbmdcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIG92ZXJmbG93IGluY29tcGxldGUgaGVhZGVyXG4gICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIHVuaXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHVuaXQuc2V0KGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmxlbmd0aCksIDApO1xuICAgIHZhciBzYW1wbGUgPSB7XG4gICAgICB1bml0OiB1bml0LFxuICAgICAgcHRzOiBzdGFtcFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZTogc2FtcGxlLFxuICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICBtaXNzaW5nOiAtMVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBkYXRhIGNvbnRhaW5zIGFuIElEMyB0YWcuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gY2hlY2tcbiAgICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgY2hlY2tpbmdcbiAgICpcbiAgICogQHJldHVybnMgYHRydWVgIGlmIGFuIElEMyB0YWcgaXMgZm91bmRcbiAgICpcbiAgICogQGdyb3VwIElEM1xuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgZnVuY3Rpb24gY2FuUGFyc2VJZDMoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGlzSWQzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiYgcmVhZElkM1NpemUoZGF0YSwgb2Zmc2V0ICsgNikgKyAxMCA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIodmlldykge1xuICAgIGlmICh2aWV3IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmlldy5ieXRlT2Zmc2V0ID09IDAgJiYgdmlldy5ieXRlTGVuZ3RoID09IHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIFR5cGVkQXJyYXkgb3ZlciB0aGUgd2hvbGUgYnVmZmVyLlxuICAgICAgICByZXR1cm4gdmlldy5idWZmZXI7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGlzIGEgJ3ZpZXcnIG9uIHRoZSBidWZmZXIuICBDcmVhdGUgYSBuZXcgYnVmZmVyIHRoYXQgb25seSBjb250YWluc1xuICAgICAgLy8gdGhlIGRhdGEuICBOb3RlIHRoYXQgc2luY2UgdGhpcyBpc24ndCBhbiBBcnJheUJ1ZmZlciwgdGhlICduZXcnIGNhbGxcbiAgICAgIC8vIHdpbGwgYWxsb2NhdGUgYSBuZXcgYnVmZmVyIHRvIGhvbGQgdGhlIGNvcHkuXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmlldykuYnVmZmVyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvVWludDgoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkge1xuICAgICAgbGVuZ3RoID0gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3KGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBVaW50OEFycmF5KTtcbiAgfVxuICBmdW5jdGlvbiB2aWV3KGRhdGEsIG9mZnNldCwgbGVuZ3RoLCBUeXBlKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHVuc2FmZUdldEFycmF5QnVmZmVyKGRhdGEpO1xuICAgIHZhciBieXRlc1BlckVsZW1lbnQgPSAxO1xuICAgIGlmICgnQllURVNfUEVSX0VMRU1FTlQnIGluIFR5cGUpIHtcbiAgICAgIGJ5dGVzUGVyRWxlbWVudCA9IFR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgfVxuICAgIC8vIEFic29sdXRlIGVuZCBvZiB0aGUgfGRhdGF8IHZpZXcgd2l0aGluIHxidWZmZXJ8LlxuICAgIHZhciBkYXRhT2Zmc2V0ID0gaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkgPyBkYXRhLmJ5dGVPZmZzZXQgOiAwO1xuICAgIHZhciBkYXRhRW5kID0gKGRhdGFPZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGgpIC8gYnl0ZXNQZXJFbGVtZW50O1xuICAgIC8vIEFic29sdXRlIHN0YXJ0IG9mIHRoZSByZXN1bHQgd2l0aGluIHxidWZmZXJ8LlxuICAgIHZhciByYXdTdGFydCA9IChkYXRhT2Zmc2V0ICsgb2Zmc2V0KSAvIGJ5dGVzUGVyRWxlbWVudDtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIE1hdGgubWluKHJhd1N0YXJ0LCBkYXRhRW5kKSkpO1xuICAgIC8vIEFic29sdXRlIGVuZCBvZiB0aGUgcmVzdWx0IHdpdGhpbiB8YnVmZmVyfC5cbiAgICB2YXIgZW5kID0gTWF0aC5mbG9vcihNYXRoLm1pbihzdGFydCArIE1hdGgubWF4KGxlbmd0aCwgMCksIGRhdGFFbmQpKTtcbiAgICByZXR1cm4gbmV3IFR5cGUoYnVmZmVyLCBzdGFydCwgZW5kIC0gc3RhcnQpO1xuICB9XG4gIGZ1bmN0aW9uIHVuc2FmZUdldEFycmF5QnVmZmVyKHZpZXcpIHtcbiAgICBpZiAodmlldyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gdmlldztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyhvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciAmJiBvYmouYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIG9iai5ieXRlT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVJZDNJbWFnZUZyYW1lKGZyYW1lKSB7XG4gICAgdmFyIG1ldGFkYXRhRnJhbWUgPSB7XG4gICAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICBkYXRhOiAnJyxcbiAgICAgIG1pbWVUeXBlOiBudWxsLFxuICAgICAgcGljdHVyZVR5cGU6IG51bGxcbiAgICB9O1xuICAgIHZhciB1dGY4RW5jb2RpbmcgPSAweDAzO1xuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGZyYW1lLmRhdGFbMF0gIT09IHV0ZjhFbmNvZGluZykge1xuICAgICAgY29uc29sZS5sb2coJ0lnbm9yZSBmcmFtZSB3aXRoIHVucmVjb2duaXplZCBjaGFyYWN0ZXIgJyArICdlbmNvZGluZycpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIG1pbWVUeXBlRW5kSW5kZXggPSBmcmFtZS5kYXRhLnN1YmFycmF5KDEpLmluZGV4T2YoMCk7XG4gICAgaWYgKG1pbWVUeXBlRW5kSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgbWltZVR5cGUgPSB1dGY4QXJyYXlUb1N0cih0b1VpbnQ4KGZyYW1lLmRhdGEsIDEsIG1pbWVUeXBlRW5kSW5kZXgpKTtcbiAgICB2YXIgcGljdHVyZVR5cGUgPSBmcmFtZS5kYXRhWzIgKyBtaW1lVHlwZUVuZEluZGV4XTtcbiAgICB2YXIgZGVzY3JpcHRpb25FbmRJbmRleCA9IGZyYW1lLmRhdGEuc3ViYXJyYXkoMyArIG1pbWVUeXBlRW5kSW5kZXgpLmluZGV4T2YoMCk7XG4gICAgaWYgKGRlc2NyaXB0aW9uRW5kSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cih0b1VpbnQ4KGZyYW1lLmRhdGEsIDMgKyBtaW1lVHlwZUVuZEluZGV4LCBkZXNjcmlwdGlvbkVuZEluZGV4KSk7XG4gICAgdmFyIGRhdGE7XG4gICAgaWYgKG1pbWVUeXBlID09PSAnLS0+Jykge1xuICAgICAgZGF0YSA9IHV0ZjhBcnJheVRvU3RyKHRvVWludDgoZnJhbWUuZGF0YSwgNCArIG1pbWVUeXBlRW5kSW5kZXggKyBkZXNjcmlwdGlvbkVuZEluZGV4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGZyYW1lLmRhdGEuc3ViYXJyYXkoNCArIG1pbWVUeXBlRW5kSW5kZXggKyBkZXNjcmlwdGlvbkVuZEluZGV4KSk7XG4gICAgfVxuICAgIG1ldGFkYXRhRnJhbWUubWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICBtZXRhZGF0YUZyYW1lLnBpY3R1cmVUeXBlID0gcGljdHVyZVR5cGU7XG4gICAgbWV0YWRhdGFGcmFtZS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIG1ldGFkYXRhRnJhbWUuZGF0YSA9IGRhdGE7XG4gICAgcmV0dXJuIG1ldGFkYXRhRnJhbWU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIElEMyBQUklWIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gZnJhbWUgLSB0aGUgSUQzIFBSSVYgZnJhbWVcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGRlY29kZWQgSUQzIFBSSVYgZnJhbWVcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBncm91cCBJRDNcbiAgICovXG4gIGZ1bmN0aW9uIGRlY29kZUlkM1ByaXZGcmFtZShmcmFtZSkge1xuICAgIC8qXG4gICAgRm9ybWF0OiA8dGV4dCBzdHJpbmc+XFwwPGJpbmFyeSBkYXRhPlxuICAgICovXG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLCB0cnVlKTtcbiAgICB2YXIgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogb3duZXIsXG4gICAgICBkYXRhOiBwcml2YXRlRGF0YS5idWZmZXJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZXMgYW4gSUQzIHRleHQgZnJhbWVcbiAgICpcbiAgICogQHBhcmFtIGZyYW1lIC0gdGhlIElEMyB0ZXh0IGZyYW1lXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIElEMyB0ZXh0IGZyYW1lXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBAZ3JvdXAgSUQzXG4gICAqL1xuICBmdW5jdGlvbiBkZWNvZGVJZDNUZXh0RnJhbWUoZnJhbWUpIHtcbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAgIC8qXG4gICAgICBGb3JtYXQ6XG4gICAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1ZhbHVlfVxuICAgICAgKi9cbiAgICAgIHZhciBpbmRleCA9IDE7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgICAgdmFyIHZhbHVlID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgICBpbmZvOiBkZXNjcmlwdGlvbixcbiAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgWzEtP10gPSB7VmFsdWV9XG4gICAgKi9cbiAgICB2YXIgdGV4dCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgICBpbmZvOiAnJyxcbiAgICAgIGRhdGE6IHRleHRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIFVSTCBmcmFtZVxuICAgKlxuICAgKiBAcGFyYW0gZnJhbWUgLSB0aGUgSUQzIFVSTCBmcmFtZVxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBJRDMgVVJMIGZyYW1lXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBAZ3JvdXAgSUQzXG4gICAqL1xuICBmdW5jdGlvbiBkZWNvZGVJZDNVcmxGcmFtZShmcmFtZSkge1xuICAgIGlmIChmcmFtZS50eXBlID09PSAnV1hYWCcpIHtcbiAgICAgIC8qXG4gICAgICBGb3JtYXQ6XG4gICAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1VSTH1cbiAgICAgICovXG4gICAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDE7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgICAgdmFyIHZhbHVlID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgICBpbmZvOiBkZXNjcmlwdGlvbixcbiAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswLT9dID0ge1VSTH1cbiAgICAqL1xuICAgIHZhciB1cmwgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogJycsXG4gICAgICBkYXRhOiB1cmxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBJRDMgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSBmcmFtZSAtIHRoZSBJRDMgZnJhbWVcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGRlY29kZWQgSUQzIGZyYW1lXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBAZ3JvdXAgSUQzXG4gICAqL1xuICBmdW5jdGlvbiBkZWNvZGVJZDNGcmFtZShmcmFtZSkge1xuICAgIGlmIChmcmFtZS50eXBlID09PSAnUFJJVicpIHtcbiAgICAgIHJldHVybiBkZWNvZGVJZDNQcml2RnJhbWUoZnJhbWUpO1xuICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZVswXSA9PT0gJ1cnKSB7XG4gICAgICByZXR1cm4gZGVjb2RlSWQzVXJsRnJhbWUoZnJhbWUpO1xuICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZSA9PT0gJ0FQSUMnKSB7XG4gICAgICByZXR1cm4gZGVjb2RlSWQzSW1hZ2VGcmFtZShmcmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVJZDNUZXh0RnJhbWUoZnJhbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgb2YgYW4gSUQzIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHJlYWQgZnJvbVxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgZGF0YSBvZiB0aGUgSUQzIGZyYW1lXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBAZ3JvdXAgSUQzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRJZDNGcmFtZURhdGEoZGF0YSkge1xuICAgIC8qXG4gICAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXG4gICAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XG4gICAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICAgKi9cbiAgICB2YXIgdHlwZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gICAgdmFyIHNpemUgPSByZWFkSWQzU2l6ZShkYXRhLCA0KTtcbiAgICAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgICB2YXIgb2Zmc2V0ID0gMTA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgZGF0YTogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHNpemUpXG4gICAgfTtcbiAgfVxuXG4gIHZhciBIRUFERVJfRk9PVEVSX1NJWkUgPSAxMDtcbiAgdmFyIEZSQU1FX1NJWkUgPSAxMDtcbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gICAqXG4gICAqIEBwYXJhbSBpZDNEYXRhIC0gVGhlIElEMyBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAgICpcbiAgICogQHJldHVybnMgQXJyYXkgb2YgSUQzIGZyYW1lIG9iamVjdHNcbiAgICpcbiAgICogQGdyb3VwIElEM1xuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SWQzRnJhbWVzKGlkM0RhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgZnJhbWVzID0gW107XG4gICAgd2hpbGUgKGlzSWQzSGVhZGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIHZhciBzaXplID0gcmVhZElkM1NpemUoaWQzRGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICBpZiAoaWQzRGF0YVtvZmZzZXQgKyA1XSA+PiA2ICYgMSkge1xuICAgICAgICAvLyBza2lwIGV4dGVuZGVkIGhlYWRlclxuICAgICAgICBvZmZzZXQgKz0gSEVBREVSX0ZPT1RFUl9TSVpFO1xuICAgICAgfVxuICAgICAgLy8gc2tpcCBwYXN0IElEMyBoZWFkZXJcbiAgICAgIG9mZnNldCArPSBIRUFERVJfRk9PVEVSX1NJWkU7XG4gICAgICB2YXIgZW5kID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBmcmFtZXMgaW4gdGhlIElEMyB0YWdcbiAgICAgIHdoaWxlIChvZmZzZXQgKyBGUkFNRV9TSVpFIDwgZW5kKSB7XG4gICAgICAgIHZhciBmcmFtZURhdGEgPSBnZXRJZDNGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgICAgdmFyIGZyYW1lID0gZGVjb2RlSWQzRnJhbWUoZnJhbWVEYXRhKTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG4gICAgICAgIG9mZnNldCArPSBmcmFtZURhdGEuc2l6ZSArIEhFQURFUl9GT09URVJfU0laRTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0lkM0Zvb3RlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIG9mZnNldCArPSBIRUFERVJfRk9PVEVSX1NJWkU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFtZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBJRDMgZnJhbWUgaXMgYW4gRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZyYW1lXG4gICAqXG4gICAqIEBwYXJhbSBmcmFtZSAtIHRoZSBJRDMgZnJhbWVcbiAgICpcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBJRDMgZnJhbWUgaXMgYW4gRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZyYW1lXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBAZ3JvdXAgSUQzXG4gICAqL1xuICBmdW5jdGlvbiBpc0lkM1RpbWVzdGFtcEZyYW1lKGZyYW1lKSB7XG4gICAgcmV0dXJuIGZyYW1lICYmIGZyYW1lLmtleSA9PT0gJ1BSSVYnICYmIGZyYW1lLmluZm8gPT09ICdjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcCc7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIDMzIGJpdCB0aW1lc3RhbXAgZnJvbSBhbiBJRDMgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lU3RhbXBGcmFtZSAtIHRoZSBJRDMgZnJhbWVcbiAgICpcbiAgICogQHJldHVybnMgVGhlIHRpbWVzdGFtcFxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQGdyb3VwIElEM1xuICAgKi9cbiAgZnVuY3Rpb24gcmVhZElkM1RpbWVzdGFtcCh0aW1lU3RhbXBGcmFtZSkge1xuICAgIGlmICh0aW1lU3RhbXBGcmFtZS5kYXRhLmJ5dGVMZW5ndGggPT09IDgpIHtcbiAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGltZVN0YW1wRnJhbWUuZGF0YSk7XG4gICAgICAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLFxuICAgICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cbiAgICAgIHZhciBwdHMzM0JpdCA9IGRhdGFbM10gJiAweDE7XG4gICAgICB2YXIgdGltZXN0YW1wID0gKGRhdGFbNF0gPDwgMjMpICsgKGRhdGFbNV0gPDwgMTUpICsgKGRhdGFbNl0gPDwgNykgKyBkYXRhWzddO1xuICAgICAgdGltZXN0YW1wIC89IDQ1O1xuICAgICAgaWYgKHB0czMzQml0KSB7XG4gICAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcbiAgICAgIH0gLy8gMl4zMiAvIDkwXG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lc3RhbXApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciB0aGUgRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZvdW5kIGluIHRoZSBJRDMgZGF0YSBjaHVua1xuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIEJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgdGltZXN0YW1wXG4gICAqXG4gICAqIEBncm91cCBJRDNcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIGZ1bmN0aW9uIGdldElkM1RpbWVzdGFtcChkYXRhKSB7XG4gICAgdmFyIGZyYW1lcyA9IGdldElkM0ZyYW1lcyhkYXRhKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZyYW1lID0gZnJhbWVzW2ldO1xuICAgICAgaWYgKGlzSWQzVGltZXN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICAgIHJldHVybiByZWFkSWQzVGltZXN0YW1wKGZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBNZXRhZGF0YVNjaGVtYSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoTWV0YWRhdGFTY2hlbWEpIHtcbiAgICBNZXRhZGF0YVNjaGVtYVtcImF1ZGlvSWQzXCJdID0gXCJvcmcuaWQzXCI7XG4gICAgTWV0YWRhdGFTY2hlbWFbXCJkYXRlUmFuZ2VcIl0gPSBcImNvbS5hcHBsZS5xdWlja3RpbWUuSExTXCI7XG4gICAgTWV0YWRhdGFTY2hlbWFbXCJlbXNnXCJdID0gXCJodHRwczovL2FvbWVkaWEub3JnL2Vtc2cvSUQzXCI7XG4gICAgTWV0YWRhdGFTY2hlbWFbXCJtaXNia2x2XCJdID0gXCJ1cm46bWlzYjpLTFY6YmluOjE5MTAuMVwiO1xuICAgIHJldHVybiBNZXRhZGF0YVNjaGVtYTtcbiAgfSh7fSk7XG5cbiAgZnVuY3Rpb24gZHVtbXlUcmFjayh0eXBlLCBpbnB1dFRpbWVTY2FsZSkge1xuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgIHR5cGUgPSAnJztcbiAgICB9XG4gICAgaWYgKGlucHV0VGltZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICAgIGlucHV0VGltZVNjYWxlID0gOTAwMDA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaWQ6IC0xLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiBpbnB1dFRpbWVTY2FsZSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAtMSxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cblxuICB2YXIgQmFzZUF1ZGlvRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZUF1ZGlvRGVtdXhlcigpIHtcbiAgICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9pZDNUcmFjayA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgICAgdGhpcy5iYXNlUFRTID0gbnVsbDtcbiAgICAgIHRoaXMuaW5pdFBUUyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQmFzZUF1ZGlvRGVtdXhlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgICB0aGlzLl9pZDNUcmFjayA9IHtcbiAgICAgICAgdHlwZTogJ2lkMycsXG4gICAgICAgIGlkOiAzLFxuICAgICAgICBwaWQ6IC0xLFxuICAgICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgICBzYW1wbGVzOiBbXSxcbiAgICAgICAgZHJvcHBlZDogMFxuICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKGRlYXVsdFRpbWVzdGFtcCkge1xuICAgICAgdGhpcy5pbml0UFRTID0gZGVhdWx0VGltZXN0YW1wO1xuICAgICAgdGhpcy5yZXNldENvbnRpZ3VpdHkoKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldENvbnRpZ3VpdHkgPSBmdW5jdGlvbiByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgICB0aGlzLmJhc2VQVFMgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0UFRTID0gbnVsbDtcbiAgICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gICAgfTtcbiAgICBfcHJvdG8uY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5hcHBlbmRGcmFtZSA9IGZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHt9XG5cbiAgICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gICAgO1xuICAgIF9wcm90by5kZW11eCA9IGZ1bmN0aW9uIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICAgIGlmICh0aGlzLmNhY2hlZERhdGEpIHtcbiAgICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5jYWNoZWREYXRhLCBkYXRhKTtcbiAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBpZDNEYXRhID0gZ2V0SWQzRGF0YShkYXRhLCAwKTtcbiAgICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhID8gaWQzRGF0YS5sZW5ndGggOiAwO1xuICAgICAgdmFyIGxhc3REYXRhSW5kZXg7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgICAgdmFyIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgICB2YXIgdGltZXN0YW1wID0gaWQzRGF0YSA/IGdldElkM1RpbWVzdGFtcChpZDNEYXRhKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmJhc2VQVFMgPT09IG51bGwgfHwgdGhpcy5mcmFtZUluZGV4ID09PSAwICYmIGlzRmluaXRlTnVtYmVyKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgdGhpcy5iYXNlUFRTID0gaW5pdFBUU0ZuKHRpbWVzdGFtcCwgdGltZU9mZnNldCwgdGhpcy5pbml0UFRTKTtcbiAgICAgICAgdGhpcy5sYXN0UFRTID0gdGhpcy5iYXNlUFRTO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGFzdFBUUyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFM7XG4gICAgICB9XG5cbiAgICAgIC8vIG1vcmUgZXhwcmVzc2l2ZSB0aGFuIGFsdGVybmF0aXZlOiBpZDNEYXRhPy5sZW5ndGhcbiAgICAgIGlmIChpZDNEYXRhICYmIGlkM0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGR0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICAgIGRhdGE6IGlkM0RhdGEsXG4gICAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgIHZhciBmcmFtZSA9IHRoaXMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgIHRoaXMubGFzdFBUUyA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgbGFzdERhdGFJbmRleCA9IG9mZnNldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjYW5QYXJzZUlkMyhkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgLy8gYWZ0ZXIgYSBjYW5QYXJzZSwgYSBjYWxsIHRvIGdldElkM0RhdGEgKnNob3VsZCogYWx3YXlzIHJldHVybnMgc29tZSBkYXRhXG4gICAgICAgICAgaWQzRGF0YSA9IGdldElkM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgcHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgICAgIGRhdGE6IGlkM0RhdGEsXG4gICAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgICAgbGFzdERhdGFJbmRleCA9IG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGggJiYgbGFzdERhdGFJbmRleCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhcnRpYWxEYXRhID0gZGF0YS5zbGljZShsYXN0RGF0YUluZGV4KTtcbiAgICAgICAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMuY2FjaGVkRGF0YSwgcGFydGlhbERhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBwYXJ0aWFsRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvVHJhY2s6IHRyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrOiBkdW1teVRyYWNrKCksXG4gICAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKClcbiAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uZGVtdXhTYW1wbGVBZXMgPSBmdW5jdGlvbiBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiW1wiICsgdGhpcyArIFwiXSBUaGlzIGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTYW1wbGUtQUVTIGRlY3J5cHRpb25cIikpO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2godGltZU9mZnNldCkge1xuICAgICAgLy8gUGFyc2UgY2FjaGUgaW4gY2FzZSBvZiByZW1haW5pbmcgZnJhbWVzLlxuICAgICAgdmFyIGNhY2hlZERhdGEgPSB0aGlzLmNhY2hlZERhdGE7XG4gICAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmRlbXV4KGNhY2hlZERhdGEsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFjazogZHVtbXlUcmFjaygpLFxuICAgICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB0aGlzLl9pZDNUcmFjayA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlQXVkaW9EZW11eGVyO1xuICB9KCk7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIFBUU1xuICAgKiA8cD5cbiAgICogICAgdXNlIHRpbWVzdGFtcCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBOYU4gb3IgSW5maW5pdHlcbiAgICogPC9wPlxuICAgKi9cbiAgdmFyIGluaXRQVFNGbiA9IGZ1bmN0aW9uIGluaXRQVFNGbih0aW1lc3RhbXAsIHRpbWVPZmZzZXQsIGluaXRQVFMpIHtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIodGltZXN0YW1wKSkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcCAqIDkwO1xuICAgIH1cbiAgICB2YXIgaW5pdDkwa0h6ID0gaW5pdFBUUyA/IGluaXRQVFMuYmFzZVRpbWUgKiA5MDAwMCAvIGluaXRQVFMudGltZXNjYWxlIDogMDtcbiAgICByZXR1cm4gdGltZU9mZnNldCAqIDkwMDAwICsgaW5pdDkwa0h6O1xuICB9O1xuXG4gIC8qKlxuICAgKiAgTVBFRyBwYXJzZXIgaGVscGVyXG4gICAqL1xuXG4gIHZhciBjaHJvbWVWZXJzaW9uJDEgPSBudWxsO1xuICB2YXIgQml0cmF0ZXNNYXAgPSBbMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzg0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NiwgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwXTtcbiAgdmFyIFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xuICB2YXIgU2FtcGxlc0NvZWZmaWNpZW50cyA9IFtcbiAgLy8gTVBFRyAyLjVcbiAgWzAsXG4gIC8vIFJlc2VydmVkXG4gIDcyLFxuICAvLyBMYXllcjNcbiAgMTQ0LFxuICAvLyBMYXllcjJcbiAgMTIgLy8gTGF5ZXIxXG4gIF0sXG4gIC8vIFJlc2VydmVkXG4gIFswLFxuICAvLyBSZXNlcnZlZFxuICAwLFxuICAvLyBMYXllcjNcbiAgMCxcbiAgLy8gTGF5ZXIyXG4gIDAgLy8gTGF5ZXIxXG4gIF0sXG4gIC8vIE1QRUcgMlxuICBbMCxcbiAgLy8gUmVzZXJ2ZWRcbiAgNzIsXG4gIC8vIExheWVyM1xuICAxNDQsXG4gIC8vIExheWVyMlxuICAxMiAvLyBMYXllcjFcbiAgXSxcbiAgLy8gTVBFRyAxXG4gIFswLFxuICAvLyBSZXNlcnZlZFxuICAxNDQsXG4gIC8vIExheWVyM1xuICAxNDQsXG4gIC8vIExheWVyMlxuICAxMiAvLyBMYXllcjFcbiAgXV07XG4gIHZhciBCeXRlc0luU2xvdCA9IFswLFxuICAvLyBSZXNlcnZlZFxuICAxLFxuICAvLyBMYXllcjNcbiAgMSxcbiAgLy8gTGF5ZXIyXG4gIDQgLy8gTGF5ZXIxXG4gIF07XG4gIGZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICAgIC8vIFVzaW5nIGh0dHA6Ly93d3cuZGF0YXZveWFnZS5jb20vbXBnc2NyaXB0L21wZWdoZHIuaHRtIGFzIGEgcmVmZXJlbmNlXG4gICAgaWYgKG9mZnNldCArIDI0ID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgaWYgKGhlYWRlciAmJiBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gaGVhZGVyLnNhbXBsZXNQZXJGcmFtZSAqIDkwMDAwIC8gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHZhciBzYW1wbGUgPSB7XG4gICAgICAgIHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGgpLFxuICAgICAgICBwdHM6IHN0YW1wLFxuICAgICAgICBkdHM6IHN0YW1wXG4gICAgICB9O1xuICAgICAgdHJhY2suY29uZmlnID0gW107XG4gICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBoZWFkZXIuY2hhbm5lbENvdW50O1xuICAgICAgdHJhY2suc2FtcGxlcmF0ZSA9IGhlYWRlci5zYW1wbGVSYXRlO1xuICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzYW1wbGU6IHNhbXBsZSxcbiAgICAgICAgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGgsXG4gICAgICAgIG1pc3Npbmc6IDBcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAgIHZhciBtcGVnVmVyc2lvbiA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMyAmIDM7XG4gICAgdmFyIG1wZWdMYXllciA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMSAmIDM7XG4gICAgdmFyIGJpdFJhdGVJbmRleCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCAmIDE1O1xuICAgIHZhciBzYW1wbGVSYXRlSW5kZXggPSBkYXRhW29mZnNldCArIDJdID4+IDIgJiAzO1xuICAgIGlmIChtcGVnVmVyc2lvbiAhPT0gMSAmJiBiaXRSYXRlSW5kZXggIT09IDAgJiYgYml0UmF0ZUluZGV4ICE9PSAxNSAmJiBzYW1wbGVSYXRlSW5kZXggIT09IDMpIHtcbiAgICAgIHZhciBwYWRkaW5nQml0ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiAxICYgMTtcbiAgICAgIHZhciBjaGFubmVsTW9kZSA9IGRhdGFbb2Zmc2V0ICsgM10gPj4gNjtcbiAgICAgIHZhciBjb2x1bW5JbkJpdHJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAzIC0gbXBlZ0xheWVyIDogbXBlZ0xheWVyID09PSAzID8gMyA6IDQ7XG4gICAgICB2YXIgYml0UmF0ZSA9IEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGJpdFJhdGVJbmRleCAtIDFdICogMTAwMDtcbiAgICAgIHZhciBjb2x1bW5JblNhbXBsZVJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAwIDogbXBlZ1ZlcnNpb24gPT09IDIgPyAxIDogMjtcbiAgICAgIHZhciBzYW1wbGVSYXRlID0gU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgc2FtcGxlUmF0ZUluZGV4XTtcbiAgICAgIHZhciBjaGFubmVsQ291bnQgPSBjaGFubmVsTW9kZSA9PT0gMyA/IDEgOiAyOyAvLyBJZiBiaXRzIG9mIGNoYW5uZWwgbW9kZSBhcmUgYDExYCB0aGVuIGl0IGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1vbm8pXG4gICAgICB2YXIgc2FtcGxlQ29lZmZpY2llbnQgPSBTYW1wbGVzQ29lZmZpY2llbnRzW21wZWdWZXJzaW9uXVttcGVnTGF5ZXJdO1xuICAgICAgdmFyIGJ5dGVzSW5TbG90ID0gQnl0ZXNJblNsb3RbbXBlZ0xheWVyXTtcbiAgICAgIHZhciBzYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVDb2VmZmljaWVudCAqIDggKiBieXRlc0luU2xvdDtcbiAgICAgIHZhciBmcmFtZUxlbmd0aCA9IE1hdGguZmxvb3Ioc2FtcGxlQ29lZmZpY2llbnQgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIHBhZGRpbmdCaXQpICogYnl0ZXNJblNsb3Q7XG4gICAgICBpZiAoY2hyb21lVmVyc2lvbiQxID09PSBudWxsKSB7XG4gICAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvaSk7XG4gICAgICAgIGNocm9tZVZlcnNpb24kMSA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgICAgfVxuICAgICAgdmFyIG5lZWRDaHJvbWVGaXggPSAhIWNocm9tZVZlcnNpb24kMSAmJiBjaHJvbWVWZXJzaW9uJDEgPD0gODc7XG4gICAgICBpZiAobmVlZENocm9tZUZpeCAmJiBtcGVnTGF5ZXIgPT09IDIgJiYgYml0UmF0ZSA+PSAyMjQwMDAgJiYgY2hhbm5lbE1vZGUgPT09IDApIHtcbiAgICAgICAgLy8gV29yayBhcm91bmQgYnVnIGluIENocm9taXVtIGJ5IHNldHRpbmcgY2hhbm5lbE1vZGUgdG8gZHVhbC1jaGFubmVsICgwMSkgaW5zdGVhZCBvZiBzdGVyZW8gKDAwKVxuICAgICAgICBkYXRhW29mZnNldCArIDNdID0gZGF0YVtvZmZzZXQgKyAzXSB8IDB4ODA7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlLFxuICAgICAgICBjaGFubmVsQ291bnQ6IGNoYW5uZWxDb3VudCxcbiAgICAgICAgZnJhbWVMZW5ndGg6IGZyYW1lTGVuZ3RoLFxuICAgICAgICBzYW1wbGVzUGVyRnJhbWU6IHNhbXBsZXNQZXJGcmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xuICB9XG4gIGZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICAgIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdmFyIGhlYWRlclNpemUgPSA0O1xuICAgIHJldHVybiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSAmJiBoZWFkZXJTaXplIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xuICB9XG4gIGZ1bmN0aW9uIHByb2JlKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBNUEVHIGZyYW1lIGZvbGxvd3MgbGFzdCBNUEVHIGZyYW1lXG4gICAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICAgIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIC8vIE1QRUcgaGVhZGVyIExlbmd0aFxuICAgICAgdmFyIGhlYWRlckxlbmd0aCA9IDQ7XG4gICAgICAvLyBNUEVHIGZyYW1lIExlbmd0aFxuICAgICAgdmFyIGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG4gICAgICBpZiAoaGVhZGVyICE9IG51bGwgJiYgaGVhZGVyLmZyYW1lTGVuZ3RoKSB7XG4gICAgICAgIGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIEFBQ0RlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQXVkaW9EZW11eGVyKSB7XG4gICAgZnVuY3Rpb24gQUFDRGVtdXhlcihvYnNlcnZlciwgY29uZmlnKSB7XG4gICAgICB2YXIgX3RoaXM7XG4gICAgICBfdGhpcyA9IF9CYXNlQXVkaW9EZW11eGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgIF90aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgX3RoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgICAgX3RoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIF90aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoQUFDRGVtdXhlciwgX0Jhc2VBdWRpb0RlbXV4ZXIpO1xuICAgIHZhciBfcHJvdG8gPSBBQUNEZW11eGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICAgIF9CYXNlQXVkaW9EZW11eGVyLnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50LmNhbGwodGhpcywgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgICAgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsXG4gICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgIGlkOiAyLFxuICAgICAgICBwaWQ6IC0xLFxuICAgICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgICAgc2VnbWVudENvZGVjOiAnYWFjJyxcbiAgICAgICAgc2FtcGxlczogW10sXG4gICAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICAgIGRyb3BwZWQ6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgICA7XG4gICAgQUFDRGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIHByb2JlJDIoZGF0YSwgbG9nZ2VyKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgdGhlIEFEVFMgc3luYyB3b3JkXG4gICAgICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAgICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgICB2YXIgaWQzRGF0YSA9IGdldElkM0RhdGEoZGF0YSwgMCk7XG4gICAgICB2YXIgb2Zmc2V0ID0gKGlkM0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGlkM0RhdGEubGVuZ3RoKSB8fCAwO1xuICAgICAgaWYgKHByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgICAgaWYgKHByb2JlJDEoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmNhblBhcnNlID0gZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gY2FuUGFyc2UkMShkYXRhLCBvZmZzZXQpO1xuICAgIH07XG4gICAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgICAgaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRyYWNrLm1hbmlmZXN0Q29kZWMpO1xuICAgICAgdmFyIGZyYW1lID0gYXBwZW5kRnJhbWUkMSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gICAgICBpZiAoZnJhbWUgJiYgZnJhbWUubWlzc2luZyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQUFDRGVtdXhlcjtcbiAgfShCYXNlQXVkaW9EZW11eGVyKTtcblxuICB2YXIgZ2V0QXVkaW9CU0lEID0gZnVuY3Rpb24gZ2V0QXVkaW9CU0lEKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIGNoZWNrIHRoZSBic2lkIHRvIGNvbmZpcm0gYWMtMyB8IGVjLTNcbiAgICB2YXIgYnNpZCA9IDA7XG4gICAgdmFyIG51bUJpdHMgPSA1O1xuICAgIG9mZnNldCArPSBudW1CaXRzO1xuICAgIHZhciB0ZW1wID0gbmV3IFVpbnQzMkFycmF5KDEpOyAvLyB1bnNpZ25lZCAzMiBiaXQgZm9yIHRlbXBvcmFyeSBzdG9yYWdlXG4gICAgdmFyIG1hc2sgPSBuZXcgVWludDMyQXJyYXkoMSk7IC8vIHVuc2lnbmVkIDMyIGJpdCBtYXNrIHZhbHVlXG4gICAgdmFyIF9ieXRlID0gbmV3IFVpbnQ4QXJyYXkoMSk7IC8vIHVuc2lnbmVkIDggYml0IGZvciB0ZW1wb3Jhcnkgc3RvcmFnZVxuICAgIHdoaWxlIChudW1CaXRzID4gMCkge1xuICAgICAgX2J5dGVbMF0gPSBkYXRhW29mZnNldF07XG4gICAgICAvLyByZWFkIHJlbWFpbmluZyBiaXRzLCB1cHRvIDggYml0cyBhdCBhIHRpbWVcbiAgICAgIHZhciBiaXRzID0gTWF0aC5taW4obnVtQml0cywgOCk7XG4gICAgICB2YXIgc2hpZnQgPSA4IC0gYml0cztcbiAgICAgIG1hc2tbMF0gPSAweGZmMDAwMDAwID4+PiAyNCArIHNoaWZ0IDw8IHNoaWZ0O1xuICAgICAgdGVtcFswXSA9IChfYnl0ZVswXSAmIG1hc2tbMF0pID4+IHNoaWZ0O1xuICAgICAgYnNpZCA9ICFic2lkID8gdGVtcFswXSA6IGJzaWQgPDwgYml0cyB8IHRlbXBbMF07XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIG51bUJpdHMgLT0gYml0cztcbiAgICB9XG4gICAgcmV0dXJuIGJzaWQ7XG4gIH07XG5cbiAgdmFyIEFDM0RlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQXVkaW9EZW11eGVyKSB7XG4gICAgZnVuY3Rpb24gQUMzRGVtdXhlcihvYnNlcnZlcikge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfQmFzZUF1ZGlvRGVtdXhlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgIF90aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKEFDM0RlbXV4ZXIsIF9CYXNlQXVkaW9EZW11eGVyKTtcbiAgICB2YXIgX3Byb3RvID0gQUMzRGVtdXhlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgICBfQmFzZUF1ZGlvRGVtdXhlci5wcm90b3R5cGUucmVzZXRJbml0U2VnbWVudC5jYWxsKHRoaXMsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcbiAgICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL2FjLTMnLFxuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBpZDogMixcbiAgICAgICAgcGlkOiAtMSxcbiAgICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICAgIHNlZ21lbnRDb2RlYzogJ2FjMycsXG4gICAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgICBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgICBkcm9wcGVkOiAwXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmNhblBhcnNlID0gZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNjQgPCBkYXRhLmxlbmd0aDtcbiAgICB9O1xuICAgIF9wcm90by5hcHBlbmRGcmFtZSA9IGZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHZhciBmcmFtZUxlbmd0aCA9IF9hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gICAgICBpZiAoZnJhbWVMZW5ndGggIT09IC0xKSB7XG4gICAgICAgIHZhciBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW3RyYWNrLnNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2FtcGxlOiBzYW1wbGUsXG4gICAgICAgICAgbGVuZ3RoOiBmcmFtZUxlbmd0aCxcbiAgICAgICAgICBtaXNzaW5nOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBBQzNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpZDNEYXRhID0gZ2V0SWQzRGF0YShkYXRhLCAwKTtcbiAgICAgIGlmICghaWQzRGF0YSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvb2sgZm9yIHRoZSBhYy0zIHN5bmMgYnl0ZXNcbiAgICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4MGIgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg3NyAmJiBnZXRJZDNUaW1lc3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgLy8gY2hlY2sgdGhlIGJzaWQgdG8gY29uZmlybSBhYy0zXG4gICAgICBnZXRBdWRpb0JTSUQoZGF0YSwgb2Zmc2V0KSA8IDE2KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIEFDM0RlbXV4ZXI7XG4gIH0oQmFzZUF1ZGlvRGVtdXhlcik7XG4gIGZ1bmN0aW9uIF9hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgc3RhcnQsIHB0cywgZnJhbWVJbmRleCkge1xuICAgIGlmIChzdGFydCArIDggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xOyAvLyBub3QgZW5vdWdoIGJ5dGVzIGxlZnRcbiAgICB9XG4gICAgaWYgKGRhdGFbc3RhcnRdICE9PSAweDBiIHx8IGRhdGFbc3RhcnQgKyAxXSAhPT0gMHg3Nykge1xuICAgICAgcmV0dXJuIC0xOyAvLyBpbnZhbGlkIG1hZ2ljXG4gICAgfVxuXG4gICAgLy8gZ2V0IHNhbXBsZSByYXRlXG4gICAgdmFyIHNhbXBsaW5nUmF0ZUNvZGUgPSBkYXRhW3N0YXJ0ICsgNF0gPj4gNjtcbiAgICBpZiAoc2FtcGxpbmdSYXRlQ29kZSA+PSAzKSB7XG4gICAgICByZXR1cm4gLTE7IC8vIGludmFsaWQgc2FtcGxpbmcgcmF0ZVxuICAgIH1cbiAgICB2YXIgc2FtcGxpbmdSYXRlTWFwID0gWzQ4MDAwLCA0NDEwMCwgMzIwMDBdO1xuICAgIHZhciBzYW1wbGVSYXRlID0gc2FtcGxpbmdSYXRlTWFwW3NhbXBsaW5nUmF0ZUNvZGVdO1xuXG4gICAgLy8gZ2V0IGZyYW1lIHNpemVcbiAgICB2YXIgZnJhbWVTaXplQ29kZSA9IGRhdGFbc3RhcnQgKyA0XSAmIDB4M2Y7XG4gICAgdmFyIGZyYW1lU2l6ZU1hcCA9IFs2NCwgNjksIDk2LCA2NCwgNzAsIDk2LCA4MCwgODcsIDEyMCwgODAsIDg4LCAxMjAsIDk2LCAxMDQsIDE0NCwgOTYsIDEwNSwgMTQ0LCAxMTIsIDEyMSwgMTY4LCAxMTIsIDEyMiwgMTY4LCAxMjgsIDEzOSwgMTkyLCAxMjgsIDE0MCwgMTkyLCAxNjAsIDE3NCwgMjQwLCAxNjAsIDE3NSwgMjQwLCAxOTIsIDIwOCwgMjg4LCAxOTIsIDIwOSwgMjg4LCAyMjQsIDI0MywgMzM2LCAyMjQsIDI0NCwgMzM2LCAyNTYsIDI3OCwgMzg0LCAyNTYsIDI3OSwgMzg0LCAzMjAsIDM0OCwgNDgwLCAzMjAsIDM0OSwgNDgwLCAzODQsIDQxNywgNTc2LCAzODQsIDQxOCwgNTc2LCA0NDgsIDQ4NywgNjcyLCA0NDgsIDQ4OCwgNjcyLCA1MTIsIDU1NywgNzY4LCA1MTIsIDU1OCwgNzY4LCA2NDAsIDY5NiwgOTYwLCA2NDAsIDY5NywgOTYwLCA3NjgsIDgzNSwgMTE1MiwgNzY4LCA4MzYsIDExNTIsIDg5NiwgOTc1LCAxMzQ0LCA4OTYsIDk3NiwgMTM0NCwgMTAyNCwgMTExNCwgMTUzNiwgMTAyNCwgMTExNSwgMTUzNiwgMTE1MiwgMTI1MywgMTcyOCwgMTE1MiwgMTI1NCwgMTcyOCwgMTI4MCwgMTM5MywgMTkyMCwgMTI4MCwgMTM5NCwgMTkyMF07XG4gICAgdmFyIGZyYW1lTGVuZ3RoID0gZnJhbWVTaXplTWFwW2ZyYW1lU2l6ZUNvZGUgKiAzICsgc2FtcGxpbmdSYXRlQ29kZV0gKiAyO1xuICAgIGlmIChzdGFydCArIGZyYW1lTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBnZXQgY2hhbm5lbCBjb3VudFxuICAgIHZhciBjaGFubmVsTW9kZSA9IGRhdGFbc3RhcnQgKyA2XSA+PiA1O1xuICAgIHZhciBza2lwQ291bnQgPSAwO1xuICAgIGlmIChjaGFubmVsTW9kZSA9PT0gMikge1xuICAgICAgc2tpcENvdW50ICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGFubmVsTW9kZSAmIDEgJiYgY2hhbm5lbE1vZGUgIT09IDEpIHtcbiAgICAgICAgc2tpcENvdW50ICs9IDI7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbm5lbE1vZGUgJiA0KSB7XG4gICAgICAgIHNraXBDb3VudCArPSAyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbGZlb24gPSAoZGF0YVtzdGFydCArIDZdIDw8IDggfCBkYXRhW3N0YXJ0ICsgN10pID4+IDEyIC0gc2tpcENvdW50ICYgMTtcbiAgICB2YXIgY2hhbm5lbHNNYXAgPSBbMiwgMSwgMiwgMywgMywgNCwgNCwgNV07XG4gICAgdmFyIGNoYW5uZWxDb3VudCA9IGNoYW5uZWxzTWFwW2NoYW5uZWxNb2RlXSArIGxmZW9uO1xuXG4gICAgLy8gYnVpbGQgZGFjMyBib3hcbiAgICB2YXIgYnNpZCA9IGRhdGFbc3RhcnQgKyA1XSA+PiAzO1xuICAgIHZhciBic21vZCA9IGRhdGFbc3RhcnQgKyA1XSAmIDc7XG4gICAgdmFyIGNvbmZpZyA9IG5ldyBVaW50OEFycmF5KFtzYW1wbGluZ1JhdGVDb2RlIDw8IDYgfCBic2lkIDw8IDEgfCBic21vZCA+PiAyLCAoYnNtb2QgJiAzKSA8PCA2IHwgY2hhbm5lbE1vZGUgPDwgMyB8IGxmZW9uIDw8IDIgfCBmcmFtZVNpemVDb2RlID4+IDQsIGZyYW1lU2l6ZUNvZGUgPDwgNCAmIDB4ZTBdKTtcbiAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IDE1MzYgLyBzYW1wbGVSYXRlICogOTAwMDA7XG4gICAgdmFyIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgdmFyIHVuaXQgPSBkYXRhLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGZyYW1lTGVuZ3RoKTtcbiAgICB0cmFjay5jb25maWcgPSBjb25maWc7XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBzYW1wbGVSYXRlO1xuICAgIHRyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICB1bml0OiB1bml0LFxuICAgICAgcHRzOiBzdGFtcFxuICAgIH0pO1xuICAgIHJldHVybiBmcmFtZUxlbmd0aDtcbiAgfVxuXG4gIHZhciBNUDNEZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUF1ZGlvRGVtdXhlcikge1xuICAgIGZ1bmN0aW9uIE1QM0RlbXV4ZXIoKSB7XG4gICAgICByZXR1cm4gX0Jhc2VBdWRpb0RlbXV4ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHNMb29zZShNUDNEZW11eGVyLCBfQmFzZUF1ZGlvRGVtdXhlcik7XG4gICAgdmFyIF9wcm90byA9IE1QM0RlbXV4ZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgICAgX0Jhc2VBdWRpb0RlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQuY2FsbCh0aGlzLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgICB0aGlzLl9hdWRpb1RyYWNrID0ge1xuICAgICAgICBjb250YWluZXI6ICdhdWRpby9tcGVnJyxcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgaWQ6IDIsXG4gICAgICAgIHBpZDogLTEsXG4gICAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgICBzZWdtZW50Q29kZWM6ICdtcDMnLFxuICAgICAgICBzYW1wbGVzOiBbXSxcbiAgICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgICAgZHVyYXRpb246IHRyYWNrRHVyYXRpb24sXG4gICAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgICAgZHJvcHBlZDogMFxuICAgICAgfTtcbiAgICB9O1xuICAgIE1QM0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiBwcm9iZSQxKGRhdGEpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGRhdGEgY29udGFpbnMgSUQzIHRpbWVzdGFtcCBhbmQgTVBFRyBzeW5jIHdvcmRcbiAgICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICAgIHZhciBpZDNEYXRhID0gZ2V0SWQzRGF0YShkYXRhLCAwKTtcbiAgICAgIHZhciBvZmZzZXQgPSAoaWQzRGF0YSA9PSBudWxsID8gdm9pZCAwIDogaWQzRGF0YS5sZW5ndGgpIHx8IDA7XG5cbiAgICAgIC8vIENoZWNrIGZvciBhYy0zfGVjLTMgc3luYyBieXRlcyBhbmQgcmV0dXJuIGZhbHNlIGlmIHByZXNlbnRcbiAgICAgIGlmIChpZDNEYXRhICYmIGRhdGFbb2Zmc2V0XSA9PT0gMHgwYiAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDc3ICYmIGdldElkM1RpbWVzdGFtcChpZDNEYXRhKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAvLyBjaGVjayB0aGUgYnNpZCB0byBjb25maXJtIGFjLTMgb3IgZWMtMyAobm90IG1wMylcbiAgICAgIGdldEF1ZGlvQlNJRChkYXRhLCBvZmZzZXQpIDw9IDE2KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgIGlmIChwcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBBdWRpbyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8uY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZSQxKGRhdGEsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGNhblBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgfTtcbiAgICBfcHJvdG8uYXBwZW5kRnJhbWUgPSBmdW5jdGlvbiBhcHBlbmRGcmFtZSQxKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICAgIGlmICh0aGlzLmJhc2VQVFMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHRoaXMuYmFzZVBUUywgdGhpcy5mcmFtZUluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBNUDNEZW11eGVyO1xuICB9KEJhc2VBdWRpb0RlbXV4ZXIpO1xuXG4gIHZhciBlbXNnU2NoZW1lUGF0dGVybiA9IC9cXC9lbXNnWy0vXUlEMy9pO1xuICB2YXIgTVA0RGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTVA0RGVtdXhlcihvYnNlcnZlciwgY29uZmlnKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgdGhpcy50aW1lT2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgICAgdGhpcy52aWRlb1RyYWNrID0gdm9pZCAwO1xuICAgICAgdGhpcy5hdWRpb1RyYWNrID0gdm9pZCAwO1xuICAgICAgdGhpcy5pZDNUcmFjayA9IHZvaWQgMDtcbiAgICAgIHRoaXMudHh0VHJhY2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE1QNERlbXV4ZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKCkge307XG4gICAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgICB2YXIgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjayA9IGR1bW15VHJhY2soJ3ZpZGVvJywgMSk7XG4gICAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMuYXVkaW9UcmFjayA9IGR1bW15VHJhY2soJ2F1ZGlvJywgMSk7XG4gICAgICB2YXIgY2FwdGlvblRyYWNrID0gdGhpcy50eHRUcmFjayA9IGR1bW15VHJhY2soJ3RleHQnLCAxKTtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSBkdW1teVRyYWNrKCdpZDMnLCAxKTtcbiAgICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG4gICAgICBpZiAoIShpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbml0RGF0YSA9IHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpO1xuICAgICAgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICAgIHZhciBfaW5pdERhdGEkdmlkZW8gPSBpbml0RGF0YS52aWRlbyxcbiAgICAgICAgICBpZCA9IF9pbml0RGF0YSR2aWRlby5pZCxcbiAgICAgICAgICB0aW1lc2NhbGUgPSBfaW5pdERhdGEkdmlkZW8udGltZXNjYWxlLFxuICAgICAgICAgIGNvZGVjID0gX2luaXREYXRhJHZpZGVvLmNvZGVjLFxuICAgICAgICAgIHN1cHBsZW1lbnRhbCA9IF9pbml0RGF0YSR2aWRlby5zdXBwbGVtZW50YWw7XG4gICAgICAgIHZpZGVvVHJhY2suaWQgPSBpZDtcbiAgICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSBjYXB0aW9uVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgICB2aWRlb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgICAgIHZpZGVvVHJhY2suc3VwcGxlbWVudGFsID0gc3VwcGxlbWVudGFsO1xuICAgICAgfVxuICAgICAgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICAgIHZhciBfaW5pdERhdGEkYXVkaW8gPSBpbml0RGF0YS5hdWRpbyxcbiAgICAgICAgICBfaWQgPSBfaW5pdERhdGEkYXVkaW8uaWQsXG4gICAgICAgICAgX3RpbWVzY2FsZSA9IF9pbml0RGF0YSRhdWRpby50aW1lc2NhbGUsXG4gICAgICAgICAgX2NvZGVjID0gX2luaXREYXRhJGF1ZGlvLmNvZGVjO1xuICAgICAgICBhdWRpb1RyYWNrLmlkID0gX2lkO1xuICAgICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IF90aW1lc2NhbGU7XG4gICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSBfY29kZWM7XG4gICAgICB9XG4gICAgICBjYXB0aW9uVHJhY2suaWQgPSBSZW11eGVyVHJhY2tJZENvbmZpZy50ZXh0O1xuICAgICAgdmlkZW9UcmFjay5zYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICB2aWRlb1RyYWNrLmR1cmF0aW9uID0gYXVkaW9UcmFjay5kdXJhdGlvbiA9IHRyYWNrRHVyYXRpb247XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRDb250aWd1aXR5ID0gZnVuY3Rpb24gcmVzZXRDb250aWd1aXR5KCkge1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9O1xuICAgIE1QNERlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiBwcm9iZShkYXRhKSB7XG4gICAgICByZXR1cm4gaGFzTW9vZkRhdGEoZGF0YSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVtdXggPSBmdW5jdGlvbiBkZW11eChkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgICB0aGlzLnRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgICAgLy8gTG9hZCBhbGwgZGF0YSBpbnRvIHRoZSBhdmMgdHJhY2suIFRoZSBDTUFGIHJlbXV4ZXIgd2lsbCBsb29rIGZvciB0aGUgZGF0YSBpbiB0aGUgc2FtcGxlcyBvYmplY3Q7IHRoZSByZXN0IG9mIHRoZSBmaWVsZHMgZG8gbm90IG1hdHRlclxuICAgICAgdmFyIHZpZGVvU2FtcGxlcyA9IGRhdGE7XG4gICAgICB2YXIgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjaztcbiAgICAgIHZhciB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBieXRlc3RyZWFtIGludG8gdHdvIHJhbmdlczogb25lIGVuY29tcGFzc2luZyBhbGwgZGF0YSB1cCB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIGxhc3QgbW9vZiwgYW5kIGV2ZXJ5dGhpbmcgZWxzZS5cbiAgICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIGd1YXJhbnRlZSB0aGF0IHdlJ3JlIHNlbmRpbmcgdmFsaWQgZGF0YSB0byBNU0UgLSB3aGVuIGRlbXV4aW5nIHByb2dyZXNzaXZlbHksIHdlIGhhdmUgbm8gZ3VhcmFudGVlXG4gICAgICAgIC8vIHRoYXQgdGhlIGZldGNoIGxvYWRlciBnaXZlcyB1cyBmbHVzaCBtb29mK21kYXQgcGFpcnMuIElmIHdlIHB1c2ggamFnZ2VkIGRhdGEgdG8gTVNFLCBpdCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKHRoaXMucmVtYWluZGVyRGF0YSkge1xuICAgICAgICAgIHZpZGVvU2FtcGxlcyA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VnbWVudGVkRGF0YSA9IHNlZ21lbnRWYWxpZFJhbmdlKHZpZGVvU2FtcGxlcyk7XG4gICAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IHNlZ21lbnRlZERhdGEucmVtYWluZGVyO1xuICAgICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSBzZWdtZW50ZWREYXRhLnZhbGlkIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB2aWRlb1NhbXBsZXM7XG4gICAgICB9XG4gICAgICB2YXIgaWQzVHJhY2sgPSB0aGlzLmV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgIHRleHRUcmFjay5zYW1wbGVzID0gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmlkZW9UcmFjazogdmlkZW9UcmFjayxcbiAgICAgICAgYXVkaW9UcmFjazogdGhpcy5hdWRpb1RyYWNrLFxuICAgICAgICBpZDNUcmFjazogaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogdGhpcy50eHRUcmFja1xuICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgdmFyIHRpbWVPZmZzZXQgPSB0aGlzLnRpbWVPZmZzZXQ7XG4gICAgICB2YXIgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjaztcbiAgICAgIHZhciB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrO1xuICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdGhpcy5yZW1haW5kZXJEYXRhIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgdmFyIGlkM1RyYWNrID0gdGhpcy5leHRyYWN0SUQzVHJhY2sodmlkZW9UcmFjaywgdGhpcy50aW1lT2Zmc2V0KTtcbiAgICAgIHRleHRUcmFjay5zYW1wbGVzID0gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmlkZW9UcmFjazogdmlkZW9UcmFjayxcbiAgICAgICAgYXVkaW9UcmFjazogZHVtbXlUcmFjaygpLFxuICAgICAgICBpZDNUcmFjazogaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmV4dHJhY3RJRDNUcmFjayA9IGZ1bmN0aW9uIGV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjaztcbiAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbXNncyA9IGZpbmRCb3godmlkZW9UcmFjay5zYW1wbGVzLCBbJ2Vtc2cnXSk7XG4gICAgICAgIGlmIChlbXNncykge1xuICAgICAgICAgIGVtc2dzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBlbXNnSW5mbyA9IHBhcnNlRW1zZyhkYXRhKTtcbiAgICAgICAgICAgIGlmIChlbXNnU2NoZW1lUGF0dGVybi50ZXN0KGVtc2dJbmZvLnNjaGVtZUlkVXJpKSkge1xuICAgICAgICAgICAgICB2YXIgcHRzID0gZ2V0RW1zZ1N0YXJ0VGltZShlbXNnSW5mbywgdGltZU9mZnNldCk7XG4gICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGVtc2dJbmZvLmV2ZW50RHVyYXRpb24gPT09IDB4ZmZmZmZmZmYgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBlbXNnSW5mby5ldmVudER1cmF0aW9uIC8gZW1zZ0luZm8udGltZVNjYWxlO1xuICAgICAgICAgICAgICAvLyBTYWZhcmkgdGFrZXMgYW55dGhpbmcgPD0gMC4wMDEgc2Vjb25kcyBhbmQgbWFwcyBpdCB0byBJbmZpbml0eVxuICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPD0gMC4wMDEpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGVtc2dJbmZvLnBheWxvYWQ7XG4gICAgICAgICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBsZW46IHBheWxvYWQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5lbXNnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuY29uZmlnLmVuYWJsZUVtc2dLTFZNZXRhZGF0YSAmJiBlbXNnSW5mby5zY2hlbWVJZFVyaS5zdGFydHNXaXRoKCd1cm46bWlzYjpLTFY6YmluOjE5MTAuMScpKSB7XG4gICAgICAgICAgICAgIHZhciBfcHRzID0gZ2V0RW1zZ1N0YXJ0VGltZShlbXNnSW5mbywgdGltZU9mZnNldCk7XG4gICAgICAgICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogZW1zZ0luZm8ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICBsZW46IGVtc2dJbmZvLnBheWxvYWQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBkdHM6IF9wdHMsXG4gICAgICAgICAgICAgICAgcHRzOiBfcHRzLFxuICAgICAgICAgICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLm1pc2JrbHYsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkM1RyYWNrO1xuICAgIH07XG4gICAgX3Byb3RvLmRlbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIE1QNCBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU0FNUExFLUFFUyBkZWNyeXB0aW9uJykpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICAgIHRoaXMudmlkZW9UcmFjayA9IHRoaXMuYXVkaW9UcmFjayA9IHRoaXMuaWQzVHJhY2sgPSB0aGlzLnR4dFRyYWNrID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIE1QNERlbXV4ZXI7XG4gIH0oKTtcbiAgZnVuY3Rpb24gZ2V0RW1zZ1N0YXJ0VGltZShlbXNnSW5mbywgdGltZU9mZnNldCkge1xuICAgIHJldHVybiBpc0Zpbml0ZU51bWJlcihlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lKSA/IGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWUgLyBlbXNnSW5mby50aW1lU2NhbGUgOiB0aW1lT2Zmc2V0ICsgZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZURlbHRhIC8gZW1zZ0luZm8udGltZVNjYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNBTVBMRS1BRVMgZGVjcnlwdGVyXG4gICAqL1xuXG4gIHZhciBTYW1wbGVBZXNEZWNyeXB0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhbXBsZUFlc0RlY3J5cHRlcihvYnNlcnZlciwgY29uZmlnLCBrZXlEYXRhKSB7XG4gICAgICB0aGlzLmtleURhdGEgPSB2b2lkIDA7XG4gICAgICB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMua2V5RGF0YSA9IGtleURhdGE7XG4gICAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoY29uZmlnLCB7XG4gICAgICAgIHJlbW92ZVBLQ1M3UGFkZGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU2FtcGxlQWVzRGVjcnlwdGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVjcnlwdEJ1ZmZlciA9IGZ1bmN0aW9uIGRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgdGhpcy5rZXlEYXRhLmtleS5idWZmZXIsIHRoaXMua2V5RGF0YS5pdi5idWZmZXIsIERlY3J5cHRlckFlc01vZGUuY2JjKTtcbiAgICB9XG5cbiAgICAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxuICAgIDtcbiAgICBfcHJvdG8uZGVjcnlwdEFhY1NhbXBsZSA9IGZ1bmN0aW9uIGRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGN1clVuaXQgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0O1xuICAgICAgaWYgKGN1clVuaXQubGVuZ3RoIDw9IDE2KSB7XG4gICAgICAgIC8vIE5vIGVuY3J5cHRlZCBwb3J0aW9uIGluIHRoaXMgc2FtcGxlIChmaXJzdCAxNiBieXRlcyBpcyBub3RcbiAgICAgICAgLy8gZW5jcnlwdGVkLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0F1ZGlvVmlkZW8vQ29uY2VwdHVhbC9ITFNfU2FtcGxlX0VuY3J5cHRpb24vRW5jcnlwdGlvbi9FbmNyeXB0aW9uLmh0bWwpLFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XG4gICAgICB2YXIgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0LCBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XG4gICAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyKS50aGVuKGZ1bmN0aW9uIChkZWNyeXB0ZWRCdWZmZXIpIHtcbiAgICAgICAgdmFyIGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWRCdWZmZXIpO1xuICAgICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XG4gICAgICAgIGlmICghX3RoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgICAgX3RoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNyeXB0QWFjU2FtcGxlcyA9IGZ1bmN0aW9uIGRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaykge1xuICAgICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XG4gICAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0Lmxlbmd0aCA8IDMyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjayk7XG4gICAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICAgIDtcbiAgICBfcHJvdG8uZ2V0QXZjRW5jcnlwdGVkRGF0YSA9IGZ1bmN0aW9uIGdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpIHtcbiAgICAgIHZhciBlbmNyeXB0ZWREYXRhTGVuID0gTWF0aC5mbG9vcigoZGVjb2RlZERhdGEubGVuZ3RoIC0gNDgpIC8gMTYwKSAqIDE2ICsgMTY7XG4gICAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgICB2YXIgb3V0cHV0UG9zID0gMDtcbiAgICAgIGZvciAodmFyIGlucHV0UG9zID0gMzI7IGlucHV0UG9zIDwgZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IGlucHV0UG9zICs9IDE2MCwgb3V0cHV0UG9zICs9IDE2KSB7XG4gICAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEF2Y0RlY3J5cHRlZFVuaXQgPSBmdW5jdGlvbiBnZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWREYXRhKSB7XG4gICAgICB2YXIgdWludDhEZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICB2YXIgaW5wdXRQb3MgPSAwO1xuICAgICAgZm9yICh2YXIgb3V0cHV0UG9zID0gMzI7IG91dHB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNikge1xuICAgICAgICBkZWNvZGVkRGF0YS5zZXQodWludDhEZWNyeXB0ZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvZGVkRGF0YTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNyeXB0QXZjU2FtcGxlID0gZnVuY3Rpb24gZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgZGVjb2RlZERhdGEgPSBkaXNjYXJkRVBCKGN1clVuaXQuZGF0YSk7XG4gICAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSk7XG4gICAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIpLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZEJ1ZmZlcikge1xuICAgICAgICBjdXJVbml0LmRhdGEgPSBfdGhpczIuZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkQnVmZmVyKTtcbiAgICAgICAgaWYgKCFfdGhpczIuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgICAgX3RoaXMyLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNyeXB0QXZjU2FtcGxlcyA9IGZ1bmN0aW9uIGRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoc2FtcGxlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjcnlwdCBzYW1wbGVzIG9mIHR5cGUgVWludDhBcnJheScpO1xuICAgICAgfVxuICAgICAgZm9yICg7OyBzYW1wbGVJbmRleCsrLCB1bml0SW5kZXggPSAwKSB7XG4gICAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJVbml0cyA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXRzO1xuICAgICAgICBmb3IgKDs7IHVuaXRJbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHVuaXRJbmRleCA+PSBjdXJVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3VyVW5pdCA9IGN1clVuaXRzW3VuaXRJbmRleF07XG4gICAgICAgICAgaWYgKGN1clVuaXQuZGF0YS5sZW5ndGggPD0gNDggfHwgY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNhbXBsZUFlc0RlY3J5cHRlcjtcbiAgfSgpO1xuXG4gIHZhciBCYXNlVmlkZW9QYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VWaWRlb1BhcnNlcigpIHtcbiAgICAgIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQmFzZVZpZGVvUGFyc2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uY3JlYXRlVmlkZW9TYW1wbGUgPSBmdW5jdGlvbiBjcmVhdGVWaWRlb1NhbXBsZShrZXksIHB0cywgZHRzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgZnJhbWU6IGZhbHNlLFxuICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgZHRzOiBkdHMsXG4gICAgICAgIHVuaXRzOiBbXSxcbiAgICAgICAgbGVuZ3RoOiAwXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmdldExhc3ROYWxVbml0ID0gZnVuY3Rpb24gZ2V0TGFzdE5hbFVuaXQoc2FtcGxlcykge1xuICAgICAgdmFyIF9WaWRlb1NhbXBsZTtcbiAgICAgIHZhciBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGU7XG4gICAgICB2YXIgbGFzdFVuaXQ7XG4gICAgICAvLyB0cnkgdG8gZmFsbGJhY2sgdG8gcHJldmlvdXMgc2FtcGxlIGlmIGN1cnJlbnQgb25lIGlzIGVtcHR5XG4gICAgICBpZiAoIVZpZGVvU2FtcGxlIHx8IFZpZGVvU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBWaWRlb1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmICgoX1ZpZGVvU2FtcGxlID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlLnVuaXRzKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RVbml0O1xuICAgIH07XG4gICAgX3Byb3RvLnB1c2hBY2Nlc3NVbml0ID0gZnVuY3Rpb24gcHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHZpZGVvVHJhY2spIHtcbiAgICAgIGlmIChWaWRlb1NhbXBsZS51bml0cy5sZW5ndGggJiYgVmlkZW9TYW1wbGUuZnJhbWUpIHtcbiAgICAgICAgLy8gaWYgc2FtcGxlIGRvZXMgbm90IGhhdmUgUFRTL0RUUywgcGF0Y2ggd2l0aCBsYXN0IHNhbXBsZSBQVFMvRFRTXG4gICAgICAgIGlmIChWaWRlb1NhbXBsZS5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuICAgICAgICAgIHZhciBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFNhbXBsZSA9IHNhbXBsZXNbbmJTYW1wbGVzIC0gMV07XG4gICAgICAgICAgICBWaWRlb1NhbXBsZS5wdHMgPSBsYXN0U2FtcGxlLnB0cztcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmR0cyA9IGxhc3RTYW1wbGUuZHRzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkcm9wcGluZyBzYW1wbGVzLCBubyB0aW1lc3RhbXAgZm91bmRcbiAgICAgICAgICAgIHZpZGVvVHJhY2suZHJvcHBlZCsrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWRlb1RyYWNrLnNhbXBsZXMucHVzaChWaWRlb1NhbXBsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucGFyc2VOQUx1ID0gZnVuY3Rpb24gcGFyc2VOQUx1KHRyYWNrLCBhcnJheSwgZW5kT2ZTZWdtZW50KSB7XG4gICAgICB2YXIgbGVuID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgICAgIHZhciBzdGF0ZSA9IHRyYWNrLm5hbHVTdGF0ZSB8fCAwO1xuICAgICAgdmFyIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICB2YXIgdW5pdFR5cGU7XG4gICAgICB2YXIgbGFzdFVuaXRTdGFydCA9IC0xO1xuICAgICAgdmFyIGxhc3RVbml0VHlwZSA9IDA7XG4gICAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgLy8gc3BlY2lhbCB1c2UgY2FzZSB3aGVyZSB3ZSBmb3VuZCAzIG9yIDQtYnl0ZSBzdGFydCBjb2RlcyBleGFjdGx5IGF0IHRoZSBlbmQgb2YgcHJldmlvdXMgUEVTIHBhY2tldFxuICAgICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgICBsYXN0VW5pdFR5cGUgPSB0aGlzLmdldE5BTHVUeXBlKGFycmF5LCAwKTtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICBpID0gMTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTtcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uLiBzdGF0ZSAwIGFuZCAxIGFyZSB0aGUgcHJlZG9taW5hbnQgY2FzZS4gbGV0J3MgaGFuZGxlIHRoZW0gb3V0c2lkZSBvZiB0aGUgc3dpdGNoL2Nhc2VcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IHtcbiAgICAgICAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgb3ZlcmZsb3cpLFxuICAgICAgICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgICAgdmFyIGxhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgICBpZiAobGFzdFN0YXRlICYmIGkgPD0gNCAtIGxhc3RTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoIC0gbGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuXG4gICAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gYXBwZW5kVWludDhBcnJheShsYXN0VW5pdC5kYXRhLCBhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdykpO1xuICAgICAgICAgICAgICAgIGxhc3RVbml0LnN0YXRlID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgICAgdW5pdFR5cGUgPSB0aGlzLmdldE5BTHVUeXBlKGFycmF5LCBpKTtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuICAgICAgICAgICAgbGFzdFVuaXRTdGFydCA9IGk7XG4gICAgICAgICAgICBsYXN0VW5pdFR5cGUgPSB1bml0VHlwZTtcbiAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IGVub3VnaCBieXRlIHRvIHJlYWQgdW5pdCB0eXBlLiBsZXQncyByZWFkIGl0IG9uIG5leHQgUEVTIHBhcnNpbmdcbiAgICAgICAgICAgIHN0YXRlID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICAgIHZhciBfdW5pdCA9IHtcbiAgICAgICAgICBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLFxuICAgICAgICAgIHR5cGU6IGxhc3RVbml0VHlwZSxcbiAgICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgICAgfTtcbiAgICAgICAgdW5pdHMucHVzaChfdW5pdCk7XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIC8vIG5vIE5BTHUgZm91bmRcbiAgICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XG4gICAgICAgIHZhciBfbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuICAgICAgICBpZiAoX2xhc3RVbml0KSB7XG4gICAgICAgICAgX2xhc3RVbml0LmRhdGEgPSBhcHBlbmRVaW50OEFycmF5KF9sYXN0VW5pdC5kYXRhLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xuICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VWaWRlb1BhcnNlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiAgICovXG5cbiAgdmFyIEV4cEdvbG9tYiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwR29sb21iKGRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLndvcmQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgLy8gdGhlIGN1cnJlbnQgd29yZCBiZWluZyBleGFtaW5lZFxuICAgICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnRcbiAgICB9XG5cbiAgICAvLyAoKTp2b2lkXG4gICAgdmFyIF9wcm90byA9IEV4cEdvbG9tYi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmxvYWRXb3JkID0gZnVuY3Rpb24gbG9hZFdvcmQoKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciBieXRlc0F2YWlsYWJsZSA9IHRoaXMuYnl0ZXNBdmFpbGFibGU7XG4gICAgICB2YXIgcG9zaXRpb24gPSBkYXRhLmJ5dGVMZW5ndGggLSBieXRlc0F2YWlsYWJsZTtcbiAgICAgIHZhciB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIHZhciBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIGJ5dGVzQXZhaWxhYmxlKTtcbiAgICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgICAgfVxuICAgICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gICAgfVxuXG4gICAgLy8gKGNvdW50OmludCk6dm9pZFxuICAgIDtcbiAgICBfcHJvdG8uc2tpcEJpdHMgPSBmdW5jdGlvbiBza2lwQml0cyhjb3VudCkge1xuICAgICAgdmFyIHNraXBCeXRlczsgLy8gOmludFxuICAgICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgdGhpcy5ieXRlc0F2YWlsYWJsZSAqIDggKyB0aGlzLmJpdHNBdmFpbGFibGUpO1xuICAgICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgICAgY291bnQgLT0gc2tpcEJ5dGVzIDw8IDM7XG4gICAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgICA7XG4gICAgX3Byb3RvLnJlYWRCaXRzID0gZnVuY3Rpb24gcmVhZEJpdHMoc2l6ZSkge1xuICAgICAgdmFyIGJpdHMgPSBNYXRoLm1pbih0aGlzLmJpdHNBdmFpbGFibGUsIHNpemUpOyAvLyA6dWludFxuICAgICAgdmFyIHZhbHUgPSB0aGlzLndvcmQgPj4+IDMyIC0gYml0czsgLy8gOnVpbnRcbiAgICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuICAgICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgICAgdGhpcy53b3JkIDw8PSBiaXRzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzQXZhaWxhYmxlID4gMCkge1xuICAgICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJpdHMgYXZhaWxhYmxlJyk7XG4gICAgICB9XG4gICAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgICBpZiAoYml0cyA+IDAgJiYgdGhpcy5iaXRzQXZhaWxhYmxlKSB7XG4gICAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gKCk6dWludFxuICAgIDtcbiAgICBfcHJvdG8uc2tpcExaID0gZnVuY3Rpb24gc2tpcExaKCkge1xuICAgICAgdmFyIGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgICAgaWYgKCh0aGlzLndvcmQgJiAweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSAhPT0gMCkge1xuICAgICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgICB9XG5cbiAgICAvLyAoKTp2b2lkXG4gICAgO1xuICAgIF9wcm90by5za2lwVUVHID0gZnVuY3Rpb24gc2tpcFVFRygpIHtcbiAgICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICAgIH1cblxuICAgIC8vICgpOnZvaWRcbiAgICA7XG4gICAgX3Byb3RvLnNraXBFRyA9IGZ1bmN0aW9uIHNraXBFRygpIHtcbiAgICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICAgIH1cblxuICAgIC8vICgpOnVpbnRcbiAgICA7XG4gICAgX3Byb3RvLnJlYWRVRUcgPSBmdW5jdGlvbiByZWFkVUVHKCkge1xuICAgICAgdmFyIGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gICAgfVxuXG4gICAgLy8gKCk6aW50XG4gICAgO1xuICAgIF9wcm90by5yZWFkRUcgPSBmdW5jdGlvbiByZWFkRUcoKSB7XG4gICAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICAgIHJldHVybiAxICsgdmFsdSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAgIC8vIDpCb29sZWFuXG4gICAgO1xuICAgIF9wcm90by5yZWFkQm9vbGVhbiA9IGZ1bmN0aW9uIHJlYWRCb29sZWFuKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgfVxuXG4gICAgLy8gKCk6aW50XG4gICAgO1xuICAgIF9wcm90by5yZWFkVUJ5dGUgPSBmdW5jdGlvbiByZWFkVUJ5dGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgICB9XG5cbiAgICAvLyAoKTppbnRcbiAgICA7XG4gICAgX3Byb3RvLnJlYWRVU2hvcnQgPSBmdW5jdGlvbiByZWFkVVNob3J0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICAgIH1cblxuICAgIC8vICgpOmludFxuICAgIDtcbiAgICBfcHJvdG8ucmVhZFVJbnQgPSBmdW5jdGlvbiByZWFkVUludCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcbiAgICB9O1xuICAgIHJldHVybiBFeHBHb2xvbWI7XG4gIH0oKTtcblxuICB2YXIgQXZjVmlkZW9QYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlVmlkZW9QYXJzZXIpIHtcbiAgICBmdW5jdGlvbiBBdmNWaWRlb1BhcnNlcigpIHtcbiAgICAgIHJldHVybiBfQmFzZVZpZGVvUGFyc2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoQXZjVmlkZW9QYXJzZXIsIF9CYXNlVmlkZW9QYXJzZXIpO1xuICAgIHZhciBfcHJvdG8gPSBBdmNWaWRlb1BhcnNlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnBhcnNlUEVTID0gZnVuY3Rpb24gcGFyc2VQRVModHJhY2ssIHRleHRUcmFjaywgcGVzLCBlbmRPZlNlZ21lbnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgdW5pdHMgPSB0aGlzLnBhcnNlTkFMdSh0cmFjaywgcGVzLmRhdGEsIGVuZE9mU2VnbWVudCk7XG4gICAgICB2YXIgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlO1xuICAgICAgdmFyIHB1c2g7XG4gICAgICB2YXIgc3BzZm91bmQgPSBmYWxzZTtcbiAgICAgIC8vIGZyZWUgcGVzLmRhdGEgdG8gc2F2ZSB1cCBzb21lIG1lbW9yeVxuICAgICAgcGVzLmRhdGEgPSBudWxsO1xuXG4gICAgICAvLyBpZiBuZXcgTkFMIHVuaXRzIGZvdW5kIGFuZCBsYXN0IHNhbXBsZSBzdGlsbCB0aGVyZSwgbGV0J3MgcHVzaCAuLi5cbiAgICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG4gICAgICBpZiAoVmlkZW9TYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xuICAgICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMpO1xuICAgICAgfVxuICAgICAgdW5pdHMuZm9yRWFjaChmdW5jdGlvbiAodW5pdCkge1xuICAgICAgICB2YXIgX1ZpZGVvU2FtcGxlMiwgX1ZpZGVvU2FtcGxlMztcbiAgICAgICAgc3dpdGNoICh1bml0LnR5cGUpIHtcbiAgICAgICAgICAvLyBORFJcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpc2tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgc2xpY2UgdHlwZSB0byBkZXRlY3QgS0YgaW4gY2FzZSBTUFMgZm91bmQgaW4gc2FtZSBwYWNrZXQgKGFueSBrZXlmcmFtZSBpcyBwcmVjZWRlZCBieSBTUFMgLi4uKVxuICAgICAgICAgICAgICBpZiAoc3BzZm91bmQgJiYgZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgc2xpY2UgdHlwZSBieSBwYXJzaW5nIGJlZ2lubmluZyBvZiBOQUwgdW5pdCAoZm9sbG93IEgyNjQgc3BlYywgc2xpY2VfaGVhZGVyIGRlZmluaXRpb24pIHRvIGRldGVjdCBrZXlmcmFtZSBlbWJlZGRlZCBpbiBORFJcbiAgICAgICAgICAgICAgICB2YXIgc2xpY2VUeXBlID0gX3RoaXMucmVhZFNsaWNlVHlwZShkYXRhKTtcbiAgICAgICAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxuICAgICAgICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgICAgIC8vIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA3KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDQgfHwgc2xpY2VUeXBlID09PSA3IHx8IHNsaWNlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgaXNrZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX1ZpZGVvU2FtcGxlO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm9uLWtleWZyYW1lIGRhdGEgYWxyZWFkeSwgdGhhdCBjYW5ub3QgYmVsb25nIHRvIHRoZSBzYW1lIGZyYW1lIGFzIGEga2V5ZnJhbWUsIHNvIGZvcmNlIGEgcHVzaFxuICAgICAgICAgICAgICAgIGlmICgoX1ZpZGVvU2FtcGxlID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlLmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IF90aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gX3RoaXMuVmlkZW9TYW1wbGUgPSBfdGhpcy5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgIFZpZGVvU2FtcGxlLmtleSA9IGlza2V5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgLy8gSURSXG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBkYXRhIGFscmVhZHksIHRoYXQgY2Fubm90IGJlbG9uZyB0byB0aGUgc2FtZSBmcmFtZSwgc28gZm9yY2UgYSBwdXNoXG4gICAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZTIgPSBWaWRlb1NhbXBsZSkgIT0gbnVsbCAmJiBfVmlkZW9TYW1wbGUyLmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgICAgX3RoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSBfdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gX3RoaXMuVmlkZW9TYW1wbGUgPSBfdGhpcy5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBTRUlcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSh1bml0LmRhdGEsIDEsIHBlcy5wdHMsIHRleHRUcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIFNQU1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF90cmFjayRwaXhlbFJhdGlvLCBfdHJhY2skcGl4ZWxSYXRpbzI7XG4gICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICBzcHNmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBzcHMgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICAgIHZhciBjb25maWcgPSBfdGhpcy5yZWFkU1BTKHNwcyk7XG4gICAgICAgICAgICAgIGlmICghdHJhY2suc3BzIHx8IHRyYWNrLndpZHRoICE9PSBjb25maWcud2lkdGggfHwgdHJhY2suaGVpZ2h0ICE9PSBjb25maWcuaGVpZ2h0IHx8ICgoX3RyYWNrJHBpeGVsUmF0aW8gPSB0cmFjay5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogX3RyYWNrJHBpeGVsUmF0aW9bMF0pICE9PSBjb25maWcucGl4ZWxSYXRpb1swXSB8fCAoKF90cmFjayRwaXhlbFJhdGlvMiA9IHRyYWNrLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2skcGl4ZWxSYXRpbzJbMV0pICE9PSBjb25maWcucGl4ZWxSYXRpb1sxXSkge1xuICAgICAgICAgICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgICAgICAgICAgIHRyYWNrLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgICAgIHRyYWNrLnNwcyA9IFtzcHNdO1xuICAgICAgICAgICAgICAgIHZhciBjb2RlY2FycmF5ID0gc3BzLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgICAgICAgIHZhciBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBoID0gY29kZWNhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29kZWNzdHJpbmcgKz0gaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlY3N0cmluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQUFNcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gQVVEXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZTMgPSBWaWRlb1NhbXBsZSkgIT0gbnVsbCAmJiBfVmlkZW9TYW1wbGUzLmZyYW1lKSB7XG4gICAgICAgICAgICAgIF90aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSBfdGhpcy5WaWRlb1NhbXBsZSA9IF90aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEZpbGxlciBEYXRhXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChWaWRlb1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgICAgdmFyIF91bml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgICAgIF91bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG4gICAgICBpZiAoZW5kT2ZTZWdtZW50ICYmIFZpZGVvU2FtcGxlKSB7XG4gICAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TkFMdVR5cGUgPSBmdW5jdGlvbiBnZXROQUx1VHlwZShkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhW29mZnNldF0gJiAweDFmO1xuICAgIH07XG4gICAgX3Byb3RvLnJlYWRTbGljZVR5cGUgPSBmdW5jdGlvbiByZWFkU2xpY2VUeXBlKGRhdGEpIHtcbiAgICAgIHZhciBlZyA9IG5ldyBFeHBHb2xvbWIoZGF0YSk7XG4gICAgICAvLyBza2lwIE5BTHUgdHlwZVxuICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG4gICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAvLyByZXR1cm4gc2xpY2VfdHlwZVxuICAgICAgcmV0dXJuIGVnLnJlYWRVRUcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGluZyBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhpcyBzY2FsaW5nIGxpc3RcbiAgICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAgICovO1xuICAgIF9wcm90by5za2lwU2NhbGluZ0xpc3QgPSBmdW5jdGlvbiBza2lwU2NhbGluZ0xpc3QoY291bnQsIHJlYWRlcikge1xuICAgICAgdmFyIGxhc3RTY2FsZSA9IDg7XG4gICAgICB2YXIgbmV4dFNjYWxlID0gODtcbiAgICAgIHZhciBkZWx0YVNjYWxlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgICBkZWx0YVNjYWxlID0gcmVhZGVyLnJlYWRFRygpO1xuICAgICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0U2NhbGUgPSBuZXh0U2NhbGUgPT09IDAgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgICAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gcGFyc2VkIGZyb20gdGhlXG4gICAgICogc2VxdWVuY2UgcGFyYW1ldGVyIHNldCwgaW5jbHVkaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZVxuICAgICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgICAqLztcbiAgICBfcHJvdG8ucmVhZFNQUyA9IGZ1bmN0aW9uIHJlYWRTUFMoc3BzKSB7XG4gICAgICB2YXIgZWcgPSBuZXcgRXhwR29sb21iKHNwcyk7XG4gICAgICB2YXIgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDA7XG4gICAgICB2YXIgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwO1xuICAgICAgdmFyIGZyYW1lQ3JvcFRvcE9mZnNldCA9IDA7XG4gICAgICB2YXIgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMDtcbiAgICAgIHZhciBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7XG4gICAgICB2YXIgc2NhbGluZ0xpc3RDb3VudDtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHJlYWRVQnl0ZSA9IGVnLnJlYWRVQnl0ZS5iaW5kKGVnKTtcbiAgICAgIHZhciByZWFkQml0cyA9IGVnLnJlYWRCaXRzLmJpbmQoZWcpO1xuICAgICAgdmFyIHJlYWRVRUcgPSBlZy5yZWFkVUVHLmJpbmQoZWcpO1xuICAgICAgdmFyIHJlYWRCb29sZWFuID0gZWcucmVhZEJvb2xlYW4uYmluZChlZyk7XG4gICAgICB2YXIgc2tpcEJpdHMgPSBlZy5za2lwQml0cy5iaW5kKGVnKTtcbiAgICAgIHZhciBza2lwRUcgPSBlZy5za2lwRUcuYmluZChlZyk7XG4gICAgICB2YXIgc2tpcFVFRyA9IGVnLnNraXBVRUcuYmluZChlZyk7XG4gICAgICB2YXIgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcbiAgICAgIHJlYWRVQnl0ZSgpO1xuICAgICAgdmFyIHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcbiAgICAgIHJlYWRCaXRzKDUpOyAvLyBwcm9maWxlQ29tcGF0IGNvbnN0cmFpbnRfc2V0WzAtNF1fZmxhZywgdSg1KVxuICAgICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICAgIHJlYWRVQnl0ZSgpOyAvLyBsZXZlbF9pZGMgdSg4KVxuICAgICAgc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgICBpZiAocHJvZmlsZUlkYyA9PT0gMTAwIHx8IHByb2ZpbGVJZGMgPT09IDExMCB8fCBwcm9maWxlSWRjID09PSAxMjIgfHwgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8IHByb2ZpbGVJZGMgPT09IDQ0IHx8IHByb2ZpbGVJZGMgPT09IDgzIHx8IHByb2ZpbGVJZGMgPT09IDg2IHx8IHByb2ZpbGVJZGMgPT09IDExOCB8fCBwcm9maWxlSWRjID09PSAxMjgpIHtcbiAgICAgICAgdmFyIGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcbiAgICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICAgIHNraXBCaXRzKDEpO1xuICAgICAgICB9IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG5cbiAgICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfbHVtYV9taW51czhcbiAgICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgICBza2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgICAgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSBjaHJvbWFGb3JtYXRJZGMgIT09IDMgPyA4IDogMTI7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgICAgICAgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoMTYsIGVnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQsIGVnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2tpcFVFRygpOyAvLyBsb2cyX21heF9mcmFtZV9udW1fbWludXM0XG4gICAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xuICAgICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGRcbiAgICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgICBza2lwRUcoKTtcbiAgICAgICAgfSAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgICB9XG4gICAgICBza2lwVUVHKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuICAgICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgICAgdmFyIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgICB2YXIgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICAgIHZhciBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgICBpZiAoZnJhbWVNYnNPbmx5RmxhZyA9PT0gMCkge1xuICAgICAgICBza2lwQml0cygxKTtcbiAgICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG4gICAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICB9XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZ1xuICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgIHZhciBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTIsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTAsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNDAsIDMzXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjQsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMzIsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbODAsIDMzXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNSwgMTFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNjQsIDMzXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNCwgM107XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszLCAyXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjU1OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFtyZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCksIHJlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2IC0gZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLSBmcmFtZUNyb3BSaWdodE9mZnNldCAqIDIpLFxuICAgICAgICBoZWlnaHQ6ICgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYgLSAoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpLFxuICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEF2Y1ZpZGVvUGFyc2VyO1xuICB9KEJhc2VWaWRlb1BhcnNlcik7XG5cbiAgdmFyIEhldmNWaWRlb1BhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VWaWRlb1BhcnNlcikge1xuICAgIGZ1bmN0aW9uIEhldmNWaWRlb1BhcnNlcigpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgX3RoaXMgPSBfQmFzZVZpZGVvUGFyc2VyLmNhbGwuYXBwbHkoX0Jhc2VWaWRlb1BhcnNlciwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICAgIF90aGlzLmluaXRWUFMgPSBudWxsO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHNMb29zZShIZXZjVmlkZW9QYXJzZXIsIF9CYXNlVmlkZW9QYXJzZXIpO1xuICAgIHZhciBfcHJvdG8gPSBIZXZjVmlkZW9QYXJzZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5wYXJzZVBFUyA9IGZ1bmN0aW9uIHBhcnNlUEVTKHRyYWNrLCB0ZXh0VHJhY2ssIHBlcywgZW5kT2ZTZWdtZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciB1bml0cyA9IHRoaXMucGFyc2VOQUx1KHRyYWNrLCBwZXMuZGF0YSwgZW5kT2ZTZWdtZW50KTtcbiAgICAgIHZhciBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGU7XG4gICAgICB2YXIgcHVzaDtcbiAgICAgIHZhciBzcHNmb3VuZCA9IGZhbHNlO1xuICAgICAgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgICBwZXMuZGF0YSA9IG51bGw7XG5cbiAgICAgIC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxuICAgICAgLy8gdGhpcyBoZWxwcyBwYXJzaW5nIHN0cmVhbXMgd2l0aCBtaXNzaW5nIEFVRCAob25seSBkbyB0aGlzIGlmIEFVRCBuZXZlciBmb3VuZClcbiAgICAgIGlmIChWaWRlb1NhbXBsZSAmJiB1bml0cy5sZW5ndGggJiYgIXRyYWNrLmF1ZEZvdW5kKSB7XG4gICAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cyk7XG4gICAgICB9XG4gICAgICB1bml0cy5mb3JFYWNoKGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICAgIHZhciBfVmlkZW9TYW1wbGUyLCBfVmlkZW9TYW1wbGUzO1xuICAgICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgICAgIC8vIE5PTi1JRFIsIE5PTiBSQU5ET00gQUNDRVNTIFNMSUNFXG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IF90aGlzMi5WaWRlb1NhbXBsZSA9IF90aGlzMi5jcmVhdGVWaWRlb1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1JBLCBCTEEgKHJhbmRvbSBhY2Nlc3MgcGljdHVyZSlcbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc3BzZm91bmQpIHtcbiAgICAgICAgICAgICAgdmFyIF9WaWRlb1NhbXBsZTtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBkYXRhIGFscmVhZHksIHRoYXQgY2Fubm90IGJlbG9uZyB0byB0aGUgc2FtZSBmcmFtZSwgc28gZm9yY2UgYSBwdXNoXG4gICAgICAgICAgICAgIGlmICgoX1ZpZGVvU2FtcGxlID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlLmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IF90aGlzMi5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSBfdGhpczIuVmlkZW9TYW1wbGUgPSBfdGhpczIuY3JlYXRlVmlkZW9TYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBWaWRlb1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBJRFJcbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIGRhdGEgYWxyZWFkeSwgdGhhdCBjYW5ub3QgYmVsb25nIHRvIHRoZSBzYW1lIGZyYW1lLCBzbyBmb3JjZSBhIHB1c2hcbiAgICAgICAgICAgIGlmICgoX1ZpZGVvU2FtcGxlMiA9IFZpZGVvU2FtcGxlKSAhPSBudWxsICYmIF9WaWRlb1NhbXBsZTIuZnJhbWUgJiYgIVZpZGVvU2FtcGxlLmtleSkge1xuICAgICAgICAgICAgICBfdGhpczIucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgICAgVmlkZW9TYW1wbGUgPSBfdGhpczIuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IF90aGlzMi5WaWRlb1NhbXBsZSA9IF90aGlzMi5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIFNFSVxuICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KHVuaXQuZGF0YSwgMixcbiAgICAgICAgICAgIC8vIE5BTHUgaGVhZGVyIHNpemVcbiAgICAgICAgICAgIHBlcy5wdHMsIHRleHRUcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gVlBTXG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0cmFjay52cHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFjay5wYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sucGFyYW1zID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhY2sucGFyYW1zID0gX2V4dGVuZHModHJhY2sucGFyYW1zLCBfdGhpczIucmVhZFZQUyh1bml0LmRhdGEpKTtcbiAgICAgICAgICAgICAgX3RoaXMyLmluaXRWUFMgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjay52cHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gU1BTXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRyYWNrLnZwcyAhPT0gdW5kZWZpbmVkICYmIHRyYWNrLnZwc1swXSAhPT0gX3RoaXMyLmluaXRWUFMgJiYgdHJhY2suc3BzICE9PSB1bmRlZmluZWQgJiYgIV90aGlzMi5tYXRjaFNQUyh0cmFjay5zcHNbMF0sIHVuaXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmluaXRWUFMgPSB0cmFjay52cHNbMF07XG4gICAgICAgICAgICAgIHRyYWNrLnNwcyA9IHRyYWNrLnBwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHJhY2suc3BzKSB7XG4gICAgICAgICAgICAgIHZhciBjb25maWcgPSBfdGhpczIucmVhZFNQUyh1bml0LmRhdGEpO1xuICAgICAgICAgICAgICB0cmFjay53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvbmZpZy5jb2RlY1N0cmluZztcbiAgICAgICAgICAgICAgdHJhY2suc3BzID0gW107XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2sucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRyYWNrLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gY29uZmlnLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIHRyYWNrLnBhcmFtc1twcm9wXSA9IGNvbmZpZy5wYXJhbXNbcHJvcF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzMi5wdXNoUGFyYW1ldGVyU2V0KHRyYWNrLnNwcywgdW5pdC5kYXRhLCB0cmFjay52cHMpO1xuICAgICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IF90aGlzMi5WaWRlb1NhbXBsZSA9IF90aGlzMi5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIFBQU1xuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhY2sucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBpZiAoIXRyYWNrLnBwcykge1xuICAgICAgICAgICAgICAgIHRyYWNrLnBwcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBfY29uZmlnID0gX3RoaXMyLnJlYWRQUFModW5pdC5kYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfcHJvcCBpbiBfY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICB0cmFjay5wYXJhbXNbX3Byb3BdID0gX2NvbmZpZ1tfcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzMi5wdXNoUGFyYW1ldGVyU2V0KHRyYWNrLnBwcywgdW5pdC5kYXRhLCB0cmFjay52cHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBBQ0NFU1MgVU5JVCBERUxJTUlURVJcbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoKF9WaWRlb1NhbXBsZTMgPSBWaWRlb1NhbXBsZSkgIT0gbnVsbCAmJiBfVmlkZW9TYW1wbGUzLmZyYW1lKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gX3RoaXMyLlZpZGVvU2FtcGxlID0gX3RoaXMyLmNyZWF0ZVZpZGVvU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoVmlkZW9TYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICAgIHZhciBfdW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgICAgICBfdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgICAgaWYgKGVuZE9mU2VnbWVudCAmJiBWaWRlb1NhbXBsZSkge1xuICAgICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnB1c2hQYXJhbWV0ZXJTZXQgPSBmdW5jdGlvbiBwdXNoUGFyYW1ldGVyU2V0KHBhcmFtZXRlclNldHMsIGRhdGEsIHZwcykge1xuICAgICAgaWYgKHZwcyAmJiB2cHNbMF0gPT09IHRoaXMuaW5pdFZQUyB8fCAhdnBzICYmICFwYXJhbWV0ZXJTZXRzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbWV0ZXJTZXRzLnB1c2goZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TkFMdVR5cGUgPSBmdW5jdGlvbiBnZXROQUx1VHlwZShkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiAoZGF0YVtvZmZzZXRdICYgMHg3ZSkgPj4+IDE7XG4gICAgfTtcbiAgICBfcHJvdG8uZWJzcDJyYnNwID0gZnVuY3Rpb24gZWJzcDJyYnNwKGFycikge1xuICAgICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KGFyci5ieXRlTGVuZ3RoKTtcbiAgICAgIHZhciBkc3RJZHggPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID49IDIpIHtcbiAgICAgICAgICAvLyBVbmVzY2FwZTogU2tpcCAweDAzIGFmdGVyIDAwIDAwXG4gICAgICAgICAgaWYgKGFycltpXSA9PT0gMHgwMyAmJiBhcnJbaSAtIDFdID09PSAweDAwICYmIGFycltpIC0gMl0gPT09IDB4MDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkc3RbZHN0SWR4XSA9IGFycltpXTtcbiAgICAgICAgZHN0SWR4Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZHN0LmJ1ZmZlciwgMCwgZHN0SWR4KTtcbiAgICB9O1xuICAgIF9wcm90by5wdXNoQWNjZXNzVW5pdCA9IGZ1bmN0aW9uIHB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB2aWRlb1RyYWNrKSB7XG4gICAgICBfQmFzZVZpZGVvUGFyc2VyLnByb3RvdHlwZS5wdXNoQWNjZXNzVW5pdC5jYWxsKHRoaXMsIFZpZGVvU2FtcGxlLCB2aWRlb1RyYWNrKTtcbiAgICAgIGlmICh0aGlzLmluaXRWUFMpIHtcbiAgICAgICAgdGhpcy5pbml0VlBTID0gbnVsbDsgLy8gbnVsbCBpbml0VlBTIHRvIHByZXZlbnQgcG9zc2libGUgdHJhY2sncyBzcHMvcHBzIGdyb3d0aCB1bnRpbCBuZXh0IFZQU1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJlYWRWUFMgPSBmdW5jdGlvbiByZWFkVlBTKHZwcykge1xuICAgICAgdmFyIGVnID0gbmV3IEV4cEdvbG9tYih2cHMpO1xuICAgICAgLy8gcmVtb3ZlIGhlYWRlclxuICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgIGVnLnJlYWRCaXRzKDQpOyAvLyB2aWRlb19wYXJhbWV0ZXJfc2V0X2lkXG4gICAgICBlZy5za2lwQml0cygyKTtcbiAgICAgIGVnLnJlYWRCaXRzKDYpOyAvLyBtYXhfbGF5ZXJzX21pbnVzMVxuICAgICAgdmFyIG1heF9zdWJfbGF5ZXJzX21pbnVzMSA9IGVnLnJlYWRCaXRzKDMpO1xuICAgICAgdmFyIHRlbXBvcmFsX2lkX25lc3RpbmdfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAvLyAuLi52dWkgZnBzIGNhbiBiZSBoZXJlLCBidXQgZW1wdHkgZnBzIHZhbHVlIGlzIG5vdCBjcml0aWNhbCBmb3IgbWV0YWRhdGFcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbnVtVGVtcG9yYWxMYXllcnM6IG1heF9zdWJfbGF5ZXJzX21pbnVzMSArIDEsXG4gICAgICAgIHRlbXBvcmFsSWROZXN0ZWQ6IHRlbXBvcmFsX2lkX25lc3RpbmdfZmxhZ1xuICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5yZWFkU1BTID0gZnVuY3Rpb24gcmVhZFNQUyhzcHMpIHtcbiAgICAgIHZhciBlZyA9IG5ldyBFeHBHb2xvbWIodGhpcy5lYnNwMnJic3Aoc3BzKSk7XG4gICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgZWcucmVhZEJpdHMoNCk7IC8vdmlkZW9fcGFyYW1ldGVyX3NldF9pZFxuICAgICAgdmFyIG1heF9zdWJfbGF5ZXJzX21pbnVzMSA9IGVnLnJlYWRCaXRzKDMpO1xuICAgICAgZWcucmVhZEJvb2xlYW4oKTsgLy8gdGVtcG9yYWxfaWRfbmVzdGluZ19mbGFnXG5cbiAgICAgIC8vIHByb2ZpbGVfdGllcl9sZXZlbFxuICAgICAgdmFyIGdlbmVyYWxfcHJvZmlsZV9zcGFjZSA9IGVnLnJlYWRCaXRzKDIpO1xuICAgICAgdmFyIGdlbmVyYWxfdGllcl9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIHZhciBnZW5lcmFsX3Byb2ZpbGVfaWRjID0gZWcucmVhZEJpdHMoNSk7XG4gICAgICB2YXIgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfMSA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgdmFyIGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzIgPSBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgIHZhciBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc18zID0gZWcucmVhZFVCeXRlKCk7XG4gICAgICB2YXIgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfNCA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgdmFyIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfMSA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgdmFyIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfMiA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgdmFyIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfMyA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgdmFyIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfNCA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgdmFyIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfNSA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgdmFyIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfNiA9IGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgdmFyIGdlbmVyYWxfbGV2ZWxfaWRjID0gZWcucmVhZFVCeXRlKCk7XG4gICAgICB2YXIgc3ViX2xheWVyX3Byb2ZpbGVfcHJlc2VudF9mbGFncyA9IFtdO1xuICAgICAgdmFyIHN1Yl9sYXllcl9sZXZlbF9wcmVzZW50X2ZsYWdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heF9zdWJfbGF5ZXJzX21pbnVzMTsgaSsrKSB7XG4gICAgICAgIHN1Yl9sYXllcl9wcm9maWxlX3ByZXNlbnRfZmxhZ3MucHVzaChlZy5yZWFkQm9vbGVhbigpKTtcbiAgICAgICAgc3ViX2xheWVyX2xldmVsX3ByZXNlbnRfZmxhZ3MucHVzaChlZy5yZWFkQm9vbGVhbigpKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhfc3ViX2xheWVyc19taW51czEgPiAwKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gbWF4X3N1Yl9sYXllcnNfbWludXMxOyBfaSA8IDg7IF9pKyspIHtcbiAgICAgICAgICBlZy5yZWFkQml0cygyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbWF4X3N1Yl9sYXllcnNfbWludXMxOyBfaTIrKykge1xuICAgICAgICBpZiAoc3ViX2xheWVyX3Byb2ZpbGVfcHJlc2VudF9mbGFnc1tfaTJdKSB7XG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7IC8vIHN1Yl9sYXllcl9wcm9maWxlX3NwYWNlLCBzdWJfbGF5ZXJfdGllcl9mbGFnLCBzdWJfbGF5ZXJfcHJvZmlsZV9pZGNcbiAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTsgLy8gc3ViX2xheWVyX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnXG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yl9sYXllcl9sZXZlbF9wcmVzZW50X2ZsYWdzW19pMl0pIHtcbiAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWcucmVhZFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgICAgdmFyIGNocm9tYV9mb3JtYXRfaWRjID0gZWcucmVhZFVFRygpO1xuICAgICAgaWYgKGNocm9tYV9mb3JtYXRfaWRjID09IDMpIHtcbiAgICAgICAgZWcuc2tpcEJpdHMoMSk7IC8vc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcbiAgICAgIH1cbiAgICAgIHZhciBwaWNfd2lkdGhfaW5fbHVtYV9zYW1wbGVzID0gZWcucmVhZFVFRygpO1xuICAgICAgdmFyIHBpY19oZWlnaHRfaW5fbHVtYV9zYW1wbGVzID0gZWcucmVhZFVFRygpO1xuICAgICAgdmFyIGNvbmZvcm1hbmNlX3dpbmRvd19mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIHZhciBwaWNfbGVmdF9vZmZzZXQgPSAwLFxuICAgICAgICBwaWNfcmlnaHRfb2Zmc2V0ID0gMCxcbiAgICAgICAgcGljX3RvcF9vZmZzZXQgPSAwLFxuICAgICAgICBwaWNfYm90dG9tX29mZnNldCA9IDA7XG4gICAgICBpZiAoY29uZm9ybWFuY2Vfd2luZG93X2ZsYWcpIHtcbiAgICAgICAgcGljX2xlZnRfb2Zmc2V0ICs9IGVnLnJlYWRVRUcoKTtcbiAgICAgICAgcGljX3JpZ2h0X29mZnNldCArPSBlZy5yZWFkVUVHKCk7XG4gICAgICAgIHBpY190b3Bfb2Zmc2V0ICs9IGVnLnJlYWRVRUcoKTtcbiAgICAgICAgcGljX2JvdHRvbV9vZmZzZXQgKz0gZWcucmVhZFVFRygpO1xuICAgICAgfVxuICAgICAgdmFyIGJpdF9kZXB0aF9sdW1hX21pbnVzOCA9IGVnLnJlYWRVRUcoKTtcbiAgICAgIHZhciBiaXRfZGVwdGhfY2hyb21hX21pbnVzOCA9IGVnLnJlYWRVRUcoKTtcbiAgICAgIHZhciBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czQgPSBlZy5yZWFkVUVHKCk7XG4gICAgICB2YXIgc3ViX2xheWVyX29yZGVyaW5nX2luZm9fcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIGZvciAodmFyIF9pMyA9IHN1Yl9sYXllcl9vcmRlcmluZ19pbmZvX3ByZXNlbnRfZmxhZyA/IDAgOiBtYXhfc3ViX2xheWVyc19taW51czE7IF9pMyA8PSBtYXhfc3ViX2xheWVyc19taW51czE7IF9pMysrKSB7XG4gICAgICAgIGVnLnNraXBVRUcoKTsgLy8gbWF4X2RlY19waWNfYnVmZmVyaW5nX21pbnVzMVtpXVxuICAgICAgICBlZy5za2lwVUVHKCk7IC8vIG1heF9udW1fcmVvcmRlcl9waWNzW2ldXG4gICAgICAgIGVnLnNraXBVRUcoKTsgLy8gbWF4X2xhdGVuY3lfaW5jcmVhc2VfcGx1czFbaV1cbiAgICAgIH1cbiAgICAgIGVnLnNraXBVRUcoKTsgLy8gbG9nMl9taW5fbHVtYV9jb2RpbmdfYmxvY2tfc2l6ZV9taW51czNcbiAgICAgIGVnLnNraXBVRUcoKTsgLy8gbG9nMl9kaWZmX21heF9taW5fbHVtYV9jb2RpbmdfYmxvY2tfc2l6ZVxuICAgICAgZWcuc2tpcFVFRygpOyAvLyBsb2cyX21pbl90cmFuc2Zvcm1fYmxvY2tfc2l6ZV9taW51czJcbiAgICAgIGVnLnNraXBVRUcoKTsgLy8gbG9nMl9kaWZmX21heF9taW5fdHJhbnNmb3JtX2Jsb2NrX3NpemVcbiAgICAgIGVnLnNraXBVRUcoKTsgLy8gbWF4X3RyYW5zZm9ybV9oaWVyYXJjaHlfZGVwdGhfaW50ZXJcbiAgICAgIGVnLnNraXBVRUcoKTsgLy8gbWF4X3RyYW5zZm9ybV9oaWVyYXJjaHlfZGVwdGhfaW50cmFcbiAgICAgIHZhciBzY2FsaW5nX2xpc3RfZW5hYmxlZF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIGlmIChzY2FsaW5nX2xpc3RfZW5hYmxlZF9mbGFnKSB7XG4gICAgICAgIHZhciBzcHNfc2NhbGluZ19saXN0X2RhdGFfcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgaWYgKHNwc19zY2FsaW5nX2xpc3RfZGF0YV9wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaXplSWQgPSAwOyBzaXplSWQgPCA0OyBzaXplSWQrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgbWF0cml4SWQgPSAwOyBtYXRyaXhJZCA8IChzaXplSWQgPT09IDMgPyAyIDogNik7IG1hdHJpeElkKyspIHtcbiAgICAgICAgICAgICAgdmFyIHNjYWxpbmdfbGlzdF9wcmVkX21vZGVfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgICAgIGlmICghc2NhbGluZ19saXN0X3ByZWRfbW9kZV9mbGFnKSB7XG4gICAgICAgICAgICAgICAgZWcucmVhZFVFRygpOyAvLyBzY2FsaW5nX2xpc3RfcHJlZF9tYXRyaXhfaWRfZGVsdGFcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY29lZk51bSA9IE1hdGgubWluKDY0LCAxIDw8IDQgKyAoc2l6ZUlkIDw8IDEpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZUlkID4gMSkge1xuICAgICAgICAgICAgICAgICAgZWcucmVhZEVHKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGNvZWZOdW07IF9pNCsrKSB7XG4gICAgICAgICAgICAgICAgICBlZy5yZWFkRUcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIGFtcF9lbmFibGVkX2ZsYWdcbiAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIHNhbXBsZV9hZGFwdGl2ZV9vZmZzZXRfZW5hYmxlZF9mbGFnXG4gICAgICB2YXIgcGNtX2VuYWJsZWRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICBpZiAocGNtX2VuYWJsZWRfZmxhZykge1xuICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgZWcuc2tpcFVFRygpO1xuICAgICAgICBlZy5za2lwVUVHKCk7XG4gICAgICAgIGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICB9XG4gICAgICB2YXIgbnVtX3Nob3J0X3Rlcm1fcmVmX3BpY19zZXRzID0gZWcucmVhZFVFRygpO1xuICAgICAgdmFyIG51bV9kZWx0YV9wb2NzID0gMDtcbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG51bV9zaG9ydF90ZXJtX3JlZl9waWNfc2V0czsgX2k1KyspIHtcbiAgICAgICAgdmFyIGludGVyX3JlZl9waWNfc2V0X3ByZWRpY3Rpb25fZmxhZyA9IGZhbHNlO1xuICAgICAgICBpZiAoX2k1ICE9PSAwKSB7XG4gICAgICAgICAgaW50ZXJfcmVmX3BpY19zZXRfcHJlZGljdGlvbl9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJfcmVmX3BpY19zZXRfcHJlZGljdGlvbl9mbGFnKSB7XG4gICAgICAgICAgaWYgKF9pNSA9PT0gbnVtX3Nob3J0X3Rlcm1fcmVmX3BpY19zZXRzKSB7XG4gICAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgIHZhciBuZXh0X251bV9kZWx0YV9wb2NzID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBudW1fZGVsdGFfcG9jczsgaisrKSB7XG4gICAgICAgICAgICB2YXIgdXNlZF9ieV9jdXJyX3BpY19mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICAgIHZhciB1c2VfZGVsdGFfZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF1c2VkX2J5X2N1cnJfcGljX2ZsYWcpIHtcbiAgICAgICAgICAgICAgdXNlX2RlbHRhX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZWRfYnlfY3Vycl9waWNfZmxhZyB8fCB1c2VfZGVsdGFfZmxhZykge1xuICAgICAgICAgICAgICBuZXh0X251bV9kZWx0YV9wb2NzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bV9kZWx0YV9wb2NzID0gbmV4dF9udW1fZGVsdGFfcG9jcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbnVtX25lZ2F0aXZlX3BpY3MgPSBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgdmFyIG51bV9wb3NpdGl2ZV9waWNzID0gZWcucmVhZFVFRygpO1xuICAgICAgICAgIG51bV9kZWx0YV9wb2NzID0gbnVtX25lZ2F0aXZlX3BpY3MgKyBudW1fcG9zaXRpdmVfcGljcztcbiAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtX25lZ2F0aXZlX3BpY3M7IF9qKyspIHtcbiAgICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICAgIGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG51bV9wb3NpdGl2ZV9waWNzOyBfajIrKykge1xuICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBsb25nX3Rlcm1fcmVmX3BpY3NfcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIGlmIChsb25nX3Rlcm1fcmVmX3BpY3NfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgIHZhciBudW1fbG9uZ190ZXJtX3JlZl9waWNzX3NwcyA9IGVnLnJlYWRVRUcoKTtcbiAgICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbnVtX2xvbmdfdGVybV9yZWZfcGljc19zcHM7IF9pNisrKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2ozID0gMDsgX2ozIDwgbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0ICsgNDsgX2ozKyspIHtcbiAgICAgICAgICAgIGVnLnJlYWRCaXRzKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZy5yZWFkQml0cygxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMgPSAwO1xuICAgICAgdmFyIHNhcl93aWR0aCA9IDEsXG4gICAgICAgIHNhcl9oZWlnaHQgPSAxO1xuICAgICAgdmFyIGZwc19maXhlZCA9IHRydWUsXG4gICAgICAgIGZwc19kZW4gPSAxLFxuICAgICAgICBmcHNfbnVtID0gMDtcbiAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIHNwc190ZW1wb3JhbF9tdnBfZW5hYmxlZF9mbGFnXG4gICAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyBzdHJvbmdfaW50cmFfc21vb3RoaW5nX2VuYWJsZWRfZmxhZ1xuICAgICAgdmFyIGRlZmF1bHRfZGlzcGxheV93aW5kb3dfZmxhZyA9IGZhbHNlO1xuICAgICAgdmFyIHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICBpZiAodnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgIHZhciBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICBpZiAoYXNwZWN0X3JhdGlvX2luZm9fcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgdmFyIGFzcGVjdF9yYXRpb19pZGMgPSBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICB2YXIgc2FyX3dpZHRoX3RhYmxlID0gWzEsIDEyLCAxMCwgMTYsIDQwLCAyNCwgMjAsIDMyLCA4MCwgMTgsIDE1LCA2NCwgMTYwLCA0LCAzLCAyXTtcbiAgICAgICAgICB2YXIgc2FyX2hlaWdodF90YWJsZSA9IFsxLCAxMSwgMTEsIDExLCAzMywgMTEsIDExLCAxMSwgMzMsIDExLCAxMSwgMzMsIDk5LCAzLCAyLCAxXTtcbiAgICAgICAgICBpZiAoYXNwZWN0X3JhdGlvX2lkYyA+IDAgJiYgYXNwZWN0X3JhdGlvX2lkYyA8IDE2KSB7XG4gICAgICAgICAgICBzYXJfd2lkdGggPSBzYXJfd2lkdGhfdGFibGVbYXNwZWN0X3JhdGlvX2lkYyAtIDFdO1xuICAgICAgICAgICAgc2FyX2hlaWdodCA9IHNhcl9oZWlnaHRfdGFibGVbYXNwZWN0X3JhdGlvX2lkYyAtIDFdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXNwZWN0X3JhdGlvX2lkYyA9PT0gMjU1KSB7XG4gICAgICAgICAgICBzYXJfd2lkdGggPSBlZy5yZWFkQml0cygxNik7XG4gICAgICAgICAgICBzYXJfaGVpZ2h0ID0gZWcucmVhZEJpdHMoMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3ZlcnNjYW5faW5mb19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICBpZiAob3ZlcnNjYW5faW5mb19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWRlb19zaWduYWxfdHlwZV9wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICBpZiAodmlkZW9fc2lnbmFsX3R5cGVfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgZWcucmVhZEJpdHMoMyk7XG4gICAgICAgICAgZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICB2YXIgY29sb3VyX2Rlc2NyaXB0aW9uX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgaWYgKGNvbG91cl9kZXNjcmlwdGlvbl9wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgZWcucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNocm9tYV9sb2NfaW5mb19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICBpZiAoY2hyb21hX2xvY19pbmZvX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgIGVnLnJlYWRVRUcoKTtcbiAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWcucmVhZEJvb2xlYW4oKTsgLy8gbmV1dHJhbF9jaHJvbWFfaW5kaWNhdGlvbl9mbGFnXG4gICAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIGZpZWxkX3NlcV9mbGFnXG4gICAgICAgIGVnLnJlYWRCb29sZWFuKCk7IC8vIGZyYW1lX2ZpZWxkX2luZm9fcHJlc2VudF9mbGFnXG4gICAgICAgIGRlZmF1bHRfZGlzcGxheV93aW5kb3dfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgIGlmIChkZWZhdWx0X2Rpc3BsYXlfd2luZG93X2ZsYWcpIHtcbiAgICAgICAgICBlZy5za2lwVUVHKCk7XG4gICAgICAgICAgZWcuc2tpcFVFRygpO1xuICAgICAgICAgIGVnLnNraXBVRUcoKTtcbiAgICAgICAgICBlZy5za2lwVUVHKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZ1aV90aW1pbmdfaW5mb19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICBpZiAodnVpX3RpbWluZ19pbmZvX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgIGZwc19kZW4gPSBlZy5yZWFkQml0cygzMik7XG4gICAgICAgICAgZnBzX251bSA9IGVnLnJlYWRCaXRzKDMyKTtcbiAgICAgICAgICB2YXIgdnVpX3BvY19wcm9wb3J0aW9uYWxfdG9fdGltaW5nX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgIGlmICh2dWlfcG9jX3Byb3BvcnRpb25hbF90b190aW1pbmdfZmxhZykge1xuICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdnVpX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgaWYgKHZ1aV9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgIC8vY29uc3QgY29tbW9uSW5mUHJlc2VudEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgLy9pZiAoY29tbW9uSW5mUHJlc2VudEZsYWcpIHtcbiAgICAgICAgICAgIHZhciBuYWxfaHJkX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICAgIHZhciB2Y2xfaHJkX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICAgIHZhciBzdWJfcGljX2hyZF9wYXJhbXNfcHJlc2VudF9mbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmFsX2hyZF9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZyB8fCB2Y2xfaHJkX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnKSB7XG4gICAgICAgICAgICAgIHN1Yl9waWNfaHJkX3BhcmFtc19wcmVzZW50X2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgICAgICBpZiAoc3ViX3BpY19ocmRfcGFyYW1zX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGVnLnJlYWRCaXRzKDUpO1xuICAgICAgICAgICAgICAgIGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgICAgICAgZWcucmVhZEJpdHMoNSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWcucmVhZEJpdHMoNCk7IC8vIGJpdF9yYXRlX3NjYWxlXG4gICAgICAgICAgICAgIGVnLnJlYWRCaXRzKDQpOyAvLyBjcGJfc2l6ZV9zY2FsZVxuICAgICAgICAgICAgICBpZiAoc3ViX3BpY19ocmRfcGFyYW1zX3ByZXNlbnRfZmxhZykge1xuICAgICAgICAgICAgICAgIGVnLnJlYWRCaXRzKDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVnLnJlYWRCaXRzKDUpO1xuICAgICAgICAgICAgICBlZy5yZWFkQml0cyg1KTtcbiAgICAgICAgICAgICAgZWcucmVhZEJpdHMoNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8PSBtYXhfc3ViX2xheWVyc19taW51czE7IF9pNysrKSB7XG4gICAgICAgICAgICAgIGZwc19maXhlZCA9IGVnLnJlYWRCb29sZWFuKCk7IC8vIGZpeGVkX3BpY19yYXRlX2dlbmVyYWxfZmxhZ1xuICAgICAgICAgICAgICB2YXIgZml4ZWRfcGljX3JhdGVfd2l0aGluX2N2c19mbGFnID0gZnBzX2ZpeGVkIHx8IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgICAgIHZhciBsb3dfZGVsYXlfaHJkX2ZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGZpeGVkX3BpY19yYXRlX3dpdGhpbl9jdnNfZmxhZykge1xuICAgICAgICAgICAgICAgIGVnLnJlYWRFRygpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvd19kZWxheV9ocmRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNwYl9jbnQgPSBsb3dfZGVsYXlfaHJkX2ZsYWcgPyAxIDogZWcucmVhZFVFRygpICsgMTtcbiAgICAgICAgICAgICAgaWYgKG5hbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfajQgPSAwOyBfajQgPCBjcGJfY250OyBfajQrKykge1xuICAgICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHN1Yl9waWNfaHJkX3BhcmFtc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlZy5za2lwQml0cygxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZjbF9ocmRfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfajUgPSAwOyBfajUgPCBjcGJfY250OyBfajUrKykge1xuICAgICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHN1Yl9waWNfaHJkX3BhcmFtc19wcmVzZW50X2ZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWcucmVhZFVFRygpO1xuICAgICAgICAgICAgICAgICAgICBlZy5yZWFkVUVHKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlZy5za2lwQml0cygxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpdHN0cmVhbV9yZXN0cmljdGlvbl9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgaWYgKGJpdHN0cmVhbV9yZXN0cmljdGlvbl9mbGFnKSB7XG4gICAgICAgICAgZWcucmVhZEJvb2xlYW4oKTsgLy8gdGlsZXNfZml4ZWRfc3RydWN0dXJlX2ZsYWdcbiAgICAgICAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyBtb3Rpb25fdmVjdG9yc19vdmVyX3BpY19ib3VuZGFyaWVzX2ZsYWdcbiAgICAgICAgICBlZy5yZWFkQm9vbGVhbigpOyAvLyByZXN0cmljdGVkX3JlZl9waWNfbGlzdHNfZmxhZ1xuICAgICAgICAgIG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMgPSBlZy5yZWFkVUVHKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB3aWR0aCA9IHBpY193aWR0aF9pbl9sdW1hX3NhbXBsZXMsXG4gICAgICAgIGhlaWdodCA9IHBpY19oZWlnaHRfaW5fbHVtYV9zYW1wbGVzO1xuICAgICAgaWYgKGNvbmZvcm1hbmNlX3dpbmRvd19mbGFnKSB7XG4gICAgICAgIHZhciBjaHJvbWFfc2NhbGVfdyA9IDEsXG4gICAgICAgICAgY2hyb21hX3NjYWxlX2ggPSAxO1xuICAgICAgICBpZiAoY2hyb21hX2Zvcm1hdF9pZGMgPT09IDEpIHtcbiAgICAgICAgICAvLyBZVVYgNDIwXG4gICAgICAgICAgY2hyb21hX3NjYWxlX3cgPSBjaHJvbWFfc2NhbGVfaCA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hyb21hX2Zvcm1hdF9pZGMgPT0gMikge1xuICAgICAgICAgIC8vIFlVViA0MjJcbiAgICAgICAgICBjaHJvbWFfc2NhbGVfdyA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgd2lkdGggPSBwaWNfd2lkdGhfaW5fbHVtYV9zYW1wbGVzIC0gY2hyb21hX3NjYWxlX3cgKiBwaWNfcmlnaHRfb2Zmc2V0IC0gY2hyb21hX3NjYWxlX3cgKiBwaWNfbGVmdF9vZmZzZXQ7XG4gICAgICAgIGhlaWdodCA9IHBpY19oZWlnaHRfaW5fbHVtYV9zYW1wbGVzIC0gY2hyb21hX3NjYWxlX2ggKiBwaWNfYm90dG9tX29mZnNldCAtIGNocm9tYV9zY2FsZV9oICogcGljX3RvcF9vZmZzZXQ7XG4gICAgICB9XG4gICAgICB2YXIgcHJvZmlsZV9zcGFjZV9zdHJpbmcgPSBnZW5lcmFsX3Byb2ZpbGVfc3BhY2UgPyBbJ0EnLCAnQicsICdDJ11bZ2VuZXJhbF9wcm9maWxlX3NwYWNlXSA6ICcnO1xuICAgICAgdmFyIHByb2ZpbGVfY29tcGF0aWJpbGl0eV9idWYgPSBnZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc18xIDw8IDI0IHwgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfMiA8PCAxNiB8IGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzMgPDwgOCB8IGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzXzQ7XG4gICAgICB2YXIgcHJvZmlsZV9jb21wYXRpYmlsaXR5X3JldiA9IDA7XG4gICAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCAzMjsgX2k4KyspIHtcbiAgICAgICAgcHJvZmlsZV9jb21wYXRpYmlsaXR5X3JldiA9IChwcm9maWxlX2NvbXBhdGliaWxpdHlfcmV2IHwgKHByb2ZpbGVfY29tcGF0aWJpbGl0eV9idWYgPj4gX2k4ICYgMSkgPDwgMzEgLSBfaTgpID4+PiAwOyAvLyByZXZlcnNlIGJpdCBwb3NpdGlvbiAoYW5kIGNhc3QgYXMgVUludDMyKVxuICAgICAgfVxuICAgICAgdmFyIHByb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc19zdHJpbmcgPSBwcm9maWxlX2NvbXBhdGliaWxpdHlfcmV2LnRvU3RyaW5nKDE2KTtcbiAgICAgIGlmIChnZW5lcmFsX3Byb2ZpbGVfaWRjID09PSAxICYmIHByb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc19zdHJpbmcgPT09ICcyJykge1xuICAgICAgICBwcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3Nfc3RyaW5nID0gJzYnO1xuICAgICAgfVxuICAgICAgdmFyIHRpZXJfZmxhZ19zdHJpbmcgPSBnZW5lcmFsX3RpZXJfZmxhZyA/ICdIJyA6ICdMJztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVjU3RyaW5nOiBcImh2YzEuXCIgKyBwcm9maWxlX3NwYWNlX3N0cmluZyArIGdlbmVyYWxfcHJvZmlsZV9pZGMgKyBcIi5cIiArIHByb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc19zdHJpbmcgKyBcIi5cIiArIHRpZXJfZmxhZ19zdHJpbmcgKyBnZW5lcmFsX2xldmVsX2lkYyArIFwiLkIwXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGdlbmVyYWxfdGllcl9mbGFnOiBnZW5lcmFsX3RpZXJfZmxhZyxcbiAgICAgICAgICBnZW5lcmFsX3Byb2ZpbGVfaWRjOiBnZW5lcmFsX3Byb2ZpbGVfaWRjLFxuICAgICAgICAgIGdlbmVyYWxfcHJvZmlsZV9zcGFjZTogZ2VuZXJhbF9wcm9maWxlX3NwYWNlLFxuICAgICAgICAgIGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzOiBbZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfMSwgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfMiwgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfMywgZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NfNF0sXG4gICAgICAgICAgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnczogW2dlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfMSwgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc18yLCBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzXzMsIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NfNCwgZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc181LCBnZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzXzZdLFxuICAgICAgICAgIGdlbmVyYWxfbGV2ZWxfaWRjOiBnZW5lcmFsX2xldmVsX2lkYyxcbiAgICAgICAgICBiaXRfZGVwdGg6IGJpdF9kZXB0aF9sdW1hX21pbnVzOCArIDgsXG4gICAgICAgICAgYml0X2RlcHRoX2x1bWFfbWludXM4OiBiaXRfZGVwdGhfbHVtYV9taW51czgsXG4gICAgICAgICAgYml0X2RlcHRoX2Nocm9tYV9taW51czg6IGJpdF9kZXB0aF9jaHJvbWFfbWludXM4LFxuICAgICAgICAgIG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGM6IG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMsXG4gICAgICAgICAgY2hyb21hX2Zvcm1hdF9pZGM6IGNocm9tYV9mb3JtYXRfaWRjLFxuICAgICAgICAgIGZyYW1lX3JhdGU6IHtcbiAgICAgICAgICAgIGZpeGVkOiBmcHNfZml4ZWQsXG4gICAgICAgICAgICBmcHM6IGZwc19udW0gLyBmcHNfZGVuXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvOiBbc2FyX3dpZHRoLCBzYXJfaGVpZ2h0XVxuICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5yZWFkUFBTID0gZnVuY3Rpb24gcmVhZFBQUyhwcHMpIHtcbiAgICAgIHZhciBlZyA9IG5ldyBFeHBHb2xvbWIodGhpcy5lYnNwMnJic3AocHBzKSk7XG4gICAgICBlZy5yZWFkVUJ5dGUoKTtcbiAgICAgIGVnLnJlYWRVQnl0ZSgpO1xuICAgICAgZWcuc2tpcFVFRygpOyAvLyBwaWNfcGFyYW1ldGVyX3NldF9pZFxuICAgICAgZWcuc2tpcFVFRygpOyAvLyBzZXFfcGFyYW1ldGVyX3NldF9pZFxuICAgICAgZWcuc2tpcEJpdHMoMik7IC8vIGRlcGVuZGVudF9zbGljZV9zZWdtZW50c19lbmFibGVkX2ZsYWcsIG91dHB1dF9mbGFnX3ByZXNlbnRfZmxhZ1xuICAgICAgZWcuc2tpcEJpdHMoMyk7IC8vIG51bV9leHRyYV9zbGljZV9oZWFkZXJfYml0c1xuICAgICAgZWcuc2tpcEJpdHMoMik7IC8vIHNpZ25fZGF0YV9oaWRpbmdfZW5hYmxlZF9mbGFnLCBjYWJhY19pbml0X3ByZXNlbnRfZmxhZ1xuICAgICAgZWcuc2tpcFVFRygpO1xuICAgICAgZWcuc2tpcFVFRygpO1xuICAgICAgZWcuc2tpcEVHKCk7IC8vIGluaXRfcXBfbWludXMyNlxuICAgICAgZWcuc2tpcEJpdHMoMik7IC8vIGNvbnN0cmFpbmVkX2ludHJhX3ByZWRfZmxhZywgdHJhbnNmb3JtX3NraXBfZW5hYmxlZF9mbGFnXG4gICAgICB2YXIgY3VfcXBfZGVsdGFfZW5hYmxlZF9mbGFnID0gZWcucmVhZEJvb2xlYW4oKTtcbiAgICAgIGlmIChjdV9xcF9kZWx0YV9lbmFibGVkX2ZsYWcpIHtcbiAgICAgICAgZWcuc2tpcFVFRygpO1xuICAgICAgfVxuICAgICAgZWcuc2tpcEVHKCk7IC8vIGNiX3FwX29mZnNldFxuICAgICAgZWcuc2tpcEVHKCk7IC8vIGNyX3FwX29mZnNldFxuICAgICAgZWcuc2tpcEJpdHMoNCk7IC8vIHBwc19zbGljZV9jaHJvbWFfcXBfb2Zmc2V0c19wcmVzZW50X2ZsYWcsIHdlaWdodGVkX3ByZWRfZmxhZywgd2VpZ2h0ZWRfYmlwcmVkX2ZsYWcsIHRyYW5zcXVhbnRfYnlwYXNzX2VuYWJsZWRfZmxhZ1xuICAgICAgdmFyIHRpbGVzX2VuYWJsZWRfZmxhZyA9IGVnLnJlYWRCb29sZWFuKCk7XG4gICAgICB2YXIgZW50cm9weV9jb2Rpbmdfc3luY19lbmFibGVkX2ZsYWcgPSBlZy5yZWFkQm9vbGVhbigpO1xuICAgICAgdmFyIHBhcmFsbGVsaXNtVHlwZSA9IDE7IC8vIHNsaWNlLWJhc2VkIHBhcmFsbGVsIGRlY29kaW5nXG4gICAgICBpZiAoZW50cm9weV9jb2Rpbmdfc3luY19lbmFibGVkX2ZsYWcgJiYgdGlsZXNfZW5hYmxlZF9mbGFnKSB7XG4gICAgICAgIHBhcmFsbGVsaXNtVHlwZSA9IDA7IC8vIG1peGVkLXR5cGUgcGFyYWxsZWwgZGVjb2RpbmdcbiAgICAgIH0gZWxzZSBpZiAoZW50cm9weV9jb2Rpbmdfc3luY19lbmFibGVkX2ZsYWcpIHtcbiAgICAgICAgcGFyYWxsZWxpc21UeXBlID0gMzsgLy8gd2F2ZWZyb250LWJhc2VkIHBhcmFsbGVsIGRlY29kaW5nXG4gICAgICB9IGVsc2UgaWYgKHRpbGVzX2VuYWJsZWRfZmxhZykge1xuICAgICAgICBwYXJhbGxlbGlzbVR5cGUgPSAyOyAvLyB0aWxlLWJhc2VkIHBhcmFsbGVsIGRlY29kaW5nXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbGxlbGlzbVR5cGU6IHBhcmFsbGVsaXNtVHlwZVxuICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5tYXRjaFNQUyA9IGZ1bmN0aW9uIG1hdGNoU1BTKHNwczEsIHNwczIpIHtcbiAgICAgIC8vIGNvbXBhcmUgd2l0aG91dCBoZWFkZXJzIGFuZCBWUFMgcmVsYXRlZCBwYXJhbXNcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHNwczEpLnN1YnN0cigzKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBzcHMyKS5zdWJzdHIoMyk7XG4gICAgfTtcbiAgICByZXR1cm4gSGV2Y1ZpZGVvUGFyc2VyO1xuICB9KEJhc2VWaWRlb1BhcnNlcik7XG5cbiAgdmFyIFBBQ0tFVF9MRU5HVEggPSAxODg7XG4gIHZhciBUU0RlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRTRGVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCBsb2dnZXIpIHtcbiAgICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgICB0aGlzLl92aWRlb1RyYWNrID0gdm9pZCAwO1xuICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwO1xuICAgICAgdGhpcy5fdHh0VHJhY2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLnZpZGVvUGFyc2VyID0gdm9pZCAwO1xuICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICB0aGlzLnZpZGVvUGFyc2VyID0gbnVsbDtcbiAgICB9XG4gICAgVFNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSwgbG9nZ2VyKSB7XG4gICAgICB2YXIgc3luY09mZnNldCA9IFRTRGVtdXhlci5zeW5jT2Zmc2V0KGRhdGEpO1xuICAgICAgaWYgKHN5bmNPZmZzZXQgPiAwKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCBcIiArIHN5bmNPZmZzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN5bmNPZmZzZXQgIT09IC0xO1xuICAgIH07XG4gICAgVFNEZW11eGVyLnN5bmNPZmZzZXQgPSBmdW5jdGlvbiBzeW5jT2Zmc2V0KGRhdGEpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHZhciBzY2Fud2luZG93ID0gTWF0aC5taW4oUEFDS0VUX0xFTkdUSCAqIDUsIGxlbmd0aCAtIFBBQ0tFVF9MRU5HVEgpICsgMTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgc2NhbndpbmRvdykge1xuICAgICAgICAvLyBhIFRTIGluaXQgc2VnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAyIFRTIHBhY2tldHM6IFBBVCBhbmQgUE1ULCBlYWNoIHN0YXJ0aW5nIHdpdGggMHg0N1xuICAgICAgICB2YXIgZm91bmRQYXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHBhY2tldFN0YXJ0ID0gLTE7XG4gICAgICAgIHZhciB0c1BhY2tldHMgPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGxlbmd0aDsgaiArPSBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICAgICAgaWYgKGRhdGFbal0gPT09IDB4NDcgJiYgKGxlbmd0aCAtIGogPT09IFBBQ0tFVF9MRU5HVEggfHwgZGF0YVtqICsgUEFDS0VUX0xFTkdUSF0gPT09IDB4NDcpKSB7XG4gICAgICAgICAgICB0c1BhY2tldHMrKztcbiAgICAgICAgICAgIGlmIChwYWNrZXRTdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcGFja2V0U3RhcnQgPSBqO1xuICAgICAgICAgICAgICAvLyBGaXJzdCBzeW5jIHdvcmQgZm91bmQgYXQgb2Zmc2V0LCBpbmNyZWFzZSBzY2FuIGxlbmd0aCAoIzUyNTEpXG4gICAgICAgICAgICAgIGlmIChwYWNrZXRTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHNjYW53aW5kb3cgPSBNYXRoLm1pbihwYWNrZXRTdGFydCArIFBBQ0tFVF9MRU5HVEggKiA5OSwgZGF0YS5sZW5ndGggLSBQQUNLRVRfTEVOR1RIKSArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmRQYXQpIHtcbiAgICAgICAgICAgICAgZm91bmRQYXQgPSBwYXJzZVBJRChkYXRhLCBqKSA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN5bmMgd29yZCBmb3VuZCBhdCAwIHdpdGggMyBwYWNrZXRzLCBvciBmb3VuZCBhdCBvZmZzZXQgbGVhc3QgMiBwYWNrZXRzIHVwIHRvIHNjYW53aW5kb3cgKCM1NTAxKVxuICAgICAgICAgICAgaWYgKGZvdW5kUGF0ICYmIHRzUGFja2V0cyA+IDEgJiYgKHBhY2tldFN0YXJ0ID09PSAwICYmIHRzUGFja2V0cyA+IDIgfHwgaiArIFBBQ0tFVF9MRU5HVEggPiBzY2Fud2luZG93KSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFja2V0U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0c1BhY2tldHMpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgaWYgc3luYyB3b3JkIGZvdW5kLCBidXQgZG9lcyBub3QgY29udGFpbiBjb250aWd1b3VzIHBhY2tldHNcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHJhY2sgbW9kZWwgaW50ZXJuYWwgdG8gZGVtdXhlciB1c2VkIHRvIGRyaXZlIHJlbXV4aW5nIGlucHV0XG4gICAgICovO1xuICAgIFRTRGVtdXhlci5jcmVhdGVUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVRyYWNrKHR5cGUsIGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluZXI6IHR5cGUgPT09ICd2aWRlbycgfHwgdHlwZSA9PT0gJ2F1ZGlvJyA/ICd2aWRlby9tcDJ0JyA6IHVuZGVmaW5lZCxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgaWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgICBwaWQ6IC0xLFxuICAgICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgICBzYW1wbGVzOiBbXSxcbiAgICAgICAgZHJvcHBlZDogMCxcbiAgICAgICAgZHVyYXRpb246IHR5cGUgPT09ICdhdWRpbycgPyBkdXJhdGlvbiA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbml0IHNlZ21lbnQgb24gdGhlIGRlbXV4ZXIvcmVtdXhlciBpbnRlcmZhY2UuIE5lZWRlZCBmb3IgZGlzY29udGludWl0aWVzL3RyYWNrLXN3aXRjaGVzIChvciBhdCBzdHJlYW0gc3RhcnQpXG4gICAgICogUmVzZXRzIGFsbCBpbnRlcm5hbCB0cmFjayBpbnN0YW5jZXMgb2YgdGhlIGRlbXV4ZXIuXG4gICAgICovO1xuICAgIHZhciBfcHJvdG8gPSBUU0RlbXV4ZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgICB0aGlzLl92aWRlb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycpO1xuICAgICAgdGhpcy5fdmlkZW9UcmFjay5kdXJhdGlvbiA9IHRyYWNrRHVyYXRpb247XG4gICAgICB0aGlzLl9hdWRpb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdhdWRpbycsIHRyYWNrRHVyYXRpb24pO1xuICAgICAgdGhpcy5faWQzVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2lkMycpO1xuICAgICAgdGhpcy5fdHh0VHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3RleHQnKTtcbiAgICAgIHRoaXMuX2F1ZGlvVHJhY2suc2VnbWVudENvZGVjID0gJ2FhYyc7XG5cbiAgICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICAgIHRoaXMudmlkZW9QYXJzZXIgPSBudWxsO1xuICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcCgpIHt9O1xuICAgIF9wcm90by5yZXNldENvbnRpZ3VpdHkgPSBmdW5jdGlvbiByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgICB2YXIgX2F1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICBfdmlkZW9UcmFjayA9IHRoaXMuX3ZpZGVvVHJhY2ssXG4gICAgICAgIF9pZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgICAgaWYgKF9hdWRpb1RyYWNrKSB7XG4gICAgICAgIF9hdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKF92aWRlb1RyYWNrKSB7XG4gICAgICAgIF92aWRlb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKF9pZDNUcmFjaykge1xuICAgICAgICBfaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVtdXggPSBmdW5jdGlvbiBkZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBpc1NhbXBsZUFlcywgZmx1c2gpIHtcbiAgICAgIGlmIChpc1NhbXBsZUFlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzU2FtcGxlQWVzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZmx1c2ggPT09IHZvaWQgMCkge1xuICAgICAgICBmbHVzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcGVzO1xuICAgICAgdmFyIHZpZGVvVHJhY2sgPSB0aGlzLl92aWRlb1RyYWNrO1xuICAgICAgdmFyIGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgICAgdmFyIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy5fdHh0VHJhY2s7XG4gICAgICB2YXIgdmlkZW9QaWQgPSB2aWRlb1RyYWNrLnBpZDtcbiAgICAgIHZhciB2aWRlb0RhdGEgPSB2aWRlb1RyYWNrLnBlc0RhdGE7XG4gICAgICB2YXIgYXVkaW9QaWQgPSBhdWRpb1RyYWNrLnBpZDtcbiAgICAgIHZhciBpZDNQaWQgPSBpZDNUcmFjay5waWQ7XG4gICAgICB2YXIgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgICAgdmFyIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgICAgdmFyIHVua25vd25QSUQgPSBudWxsO1xuICAgICAgdmFyIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkO1xuICAgICAgdmFyIHBtdElkID0gdGhpcy5fcG10SWQ7XG4gICAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMucmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGxlbiA8IFBBQ0tFVF9MRU5HVEggJiYgIWZsdXNoKSB7XG4gICAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXVkaW9UcmFjazogYXVkaW9UcmFjayxcbiAgICAgICAgICB2aWRlb1RyYWNrOiB2aWRlb1RyYWNrLFxuICAgICAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgICAgICB0ZXh0VHJhY2s6IHRleHRUcmFja1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHN5bmNPZmZzZXQgPSBNYXRoLm1heCgwLCBUU0RlbXV4ZXIuc3luY09mZnNldChkYXRhKSk7XG4gICAgICBsZW4gLT0gKGxlbiAtIHN5bmNPZmZzZXQpICUgUEFDS0VUX0xFTkdUSDtcbiAgICAgIGlmIChsZW4gPCBkYXRhLmJ5dGVMZW5ndGggJiYgIWZsdXNoKSB7XG4gICAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBsZW4sIGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggLSBsZW4pO1xuICAgICAgfVxuXG4gICAgICAvLyBsb29wIHRocm91Z2ggVFMgcGFja2V0c1xuICAgICAgdmFyIHRzUGFja2V0RXJyb3JzID0gMDtcbiAgICAgIGZvciAodmFyIHN0YXJ0ID0gc3luY09mZnNldDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweDQ3KSB7XG4gICAgICAgICAgdmFyIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICAgIHZhciBwaWQgPSBwYXJzZVBJRChkYXRhLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuXG4gICAgICAgICAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgICAgIGNhc2UgdmlkZW9QaWQ6XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyh2aWRlb0RhdGEsIHRoaXMubG9nZ2VyKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVhZHlWaWRlb1BhcnNlcih2aWRlb1RyYWNrLnNlZ21lbnRDb2RlYyk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWRlb1BhcnNlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvUGFyc2VyLnBhcnNlUEVTKHZpZGVvVHJhY2ssIHRleHRUcmFjaywgcGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZGVvRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZpZGVvRGF0YSkge1xuICAgICAgICAgICAgICAgIHZpZGVvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCkpO1xuICAgICAgICAgICAgICAgIHZpZGVvRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYXVkaW9QaWQ6XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEsIHRoaXMubG9nZ2VyKSkpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWMzJzpcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQUMzUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdWRpb0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgICAgICBhdWRpb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgICBhdWRpb0RhdGEuc2l6ZSArPSBzdGFydCArIFBBQ0tFVF9MRU5HVEggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGlkM1BpZDpcbiAgICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhLCB0aGlzLmxvZ2dlcikpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZDNEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgIC8vIHRoaXMubG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBtdElkOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzLCB0aGlzLm9ic2VydmVyLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0cmFjayBpZCBpZiB0cmFjayBQSUQgZm91bmQgd2hpbGUgcGFyc2luZyBQTVRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIHJlc2V0dGluZyB0aGUgUElEIHRvIC0xIGluIGNhc2VcbiAgICAgICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpbiBjYXNlIG9mIHRyYW5zaWVudCBtaXNzaW5nIGF1ZGlvIHNhbXBsZXMgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgICAgICAvLyBOT1RFIHRoaXMgaXMgb25seSB0aGUgUElEIG9mIHRoZSB0cmFjayBhcyBmb3VuZCBpbiBUUyxcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuICAgICAgICAgICAgICAgIHZpZGVvUGlkID0gcGFyc2VkUElEcy52aWRlb1BpZDtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW9QaWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLnBpZCA9IHZpZGVvUGlkO1xuICAgICAgICAgICAgICAgICAgdmlkZW9UcmFjay5zZWdtZW50Q29kZWMgPSBwYXJzZWRQSURzLnNlZ21lbnRWaWRlb0NvZGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdWRpb1BpZCA9IHBhcnNlZFBJRHMuYXVkaW9QaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvUGlkID4gMCkge1xuICAgICAgICAgICAgICAgICAgYXVkaW9UcmFjay5waWQgPSBhdWRpb1BpZDtcbiAgICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID0gcGFyc2VkUElEcy5zZWdtZW50QXVkaW9Db2RlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQzUGlkID0gcGFyc2VkUElEcy5pZDNQaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlkM1BpZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGlkM1RyYWNrLnBpZCA9IGlkM1BpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVua25vd25QSUQgIT09IG51bGwgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk1QRUctVFMgUE1UIGZvdW5kIGF0IFwiICsgc3RhcnQgKyBcIiBhZnRlciB1bmtub3duIFBJRCAnXCIgKyB1bmtub3duUElEICsgXCInLiBCYWNrdHJhY2tpbmcgdG8gc3luYyBieXRlIEBcIiArIHN5bmNPZmZzZXQgKyBcIiB0byBwYXJzZSBhbGwgVFMgcGFja2V0cy5cIik7XG4gICAgICAgICAgICAgICAgICB1bmtub3duUElEID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIC8vIHdlIHNldCBpdCB0byAtMTg4LCB0aGUgKz0gMTg4IGluIHRoZSBmb3IgbG9vcCB3aWxsIHJlc2V0IHN0YXJ0IHRvIDBcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDB4MTE6XG4gICAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB1bmtub3duUElEID0gcGlkO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHNQYWNrZXRFcnJvcnMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRzUGFja2V0RXJyb3JzID4gMCkge1xuICAgICAgICBlbWl0UGFyc2luZ0Vycm9yKHRoaXMub2JzZXJ2ZXIsIG5ldyBFcnJvcihcIkZvdW5kIFwiICsgdHNQYWNrZXRFcnJvcnMgKyBcIiBUUyBwYWNrZXQvcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIDB4NDdcIiksIHVuZGVmaW5lZCwgdGhpcy5sb2dnZXIpO1xuICAgICAgfVxuICAgICAgdmlkZW9UcmFjay5wZXNEYXRhID0gdmlkZW9EYXRhO1xuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgICB2YXIgZGVtdXhSZXN1bHQgPSB7XG4gICAgICAgIGF1ZGlvVHJhY2s6IGF1ZGlvVHJhY2ssXG4gICAgICAgIHZpZGVvVHJhY2s6IHZpZGVvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiB0ZXh0VHJhY2tcbiAgICAgIH07XG4gICAgICBpZiAoZmx1c2gpIHtcbiAgICAgICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVtdXhSZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHZhciByZW1haW5kZXJEYXRhID0gdGhpcy5yZW1haW5kZXJEYXRhO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAocmVtYWluZGVyRGF0YSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmRlbXV4KHJlbWFpbmRlckRhdGEsIC0xLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgdmlkZW9UcmFjazogdGhpcy5fdmlkZW9UcmFjayxcbiAgICAgICAgICBhdWRpb1RyYWNrOiB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayxcbiAgICAgICAgICB0ZXh0VHJhY2s6IHRoaXMuX3R4dFRyYWNrXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKHJlc3VsdCk7XG4gICAgICBpZiAodGhpcy5zYW1wbGVBZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdChyZXN1bHQsIHRoaXMuc2FtcGxlQWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMgPSBmdW5jdGlvbiBleHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdCkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2sgPSBkZW11eFJlc3VsdC5hdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrID0gZGVtdXhSZXN1bHQudmlkZW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2sgPSBkZW11eFJlc3VsdC5pZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrID0gZGVtdXhSZXN1bHQudGV4dFRyYWNrO1xuICAgICAgdmFyIHZpZGVvRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICAgIHZhciBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgICB2YXIgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGE7XG4gICAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgICAgdmFyIHBlcztcbiAgICAgIGlmICh2aWRlb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKHZpZGVvRGF0YSwgdGhpcy5sb2dnZXIpKSkge1xuICAgICAgICB0aGlzLnJlYWR5VmlkZW9QYXJzZXIodmlkZW9UcmFjay5zZWdtZW50Q29kZWMpO1xuICAgICAgICBpZiAodGhpcy52aWRlb1BhcnNlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudmlkZW9QYXJzZXIucGFyc2VQRVModmlkZW9UcmFjaywgdGV4dFRyYWNrLCBwZXMsIHRydWUpO1xuICAgICAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgICAgdmlkZW9UcmFjay5wZXNEYXRhID0gdmlkZW9EYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhLCB0aGlzLmxvZ2dlcikpKSB7XG4gICAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhYzMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnBhcnNlQUMzUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGF1ZGlvRGF0YSAhPSBudWxsICYmIGF1ZGlvRGF0YS5zaXplKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlaXRoZXIgYXVkaW9EYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEsIHRoaXMubG9nZ2VyKSkpIHtcbiAgICAgICAgdGhpcy5wYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKTtcbiAgICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRlbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgICAgdmFyIGRlbXV4UmVzdWx0ID0gdGhpcy5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCB0cnVlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpO1xuICAgICAgdmFyIHNhbXBsZUFlcyA9IHRoaXMuc2FtcGxlQWVzID0gbmV3IFNhbXBsZUFlc0RlY3J5cHRlcih0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZywga2V5RGF0YSk7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlYWR5VmlkZW9QYXJzZXIgPSBmdW5jdGlvbiByZWFkeVZpZGVvUGFyc2VyKGNvZGVjKSB7XG4gICAgICBpZiAodGhpcy52aWRlb1BhcnNlciA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoY29kZWMgPT09ICdhdmMnKSB7XG4gICAgICAgICAgdGhpcy52aWRlb1BhcnNlciA9IG5ldyBBdmNWaWRlb1BhcnNlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVjID09PSAnaGV2YycpIHtcbiAgICAgICAgICB0aGlzLnZpZGVvUGFyc2VyID0gbmV3IEhldmNWaWRlb1BhcnNlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjcnlwdCA9IGZ1bmN0aW9uIGRlY3J5cHQoZGVtdXhSZXN1bHQsIHNhbXBsZUFlcykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciBhdWRpb1RyYWNrID0gZGVtdXhSZXN1bHQuYXVkaW9UcmFjayxcbiAgICAgICAgICB2aWRlb1RyYWNrID0gZGVtdXhSZXN1bHQudmlkZW9UcmFjaztcbiAgICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcyAmJiBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEFhY1NhbXBsZXMoYXVkaW9UcmFjay5zYW1wbGVzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5jb25maWcgPSB0aGlzLmxvZ2dlciA9IHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IHRoaXMudmlkZW9QYXJzZXIgPSB0aGlzLnJlbWFpbmRlckRhdGEgPSB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgICB0aGlzLl92aWRlb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjayA9IHRoaXMuX2lkM1RyYWNrID0gdGhpcy5fdHh0VHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucGFyc2VBQUNQRVMgPSBmdW5jdGlvbiBwYXJzZUFBQ1BFUyh0cmFjaywgcGVzKSB7XG4gICAgICB2YXIgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgdmFyIGFhY092ZXJGbG93ID0gdGhpcy5hYWNPdmVyRmxvdztcbiAgICAgIHZhciBkYXRhID0gcGVzLmRhdGE7XG4gICAgICBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgICAgIHZhciBmcmFtZU1pc3NpbmdCeXRlcyA9IGFhY092ZXJGbG93Lm1pc3Npbmc7XG4gICAgICAgIHZhciBzYW1wbGVMZW5ndGggPSBhYWNPdmVyRmxvdy5zYW1wbGUudW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke3NhbXBsZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcbiAgICAgICAgaWYgKGZyYW1lTWlzc2luZ0J5dGVzID09PSAtMSkge1xuICAgICAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KGFhY092ZXJGbG93LnNhbXBsZS51bml0LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZnJhbWVPdmVyZmxvd0J5dGVzID0gc2FtcGxlTGVuZ3RoIC0gZnJhbWVNaXNzaW5nQnl0ZXM7XG4gICAgICAgICAgYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQuc2V0KGRhdGEuc3ViYXJyYXkoMCwgZnJhbWVNaXNzaW5nQnl0ZXMpLCBmcmFtZU92ZXJmbG93Qnl0ZXMpO1xuICAgICAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNPdmVyRmxvdy5zYW1wbGUpO1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICAgIHZhciBvZmZzZXQ7XG4gICAgICB2YXIgbGVuO1xuICAgICAgZm9yIChvZmZzZXQgPSBzdGFydE9mZnNldCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgIGlmIChpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICAgIGlmIChvZmZzZXQgIT09IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIHZhciByZWFzb247XG4gICAgICAgIHZhciByZWNvdmVyYWJsZSA9IG9mZnNldCA8IGxlbiAtIDE7XG4gICAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICAgIHJlYXNvbiA9IFwiQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OlwiICsgb2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlYXNvbiA9ICdObyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTJztcbiAgICAgICAgfVxuICAgICAgICBlbWl0UGFyc2luZ0Vycm9yKHRoaXMub2JzZXJ2ZXIsIG5ldyBFcnJvcihyZWFzb24pLCByZWNvdmVyYWJsZSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICBpZiAoIXJlY292ZXJhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdGhpcy5hdWRpb0NvZGVjKTtcbiAgICAgIHZhciBwdHM7XG4gICAgICBpZiAocGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHB0cyA9IHBlcy5wdHM7XG4gICAgICB9IGVsc2UgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICAgIC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgICAgICBwdHMgPSBhYWNPdmVyRmxvdy5zYW1wbGUucHRzICsgZnJhbWVEdXJhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBBQUMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc2NhbiBmb3IgYWFjIHNhbXBsZXNcbiAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcbiAgICAgIHZhciBmcmFtZTtcbiAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgICAgZnJhbWUgPSBhcHBlbmRGcmFtZSQxKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgIGlmICghZnJhbWUubWlzc2luZykge1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgIGlmIChpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBmcmFtZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhcnNlTVBFR1BFUyA9IGZ1bmN0aW9uIHBhcnNlTVBFR1BFUyh0cmFjaywgcGVzKSB7XG4gICAgICB2YXIgZGF0YSA9IHBlcy5kYXRhO1xuICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgcHRzID0gcGVzLnB0cztcbiAgICAgIGlmIChwdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogTVBFRyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgIHZhciBmcmFtZSA9IGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgTXBlZyBhdWRpbyBmcmFtZScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucGFyc2VBQzNQRVMgPSBmdW5jdGlvbiBwYXJzZUFDM1BFUyh0cmFjaywgcGVzKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBkYXRhID0gcGVzLmRhdGE7XG4gICAgICAgIHZhciBwdHMgPSBwZXMucHRzO1xuICAgICAgICBpZiAocHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUMzIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBwYXJzZWQ7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGggJiYgKHBhcnNlZCA9IF9hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgrKykpID4gMCkge1xuICAgICAgICAgIG9mZnNldCArPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXJzZUlEM1BFUyA9IGZ1bmN0aW9uIHBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpIHtcbiAgICAgIGlmIChwZXMucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybignW3RzZGVtdXhlcl06IElEMyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGlkM1NhbXBsZSA9IF9leHRlbmRzKHt9LCBwZXMsIHtcbiAgICAgICAgdHlwZTogdGhpcy5fdmlkZW9UcmFjayA/IE1ldGFkYXRhU2NoZW1hLmVtc2cgOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgfSk7XG4gICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goaWQzU2FtcGxlKTtcbiAgICB9O1xuICAgIHJldHVybiBUU0RlbXV4ZXI7XG4gIH0oKTtcbiAgZnVuY3Rpb24gcGFyc2VQSUQoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuICAgIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbb2Zmc2V0ICsgMl07XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxuICAgIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0eXBlU3VwcG9ydGVkLCBpc1NhbXBsZUFlcywgb2JzZXJ2ZXIsIGxvZ2dlcikge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBhdWRpb1BpZDogLTEsXG4gICAgICB2aWRlb1BpZDogLTEsXG4gICAgICBpZDNQaWQ6IC0xLFxuICAgICAgc2VnbWVudFZpZGVvQ29kZWM6ICdhdmMnLFxuICAgICAgc2VnbWVudEF1ZGlvQ29kZWM6ICdhYWMnXG4gICAgfTtcbiAgICB2YXIgc2VjdGlvbkxlbmd0aCA9IChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgdmFyIHRhYmxlRW5kID0gb2Zmc2V0ICsgMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuICAgIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gICAgdmFyIHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAgIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgICBvZmZzZXQgKz0gMTIgKyBwcm9ncmFtSW5mb0xlbmd0aDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICAgIHZhciBwaWQgPSBwYXJzZVBJRChkYXRhLCBvZmZzZXQpO1xuICAgICAgdmFyIGVzSW5mb0xlbmd0aCA9IChkYXRhW29mZnNldCArIDNdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgNF07XG4gICAgICBzd2l0Y2ggKGRhdGFbb2Zmc2V0XSkge1xuICAgICAgICBjYXNlIDB4Y2Y6XG4gICAgICAgICAgLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgICBsb2dFbmNyeXB0ZWRTYW1wbGVzRm91bmRJblVuZW5jcnlwdGVkU3RyZWFtKCdBRFRTIEFBQycsIGxvZ2dlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAweDBmOlxuICAgICAgICAgIC8vIElTTy9JRUMgMTM4MTgtNyBBRFRTIEFBQyAoTVBFRy0yIGxvd2VyIGJpdC1yYXRlIGF1ZGlvKVxuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcbiAgICAgICAgY2FzZSAweDE1OlxuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuaWQzUGlkID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmlkM1BpZCA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHhkYjpcbiAgICAgICAgICAvLyBTQU1QTEUtQUVTIEFWQ1xuICAgICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0guMjY0JywgbG9nZ2VyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlIDB4MWI6XG4gICAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnQVZDIFBJRDonICArIHBpZCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC52aWRlb1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC52aWRlb1BpZCA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgICAgY2FzZSAweDAzOlxuICAgICAgICBjYXNlIDB4MDQ6XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmICghdHlwZVN1cHBvcnRlZC5tcGVnICYmICF0eXBlU3VwcG9ydGVkLm1wMykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpb1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdWRpb1BpZCA9IHBpZDtcbiAgICAgICAgICAgIHJlc3VsdC5zZWdtZW50QXVkaW9Db2RlYyA9ICdtcDMnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweGMxOlxuICAgICAgICAgIC8vIFNBTVBMRS1BRVMgQUMzXG4gICAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgICAgbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSgnQUMtMycsIGxvZ2dlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAweDgxOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdHlwZVN1cHBvcnRlZC5hYzMpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnQUMtMyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSkge1xuICAgICAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgICAgIHJlc3VsdC5zZWdtZW50QXVkaW9Db2RlYyA9ICdhYzMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA2OlxuICAgICAgICAgIC8vIHN0cmVhbV90eXBlIDYgY2FuIG1lYW4gYSBsb3Qgb2YgZGlmZmVyZW50IHRoaW5ncyBpbiBjYXNlIG9mIERWQi5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGxvb2sgYXQgdGhlIGRlc2NyaXB0b3JzLiBSaWdodCBub3csIHdlJ3JlIG9ubHkgaW50ZXJlc3RlZFxuICAgICAgICAgIC8vIGluIEFDLTMgYXVkaW8sIHNvIHdlIGRvIHRoZSBkZXNjcmlwdG9yIHBhcnNpbmcgb25seSB3aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBhbiBhdWRpbyBQSUQgeWV0LlxuICAgICAgICAgIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xICYmIGVzSW5mb0xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJzZVBvcyA9IG9mZnNldCArIDU7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gZXNJbmZvTGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHJlbWFpbmluZyA+IDIpIHtcbiAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3JJZCA9IGRhdGFbcGFyc2VQb3NdO1xuICAgICAgICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0b3JJZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHg2YTpcbiAgICAgICAgICAgICAgICAgIC8vIERWQiBEZXNjcmlwdG9yIGZvciBBQy0zXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLmFjMyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0FDLTMgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyIGZvciBub3cnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNlZ21lbnRBdWRpb0NvZGVjID0gJ2FjMyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yTGVuID0gZGF0YVtwYXJzZVBvcyArIDFdICsgMjtcbiAgICAgICAgICAgICAgcGFyc2VQb3MgKz0gZGVzY3JpcHRvckxlbjtcbiAgICAgICAgICAgICAgcmVtYWluaW5nIC09IGRlc2NyaXB0b3JMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4YzI6IC8vIFNBTVBMRS1BRVMgRUMzXG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAweDg3OlxuICAgICAgICAgIGVtaXRQYXJzaW5nRXJyb3Iob2JzZXJ2ZXIsIG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgRUMtMyBpbiBNMlRTIGZvdW5kJyksIHVuZGVmaW5lZCwgbG9nZ2VyKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlIDB4MjQ6XG4gICAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NSBhbmQgSVNPL0lFQyAyMzAwOC0yIChIRVZDKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudmlkZW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC52aWRlb1BpZCA9IHBpZDtcbiAgICAgICAgICAgICAgcmVzdWx0LnNlZ21lbnRWaWRlb0NvZGVjID0gJ2hldmMnO1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdIRVZDIGluIE0yVFMgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XG4gICAgICAvLyBza2lwIHBhc3QgdGhlIGVsZW1lbnRhcnkgc3RyZWFtIGRlc2NyaXB0b3JzLCBpZiBwcmVzZW50XG4gICAgICBvZmZzZXQgKz0gZXNJbmZvTGVuZ3RoICsgNTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBlbWl0UGFyc2luZ0Vycm9yKG9ic2VydmVyLCBlcnJvciwgbGV2ZWxSZXRyeSwgbG9nZ2VyKSB7XG4gICAgbG9nZ2VyLndhcm4oXCJwYXJzaW5nIGVycm9yOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgbGV2ZWxSZXRyeTogbGV2ZWxSZXRyeSxcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0odHlwZSwgbG9nZ2VyKSB7XG4gICAgbG9nZ2VyLmxvZyh0eXBlICsgXCIgd2l0aCBBRVMtMTI4LUNCQyBlbmNyeXB0aW9uIGZvdW5kIGluIHVuZW5jcnlwdGVkIHN0cmVhbVwiKTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVBFUyhzdHJlYW0sIGxvZ2dlcikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZnJhZztcbiAgICB2YXIgcGVzTGVuO1xuICAgIHZhciBwZXNIZHJMZW47XG4gICAgdmFyIHBlc1B0cztcbiAgICB2YXIgcGVzRHRzO1xuICAgIHZhciBkYXRhID0gc3RyZWFtLmRhdGE7XG4gICAgLy8gc2FmZXR5IGNoZWNrXG4gICAgaWYgKCFzdHJlYW0gfHwgc3RyZWFtLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHdlIG1pZ2h0IG5lZWQgdXAgdG8gMTkgYnl0ZXMgdG8gcmVhZCBQRVMgaGVhZGVyXG4gICAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gICAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICAgIHdoaWxlIChkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgZGF0YVswXSA9IGFwcGVuZFVpbnQ4QXJyYXkoZGF0YVswXSwgZGF0YVsxXSk7XG4gICAgICBkYXRhLnNwbGljZSgxLCAxKTtcbiAgICB9XG4gICAgLy8gcmV0cmlldmUgUFRTL0RUUyBmcm9tIGZpcnN0IGZyYWdtZW50XG4gICAgZnJhZyA9IGRhdGFbMF07XG4gICAgdmFyIHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXG4gICAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXG4gICAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgICBpZiAocGVzRmxhZ3MgJiAweGMwKSB7XG4gICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBlKSAqIDUzNjg3MDkxMiArXG4gICAgICAgIC8vIDEgPDwgMjlcbiAgICAgICAgKGZyYWdbMTBdICYgMHhmZikgKiA0MTk0MzA0ICtcbiAgICAgICAgLy8gMSA8PCAyMlxuICAgICAgICAoZnJhZ1sxMV0gJiAweGZlKSAqIDE2Mzg0ICtcbiAgICAgICAgLy8gMSA8PCAxNFxuICAgICAgICAoZnJhZ1sxMl0gJiAweGZmKSAqIDEyOCArXG4gICAgICAgIC8vIDEgPDwgN1xuICAgICAgICAoZnJhZ1sxM10gJiAweGZlKSAvIDI7XG4gICAgICAgIGlmIChwZXNGbGFncyAmIDB4NDApIHtcbiAgICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBlKSAqIDUzNjg3MDkxMiArXG4gICAgICAgICAgLy8gMSA8PCAyOVxuICAgICAgICAgIChmcmFnWzE1XSAmIDB4ZmYpICogNDE5NDMwNCArXG4gICAgICAgICAgLy8gMSA8PCAyMlxuICAgICAgICAgIChmcmFnWzE2XSAmIDB4ZmUpICogMTYzODQgK1xuICAgICAgICAgIC8vIDEgPDwgMTRcbiAgICAgICAgICAoZnJhZ1sxN10gJiAweGZmKSAqIDEyOCArXG4gICAgICAgICAgLy8gMSA8PCA3XG4gICAgICAgICAgKGZyYWdbMThdICYgMHhmZSkgLyAyO1xuICAgICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApICsgXCJzIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1cIik7XG4gICAgICAgICAgICBwZXNQdHMgPSBwZXNEdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlc0R0cyA9IHBlc1B0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVzSGRyTGVuID0gZnJhZ1s4XTtcbiAgICAgIC8vIDkgYnl0ZXMgOiA2IGJ5dGVzIGZvciBQRVMgaGVhZGVyICsgMyBieXRlcyBmb3IgUEVTIGV4dGVuc2lvblxuICAgICAgdmFyIHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG4gICAgICBpZiAoc3RyZWFtLnNpemUgPD0gcGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgLy8gcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgICB2YXIgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7IGogPCBkYXRhTGVuOyBqKyspIHtcbiAgICAgICAgZnJhZyA9IGRhdGFbal07XG4gICAgICAgIHZhciBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgICAgZnJhZyA9IGZyYWcuc3ViYXJyYXkocGF5bG9hZFN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGxlbiAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgICAgaSArPSBsZW47XG4gICAgICB9XG4gICAgICBpZiAocGVzTGVuKSB7XG4gICAgICAgIC8vIHBheWxvYWQgc2l6ZSA6IHJlbW92ZSBQRVMgaGVhZGVyICsgUEVTIGV4dGVuc2lvblxuICAgICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBlc0RhdGEsXG4gICAgICAgIHB0czogcGVzUHRzLFxuICAgICAgICBkdHM6IHBlc0R0cyxcbiAgICAgICAgbGVuOiBwZXNMZW5cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqICBBQUMgaGVscGVyXG4gICAqL1xuICB2YXIgQUFDID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBQUMoKSB7fVxuICAgIEFBQy5nZXRTaWxlbnRGcmFtZSA9IGZ1bmN0aW9uIGdldFNpbGVudEZyYW1lKGNvZGVjLCBjaGFubmVsQ291bnQpIHtcbiAgICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgICAgY2FzZSAnbXA0YS40MC4yJzpcbiAgICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODAsIDB4MmMsIDB4ODAsIDB4MDgsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NGUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgxYywgMHg2LCAweGYxLCAweGMxLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBBQUM7XG4gIH0oKTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgTVA0IEJveFxuICAgKi9cblxuICB2YXIgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG4gIHZhciBNUDQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1QNCgpIHt9XG4gICAgTVA0LmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgTVA0LnR5cGVzID0ge1xuICAgICAgICBhdmMxOiBbXSxcbiAgICAgICAgLy8gY29kaW5nbmFtZVxuICAgICAgICBhdmNDOiBbXSxcbiAgICAgICAgaHZjMTogW10sXG4gICAgICAgIGh2Y0M6IFtdLFxuICAgICAgICBidHJ0OiBbXSxcbiAgICAgICAgZGluZjogW10sXG4gICAgICAgIGRyZWY6IFtdLFxuICAgICAgICBlc2RzOiBbXSxcbiAgICAgICAgZnR5cDogW10sXG4gICAgICAgIGhkbHI6IFtdLFxuICAgICAgICBtZGF0OiBbXSxcbiAgICAgICAgbWRoZDogW10sXG4gICAgICAgIG1kaWE6IFtdLFxuICAgICAgICBtZmhkOiBbXSxcbiAgICAgICAgbWluZjogW10sXG4gICAgICAgIG1vb2Y6IFtdLFxuICAgICAgICBtb292OiBbXSxcbiAgICAgICAgbXA0YTogW10sXG4gICAgICAgICcubXAzJzogW10sXG4gICAgICAgIGRhYzM6IFtdLFxuICAgICAgICAnYWMtMyc6IFtdLFxuICAgICAgICBtdmV4OiBbXSxcbiAgICAgICAgbXZoZDogW10sXG4gICAgICAgIHBhc3A6IFtdLFxuICAgICAgICBzZHRwOiBbXSxcbiAgICAgICAgc3RibDogW10sXG4gICAgICAgIHN0Y286IFtdLFxuICAgICAgICBzdHNjOiBbXSxcbiAgICAgICAgc3RzZDogW10sXG4gICAgICAgIHN0c3o6IFtdLFxuICAgICAgICBzdHRzOiBbXSxcbiAgICAgICAgdGZkdDogW10sXG4gICAgICAgIHRmaGQ6IFtdLFxuICAgICAgICB0cmFmOiBbXSxcbiAgICAgICAgdHJhazogW10sXG4gICAgICAgIHRydW46IFtdLFxuICAgICAgICB0cmV4OiBbXSxcbiAgICAgICAgdGtoZDogW10sXG4gICAgICAgIHZtaGQ6IFtdLFxuICAgICAgICBzbWhkOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpIGluIE1QNC50eXBlcykge1xuICAgICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgTVA0LnR5cGVzW2ldID0gW2kuY2hhckNvZGVBdCgwKSwgaS5jaGFyQ29kZUF0KDEpLCBpLmNoYXJDb2RlQXQoMiksIGkuY2hhckNvZGVBdCgzKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAgIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgICAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSwgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgICAgXSk7XG4gICAgICB2YXIgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDczLCAweDZmLCAweDc1LCAweDZlLFxuICAgICAgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICAgIF0pO1xuICAgICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICAgIHZpZGVvOiB2aWRlb0hkbHIsXG4gICAgICAgIGF1ZGlvOiBhdWRpb0hkbHJcbiAgICAgIH07XG4gICAgICB2YXIgZHJlZiA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgICAgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgICAvLyBlbnRyeV9jb3VudFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYyxcbiAgICAgIC8vIGVudHJ5X3NpemVcbiAgICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsXG4gICAgICAvLyAndXJsJyB0eXBlXG4gICAgICAweDAwLFxuICAgICAgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgICBdKTtcbiAgICAgIHZhciBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICAgIF0pO1xuICAgICAgTVA0LlNUVFMgPSBNUDQuU1RTQyA9IE1QNC5TVENPID0gc3RjbztcbiAgICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBzYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgICAgIF0pO1xuICAgICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAgIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGdyYXBoaWNzbW9kZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gICAgICBdKTtcbiAgICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAvLyBiYWxhbmNlXG4gICAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXG4gICAgICBdKTtcbiAgICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOyAvLyBlbnRyeV9jb3VudFxuXG4gICAgICB2YXIgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuICAgICAgdmFyIGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuICAgICAgdmFyIG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG4gICAgICBNUDQuRlRZUCA9IE1QNC5ib3goTVA0LnR5cGVzLmZ0eXAsIG1ham9yQnJhbmQsIG1pbm9yVmVyc2lvbiwgbWFqb3JCcmFuZCwgYXZjMUJyYW5kKTtcbiAgICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICAgIH07XG4gICAgTVA0LmJveCA9IGZ1bmN0aW9uIGJveCh0eXBlKSB7XG4gICAgICB2YXIgc2l6ZSA9IDg7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGF5bG9hZCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHBheWxvYWRbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSBwYXlsb2FkLmxlbmd0aDtcbiAgICAgIHZhciBsZW4gPSBpO1xuICAgICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgICAgIHJlc3VsdFsxXSA9IHNpemUgPj4gMTYgJiAweGZmO1xuICAgICAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgICAgIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICAgICAgcmVzdWx0LnNldCh0eXBlLCA0KTtcbiAgICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIGNvcHkgcGF5bG9hZFtpXSBhcnJheSBAIG9mZnNldCBzaXplXG4gICAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1QNC5oZGxyID0gZnVuY3Rpb24gaGRscih0eXBlKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICAgIH07XG4gICAgTVA0Lm1kYXQgPSBmdW5jdGlvbiBtZGF0KGRhdGEpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgICB9O1xuICAgIE1QNC5tZGhkID0gZnVuY3Rpb24gbWRoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgICB2YXIgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICB2YXIgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgICAvLyB2ZXJzaW9uIDFcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMixcbiAgICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgICAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgdGltZXNjYWxlID4+IDI0ICYgMHhmZiwgdGltZXNjYWxlID4+IDE2ICYgMHhmZiwgdGltZXNjYWxlID4+IDggJiAweGZmLCB0aW1lc2NhbGUgJiAweGZmLFxuICAgICAgLy8gdGltZXNjYWxlXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCwgdXBwZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLCAweDU1LCAweGM0LFxuICAgICAgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAgIDB4MDAsIDB4MDBdKSk7XG4gICAgfTtcbiAgICBNUDQubWRpYSA9IGZ1bmN0aW9uIG1kaWEodHJhY2spIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUgfHwgMCwgdHJhY2suZHVyYXRpb24gfHwgMCksIE1QNC5oZGxyKHRyYWNrLnR5cGUpLCBNUDQubWluZih0cmFjaykpO1xuICAgIH07XG4gICAgTVA0Lm1maGQgPSBmdW5jdGlvbiBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWZoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgc2VxdWVuY2VOdW1iZXIgPj4gMjQsIHNlcXVlbmNlTnVtYmVyID4+IDE2ICYgMHhmZiwgc2VxdWVuY2VOdW1iZXIgPj4gOCAmIDB4ZmYsIHNlcXVlbmNlTnVtYmVyICYgMHhmZiAvLyBzZXF1ZW5jZV9udW1iZXJcbiAgICAgIF0pKTtcbiAgICB9O1xuICAgIE1QNC5taW5mID0gZnVuY3Rpb24gbWluZih0cmFjaykge1xuICAgICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnNtaGQsIE1QNC5TTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE1QNC5tb29mID0gZnVuY3Rpb24gbW9vZihzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XG4gICAgfTtcbiAgICBNUDQubW9vdiA9IGZ1bmN0aW9uIG1vb3YodHJhY2tzKSB7XG4gICAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgICB2YXIgYm94ZXMgPSBbXTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tb292LCBNUDQubXZoZCh0cmFja3NbMF0udGltZXNjYWxlIHx8IDAsIHRyYWNrc1swXS5kdXJhdGlvbiB8fCAwKV0uY29uY2F0KGJveGVzKS5jb25jYXQoTVA0Lm12ZXgodHJhY2tzKSkpO1xuICAgIH07XG4gICAgTVA0Lm12ZXggPSBmdW5jdGlvbiBtdmV4KHRyYWNrcykge1xuICAgICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoO1xuICAgICAgdmFyIGJveGVzID0gW107XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGJveGVzW2ldID0gTVA0LnRyZXgodHJhY2tzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gICAgfTtcbiAgICBNUDQubXZoZCA9IGZ1bmN0aW9uIG12aGQodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgICAgdmFyIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgdmFyIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgICAvLyB2ZXJzaW9uIDFcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMixcbiAgICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgICAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgdGltZXNjYWxlID4+IDI0ICYgMHhmZiwgdGltZXNjYWxlID4+IDE2ICYgMHhmZiwgdGltZXNjYWxlID4+IDggJiAweGZmLCB0aW1lc2NhbGUgJiAweGZmLFxuICAgICAgLy8gdGltZXNjYWxlXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCwgdXBwZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLCAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgLy8gMS4wIHJhdGVcbiAgICAgIDB4MDEsIDB4MDAsXG4gICAgICAvLyAxLjAgdm9sdW1lXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHByZV9kZWZpbmVkXG4gICAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12aGQsIGJ5dGVzKTtcbiAgICB9O1xuICAgIE1QNC5zZHRwID0gZnVuY3Rpb24gc2R0cCh0cmFjaykge1xuICAgICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCArIHNhbXBsZXMubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGZsYWdzO1xuICAgICAgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cbiAgICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZsYWdzID0gc2FtcGxlc1tpXS5mbGFncztcbiAgICAgICAgYnl0ZXNbaSArIDRdID0gZmxhZ3MuZGVwZW5kc09uIDw8IDQgfCBmbGFncy5pc0RlcGVuZGVkT24gPDwgMiB8IGZsYWdzLmhhc1JlZHVuZGFuY3k7XG4gICAgICB9XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICAgIH07XG4gICAgTVA0LnN0YmwgPSBmdW5jdGlvbiBzdGJsKHRyYWNrKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICAgIH07XG4gICAgTVA0LmF2YzEgPSBmdW5jdGlvbiBhdmMxKHRyYWNrKSB7XG4gICAgICB2YXIgc3BzID0gW107XG4gICAgICB2YXIgcHBzID0gW107XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgdmFyIGxlbjtcbiAgICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICBzcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgICAgc3BzLnB1c2gobGVuICYgMHhmZik7XG5cbiAgICAgICAgLy8gU1BTXG4gICAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhID0gdHJhY2sucHBzW2ldO1xuICAgICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIHBwcy5wdXNoKGxlbiA+Pj4gOCAmIDB4ZmYpO1xuICAgICAgICBwcHMucHVzaChsZW4gJiAweGZmKTtcbiAgICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgICB9XG4gICAgICB2YXIgYXZjYyA9IE1QNC5ib3goTVA0LnR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgICAgLy8gdmVyc2lvblxuICAgICAgc3BzWzNdLFxuICAgICAgLy8gcHJvZmlsZVxuICAgICAgc3BzWzRdLFxuICAgICAgLy8gcHJvZmlsZSBjb21wYXRcbiAgICAgIHNwc1s1XSxcbiAgICAgIC8vIGxldmVsXG4gICAgICAweGZjIHwgMyxcbiAgICAgIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgICAweGUwIHwgdHJhY2suc3BzLmxlbmd0aCAvLyAzYml0IHJlc2VydmVkICgxMTEpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcbiAgICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFt0cmFjay5wcHMubGVuZ3RoIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICAgIF0pLmNvbmNhdChwcHMpKSk7IC8vIFwiUFBTXCJcbiAgICAgIHZhciB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICAgIHZhciBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF07XG4gICAgICB2YXIgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmF2YzEsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSxcbiAgICAgIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLFxuICAgICAgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHByZV9kZWZpbmVkXG4gICAgICB3aWR0aCA+PiA4ICYgMHhmZiwgd2lkdGggJiAweGZmLFxuICAgICAgLy8gd2lkdGhcbiAgICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZixcbiAgICAgIC8vIGhlaWdodFxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGhvcml6cmVzb2x1dGlvblxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsXG4gICAgICAvLyBmcmFtZV9jb3VudFxuICAgICAgMHgxMiwgMHg2NCwgMHg2MSwgMHg2OSwgMHg2YyxcbiAgICAgIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgICAgMHg3OSwgMHg2ZCwgMHg2ZiwgMHg3NCwgMHg2OSwgMHg2ZiwgMHg2ZSwgMHgyZiwgMHg2OCwgMHg2YywgMHg3MywgMHgyZSwgMHg2YSwgMHg3MywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgICAweDAwLCAweDE4LFxuICAgICAgLy8gZGVwdGggPSAyNFxuICAgICAgMHgxMSwgMHgxMV0pLFxuICAgICAgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgYXZjYywgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsXG4gICAgICAvLyBidWZmZXJTaXplREJcbiAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsXG4gICAgICAvLyBtYXhCaXRyYXRlXG4gICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwXSkpLFxuICAgICAgLy8gYXZnQml0cmF0ZVxuICAgICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW2hTcGFjaW5nID4+IDI0LFxuICAgICAgLy8gaFNwYWNpbmdcbiAgICAgIGhTcGFjaW5nID4+IDE2ICYgMHhmZiwgaFNwYWNpbmcgPj4gOCAmIDB4ZmYsIGhTcGFjaW5nICYgMHhmZiwgdlNwYWNpbmcgPj4gMjQsXG4gICAgICAvLyB2U3BhY2luZ1xuICAgICAgdlNwYWNpbmcgPj4gMTYgJiAweGZmLCB2U3BhY2luZyA+PiA4ICYgMHhmZiwgdlNwYWNpbmcgJiAweGZmXSkpKTtcbiAgICB9O1xuICAgIE1QNC5lc2RzID0gZnVuY3Rpb24gZXNkcyh0cmFjaykge1xuICAgICAgdmFyIGNvbmZpZyA9IHRyYWNrLmNvbmZpZztcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAgIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGZsYWdzXG5cbiAgICAgIDB4MDMsXG4gICAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MTksXG4gICAgICAvLyBsZW5ndGhcblxuICAgICAgMHgwMCwgMHgwMSxcbiAgICAgIC8vIGVzX2lkXG5cbiAgICAgIDB4MDAsXG4gICAgICAvLyBzdHJlYW1fcHJpb3JpdHlcblxuICAgICAgMHgwNCxcbiAgICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgxMSxcbiAgICAgIC8vIGxlbmd0aFxuICAgICAgMHg0MCxcbiAgICAgIC8vIGNvZGVjIDogbXBlZzRfYXVkaW9cbiAgICAgIDB4MTUsXG4gICAgICAvLyBzdHJlYW1fdHlwZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGJ1ZmZlcl9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gbWF4Qml0cmF0ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGF2Z0JpdHJhdGVcblxuICAgICAgMHgwNSxcbiAgICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgwMl0uY29uY2F0KGNvbmZpZywgWzB4MDYsIDB4MDEsIDB4MDIgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxuICAgICAgXSkpO1xuICAgIH07XG4gICAgTVA0LmF1ZGlvU3RzZCA9IGZ1bmN0aW9uIGF1ZGlvU3RzZCh0cmFjaykge1xuICAgICAgdmFyIHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlIHx8IDA7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLFxuICAgICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50IHx8IDAsXG4gICAgICAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsIDB4MTAsXG4gICAgICAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkMlxuICAgICAgc2FtcGxlcmF0ZSA+PiA4ICYgMHhmZiwgc2FtcGxlcmF0ZSAmIDB4ZmYsXG4gICAgICAvL1xuICAgICAgMHgwMCwgMHgwMF0pO1xuICAgIH07XG4gICAgTVA0Lm1wNGEgPSBmdW5jdGlvbiBtcDRhKHRyYWNrKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgTVA0LmF1ZGlvU3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xuICAgIH07XG4gICAgTVA0Lm1wMyA9IGZ1bmN0aW9uIG1wMyh0cmFjaykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIE1QNC5hdWRpb1N0c2QodHJhY2spKTtcbiAgICB9O1xuICAgIE1QNC5hYzMgPSBmdW5jdGlvbiBhYzModHJhY2spIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlc1snYWMtMyddLCBNUDQuYXVkaW9TdHNkKHRyYWNrKSwgTVA0LmJveChNUDQudHlwZXMuZGFjMywgdHJhY2suY29uZmlnKSk7XG4gICAgfTtcbiAgICBNUDQuc3RzZCA9IGZ1bmN0aW9uIHN0c2QodHJhY2spIHtcbiAgICAgIHZhciBzZWdtZW50Q29kZWMgPSB0cmFjay5zZWdtZW50Q29kZWM7XG4gICAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBpZiAoc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VnbWVudENvZGVjID09PSAnYWMzJyAmJiB0cmFjay5jb25maWcpIHtcbiAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hYzModHJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRyYWNrLnBwcyAmJiB0cmFjay5zcHMpIHtcbiAgICAgICAgICBpZiAoc2VnbWVudENvZGVjID09PSAnYXZjJykge1xuICAgICAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VnbWVudENvZGVjID09PSAnaGV2YycgJiYgdHJhY2sudnBzKSB7XG4gICAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5odmMxKHRyYWNrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZpZGVvIHRyYWNrIG1pc3NpbmcgcHBzIG9yIHNwc1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgXCIgKyB0cmFjay50eXBlICsgXCIgc2VnbWVudCBjb2RlYyAoXCIgKyBzZWdtZW50Q29kZWMgKyBcIi9cIiArIHRyYWNrLmNvZGVjICsgXCIpXCIpO1xuICAgIH07XG4gICAgTVA0LnRraGQgPSBmdW5jdGlvbiB0a2hkKHRyYWNrKSB7XG4gICAgICB2YXIgaWQgPSB0cmFjay5pZDtcbiAgICAgIHZhciBkdXJhdGlvbiA9ICh0cmFjay5kdXJhdGlvbiB8fCAwKSAqICh0cmFjay50aW1lc2NhbGUgfHwgMCk7XG4gICAgICB2YXIgd2lkdGggPSB0cmFjay53aWR0aCB8fCAwO1xuICAgICAgdmFyIGhlaWdodCA9IHRyYWNrLmhlaWdodCB8fCAwO1xuICAgICAgdmFyIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgdmFyIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgICAgLy8gdmVyc2lvbiAxXG4gICAgICAweDAwLCAweDAwLCAweDA3LFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgICAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgIGlkID4+IDI0ICYgMHhmZiwgaWQgPj4gMTYgJiAweGZmLCBpZCA+PiA4ICYgMHhmZiwgaWQgJiAweGZmLFxuICAgICAgLy8gdHJhY2tfSURcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgLy8gbGF5ZXJcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICB3aWR0aCA+PiA4ICYgMHhmZiwgd2lkdGggJiAweGZmLCAweDAwLCAweDAwLFxuICAgICAgLy8gd2lkdGhcbiAgICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZiwgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICAgIF0pKTtcbiAgICB9O1xuICAgIE1QNC50cmFmID0gZnVuY3Rpb24gdHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgICAgdmFyIHNhbXBsZURlcGVuZGVuY3lUYWJsZSA9IE1QNC5zZHRwKHRyYWNrKTtcbiAgICAgIHZhciBpZCA9IHRyYWNrLmlkO1xuICAgICAgdmFyIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgIHZhciBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZiwgTVA0LmJveChNUDQudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgaWQgPj4gMjQsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZiAvLyB0cmFja19JRFxuICAgICAgXSkpLCBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAgIC8vIHZlcnNpb24gMVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZl0pKSwgTVA0LnRydW4odHJhY2ssIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggKyAxNiArXG4gICAgICAvLyB0ZmhkXG4gICAgICAyMCArXG4gICAgICAvLyB0ZmR0XG4gICAgICA4ICtcbiAgICAgIC8vIHRyYWYgaGVhZGVyXG4gICAgICAxNiArXG4gICAgICAvLyBtZmhkXG4gICAgICA4ICtcbiAgICAgIC8vIG1vb2YgaGVhZGVyXG4gICAgICA4KSxcbiAgICAgIC8vIG1kYXQgaGVhZGVyXG4gICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgICAqIEBwYXJhbSB0cmFjayBhIHRyYWNrIGRlZmluaXRpb25cbiAgICAgKi87XG4gICAgTVA0LnRyYWsgPSBmdW5jdGlvbiB0cmFrKHRyYWNrKSB7XG4gICAgICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICAgIH07XG4gICAgTVA0LnRyZXggPSBmdW5jdGlvbiB0cmV4KHRyYWNrKSB7XG4gICAgICB2YXIgaWQgPSB0cmFjay5pZDtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmV4LCBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAgIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICBpZCA+PiAyNCwgaWQgPj4gMTYgJiAweGZmLCBpZCA+PiA4ICYgMHhmZiwgaWQgJiAweGZmLFxuICAgICAgLy8gdHJhY2tfSURcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgICAvLyBkZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgICAgXSkpO1xuICAgIH07XG4gICAgTVA0LnRydW4gPSBmdW5jdGlvbiB0cnVuKHRyYWNrLCBvZmZzZXQpIHtcbiAgICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICAgIHZhciBsZW4gPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgIHZhciBhcnJheWxlbiA9IDEyICsgMTYgKiBsZW47XG4gICAgICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheWxlbik7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBzYW1wbGU7XG4gICAgICB2YXIgZHVyYXRpb247XG4gICAgICB2YXIgc2l6ZTtcbiAgICAgIHZhciBmbGFncztcbiAgICAgIHZhciBjdHM7XG4gICAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgICAgYXJyYXkuc2V0KFt0cmFjay50eXBlID09PSAndmlkZW8nID8gMHgwMSA6IDB4MDAsXG4gICAgICAvLyB2ZXJzaW9uIDEgZm9yIHZpZGVvIHdpdGggc2lnbmVkLWludCBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAgIDB4MDAsIDB4MGYsIDB4MDEsXG4gICAgICAvLyBmbGFnc1xuICAgICAgbGVuID4+PiAyNCAmIDB4ZmYsIGxlbiA+Pj4gMTYgJiAweGZmLCBsZW4gPj4+IDggJiAweGZmLCBsZW4gJiAweGZmLFxuICAgICAgLy8gc2FtcGxlX2NvdW50XG4gICAgICBvZmZzZXQgPj4+IDI0ICYgMHhmZiwgb2Zmc2V0ID4+PiAxNiAmIDB4ZmYsIG9mZnNldCA+Pj4gOCAmIDB4ZmYsIG9mZnNldCAmIDB4ZmYgLy8gZGF0YV9vZmZzZXRcbiAgICAgIF0sIDApO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICAgIGR1cmF0aW9uID0gc2FtcGxlLmR1cmF0aW9uO1xuICAgICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgICBjdHMgPSBzYW1wbGUuY3RzO1xuICAgICAgICBhcnJheS5zZXQoW2R1cmF0aW9uID4+PiAyNCAmIDB4ZmYsIGR1cmF0aW9uID4+PiAxNiAmIDB4ZmYsIGR1cmF0aW9uID4+PiA4ICYgMHhmZiwgZHVyYXRpb24gJiAweGZmLFxuICAgICAgICAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgc2l6ZSA+Pj4gMjQgJiAweGZmLCBzaXplID4+PiAxNiAmIDB4ZmYsIHNpemUgPj4+IDggJiAweGZmLCBzaXplICYgMHhmZixcbiAgICAgICAgLy8gc2FtcGxlX3NpemVcbiAgICAgICAgZmxhZ3MuaXNMZWFkaW5nIDw8IDIgfCBmbGFncy5kZXBlbmRzT24sIGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2IHwgZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0IHwgZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEgfCBmbGFncy5pc05vblN5bmMsIGZsYWdzLmRlZ3JhZFByaW8gJiAweGYwIDw8IDgsIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBmLFxuICAgICAgICAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgICAgY3RzID4+PiAyNCAmIDB4ZmYsIGN0cyA+Pj4gMTYgJiAweGZmLCBjdHMgPj4+IDggJiAweGZmLCBjdHMgJiAweGZmIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgICBdLCAxMiArIDE2ICogaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xuICAgIH07XG4gICAgTVA0LmluaXRTZWdtZW50ID0gZnVuY3Rpb24gaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgICBpZiAoIU1QNC50eXBlcykge1xuICAgICAgICBNUDQuaW5pdCgpO1xuICAgICAgfVxuICAgICAgdmFyIG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKTtcbiAgICAgIHZhciByZXN1bHQgPSBhcHBlbmRVaW50OEFycmF5KE1QNC5GVFlQLCBtb3ZpZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTVA0Lmh2YzEgPSBmdW5jdGlvbiBodmMxKHRyYWNrKSB7XG4gICAgICB2YXIgcHMgPSB0cmFjay5wYXJhbXM7XG4gICAgICB2YXIgdW5pdHMgPSBbdHJhY2sudnBzLCB0cmFjay5zcHMsIHRyYWNrLnBwc107XG4gICAgICB2YXIgTkFMdUxlbmd0aFNpemUgPSA0O1xuICAgICAgdmFyIGNvbmZpZyA9IG5ldyBVaW50OEFycmF5KFsweDAxLCBwcy5nZW5lcmFsX3Byb2ZpbGVfc3BhY2UgPDwgNiB8IChwcy5nZW5lcmFsX3RpZXJfZmxhZyA/IDMyIDogMCkgfCBwcy5nZW5lcmFsX3Byb2ZpbGVfaWRjLCBwcy5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc1swXSwgcHMuZ2VuZXJhbF9wcm9maWxlX2NvbXBhdGliaWxpdHlfZmxhZ3NbMV0sIHBzLmdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzWzJdLCBwcy5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc1szXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1swXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1sxXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1syXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1szXSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1s0XSwgcHMuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1s1XSwgcHMuZ2VuZXJhbF9sZXZlbF9pZGMsIDI0MCB8IHBzLm1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGMgPj4gOCwgMjU1ICYgcHMubWluX3NwYXRpYWxfc2VnbWVudGF0aW9uX2lkYywgMjUyIHwgcHMucGFyYWxsZWxpc21UeXBlLCAyNTIgfCBwcy5jaHJvbWFfZm9ybWF0X2lkYywgMjQ4IHwgcHMuYml0X2RlcHRoX2x1bWFfbWludXM4LCAyNDggfCBwcy5iaXRfZGVwdGhfY2hyb21hX21pbnVzOCwgMHgwMCwgcGFyc2VJbnQocHMuZnJhbWVfcmF0ZS5mcHMpLCBOQUx1TGVuZ3RoU2l6ZSAtIDEgfCBwcy50ZW1wb3JhbF9pZF9uZXN0ZWQgPDwgMiB8IHBzLm51bV90ZW1wb3JhbF9sYXllcnMgPDwgMyB8IChwcy5mcmFtZV9yYXRlLmZpeGVkID8gNjQgOiAwKSwgdW5pdHMubGVuZ3RoXSk7XG5cbiAgICAgIC8vIGNvbXB1dGUgaHZjQyBzaXplIGluIGJ5dGVzXG4gICAgICB2YXIgbGVuZ3RoID0gY29uZmlnLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGVuZ3RoICs9IDM7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdW5pdHNbaV0ubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICBsZW5ndGggKz0gMiArIHVuaXRzW2ldW2pdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGh2Y0MgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgaHZjQy5zZXQoY29uZmlnLCAwKTtcbiAgICAgIGxlbmd0aCA9IGNvbmZpZy5sZW5ndGg7XG4gICAgICAvLyBhcHBlbmQgcGFyYW1ldGVyIHNldCB1bml0czogb25lIHZwcywgb25lIG9yIG1vcmUgc3BzIGFuZCBwcHNcbiAgICAgIHZhciBpTWF4ID0gdW5pdHMubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB1bml0cy5sZW5ndGg7IF9pICs9IDEpIHtcbiAgICAgICAgaHZjQy5zZXQobmV3IFVpbnQ4QXJyYXkoWzMyICsgX2kgfCAoX2kgPT09IGlNYXggPyAxMjggOiAwKSwgMHgwMCwgdW5pdHNbX2ldLmxlbmd0aF0pLCBsZW5ndGgpO1xuICAgICAgICBsZW5ndGggKz0gMztcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHVuaXRzW19pXS5sZW5ndGg7IF9qICs9IDEpIHtcbiAgICAgICAgICBodmNDLnNldChuZXcgVWludDhBcnJheShbdW5pdHNbX2ldW19qXS5sZW5ndGggPj4gOCwgdW5pdHNbX2ldW19qXS5sZW5ndGggJiAyNTVdKSwgbGVuZ3RoKTtcbiAgICAgICAgICBsZW5ndGggKz0gMjtcbiAgICAgICAgICBodmNDLnNldCh1bml0c1tfaV1bX2pdLCBsZW5ndGgpO1xuICAgICAgICAgIGxlbmd0aCArPSB1bml0c1tfaV1bX2pdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGh2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5odmNDLCBodmNDKTtcbiAgICAgIHZhciB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICAgIHZhciBoU3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMF07XG4gICAgICB2YXIgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmh2YzEsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSxcbiAgICAgIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLFxuICAgICAgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHByZV9kZWZpbmVkXG4gICAgICB3aWR0aCA+PiA4ICYgMHhmZiwgd2lkdGggJiAweGZmLFxuICAgICAgLy8gd2lkdGhcbiAgICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZixcbiAgICAgIC8vIGhlaWdodFxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGhvcml6cmVzb2x1dGlvblxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsXG4gICAgICAvLyBmcmFtZV9jb3VudFxuICAgICAgMHgxMiwgMHg2NCwgMHg2MSwgMHg2OSwgMHg2YyxcbiAgICAgIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgICAgMHg3OSwgMHg2ZCwgMHg2ZiwgMHg3NCwgMHg2OSwgMHg2ZiwgMHg2ZSwgMHgyZiwgMHg2OCwgMHg2YywgMHg3MywgMHgyZSwgMHg2YSwgMHg3MywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgICAweDAwLCAweDE4LFxuICAgICAgLy8gZGVwdGggPSAyNFxuICAgICAgMHgxMSwgMHgxMV0pLFxuICAgICAgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgaHZjYywgTVA0LmJveChNUDQudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsXG4gICAgICAvLyBidWZmZXJTaXplREJcbiAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsXG4gICAgICAvLyBtYXhCaXRyYXRlXG4gICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwXSkpLFxuICAgICAgLy8gYXZnQml0cmF0ZVxuICAgICAgTVA0LmJveChNUDQudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW2hTcGFjaW5nID4+IDI0LFxuICAgICAgLy8gaFNwYWNpbmdcbiAgICAgIGhTcGFjaW5nID4+IDE2ICYgMHhmZiwgaFNwYWNpbmcgPj4gOCAmIDB4ZmYsIGhTcGFjaW5nICYgMHhmZiwgdlNwYWNpbmcgPj4gMjQsXG4gICAgICAvLyB2U3BhY2luZ1xuICAgICAgdlNwYWNpbmcgPj4gMTYgJiAweGZmLCB2U3BhY2luZyA+PiA4ICYgMHhmZiwgdlNwYWNpbmcgJiAweGZmXSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBNUDQ7XG4gIH0oKTtcbiAgTVA0LnR5cGVzID0gdm9pZCAwO1xuICBNUDQuSERMUl9UWVBFUyA9IHZvaWQgMDtcbiAgTVA0LlNUVFMgPSB2b2lkIDA7XG4gIE1QNC5TVFNDID0gdm9pZCAwO1xuICBNUDQuU1RDTyA9IHZvaWQgMDtcbiAgTVA0LlNUU1ogPSB2b2lkIDA7XG4gIE1QNC5WTUhEID0gdm9pZCAwO1xuICBNUDQuU01IRCA9IHZvaWQgMDtcbiAgTVA0LlNUU0QgPSB2b2lkIDA7XG4gIE1QNC5GVFlQID0gdm9pZCAwO1xuICBNUDQuRElORiA9IHZvaWQgMDtcblxuICB2YXIgTVBFR19UU19DTE9DS19GUkVRX0haID0gOTAwMDA7XG4gIGZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIGRlc3RTY2FsZSwgc3JjQmFzZSwgcm91bmQpIHtcbiAgICBpZiAoc3JjQmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzcmNCYXNlID0gMTtcbiAgICB9XG4gICAgaWYgKHJvdW5kID09PSB2b2lkIDApIHtcbiAgICAgIHJvdW5kID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBiYXNlVGltZSAqIGRlc3RTY2FsZSAqIHNyY0Jhc2U7IC8vIGVxdWl2YWxlbnQgdG8gYCh2YWx1ZSAqIHNjYWxlKSAvICgxIC8gYmFzZSlgXG4gICAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbVNjYWxlKGJhc2VUaW1lLCBkZXN0U2NhbGUsIHNyY1NjYWxlLCByb3VuZCkge1xuICAgIGlmIChzcmNTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzcmNTY2FsZSA9IDE7XG4gICAgfVxuICAgIGlmIChyb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICByb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgZGVzdFNjYWxlLCAxIC8gc3JjU2NhbGUsIHJvdW5kKTtcbiAgfVxuICBmdW5jdGlvbiB0b01zRnJvbU1wZWdUc0Nsb2NrKGJhc2VUaW1lLCByb3VuZCkge1xuICAgIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCAxMDAwLCAxIC8gTVBFR19UU19DTE9DS19GUkVRX0haLCByb3VuZCk7XG4gIH1cbiAgZnVuY3Rpb24gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUoYmFzZVRpbWUsIHNyY1NjYWxlKSB7XG4gICAgaWYgKHNyY1NjYWxlID09PSB2b2lkIDApIHtcbiAgICAgIHNyY1NjYWxlID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgMSAvIHNyY1NjYWxlKTtcbiAgfVxuICBmdW5jdGlvbiB0aW1lc3RhbXBUb1N0cmluZyh0aW1lc3RhbXApIHtcbiAgICB2YXIgYmFzZVRpbWUgPSB0aW1lc3RhbXAuYmFzZVRpbWUsXG4gICAgICB0aW1lc2NhbGUgPSB0aW1lc3RhbXAudGltZXNjYWxlLFxuICAgICAgdHJhY2tJZCA9IHRpbWVzdGFtcC50cmFja0lkO1xuICAgIHJldHVybiBiYXNlVGltZSAvIHRpbWVzY2FsZSArIFwiIChcIiArIGJhc2VUaW1lICsgXCIvXCIgKyB0aW1lc2NhbGUgKyBcIikgdHJhY2tJZDogXCIgKyB0cmFja0lkO1xuICB9XG5cbiAgdmFyIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7IC8vIDEwIHNlY29uZHNcbiAgdmFyIEFBQ19TQU1QTEVTX1BFUl9GUkFNRSA9IDEwMjQ7XG4gIHZhciBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUUgPSAxMTUyO1xuICB2YXIgQUMzX1NBTVBMRVNfUEVSX0ZSQU1FID0gMTUzNjtcbiAgdmFyIGNocm9tZVZlcnNpb24gPSBudWxsO1xuICB2YXIgc2FmYXJpV2Via2l0VmVyc2lvbiA9IG51bGw7XG4gIGZ1bmN0aW9uIGNyZWF0ZU1wNFNhbXBsZShpc0tleWZyYW1lLCBkdXJhdGlvbiwgc2l6ZSwgY3RzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBjdHM6IGN0cyxcbiAgICAgIGZsYWdzOiB7XG4gICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICBkZXBlbmRzT246IGlzS2V5ZnJhbWUgPyAyIDogMSxcbiAgICAgICAgaXNOb25TeW5jOiBpc0tleWZyYW1lID8gMCA6IDFcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHZhciBNUDRSZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9nZ2VyKSB7XG4gICAgZnVuY3Rpb24gTVA0UmVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCBsb2dnZXIpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX0xvZ2dlci5jYWxsKHRoaXMsICdtcDQtcmVtdXhlcicsIGxvZ2dlcikgfHwgdGhpcztcbiAgICAgIF90aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgX3RoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgICAgX3RoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICAgIF90aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICBfdGhpcy5faW5pdFBUUyA9IG51bGw7XG4gICAgICBfdGhpcy5faW5pdERUUyA9IG51bGw7XG4gICAgICBfdGhpcy5uZXh0VmlkZW9UcyA9IG51bGw7XG4gICAgICBfdGhpcy5uZXh0QXVkaW9UcyA9IG51bGw7XG4gICAgICBfdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gbnVsbDtcbiAgICAgIF90aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgICBfdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgICAgX3RoaXMudmlkZW9UcmFja0NvbmZpZyA9IHZvaWQgMDtcbiAgICAgIF90aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICBfdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICBfdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICAgIF90aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICBpZiAoY2hyb21lVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgICBjaHJvbWVWZXJzaW9uID0gcmVzdWx0ID8gcGFyc2VJbnQocmVzdWx0WzFdKSA6IDA7XG4gICAgICB9XG4gICAgICBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgX3Jlc3VsdCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQrKS9pKTtcbiAgICAgICAgc2FmYXJpV2Via2l0VmVyc2lvbiA9IF9yZXN1bHQgPyBwYXJzZUludChfcmVzdWx0WzFdKSA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKE1QNFJlbXV4ZXIsIF9Mb2dnZXIpO1xuICAgIHZhciBfcHJvdG8gPSBNUDRSZW11eGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmNvbmZpZyA9IHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRUaW1lU3RhbXApIHtcbiAgICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICAgIGlmICghaW5pdFBUUyB8fCAhZGVmYXVsdFRpbWVTdGFtcCB8fCBkZWZhdWx0VGltZVN0YW1wLnRyYWNrSWQgIT09IGluaXRQVFMudHJhY2tJZCB8fCBkZWZhdWx0VGltZVN0YW1wLmJhc2VUaW1lICE9PSBpbml0UFRTLmJhc2VUaW1lIHx8IGRlZmF1bHRUaW1lU3RhbXAudGltZXNjYWxlICE9PSBpbml0UFRTLnRpbWVzY2FsZSkge1xuICAgICAgICB0aGlzLmxvZyhcIlJlc2V0IGluaXRQVFM6IFwiICsgKGluaXRQVFMgPyB0aW1lc3RhbXBUb1N0cmluZyhpbml0UFRTKSA6IGluaXRQVFMpICsgXCIgPiBcIiArIChkZWZhdWx0VGltZVN0YW1wID8gdGltZXN0YW1wVG9TdHJpbmcoZGVmYXVsdFRpbWVTdGFtcCkgOiBkZWZhdWx0VGltZVN0YW1wKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IGRlZmF1bHRUaW1lU3RhbXA7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXROZXh0VGltZXN0YW1wID0gZnVuY3Rpb24gcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgICAgdGhpcy5sb2coJ3Jlc2V0IG5leHQgdGltZXN0YW1wJyk7XG4gICAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoKSB7XG4gICAgICB0aGlzLmxvZygnSVNHZW5lcmF0ZWQgZmxhZyByZXNldCcpO1xuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFZpZGVvU3RhcnRQdHMgPSBmdW5jdGlvbiBnZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcykge1xuICAgICAgLy8gR2V0IHRoZSBtaW5pbXVtIFBUUyB2YWx1ZSByZWxhdGl2ZSB0byB0aGUgZmlyc3Qgc2FtcGxlJ3MgUFRTLCBub3JtYWxpemVkIGZvciAzMy1iaXQgd3JhcHBpbmdcbiAgICAgIHZhciByb2xsb3ZlckRldGVjdGVkID0gZmFsc2U7XG4gICAgICB2YXIgZmlyc3RQdHMgPSB2aWRlb1NhbXBsZXNbMF0ucHRzO1xuICAgICAgdmFyIHN0YXJ0UFRTID0gdmlkZW9TYW1wbGVzLnJlZHVjZShmdW5jdGlvbiAobWluUFRTLCBzYW1wbGUpIHtcbiAgICAgICAgdmFyIHB0cyA9IHNhbXBsZS5wdHM7XG4gICAgICAgIHZhciBkZWx0YSA9IHB0cyAtIG1pblBUUztcbiAgICAgICAgaWYgKGRlbHRhIDwgLTQyOTQ5NjcyOTYpIHtcbiAgICAgICAgICAvLyAyXjMyLCBzZWUgUFRTTm9ybWFsaXplIGZvciByZWFzb25pbmcsIGJ1dCB3ZSdyZSBoaXR0aW5nIGEgcm9sbG92ZXIgaGVyZSwgYW5kIHdlIGRvbid0IHdhbnQgdGhhdCB0byBpbXBhY3QgdGhlIHRpbWVPZmZzZXQgY2FsY3VsYXRpb25cbiAgICAgICAgICByb2xsb3ZlckRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBwdHMgPSBub3JtYWxpemVQdHMocHRzLCBmaXJzdFB0cyk7XG4gICAgICAgICAgZGVsdGEgPSBwdHMgLSBtaW5QVFM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgIHJldHVybiBtaW5QVFM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB0cztcbiAgICAgIH0sIGZpcnN0UHRzKTtcbiAgICAgIGlmIChyb2xsb3ZlckRldGVjdGVkKSB7XG4gICAgICAgIHRoaXMuZGVidWcoJ1BUUyByb2xsb3ZlciBkZXRlY3RlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0UFRTO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbXV4ID0gZnVuY3Rpb24gcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBmbHVzaCwgcGxheWxpc3RUeXBlKSB7XG4gICAgICB2YXIgdmlkZW87XG4gICAgICB2YXIgYXVkaW87XG4gICAgICB2YXIgaW5pdFNlZ21lbnQ7XG4gICAgICB2YXIgdGV4dDtcbiAgICAgIHZhciBpZDM7XG4gICAgICB2YXIgaW5kZXBlbmRlbnQ7XG4gICAgICB2YXIgYXVkaW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAgIHZhciB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuXG4gICAgICAvLyBJZiB3ZSdyZSByZW11eGluZyBhdWRpbyBhbmQgdmlkZW8gcHJvZ3Jlc3NpdmVseSwgd2FpdCB1bnRpbCB3ZSd2ZSByZWNlaXZlZCBlbm91Z2ggc2FtcGxlcyBmb3IgZWFjaCB0cmFjayBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBzeW5jaHJvbml6ZSB0aGUgYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXMuIFdlIGtub3cgaWYgdGhlIGN1cnJlbnQgc2VnbWVudCB3aWxsIGhhdmUgc2FtcGxlcyBpZiB0aGUgXCJwaWRcIlxuICAgICAgLy8gcGFyYW1ldGVyIGlzIGdyZWF0ZXIgdGhhbiAtMS4gVGhlIHBpZCBpcyBzZXQgd2hlbiB0aGUgUE1UIGlzIHBhcnNlZCwgd2hpY2ggY29udGFpbnMgdGhlIHRyYWNrcyBsaXN0LlxuICAgICAgLy8gSG93ZXZlciwgaWYgdGhlIGluaXRTZWdtZW50IGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkLCBvciB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgYSBzZWdtZW50IChmbHVzaCksXG4gICAgICAvLyB0aGVuIHdlIGNhbiByZW11eCBvbmUgdHJhY2sgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgb3RoZXIuXG4gICAgICB2YXIgaGFzQXVkaW8gPSBhdWRpb1RyYWNrLnBpZCA+IC0xO1xuICAgICAgdmFyIGhhc1ZpZGVvID0gdmlkZW9UcmFjay5waWQgPiAtMTtcbiAgICAgIHZhciBsZW5ndGggPSB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgICAgdmFyIGVub3VnaEF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGggPiAwO1xuICAgICAgdmFyIGVub3VnaFZpZGVvU2FtcGxlcyA9IGZsdXNoICYmIGxlbmd0aCA+IDAgfHwgbGVuZ3RoID4gMTtcbiAgICAgIHZhciBjYW5SZW11eEF2YyA9ICghaGFzQXVkaW8gfHwgZW5vdWdoQXVkaW9TYW1wbGVzKSAmJiAoIWhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcykgfHwgdGhpcy5JU0dlbmVyYXRlZCB8fCBmbHVzaDtcbiAgICAgIGlmIChjYW5SZW11eEF2Yykge1xuICAgICAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICAgIHZhciBfdmlkZW9UcmFjayRwaXhlbFJhdGksIF9jb25maWckcGl4ZWxSYXRpbywgX3ZpZGVvVHJhY2skcGl4ZWxSYXRpMiwgX2NvbmZpZyRwaXhlbFJhdGlvMjtcbiAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy52aWRlb1RyYWNrQ29uZmlnO1xuICAgICAgICAgIGlmIChjb25maWcgJiYgKHZpZGVvVHJhY2sud2lkdGggIT09IGNvbmZpZy53aWR0aCB8fCB2aWRlb1RyYWNrLmhlaWdodCAhPT0gY29uZmlnLmhlaWdodCB8fCAoKF92aWRlb1RyYWNrJHBpeGVsUmF0aSA9IHZpZGVvVHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF92aWRlb1RyYWNrJHBpeGVsUmF0aVswXSkgIT09ICgoX2NvbmZpZyRwaXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfY29uZmlnJHBpeGVsUmF0aW9bMF0pIHx8ICgoX3ZpZGVvVHJhY2skcGl4ZWxSYXRpMiA9IHZpZGVvVHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF92aWRlb1RyYWNrJHBpeGVsUmF0aTJbMV0pICE9PSAoKF9jb25maWckcGl4ZWxSYXRpbzIgPSBjb25maWcucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb25maWckcGl4ZWxSYXRpbzJbMV0pKSB8fCAhY29uZmlnICYmIGVub3VnaFZpZGVvU2FtcGxlcyB8fCB0aGlzLm5leHRBdWRpb1RzID09PSBudWxsICYmIGVub3VnaEF1ZGlvU2FtcGxlcykge1xuICAgICAgICAgICAgdGhpcy5yZXNldEluaXRTZWdtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzVmlkZW9Db250aWd1b3VzID0gdGhpcy5pc1ZpZGVvQ29udGlndW91cztcbiAgICAgICAgdmFyIGZpcnN0S2V5RnJhbWVJbmRleCA9IC0xO1xuICAgICAgICB2YXIgZmlyc3RLZXlGcmFtZVBUUztcbiAgICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIGZpcnN0S2V5RnJhbWVJbmRleCA9IGZpbmRLZXlmcmFtZUluZGV4KHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgaWYgKCFpc1ZpZGVvQ29udGlndW91cyAmJiB0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgICBpbmRlcGVuZGVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZmlyc3RLZXlGcmFtZUluZGV4ID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLndhcm4oXCJEcm9wcGVkIFwiICsgZmlyc3RLZXlGcmFtZUluZGV4ICsgXCIgb3V0IG9mIFwiICsgbGVuZ3RoICsgXCIgdmlkZW8gc2FtcGxlcyBkdWUgdG8gYSBtaXNzaW5nIGtleWZyYW1lXCIpO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLnNsaWNlKGZpcnN0S2V5RnJhbWVJbmRleCk7XG4gICAgICAgICAgICAgIHZpZGVvVHJhY2suZHJvcHBlZCArPSBmaXJzdEtleUZyYW1lSW5kZXg7XG4gICAgICAgICAgICAgIHZpZGVvVGltZU9mZnNldCArPSAodmlkZW9UcmFjay5zYW1wbGVzWzBdLnB0cyAtIHN0YXJ0UFRTKSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICAgIGZpcnN0S2V5RnJhbWVQVFMgPSB2aWRlb1RpbWVPZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy53YXJuKFwiTm8ga2V5ZnJhbWUgZm91bmQgb3V0IG9mIFwiICsgbGVuZ3RoICsgXCIgdmlkZW8gc2FtcGxlc1wiKTtcbiAgICAgICAgICAgICAgaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzICYmIGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgLy8gdGltZU9mZnNldCBpcyBleHBlY3RlZCB0byBiZSB0aGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCB0aW1lc3RhbXAgb2YgdGhpcyBmcmFnbWVudCAoZmlyc3QgRFRTKVxuICAgICAgICAgICAgLy8gaWYgZmlyc3QgYXVkaW8gRFRTIGlzIG5vdCBhbGlnbmVkIHdpdGggZmlyc3QgdmlkZW8gRFRTIHRoZW4gd2UgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgICAgICAvLyB3aGVuIHByb3ZpZGluZyB0aW1lT2Zmc2V0IHRvIHJlbXV4QXVkaW8gLyByZW11eFZpZGVvLiBpZiB3ZSBkb24ndCBkbyB0aGF0LCB0aGVyZSBtaWdodCBiZSBhIHBlcm1hbmVudCAvIHNtYWxsXG4gICAgICAgICAgICAvLyBkcmlmdCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zXG4gICAgICAgICAgICB2YXIgX3N0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgICB2YXIgdHNEZWx0YSA9IG5vcm1hbGl6ZVB0cyhhdWRpb1RyYWNrLnNhbXBsZXNbMF0ucHRzLCBfc3RhcnRQVFMpIC0gX3N0YXJ0UFRTO1xuICAgICAgICAgICAgdmFyIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSA9IHRzRGVsdGEgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgLWF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpcyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcykge1xuICAgICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IGF1ZGlvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICAgIGlmICghYXVkaW9UcmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMud2FybigncmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyBhdWRpbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVkaW8gPSB0aGlzLnJlbXV4QXVkaW8oYXVkaW9UcmFjaywgYXVkaW9UaW1lT2Zmc2V0LCB0aGlzLmlzQXVkaW9Db250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcyB8fCBwbGF5bGlzdFR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPID8gdmlkZW9UaW1lT2Zmc2V0IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAgICAgdmFyIGF1ZGlvVHJhY2tMZW5ndGggPSBhdWRpbyA/IGF1ZGlvLmVuZFBUUyAtIGF1ZGlvLnN0YXJ0UFRTIDogMDtcbiAgICAgICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXJuKCdyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIHZpZGVvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2aWRlbyA9IHRoaXMucmVtdXhWaWRlbyh2aWRlb1RyYWNrLCB2aWRlb1RpbWVPZmZzZXQsIGlzVmlkZW9Db250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBpc1ZpZGVvQ29udGlndW91cywgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZSA9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICAgIHZpZGVvLmluZGVwZW5kZW50ID0gZmlyc3RLZXlGcmFtZUluZGV4ICE9PSAtMTtcbiAgICAgICAgICAgIHZpZGVvLmZpcnN0S2V5RnJhbWVQVFMgPSBmaXJzdEtleUZyYW1lUFRTO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBJRDMgYW5kIHRleHQgdG8gcmVtdXgsIGV2ZW4gaWYgbW9yZSBhdWRpby92aWRlbyBzYW1wbGVzIGFyZSByZXF1aXJlZFxuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQgJiYgdGhpcy5faW5pdFBUUyAmJiB0aGlzLl9pbml0RFRTKSB7XG4gICAgICAgIGlmIChpZDNUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIGlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0LCB0aGlzLl9pbml0UFRTLCB0aGlzLl9pbml0RFRTKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGV4dCA9IGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRleHRUcmFjaywgdGltZU9mZnNldCwgdGhpcy5faW5pdFBUUyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvOiBhdWRpbyxcbiAgICAgICAgdmlkZW86IHZpZGVvLFxuICAgICAgICBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsXG4gICAgICAgIGluZGVwZW5kZW50OiBpbmRlcGVuZGVudCxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaWQzOiBpZDNcbiAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uY29tcHV0ZUluaXRQdHMgPSBmdW5jdGlvbiBjb21wdXRlSW5pdFB0cyhiYXNldGltZSwgdGltZXNjYWxlLCBwcmVzZW50YXRpb25UaW1lLCB0eXBlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5yb3VuZChwcmVzZW50YXRpb25UaW1lICogdGltZXNjYWxlKTtcbiAgICAgIHZhciB0aW1lc3RhbXAgPSBub3JtYWxpemVQdHMoYmFzZXRpbWUsIG9mZnNldCk7XG4gICAgICBpZiAodGltZXN0YW1wIDwgb2Zmc2V0ICsgdGltZXNjYWxlKSB7XG4gICAgICAgIHRoaXMubG9nKFwiQWRqdXN0aW5nIFBUUyBmb3Igcm9sbG92ZXIgaW4gdGltZWxpbmUgbmVhciBcIiArIChvZmZzZXQgLSB0aW1lc3RhbXApIC8gdGltZXNjYWxlICsgXCIgXCIgKyB0eXBlKTtcbiAgICAgICAgd2hpbGUgKHRpbWVzdGFtcCA8IG9mZnNldCArIHRpbWVzY2FsZSkge1xuICAgICAgICAgIHRpbWVzdGFtcCArPSA4NTg5OTM0NTkyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZXN0YW1wIC0gb2Zmc2V0O1xuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlSVMgPSBmdW5jdGlvbiBnZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgdmFyIGF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcztcbiAgICAgIHZhciB2aWRlb1NhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgICB2YXIgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICAgIHZhciBfaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgICB2YXIgY29tcHV0ZVBUU0RUUyA9ICFfaW5pdFBUUyB8fCBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gICAgICB2YXIgY29udGFpbmVyID0gJ2F1ZGlvL21wNCc7XG4gICAgICB2YXIgaW5pdFBUUztcbiAgICAgIHZhciBpbml0RFRTO1xuICAgICAgdmFyIHRpbWVzY2FsZTtcbiAgICAgIHZhciB0cmFja0lkID0gLTE7XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gbGV0J3MgdXNlIGF1ZGlvIHNhbXBsaW5nIHJhdGUgYXMgTVA0IHRpbWUgc2NhbGUuXG4gICAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgICAvLyB1c2luZyBhdWRpbyBzYW1wbGluZyByYXRlIGhlcmUgaGVscHMgaGF2aW5nIGFuIGludGVnZXIgTVA0IGZyYW1lIGR1cmF0aW9uXG4gICAgICAgIC8vIHRoaXMgYXZvaWRzIHBvdGVudGlhbCByb3VuZGluZyBpc3N1ZSBhbmQgQVYgc3luYyBpc3N1ZVxuICAgICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7XG4gICAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcbiAgICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlU3VwcG9ydGVkLm1wMykge1xuICAgICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnbXAzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FjMyc6XG4gICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJ2FjLTMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICAgIGlkOiAnYXVkaW8nLFxuICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgIGNvZGVjOiBhdWRpb1RyYWNrLmNvZGVjLFxuICAgICAgICAgIGluaXRTZWdtZW50OiBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBNUDQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgY2hhbm5lbENvdW50OiBhdWRpb1RyYWNrLmNoYW5uZWxDb3VudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgICB0cmFja0lkID0gYXVkaW9UcmFjay5pZDtcbiAgICAgICAgICB0aW1lc2NhbGUgPSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgIGlmICghX2luaXRQVFMgfHwgdGltZXNjYWxlICE9PSBfaW5pdFBUUy50aW1lc2NhbGUpIHtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTID0gRFRTXG4gICAgICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IHRoaXMuY29tcHV0ZUluaXRQdHMoYXVkaW9TYW1wbGVzWzBdLnB0cywgdGltZXNjYWxlLCB0aW1lT2Zmc2V0LCAnYXVkaW8nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHV0ZVBUU0RUUyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZpZGVvVHJhY2suc3BzICYmIHZpZGVvVHJhY2sucHBzICYmIHZpZGVvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxuICAgICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgICB2aWRlb1RyYWNrLnRpbWVzY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgICBpZDogJ21haW4nLFxuICAgICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgICAgaW5pdFNlZ21lbnQ6IE1QNC5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgICAgdHJhY2tJZCA9IHZpZGVvVHJhY2suaWQ7XG4gICAgICAgICAgdGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICBpZiAoIV9pbml0UFRTIHx8IHRpbWVzY2FsZSAhPT0gX2luaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgICAgICB2YXIgYmFzZVBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1NhbXBsZXMpO1xuICAgICAgICAgICAgdmFyIGJhc2VEVFMgPSBub3JtYWxpemVQdHModmlkZW9TYW1wbGVzWzBdLmR0cywgYmFzZVBUUyk7XG4gICAgICAgICAgICB2YXIgdmlkZW9Jbml0RFRTID0gdGhpcy5jb21wdXRlSW5pdFB0cyhiYXNlRFRTLCB0aW1lc2NhbGUsIHRpbWVPZmZzZXQsICd2aWRlbycpO1xuICAgICAgICAgICAgdmFyIHZpZGVvSW5pdFBUUyA9IHRoaXMuY29tcHV0ZUluaXRQdHMoYmFzZVBUUywgdGltZXNjYWxlLCB0aW1lT2Zmc2V0LCAndmlkZW8nKTtcbiAgICAgICAgICAgIGluaXREVFMgPSBNYXRoLm1pbihpbml0RFRTLCB2aWRlb0luaXREVFMpO1xuICAgICAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsIHZpZGVvSW5pdFBUUyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0ge1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHQsXG4gICAgICAgICAgcGl4ZWxSYXRpbzogdmlkZW9UcmFjay5waXhlbFJhdGlvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgICAgaWYgKF9pbml0UFRTKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJUaW1lc3RhbXBzIGF0IHBsYXlsaXN0IHRpbWU6IFwiICsgKGFjY3VyYXRlVGltZU9mZnNldCA/ICcnIDogJ34nKSArIHRpbWVPZmZzZXQgKyBcIiBcIiArIGluaXRQVFMgLyB0aW1lc2NhbGUgKyBcIiAhPSBpbml0UFRTOiBcIiArIF9pbml0UFRTLmJhc2VUaW1lIC8gX2luaXRQVFMudGltZXNjYWxlICsgXCIgKFwiICsgX2luaXRQVFMuYmFzZVRpbWUgKyBcIi9cIiArIF9pbml0UFRTLnRpbWVzY2FsZSArIFwiKSB0cmFja0lkOiBcIiArIF9pbml0UFRTLnRyYWNrSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZyhcIkZvdW5kIGluaXRQVFMgYXQgcGxheWxpc3QgdGltZTogXCIgKyB0aW1lT2Zmc2V0ICsgXCIgb2Zmc2V0OiBcIiArIGluaXRQVFMgLyB0aW1lc2NhbGUgKyBcIiAoXCIgKyBpbml0UFRTICsgXCIvXCIgKyB0aW1lc2NhbGUgKyBcIikgdHJhY2tJZDogXCIgKyB0cmFja0lkKTtcbiAgICAgICAgICB0aGlzLl9pbml0UFRTID0ge1xuICAgICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZSxcbiAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrSWRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2luaXREVFMgPSB7XG4gICAgICAgICAgICBiYXNlVGltZTogaW5pdERUUyxcbiAgICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlLFxuICAgICAgICAgICAgdHJhY2tJZDogdHJhY2tJZFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdFBUUyA9IHRpbWVzY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYWNrczogdHJhY2tzLFxuICAgICAgICAgIGluaXRQVFM6IGluaXRQVFMsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgdHJhY2tJZDogdHJhY2tJZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJlbXV4VmlkZW8gPSBmdW5jdGlvbiByZW11eFZpZGVvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKSB7XG4gICAgICB2YXIgdGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICB2YXIgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICAgIHZhciBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgICB2YXIgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICAgIHZhciBpbml0VGltZSA9IGluaXRQVFMuYmFzZVRpbWUgKiB0aW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICAgIHZhciBuZXh0VmlkZW9UcyA9IHRoaXMubmV4dFZpZGVvVHM7XG4gICAgICB2YXIgb2Zmc2V0ID0gODtcbiAgICAgIHZhciBtcDRTYW1wbGVEdXJhdGlvbiA9IHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbjtcbiAgICAgIHZhciBmaXJzdERUUztcbiAgICAgIHZhciBsYXN0RFRTO1xuICAgICAgdmFyIG1pblBUUyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIHZhciBtYXhQVFMgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICB2YXIgc29ydFNhbXBsZXMgPSBmYWxzZTtcblxuICAgICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRWaWRlb1RzID09PSBudWxsKSB7XG4gICAgICAgIHZhciBwdHMgPSBpbml0VGltZSArIHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgICAgIHZhciBjdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5kdHMsIGlucHV0U2FtcGxlc1swXS5wdHMpO1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbiAmJiBuZXh0VmlkZW9UcyAhPT0gbnVsbCAmJiBNYXRoLmFicyhwdHMgLSBjdHMgLSAobmV4dFZpZGVvVHMgKyBpbml0VGltZSkpIDwgMTUwMDApIHtcbiAgICAgICAgICAvLyB0cmVhdCBhcyBjb250aWdvdXMgdG8gYWRqdXN0IHNhbXBsZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgcHJvZHVjZSB2aWRlbyBidWZmZXIgZ2FwcyBpbiBDaHJvbWVcbiAgICAgICAgICBjb250aWd1b3VzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRhcmdldCB0aW1lT2Zmc2V0XG4gICAgICAgICAgbmV4dFZpZGVvVHMgPSBwdHMgLSBjdHMgLSBpbml0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gICAgICAvLyBQVFNOb3JtYWxpemUgd2lsbCBtYWtlIFBUUy9EVFMgdmFsdWUgbW9ub3RvbmljLCB3ZSB1c2UgbGFzdCBrbm93biBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlIHZhbHVlXG4gICAgICB2YXIgbmV4dFZpZGVvUHRzID0gbmV4dFZpZGVvVHMgKyBpbml0VGltZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzLCBuZXh0VmlkZW9QdHMpO1xuICAgICAgICBzYW1wbGUuZHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5kdHMsIG5leHRWaWRlb1B0cyk7XG4gICAgICAgIGlmIChzYW1wbGUuZHRzIDwgaW5wdXRTYW1wbGVzW2kgPiAwID8gaSAtIDEgOiBpXS5kdHMpIHtcbiAgICAgICAgICBzb3J0U2FtcGxlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc29ydCB2aWRlbyBzYW1wbGVzIGJ5IERUUyB0aGVuIFBUUyB0aGVuIGRlbXV4IGlkIG9yZGVyXG4gICAgICBpZiAoc29ydFNhbXBsZXMpIHtcbiAgICAgICAgaW5wdXRTYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICB2YXIgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgICAgIHZhciBkZWx0YXB0cyA9IGEucHRzIC0gYi5wdHM7XG4gICAgICAgICAgcmV0dXJuIGRlbHRhZHRzIHx8IGRlbHRhcHRzO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGZpcnN0L2xhc3QgRFRTXG4gICAgICBmaXJzdERUUyA9IGlucHV0U2FtcGxlc1swXS5kdHM7XG4gICAgICBsYXN0RFRTID0gaW5wdXRTYW1wbGVzW2lucHV0U2FtcGxlcy5sZW5ndGggLSAxXS5kdHM7XG5cbiAgICAgIC8vIFNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgICAgLy8gc2V0IHRoaXMgY29uc3RhbnQgZHVyYXRpb24gYXMgYmVpbmcgdGhlIGF2ZyBkZWx0YSBiZXR3ZWVuIGNvbnNlY3V0aXZlIERUUy5cbiAgICAgIHZhciBpbnB1dER1cmF0aW9uID0gbGFzdERUUyAtIGZpcnN0RFRTO1xuICAgICAgdmFyIGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiA9IGlucHV0RHVyYXRpb24gPyBNYXRoLnJvdW5kKGlucHV0RHVyYXRpb24gLyAobmJTYW1wbGVzIC0gMSkpIDogbXA0U2FtcGxlRHVyYXRpb24gfHwgdHJhY2suaW5wdXRUaW1lU2NhbGUgLyAzMDtcblxuICAgICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgICBpZiAoY29udGlndW91cykge1xuICAgICAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcbiAgICAgICAgdmFyIGRlbHRhID0gZmlyc3REVFMgLSBuZXh0VmlkZW9QdHM7XG4gICAgICAgIHZhciBmb3VuZEhvbGUgPSBkZWx0YSA+IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgdmFyIGZvdW5kT3ZlcmxhcCA9IGRlbHRhIDwgLTE7XG4gICAgICAgIGlmIChmb3VuZEhvbGUgfHwgZm91bmRPdmVybGFwKSB7XG4gICAgICAgICAgaWYgKGZvdW5kSG9sZSkge1xuICAgICAgICAgICAgdGhpcy53YXJuKCh0cmFjay5zZWdtZW50Q29kZWMgfHwgJycpLnRvVXBwZXJDYXNlKCkgKyBcIjogXCIgKyB0b01zRnJvbU1wZWdUc0Nsb2NrKGRlbHRhLCB0cnVlKSArIFwiIG1zIChcIiArIGRlbHRhICsgXCJkdHMpIGhvbGUgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWQgYXQgXCIgKyB0aW1lT2Zmc2V0LnRvRml4ZWQoMykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oKHRyYWNrLnNlZ21lbnRDb2RlYyB8fCAnJykudG9VcHBlckNhc2UoKSArIFwiOiBcIiArIHRvTXNGcm9tTXBlZ1RzQ2xvY2soLWRlbHRhLCB0cnVlKSArIFwiIG1zIChcIiArIGRlbHRhICsgXCJkdHMpIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkIGF0IFwiICsgdGltZU9mZnNldC50b0ZpeGVkKDMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZE92ZXJsYXAgfHwgbmV4dFZpZGVvUHRzID49IGlucHV0U2FtcGxlc1swXS5wdHMgfHwgY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgICAgZmlyc3REVFMgPSBuZXh0VmlkZW9QdHM7XG4gICAgICAgICAgICB2YXIgZmlyc3RQVFMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzIC0gZGVsdGE7XG4gICAgICAgICAgICBpZiAoZm91bmRIb2xlKSB7XG4gICAgICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5kdHMgPSBmaXJzdERUUztcbiAgICAgICAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGlzUFRTT3JkZXJSZXRhaW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2FtcGxlc1tfaV0uZHRzID4gZmlyc3RQVFMgJiYgaXNQVFNPcmRlclJldGFpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByZXZQVFMgPSBpbnB1dFNhbXBsZXNbX2ldLnB0cztcbiAgICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbX2ldLmR0cyAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbX2ldLnB0cyAtPSBkZWx0YTtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGlzIHNhbXBsZSdzIFBUUyBvcmRlciBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICAgICAgICAgIGlmIChfaSA8IGlucHV0U2FtcGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmV4dFNhbXBsZVBUUyA9IGlucHV0U2FtcGxlc1tfaSArIDFdLnB0cztcbiAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2FtcGxlUFRTID0gaW5wdXRTYW1wbGVzW19pXS5wdHM7XG4gICAgICAgICAgICAgICAgICB2YXIgY3VycmVudE9yZGVyID0gbmV4dFNhbXBsZVBUUyA8PSBjdXJyZW50U2FtcGxlUFRTO1xuICAgICAgICAgICAgICAgICAgdmFyIHByZXZPcmRlciA9IG5leHRTYW1wbGVQVFMgPD0gcHJldlBUUztcbiAgICAgICAgICAgICAgICAgIGlzUFRTT3JkZXJSZXRhaW5lZCA9IGN1cnJlbnRPcmRlciA9PSBwcmV2T3JkZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZyhcIlZpZGVvOiBJbml0aWFsIFBUUy9EVFMgYWRqdXN0ZWQ6IFwiICsgdG9Nc0Zyb21NcGVnVHNDbG9jayhmaXJzdFBUUywgdHJ1ZSkgKyBcIi9cIiArIHRvTXNGcm9tTXBlZ1RzQ2xvY2soZmlyc3REVFMsIHRydWUpICsgXCIsIGRlbHRhOiBcIiArIHRvTXNGcm9tTXBlZ1RzQ2xvY2soZGVsdGEsIHRydWUpICsgXCIgbXNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaXJzdERUUyA9IE1hdGgubWF4KDAsIGZpcnN0RFRTKTtcbiAgICAgIHZhciBuYk5hbHUgPSAwO1xuICAgICAgdmFyIG5hbHVMZW4gPSAwO1xuICAgICAgdmFyIGR0c1N0ZXAgPSBmaXJzdERUUztcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5iU2FtcGxlczsgX2kyKyspIHtcbiAgICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICAgIHZhciBfc2FtcGxlID0gaW5wdXRTYW1wbGVzW19pMl07XG4gICAgICAgIHZhciB1bml0cyA9IF9zYW1wbGUudW5pdHM7XG4gICAgICAgIHZhciBuYlVuaXRzID0gdW5pdHMubGVuZ3RoO1xuICAgICAgICB2YXIgc2FtcGxlTGVuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xuICAgICAgICBfc2FtcGxlLmxlbmd0aCA9IHNhbXBsZUxlbjtcblxuICAgICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgICAgaWYgKF9zYW1wbGUuZHRzIDwgZHRzU3RlcCkge1xuICAgICAgICAgIF9zYW1wbGUuZHRzID0gZHRzU3RlcDtcbiAgICAgICAgICBkdHNTdGVwICs9IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiAvIDQgfCAwIHx8IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHRzU3RlcCA9IF9zYW1wbGUuZHRzO1xuICAgICAgICB9XG4gICAgICAgIG1pblBUUyA9IE1hdGgubWluKF9zYW1wbGUucHRzLCBtaW5QVFMpO1xuICAgICAgICBtYXhQVFMgPSBNYXRoLm1heChfc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICAgIH1cbiAgICAgIGxhc3REVFMgPSBpbnB1dFNhbXBsZXNbbmJTYW1wbGVzIC0gMV0uZHRzO1xuXG4gICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICAgIHZhciBtZGF0U2l6ZSA9IG5hbHVMZW4gKyA0ICogbmJOYWx1ICsgODtcbiAgICAgIHZhciBtZGF0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgYnl0ZXM6IG1kYXRTaXplLFxuICAgICAgICAgIHJlYXNvbjogXCJmYWlsIGFsbG9jYXRpbmcgdmlkZW8gbWRhdCBcIiArIG1kYXRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICB2YXIgc3RyZXRjaGVkTGFzdEZyYW1lID0gZmFsc2U7XG4gICAgICB2YXIgbWluRHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB2YXIgbWluUHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB2YXIgbWF4RHRzRGVsdGEgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICB2YXIgbWF4UHRzRGVsdGEgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBuYlNhbXBsZXM7IF9pMysrKSB7XG4gICAgICAgIHZhciBWaWRlb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tfaTNdO1xuICAgICAgICB2YXIgVmlkZW9TYW1wbGVVbml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgICB2YXIgbXA0U2FtcGxlTGVuZ3RoID0gMDtcbiAgICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9uYlVuaXRzID0gVmlkZW9TYW1wbGVVbml0cy5sZW5ndGg7IF9qIDwgX25iVW5pdHM7IF9qKyspIHtcbiAgICAgICAgICB2YXIgdW5pdCA9IFZpZGVvU2FtcGxlVW5pdHNbX2pdO1xuICAgICAgICAgIHZhciB1bml0RGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgICB2YXIgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIHVuaXREYXRhTGVuKTtcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gdW5pdERhdGFMZW47XG4gICAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgICB2YXIgcHRzRGVsdGEgPSB2b2lkIDA7XG4gICAgICAgIGlmIChfaTMgPCBuYlNhbXBsZXMgLSAxKSB7XG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbX2kzICsgMV0uZHRzIC0gVmlkZW9TYW1wbGUuZHRzO1xuICAgICAgICAgIHB0c0RlbHRhID0gaW5wdXRTYW1wbGVzW19pMyArIDFdLnB0cyAtIFZpZGVvU2FtcGxlLnB0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgdmFyIGxhc3RGcmFtZUR1cmF0aW9uID0gX2kzID4gMCA/IFZpZGVvU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tfaTMgLSAxXS5kdHMgOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgcHRzRGVsdGEgPSBfaTMgPiAwID8gVmlkZW9TYW1wbGUucHRzIC0gaW5wdXRTYW1wbGVzW19pMyAtIDFdLnB0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2sgJiYgdGhpcy5uZXh0QXVkaW9UcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgYSBzZWdtZW50J3MgYXVkaW8gdHJhY2sgZHVyYXRpb24gbWF5IGV4Y2VlZCB0aGUgdmlkZW8gdHJhY2sgZHVyYXRpb24uXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIG1heEJ1ZmZlckhvbGUuXG4gICAgICAgICAgICAvLyBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgICB2YXIgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihjb25maWcubWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSk7XG4gICAgICAgICAgICB2YXIgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBtaW5QVFMgKyBhdWRpb1RyYWNrTGVuZ3RoICogdGltZVNjYWxlIDogdGhpcy5uZXh0QXVkaW9UcyArIGluaXRUaW1lKSAtIFZpZGVvU2FtcGxlLnB0cztcbiAgICAgICAgICAgIGlmIChkZWx0YVRvRnJhbWVFbmQgPiBnYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXG4gICAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBkZWx0YVRvRnJhbWVFbmQgLSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyZXRjaGVkTGFzdEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmxvZyhcIkl0IGlzIGFwcHJveGltYXRlbHkgXCIgKyBkZWx0YVRvRnJhbWVFbmQgLyA5MCArIFwiIG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uIFwiICsgbXA0U2FtcGxlRHVyYXRpb24gLyA5MCArIFwiIG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChWaWRlb1NhbXBsZS5wdHMgLSBWaWRlb1NhbXBsZS5kdHMpO1xuICAgICAgICBtaW5EdHNEZWx0YSA9IE1hdGgubWluKG1pbkR0c0RlbHRhLCBtcDRTYW1wbGVEdXJhdGlvbik7XG4gICAgICAgIG1heER0c0RlbHRhID0gTWF0aC5tYXgobWF4RHRzRGVsdGEsIG1wNFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgbWluUHRzRGVsdGEgPSBNYXRoLm1pbihtaW5QdHNEZWx0YSwgcHRzRGVsdGEpO1xuICAgICAgICBtYXhQdHNEZWx0YSA9IE1hdGgubWF4KG1heFB0c0RlbHRhLCBwdHNEZWx0YSk7XG4gICAgICAgIG91dHB1dFNhbXBsZXMucHVzaChjcmVhdGVNcDRTYW1wbGUoVmlkZW9TYW1wbGUua2V5LCBtcDRTYW1wbGVEdXJhdGlvbiwgbXA0U2FtcGxlTGVuZ3RoLCBjb21wb3NpdGlvblRpbWVPZmZzZXQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdXRwdXRTYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgIGlmIChjaHJvbWVWZXJzaW9uIDwgNzApIHtcbiAgICAgICAgICAgIC8vIENocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgKGtleWZyYW1lKSB0byBhdm9pZCBzb3VyY2VidWZmZXIgYXBwZW5kIGlzc3VlXG4gICAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xuICAgICAgICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24pIHtcbiAgICAgICAgICAvLyBGaXggZm9yIFwiQ05OIHNwZWNpYWwgcmVwb3J0LCB3aXRoIENDXCIgaW4gdGVzdC1zdHJlYW1zIChTYWZhcmkgYnJvd3NlciBvbmx5KVxuICAgICAgICAgIC8vIElnbm9yZSBEVFMgd2hlbiBmcmFtZSBkdXJhdGlvbnMgYXJlIGlycmVndWxhci4gU2FmYXJpIE1TRSBkb2VzIG5vdCBoYW5kbGUgdGhpcyBsZWFkaW5nIHRvIGdhcHMuXG4gICAgICAgICAgaWYgKG1heFB0c0RlbHRhIC0gbWluUHRzRGVsdGEgPCBtYXhEdHNEZWx0YSAtIG1pbkR0c0RlbHRhICYmIGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiAvIG1heER0c0RlbHRhIDwgMC4wMjUgJiYgb3V0cHV0U2FtcGxlc1swXS5jdHMgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMud2FybignRm91bmQgaXJyZWd1bGFyIGdhcHMgaW4gc2FtcGxlIGR1cmF0aW9uLiBVc2luZyBQVFMgaW5zdGVhZCBvZiBEVFMgdG8gZGV0ZXJtaW5lIE1QNCBzYW1wbGUgZHVyYXRpb24uJyk7XG4gICAgICAgICAgICB2YXIgZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBsZW4gPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDsgX2k0IDwgbGVuOyBfaTQrKykge1xuICAgICAgICAgICAgICB2YXIgbmV4dER0cyA9IGR0cyArIG91dHB1dFNhbXBsZXNbX2k0XS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgdmFyIF9wdHMgPSBkdHMgKyBvdXRwdXRTYW1wbGVzW19pNF0uY3RzO1xuICAgICAgICAgICAgICBpZiAoX2k0IDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UHRzID0gbmV4dER0cyArIG91dHB1dFNhbXBsZXNbX2k0ICsgMV0uY3RzO1xuICAgICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbX2k0XS5kdXJhdGlvbiA9IG5leHRQdHMgLSBfcHRzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbX2k0XS5kdXJhdGlvbiA9IF9pNCA/IG91dHB1dFNhbXBsZXNbX2k0IC0gMV0uZHVyYXRpb24gOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tfaTRdLmN0cyA9IDA7XG4gICAgICAgICAgICAgIGR0cyA9IG5leHREdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBuZXh0IEFWQy9IRVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBzdHJldGNoZWRMYXN0RnJhbWUgfHwgIW1wNFNhbXBsZUR1cmF0aW9uID8gYXZlcmFnZVNhbXBsZUR1cmF0aW9uIDogbXA0U2FtcGxlRHVyYXRpb247XG4gICAgICB2YXIgZW5kRFRTID0gbGFzdERUUyArIG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgICAgdGhpcy5uZXh0VmlkZW9UcyA9IG5leHRWaWRlb1RzID0gZW5kRFRTIC0gaW5pdFRpbWU7XG4gICAgICB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSB0cnVlO1xuICAgICAgdmFyIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUywgX2V4dGVuZHModHJhY2ssIHtcbiAgICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgICAgfSkpO1xuICAgICAgdmFyIHR5cGUgPSAndmlkZW8nO1xuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICBkYXRhMjogbWRhdCxcbiAgICAgICAgc3RhcnRQVFM6IChtaW5QVFMgLSBpbml0VGltZSkgLyB0aW1lU2NhbGUsXG4gICAgICAgIGVuZFBUUzogKG1heFBUUyArIG1wNFNhbXBsZUR1cmF0aW9uIC0gaW5pdFRpbWUpIC8gdGltZVNjYWxlLFxuICAgICAgICBzdGFydERUUzogKGZpcnN0RFRTIC0gaW5pdFRpbWUpIC8gdGltZVNjYWxlLFxuICAgICAgICBlbmREVFM6IG5leHRWaWRlb1RzIC8gdGltZVNjYWxlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBoYXNBdWRpbzogZmFsc2UsXG4gICAgICAgIGhhc1ZpZGVvOiB0cnVlLFxuICAgICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICAgIGRyb3BwZWQ6IHRyYWNrLmRyb3BwZWRcbiAgICAgIH07XG4gICAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFNhbXBsZXNQZXJGcmFtZSA9IGZ1bmN0aW9uIGdldFNhbXBsZXNQZXJGcmFtZSh0cmFjaykge1xuICAgICAgc3dpdGNoICh0cmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICByZXR1cm4gTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FO1xuICAgICAgICBjYXNlICdhYzMnOlxuICAgICAgICAgIHJldHVybiBBQzNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIEFBQ19TQU1QTEVTX1BFUl9GUkFNRTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZW11eEF1ZGlvID0gZnVuY3Rpb24gcmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB2aWRlb1RpbWVPZmZzZXQpIHtcbiAgICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdmFyIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgICB2YXIgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICAgIHZhciBtcDRTYW1wbGVEdXJhdGlvbiA9IHRoaXMuZ2V0U2FtcGxlc1BlckZyYW1lKHRyYWNrKTtcbiAgICAgIHZhciBpbnB1dFNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb24gKiBzY2FsZUZhY3RvcjtcbiAgICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICAgIHZhciByYXdNUEVHID0gdHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZztcbiAgICAgIHZhciBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgICB2YXIgYWxpZ25lZFdpdGhWaWRlbyA9IHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICB2YXIgb2Zmc2V0ID0gcmF3TVBFRyA/IDAgOiA4O1xuICAgICAgdmFyIG5leHRBdWRpb1RzID0gdGhpcy5uZXh0QXVkaW9UcyB8fCAtMTtcblxuICAgICAgLy8gd2luZG93LmF1ZGlvU2FtcGxlcyA/IHdpbmRvdy5hdWRpb1NhbXBsZXMucHVzaChpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpKSA6ICh3aW5kb3cuYXVkaW9TYW1wbGVzID0gW2lucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cyldKTtcblxuICAgICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG4gICAgICB2YXIgaW5pdFRpbWUgPSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICAgIHZhciB0aW1lT2Zmc2V0TXBlZ1RTID0gaW5pdFRpbWUgKyB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGU7XG4gICAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gY29udGlndW91cyA9IGNvbnRpZ3VvdXMgfHwgaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXVkaW9UcyA+IDAgJiYgKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0TXBlZ1RTIC0gKG5leHRBdWRpb1RzICsgaW5pdFRpbWUpKSA8IDkwMDAgfHwgTWF0aC5hYnMobm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5wdHMsIHRpbWVPZmZzZXRNcGVnVFMpIC0gKG5leHRBdWRpb1RzICsgaW5pdFRpbWUpKSA8IDIwICogaW5wdXRTYW1wbGVEdXJhdGlvbik7XG5cbiAgICAgIC8vIGNvbXB1dGUgbm9ybWFsaXplZCBQVFNcbiAgICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdWRpb1RzIDwgMCkge1xuICAgICAgICB2YXIgc2FtcGxlQ291bnQgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgICAgICAvLyBmaWx0ZXIgb3V0IHNhbXBsZSB3aXRoIG5lZ2F0aXZlIFBUUyB0aGF0IGFyZSBub3QgcGxheWFibGUgYW55d2F5XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IHJlbW92ZSB0aGVzZSBuZWdhdGl2ZSBzYW1wbGVzLCB0aGV5IHdpbGwgc2hpZnQgYWxsIGF1ZGlvIHNhbXBsZXMgZm9yd2FyZC5cbiAgICAgICAgLy8gbGVhZGluZyB0byBhdWRpbyBvdmVybGFwIGJldHdlZW4gY3VycmVudCAvIG5leHQgZnJhZ21lbnRcbiAgICAgICAgaW5wdXRTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmZpbHRlcihmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZS5wdHMgPj0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzYW1wbGVDb3VudCAhPT0gaW5wdXRTYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMud2FybihcIlJlbW92ZWQgXCIgKyAoaW5wdXRTYW1wbGVzLmxlbmd0aCAtIHNhbXBsZUNvdW50KSArIFwiIG9mIFwiICsgc2FtcGxlQ291bnQgKyBcIiBzYW1wbGVzIChpbml0UFRTIFwiICsgaW5pdFRpbWUgKyBcIiAvIFwiICsgaW5wdXRUaW1lU2NhbGUgKyBcIilcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiBjYXNlIGFsbCBzYW1wbGVzIGhhdmUgbmVnYXRpdmUgUFRTLCBhbmQgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dCwgcmV0dXJuIG5vd1xuICAgICAgICBpZiAoIWlucHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZGVvVGltZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIC8vIFNldCB0aGUgc3RhcnQgdG8gbWF0Y2ggdmlkZW8gc28gdGhhdCBzdGFydCBnYXBzIGxhcmdlciB0aGFuIGlucHV0U2FtcGxlRHVyYXRpb24gYXJlIGZpbGxlZCB3aXRoIHNpbGVuY2VcbiAgICAgICAgICBuZXh0QXVkaW9UcyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmICFhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgICAgLy8gV2hlbiBub3Qgc2Vla2luZywgbm90IGxpdmUsIGFuZCBMZXZlbERldGFpbHMuUFRTS25vd24sIHVzZSBmcmFnbWVudCBzdGFydCBhcyBwcmVkaWN0ZWQgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgICBuZXh0QXVkaW9UcyA9IE1hdGgubWF4KDAsIHRpbWVPZmZzZXRNcGVnVFMgLSBpbml0VGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgZnJhZ3MgYXJlIG5vdCBjb250aWd1b3VzIGFuZCBpZiB3ZSBjYW50IHRydXN0IHRpbWUgb2Zmc2V0LCBsZXQncyB1c2UgZmlyc3Qgc2FtcGxlIFBUUyBhcyBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICAgIG5leHRBdWRpb1RzID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGluaXRUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxuICAgICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgICAgLy8gZnJhbWUuXG5cbiAgICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgIHZhciBtYXhBdWRpb0ZyYW1lc0RyaWZ0ID0gdGhpcy5jb25maWcubWF4QXVkaW9GcmFtZXNEcmlmdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5leHRQdHMgPSBuZXh0QXVkaW9UcyArIGluaXRUaW1lOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgICAgICB2YXIgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgICB2YXIgZGVsdGEgPSBwdHMgLSBuZXh0UHRzO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IE1hdGguYWJzKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKTtcblxuICAgICAgICAgIC8vIFdoZW4gcmVtdXhpbmcgd2l0aCB2aWRlbywgaWYgd2UncmUgb3ZlcmxhcHBpbmcgYnkgbW9yZSB0aGFuIGEgZHVyYXRpb24sIGRyb3AgdGhpcyBzYW1wbGUgdG8gc3RheSBpbiBzeW5jXG4gICAgICAgICAgaWYgKGRlbHRhIDw9IC1tYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJiBhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICB0aGlzLndhcm4oXCJBdWRpbyBmcmFtZSBAIFwiICsgKHB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpICsgXCJzIG92ZXJsYXBzIG1hcmtlciBieSBcIiArIE1hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpICsgXCIgbXMuXCIpO1xuICAgICAgICAgICAgICB0aGlzLm5leHRBdWRpb1RzID0gbmV4dEF1ZGlvVHMgPSBwdHMgLSBpbml0VGltZTtcbiAgICAgICAgICAgICAgbmV4dFB0cyA9IHB0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcblxuICAgICAgICAgIC8vIEluc2VydCBtaXNzaW5nIGZyYW1lcyBpZjpcbiAgICAgICAgICAvLyAxOiBXZSdyZSBtb3JlIHRoYW4gbWF4QXVkaW9GcmFtZXNEcmlmdCBmcmFtZSBhd2F5XG4gICAgICAgICAgLy8gMjogTm90IG1vcmUgdGhhbiBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIGF3YXlcbiAgICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxuICAgICAgICAgIC8vIDQ6IHJlbXV4aW5nIHdpdGggdmlkZW8gKHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGVsc2UgaWYgKGRlbHRhID49IG1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmIGR1cmF0aW9uIDwgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiAmJiBhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgICAgICB2YXIgbWlzc2luZyA9IE1hdGgucm91bmQoZGVsdGEgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIEFkanVzdCBuZXh0UHRzIHNvIHRoYXQgc2lsZW50IHNhbXBsZXMgYXJlIGFsaWduZWQgd2l0aCBtZWRpYSBwdHMuIFRoaXMgd2lsbCBwcmV2ZW50IG1lZGlhIHNhbXBsZXMgZnJvbVxuICAgICAgICAgICAgLy8gbGF0ZXIgYmVpbmcgc2hpZnRlZCBpZiBuZXh0UHRzIGlzIGJhc2VkIG9uIHRpbWVPZmZzZXQgYW5kIGRlbHRhIGlzIG5vdCBhIG11bHRpcGxlIG9mIGlucHV0U2FtcGxlRHVyYXRpb24uXG4gICAgICAgICAgICBuZXh0UHRzID0gcHRzIC0gbWlzc2luZyAqIGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICB3aGlsZSAobmV4dFB0cyA8IDAgJiYgbWlzc2luZyAmJiBpbnB1dFNhbXBsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgIG1pc3NpbmctLTtcbiAgICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0QXVkaW9UcyA9IG5leHRBdWRpb1RzID0gbmV4dFB0cyAtIGluaXRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53YXJuKFwiSW5qZWN0aW5nIFwiICsgbWlzc2luZyArIFwiIGF1ZGlvIGZyYW1lcyBAIFwiICsgKChuZXh0UHRzIC0gaW5pdFRpbWUpIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMykgKyBcInMgZHVlIHRvIFwiICsgTWF0aC5yb3VuZCgxMDAwICogZGVsdGEgLyBpbnB1dFRpbWVTY2FsZSkgKyBcIiBtcyBnYXAuXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5wYXJzZWRDb2RlYyB8fCB0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIGxhc3QgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBzYW1wbGUudW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwge1xuICAgICAgICAgICAgICAgIHVuaXQ6IGZpbGxGcmFtZSxcbiAgICAgICAgICAgICAgICBwdHM6IG5leHRQdHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzYW1wbGUucHRzID0gbmV4dFB0cztcbiAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdFBUUyA9IG51bGw7XG4gICAgICB2YXIgbGFzdFBUUyA9IG51bGw7XG4gICAgICB2YXIgbWRhdDtcbiAgICAgIHZhciBtZGF0U2l6ZSA9IDA7XG4gICAgICB2YXIgc2FtcGxlTGVuZ3RoID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzYW1wbGVMZW5ndGgtLSkge1xuICAgICAgICBtZGF0U2l6ZSArPSBpbnB1dFNhbXBsZXNbc2FtcGxlTGVuZ3RoXS51bml0LmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfajIgPSAwLCBfbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDsgX2oyIDwgX25iU2FtcGxlczsgX2oyKyspIHtcbiAgICAgICAgdmFyIGF1ZGlvU2FtcGxlID0gaW5wdXRTYW1wbGVzW19qMl07XG4gICAgICAgIHZhciB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgICAgdmFyIF9wdHMyID0gYXVkaW9TYW1wbGUucHRzO1xuICAgICAgICBpZiAobGFzdFBUUyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHNhbXBsZSB0byB0aGUgXCJyZWFsXCIgZHVyYXRpb247IHRoZSBQVFMgZGlmZiB3aXRoXG4gICAgICAgICAgLy8gdGhlIHByZXZpb3VzIHNhbXBsZVxuICAgICAgICAgIHZhciBwcmV2U2FtcGxlID0gb3V0cHV0U2FtcGxlc1tfajIgLSAxXTtcbiAgICAgICAgICBwcmV2U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgoX3B0czIgLSBsYXN0UFRTKSAvIHNjYWxlRmFjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29udGlndW91cyAmJiB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXG4gICAgICAgICAgICBfcHRzMiA9IG5leHRBdWRpb1RzICsgaW5pdFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzXG4gICAgICAgICAgZmlyc3RQVFMgPSBfcHRzMjtcbiAgICAgICAgICBpZiAobWRhdFNpemUgPiAwKSB7XG4gICAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgICAgbWRhdFNpemUgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsXG4gICAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgYnl0ZXM6IG1kYXRTaXplLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogXCJmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCBcIiArIG1kYXRTaXplXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcbiAgICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gYXVkaW8gc2FtcGxlc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgICB2YXIgdW5pdExlbiA9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47XG4gICAgICAgIC8vIERlZmF1bHQgdGhlIHNhbXBsZSdzIGR1cmF0aW9uIHRvIHRoZSBjb21wdXRlZCBtcDRTYW1wbGVEdXJhdGlvbiwgd2hpY2ggd2lsbCBlaXRoZXIgYmUgMTAyNCBmb3IgQUFDIG9yIDExNTIgZm9yIE1QRUdcbiAgICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIDEgc2FtcGxlLCB0aGlzIHdpbGwgYmUgdGhlIGR1cmF0aW9uLiBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCB0aGUgZHVyYXRpb25cbiAgICAgICAgLy8gYmVjb21lcyB0aGUgUFRTIGRpZmYgd2l0aCB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICAgIG91dHB1dFNhbXBsZXMucHVzaChjcmVhdGVNcDRTYW1wbGUodHJ1ZSwgbXA0U2FtcGxlRHVyYXRpb24sIHVuaXRMZW4sIDApKTtcbiAgICAgICAgbGFzdFBUUyA9IF9wdHMyO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBjb3VsZCBlbmQgdXAgd2l0aCBubyBhdWRpbyBzYW1wbGVzIGlmIGFsbCBpbnB1dCBzYW1wbGVzIHdlcmUgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJldmlvdXNseSByZW11eGVkIG9uZXNcbiAgICAgIHZhciBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcbiAgICAgIGlmICghbmJTYW1wbGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIG5leHQgYXVkaW8gc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZHVyYXRpb25cbiAgICAgIHZhciBsYXN0U2FtcGxlID0gb3V0cHV0U2FtcGxlc1tvdXRwdXRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgICAgbmV4dEF1ZGlvVHMgPSBsYXN0UFRTIC0gaW5pdFRpbWU7XG4gICAgICB0aGlzLm5leHRBdWRpb1RzID0gbmV4dEF1ZGlvVHMgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGUuZHVyYXRpb247XG5cbiAgICAgIC8vIFNldCB0aGUgdHJhY2sgc2FtcGxlcyBmcm9tIGlucHV0U2FtcGxlcyB0byBvdXRwdXRTYW1wbGVzIGJlZm9yZSByZW11eGluZ1xuICAgICAgdmFyIG1vb2YgPSByYXdNUEVHID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdFBUUyAvIHNjYWxlRmFjdG9yLCBfZXh0ZW5kcyh7fSwgdHJhY2ssIHtcbiAgICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgICAgfSkpO1xuXG4gICAgICAvLyBDbGVhciB0aGUgdHJhY2sgc2FtcGxlcy4gVGhpcyBhbHNvIGNsZWFycyB0aGUgc2FtcGxlcyBhcnJheSBpbiB0aGUgZGVtdXhlciwgc2luY2UgdGhlIHJlZmVyZW5jZSBpcyBzaGFyZWRcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgIHZhciBzdGFydCA9IChmaXJzdFBUUyAtIGluaXRUaW1lKSAvIGlucHV0VGltZVNjYWxlO1xuICAgICAgdmFyIGVuZCA9IHRoaXMubmV4dEF1ZGlvVHMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICAgIHZhciB0eXBlID0gJ2F1ZGlvJztcbiAgICAgIHZhciBhdWRpb0RhdGEgPSB7XG4gICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICBkYXRhMjogbWRhdCxcbiAgICAgICAgc3RhcnRQVFM6IHN0YXJ0LFxuICAgICAgICBlbmRQVFM6IGVuZCxcbiAgICAgICAgc3RhcnREVFM6IHN0YXJ0LFxuICAgICAgICBlbmREVFM6IGVuZCxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgaGFzQXVkaW86IHRydWUsXG4gICAgICAgIGhhc1ZpZGVvOiBmYWxzZSxcbiAgICAgICAgbmI6IG5iU2FtcGxlc1xuICAgICAgfTtcbiAgICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSB0cnVlO1xuICAgICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBNUDRSZW11eGVyO1xuICB9KExvZ2dlcik7XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVB0cyh2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gICAgdmFyIG9mZnNldDtcbiAgICBpZiAocmVmZXJlbmNlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgICAgLy8gLSAyXjMzXG4gICAgICBvZmZzZXQgPSAtODU4OTkzNDU5MjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gKyAyXjMzXG4gICAgICBvZmZzZXQgPSA4NTg5OTM0NTkyO1xuICAgIH1cbiAgICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxuICAgICAgaWYgZGlmZiBiZXR3ZWVuIHZhbHVlIGFuZCByZWZlcmVuY2UgaXMgYmlnZ2VyIHRoYW4gaGFsZiBvZiB0aGUgYW1wbGl0dWRlICgyXjMyKSB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuICAgIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XG4gICAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kS2V5ZnJhbWVJbmRleChzYW1wbGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc2FtcGxlc1tpXS5rZXkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmdW5jdGlvbiBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyh0cmFjaywgdGltZU9mZnNldCwgaW5pdFBUUywgaW5pdERUUykge1xuICAgIHZhciBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZSwgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICAgICAgc2FtcGxlLmR0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUuZHRzIC0gaW5pdERUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdERUUy50aW1lc2NhbGUsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICB9XG4gICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlczogc2FtcGxlc1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMpIHtcbiAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgICAgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRQVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEucHRzIC0gYi5wdHM7XG4gICAgfSk7XG4gICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlczogc2FtcGxlc1xuICAgIH07XG4gIH1cblxuICB2YXIgUGFzc1Rocm91Z2hSZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9nZ2VyKSB7XG4gICAgZnVuY3Rpb24gUGFzc1Rocm91Z2hSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIGxvZ2dlcikge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfTG9nZ2VyLmNhbGwodGhpcywgJ3Bhc3N0aHJvdWdoLXJlbXV4ZXInLCBsb2dnZXIpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSBmYWxzZTtcbiAgICAgIF90aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgICBfdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgICAgX3RoaXMuaW5pdERhdGEgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5pbml0UFRTID0gbnVsbDtcbiAgICAgIF90aGlzLmluaXRUcmFja3MgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5sYXN0RW5kVGltZSA9IG51bGw7XG4gICAgICBfdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHNMb29zZShQYXNzVGhyb3VnaFJlbXV4ZXIsIF9Mb2dnZXIpO1xuICAgIHZhciBfcHJvdG8gPSBQYXNzVGhyb3VnaFJlbXV4ZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuICAgIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKSB7XG4gICAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTO1xuICAgICAgaWYgKGluaXRQVFMgJiYgZGVmYXVsdEluaXRQVFMpIHtcbiAgICAgICAgaWYgKGluaXRQVFMuYmFzZVRpbWUgPT09IGRlZmF1bHRJbml0UFRTLmJhc2VUaW1lICYmIGluaXRQVFMudGltZXNjYWxlID09PSBkZWZhdWx0SW5pdFBUUy50aW1lc2NhbGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdFBUUyA9IGRlZmF1bHRJbml0UFRTO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0TmV4dFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkZWNyeXB0ZGF0YSkge1xuICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGRlY3J5cHRkYXRhKTtcbiAgICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZUluaXRTZWdtZW50ID0gZnVuY3Rpb24gZ2VuZXJhdGVJbml0U2VnbWVudChpbml0U2VnbWVudCwgZGVjcnlwdGRhdGEpIHtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gdGhpcy5hdWRpb0NvZGVjLFxuICAgICAgICB2aWRlb0NvZGVjID0gdGhpcy52aWRlb0NvZGVjO1xuICAgICAgaWYgKCEoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSkge1xuICAgICAgICB0aGlzLmluaXRUcmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW5pdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRpbml0RGF0YSA9IHRoaXMuaW5pdERhdGEgPSBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSxcbiAgICAgICAgYXVkaW8gPSBfdGhpcyRpbml0RGF0YS5hdWRpbyxcbiAgICAgICAgdmlkZW8gPSBfdGhpcyRpbml0RGF0YS52aWRlbztcbiAgICAgIGlmIChkZWNyeXB0ZGF0YSkge1xuICAgICAgICBwYXRjaEVuY3lwdGlvbkRhdGEoaW5pdFNlZ21lbnQsIGRlY3J5cHRkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlaXRoZXJUcmFjayA9IGF1ZGlvIHx8IHZpZGVvO1xuICAgICAgICBpZiAoZWl0aGVyVHJhY2sgIT0gbnVsbCAmJiBlaXRoZXJUcmFjay5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJJbml0IHNlZ21lbnQgd2l0aCBlbmNyeXB0ZWQgdHJhY2sgd2l0aCBoYXMgbm8ga2V5IChcXFwiXCIgKyBlaXRoZXJUcmFjay5jb2RlYyArIFwiXFxcIikhXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBjb2RlYyBmcm9tIGluaXRTZWdtZW50XG4gICAgICBpZiAoYXVkaW8pIHtcbiAgICAgICAgYXVkaW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWMoYXVkaW8sIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgdmlkZW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWModmlkZW8sIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTywgdGhpcyk7XG4gICAgICB9XG4gICAgICB2YXIgdHJhY2tzID0ge307XG4gICAgICBpZiAoYXVkaW8gJiYgdmlkZW8pIHtcbiAgICAgICAgdHJhY2tzLmF1ZGlvdmlkZW8gPSB7XG4gICAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgICBjb2RlYzogYXVkaW9Db2RlYyArICcsJyArIHZpZGVvQ29kZWMsXG4gICAgICAgICAgc3VwcGxlbWVudGFsOiB2aWRlby5zdXBwbGVtZW50YWwsXG4gICAgICAgICAgZW5jcnlwdGVkOiB2aWRlby5lbmNyeXB0ZWQsXG4gICAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGlkOiAnbWFpbidcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYXVkaW8pIHtcbiAgICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wNCcsXG4gICAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgICAgZW5jcnlwdGVkOiBhdWRpby5lbmNyeXB0ZWQsXG4gICAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGlkOiAnYXVkaW8nXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHZpZGVvKSB7XG4gICAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICAgIGNvZGVjOiB2aWRlb0NvZGVjLFxuICAgICAgICAgIHN1cHBsZW1lbnRhbDogdmlkZW8uc3VwcGxlbWVudGFsLFxuICAgICAgICAgIGVuY3J5cHRlZDogdmlkZW8uZW5jcnlwdGVkLFxuICAgICAgICAgIGluaXRTZWdtZW50OiBpbml0U2VnbWVudCxcbiAgICAgICAgICBpZDogJ21haW4nXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndhcm4oJ2luaXRTZWdtZW50IGRvZXMgbm90IGNvbnRhaW4gbW9vdiBvciB0cmFrIGJveGVzLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdHJhY2tzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbXV4ID0gZnVuY3Rpb24gcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgX2luaXREYXRhLCBfaW5pdERhdGEyO1xuICAgICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFMsXG4gICAgICAgIGxhc3RFbmRUaW1lID0gdGhpcy5sYXN0RW5kVGltZTtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGF1ZGlvOiB1bmRlZmluZWQsXG4gICAgICAgIHZpZGVvOiB1bmRlZmluZWQsXG4gICAgICAgIHRleHQ6IHRleHRUcmFjayxcbiAgICAgICAgaWQzOiBpZDNUcmFjayxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgc2V0IGEgbGFzdEVuZERUUywgb3IgaXQgd2FzIHJlc2V0LCBzZXQgaXQgdG8gdGhlIHByb3ZpZGVkIHRpbWVPZmZzZXQuIFdlIHdhbnQgdG8gdXNlIHRoZVxuICAgICAgLy8gbGFzdEVuZERUUyBvdmVyIHRpbWVPZmZzZXQgd2hlbmV2ZXIgcG9zc2libGU7IGR1cmluZyBwcm9ncmVzc2l2ZSBwbGF5YmFjaywgdGhlIG1lZGlhIHNvdXJjZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgIC8vIHRoZSBtZWRpYSBkdXJhdGlvbiAod2hpY2ggaXMgd2hhdCB0aW1lT2Zmc2V0IGlzIHByb3ZpZGVkIGFzKSBiZWZvcmUgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBuZXh0IGNodW5rLlxuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihsYXN0RW5kVGltZSkpIHtcbiAgICAgICAgbGFzdEVuZFRpbWUgPSB0aGlzLmxhc3RFbmRUaW1lID0gdGltZU9mZnNldCB8fCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgYmluYXJ5IHNlZ21lbnQgZGF0YSBpcyBhZGRlZCB0byB0aGUgdmlkZW9UcmFjayBpbiB0aGUgbXA0ZGVtdXhlci4gV2UgZG9uJ3QgY2hlY2sgdG8gc2VlIGlmIHRoZSBkYXRhIGlzIG9ubHlcbiAgICAgIC8vIGF1ZGlvIG9yIHZpZGVvIChvciBib3RoKTsgYWRkaW5nIGl0IHRvIHZpZGVvIHdhcyBhbiBhcmJpdHJhcnkgY2hvaWNlLlxuICAgICAgdmFyIGRhdGEgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5pdFNlZ21lbnQgPSB7XG4gICAgICAgIGluaXRQVFM6IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZXNjYWxlOiB1bmRlZmluZWQsXG4gICAgICAgIHRyYWNrSWQ6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgICBpZiAoISgoX2luaXREYXRhID0gaW5pdERhdGEpICE9IG51bGwgJiYgX2luaXREYXRhLmxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUluaXRTZWdtZW50KGRhdGEpO1xuICAgICAgICBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgICB9XG4gICAgICBpZiAoISgoX2luaXREYXRhMiA9IGluaXREYXRhKSAhPSBudWxsICYmIF9pbml0RGF0YTIubGVuZ3RoKSkge1xuICAgICAgICAvLyBXZSBjYW4ndCByZW11eCBpZiB0aGUgaW5pdFNlZ21lbnQgY291bGQgbm90IGJlIGdlbmVyYXRlZFxuICAgICAgICB0aGlzLndhcm4oJ0ZhaWxlZCB0byBnZW5lcmF0ZSBpbml0U2VnbWVudC4nKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVtaXRJbml0U2VnbWVudCkge1xuICAgICAgICBpbml0U2VnbWVudC50cmFja3MgPSB0aGlzLmluaXRUcmFja3M7XG4gICAgICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHJhY2tTYW1wbGVEYXRhID0gZ2V0U2FtcGxlRGF0YShkYXRhLCBpbml0RGF0YSwgdGhpcyk7XG4gICAgICB2YXIgYXVkaW9TYW1wbGVUaW1lc3RhbXBzID0gaW5pdERhdGEuYXVkaW8gPyB0cmFja1NhbXBsZURhdGFbaW5pdERhdGEuYXVkaW8uaWRdIDogbnVsbDtcbiAgICAgIHZhciB2aWRlb1NhbXBsZVRpbWVzdGFtcHMgPSBpbml0RGF0YS52aWRlbyA/IHRyYWNrU2FtcGxlRGF0YVtpbml0RGF0YS52aWRlby5pZF0gOiBudWxsO1xuICAgICAgdmFyIHZpZGVvU3RhcnRUaW1lID0gdG9TdGFydEVuZE9yRGVmYXVsdCh2aWRlb1NhbXBsZVRpbWVzdGFtcHMsIEluZmluaXR5KTtcbiAgICAgIHZhciBhdWRpb1N0YXJ0VGltZSA9IHRvU3RhcnRFbmRPckRlZmF1bHQoYXVkaW9TYW1wbGVUaW1lc3RhbXBzLCBJbmZpbml0eSk7XG4gICAgICB2YXIgdmlkZW9FbmRUaW1lID0gdG9TdGFydEVuZE9yRGVmYXVsdCh2aWRlb1NhbXBsZVRpbWVzdGFtcHMsIDAsIHRydWUpO1xuICAgICAgdmFyIGF1ZGlvRW5kVGltZSA9IHRvU3RhcnRFbmRPckRlZmF1bHQoYXVkaW9TYW1wbGVUaW1lc3RhbXBzLCAwLCB0cnVlKTtcbiAgICAgIHZhciBkZWNvZGVUaW1lID0gdGltZU9mZnNldDtcbiAgICAgIHZhciBkdXJhdGlvbiA9IDA7XG4gICAgICB2YXIgc3luY09uQXVkaW8gPSBhdWRpb1NhbXBsZVRpbWVzdGFtcHMgJiYgKCF2aWRlb1NhbXBsZVRpbWVzdGFtcHMgfHwgIWluaXRQVFMgJiYgYXVkaW9TdGFydFRpbWUgPCB2aWRlb1N0YXJ0VGltZSB8fCBpbml0UFRTICYmIGluaXRQVFMudHJhY2tJZCA9PT0gaW5pdERhdGEuYXVkaW8uaWQpO1xuICAgICAgdmFyIGJhc2VPZmZzZXRTYW1wbGVzID0gc3luY09uQXVkaW8gPyBhdWRpb1NhbXBsZVRpbWVzdGFtcHMgOiB2aWRlb1NhbXBsZVRpbWVzdGFtcHM7XG4gICAgICBpZiAoYmFzZU9mZnNldFNhbXBsZXMpIHtcbiAgICAgICAgdmFyIHRpbWVzY2FsZSA9IGJhc2VPZmZzZXRTYW1wbGVzLnRpbWVzY2FsZTtcbiAgICAgICAgdmFyIGJhc2VUaW1lID0gYmFzZU9mZnNldFNhbXBsZXMuc3RhcnQgLSB0aW1lT2Zmc2V0ICogdGltZXNjYWxlO1xuICAgICAgICB2YXIgdHJhY2tJZCA9IHN5bmNPbkF1ZGlvID8gaW5pdERhdGEuYXVkaW8uaWQgOiBpbml0RGF0YS52aWRlby5pZDtcbiAgICAgICAgZGVjb2RlVGltZSA9IGJhc2VPZmZzZXRTYW1wbGVzLnN0YXJ0IC8gdGltZXNjYWxlO1xuICAgICAgICBkdXJhdGlvbiA9IHN5bmNPbkF1ZGlvID8gYXVkaW9FbmRUaW1lIC0gYXVkaW9TdGFydFRpbWUgOiB2aWRlb0VuZFRpbWUgLSB2aWRlb1N0YXJ0VGltZTtcbiAgICAgICAgaWYgKChhY2N1cmF0ZVRpbWVPZmZzZXQgfHwgIWluaXRQVFMpICYmIChpc0ludmFsaWRJbml0UHRzKGluaXRQVFMsIGRlY29kZVRpbWUsIHRpbWVPZmZzZXQsIGR1cmF0aW9uKSB8fCB0aW1lc2NhbGUgIT09IGluaXRQVFMudGltZXNjYWxlKSkge1xuICAgICAgICAgIGlmIChpbml0UFRTKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJUaW1lc3RhbXBzIGF0IHBsYXlsaXN0IHRpbWU6IFwiICsgKGFjY3VyYXRlVGltZU9mZnNldCA/ICcnIDogJ34nKSArIHRpbWVPZmZzZXQgKyBcIiBcIiArIGJhc2VUaW1lIC8gdGltZXNjYWxlICsgXCIgIT0gaW5pdFBUUzogXCIgKyBpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGUgKyBcIiAoXCIgKyBpbml0UFRTLmJhc2VUaW1lICsgXCIvXCIgKyBpbml0UFRTLnRpbWVzY2FsZSArIFwiKSB0cmFja0lkOiBcIiArIGluaXRQVFMudHJhY2tJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubG9nKFwiRm91bmQgaW5pdFBUUyBhdCBwbGF5bGlzdCB0aW1lOiBcIiArIHRpbWVPZmZzZXQgKyBcIiBvZmZzZXQ6IFwiICsgKGRlY29kZVRpbWUgLSB0aW1lT2Zmc2V0KSArIFwiIChcIiArIGJhc2VUaW1lICsgXCIvXCIgKyB0aW1lc2NhbGUgKyBcIikgdHJhY2tJZDogXCIgKyB0cmFja0lkKTtcbiAgICAgICAgICBpbml0UFRTID0gbnVsbDtcbiAgICAgICAgICBpbml0U2VnbWVudC5pbml0UFRTID0gYmFzZVRpbWU7XG4gICAgICAgICAgaW5pdFNlZ21lbnQudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgICAgIGluaXRTZWdtZW50LnRyYWNrSWQgPSB0cmFja0lkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndhcm4oXCJObyBhdWRpbyBvciB2aWRlbyBzYW1wbGVzIGZvdW5kIGZvciBpbml0UFRTIGF0IHBsYXlsaXN0IHRpbWU6IFwiICsgdGltZU9mZnNldCk7XG4gICAgICB9XG4gICAgICBpZiAoIWluaXRQVFMpIHtcbiAgICAgICAgaWYgKCFpbml0U2VnbWVudC50aW1lc2NhbGUgfHwgaW5pdFNlZ21lbnQudHJhY2tJZCA9PT0gdW5kZWZpbmVkIHx8IGluaXRTZWdtZW50LmluaXRQVFMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMud2FybignQ291bGQgbm90IHNldCBpbml0UFRTJyk7XG4gICAgICAgICAgaW5pdFNlZ21lbnQuaW5pdFBUUyA9IGRlY29kZVRpbWU7XG4gICAgICAgICAgaW5pdFNlZ21lbnQudGltZXNjYWxlID0gMTtcbiAgICAgICAgICBpbml0U2VnbWVudC50cmFja0lkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFBUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdFNlZ21lbnQuaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IGluaXRTZWdtZW50LnRpbWVzY2FsZSxcbiAgICAgICAgICB0cmFja0lkOiBpbml0U2VnbWVudC50cmFja0lkXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0U2VnbWVudC5pbml0UFRTID0gaW5pdFBUUy5iYXNlVGltZTtcbiAgICAgICAgaW5pdFNlZ21lbnQudGltZXNjYWxlID0gaW5pdFBUUy50aW1lc2NhbGU7XG4gICAgICAgIGluaXRTZWdtZW50LnRyYWNrSWQgPSBpbml0UFRTLnRyYWNrSWQ7XG4gICAgICB9XG4gICAgICB2YXIgc3RhcnRUaW1lID0gZGVjb2RlVGltZSAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICAgIHZhciBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICAgIHRoaXMubGFzdEVuZFRpbWUgPSBlbmRUaW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YXJuKCdEdXJhdGlvbiBwYXJzZWQgZnJvbSBtcDQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzQXVkaW8gPSAhIWluaXREYXRhLmF1ZGlvO1xuICAgICAgdmFyIGhhc1ZpZGVvID0gISFpbml0RGF0YS52aWRlbztcbiAgICAgIHZhciB0eXBlID0gJyc7XG4gICAgICBpZiAoaGFzQXVkaW8pIHtcbiAgICAgICAgdHlwZSArPSAnYXVkaW8nO1xuICAgICAgfVxuICAgICAgaWYgKGhhc1ZpZGVvKSB7XG4gICAgICAgIHR5cGUgKz0gJ3ZpZGVvJztcbiAgICAgIH1cbiAgICAgIHZhciBlbmNyeXB0ZWQgPSAoaW5pdERhdGEuYXVkaW8gPyBpbml0RGF0YS5hdWRpby5lbmNyeXB0ZWQgOiBmYWxzZSkgfHwgKGluaXREYXRhLnZpZGVvID8gaW5pdERhdGEudmlkZW8uZW5jcnlwdGVkIDogZmFsc2UpO1xuICAgICAgdmFyIHRyYWNrID0ge1xuICAgICAgICBkYXRhMTogZGF0YSxcbiAgICAgICAgc3RhcnRQVFM6IHN0YXJ0VGltZSxcbiAgICAgICAgc3RhcnREVFM6IHN0YXJ0VGltZSxcbiAgICAgICAgZW5kUFRTOiBlbmRUaW1lLFxuICAgICAgICBlbmREVFM6IGVuZFRpbWUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGhhc0F1ZGlvOiBoYXNBdWRpbyxcbiAgICAgICAgaGFzVmlkZW86IGhhc1ZpZGVvLFxuICAgICAgICBuYjogMSxcbiAgICAgICAgZHJvcHBlZDogMCxcbiAgICAgICAgZW5jcnlwdGVkOiBlbmNyeXB0ZWRcbiAgICAgIH07XG4gICAgICByZXN1bHQuYXVkaW8gPSBoYXNBdWRpbyAmJiAhaGFzVmlkZW8gPyB0cmFjayA6IHVuZGVmaW5lZDtcbiAgICAgIHJlc3VsdC52aWRlbyA9IGhhc1ZpZGVvID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgdmlkZW9TYW1wbGVDb3VudCA9IHZpZGVvU2FtcGxlVGltZXN0YW1wcyA9PSBudWxsID8gdm9pZCAwIDogdmlkZW9TYW1wbGVUaW1lc3RhbXBzLnNhbXBsZUNvdW50O1xuICAgICAgaWYgKHZpZGVvU2FtcGxlQ291bnQpIHtcbiAgICAgICAgdmFyIGZpcnN0S2V5RnJhbWUgPSB2aWRlb1NhbXBsZVRpbWVzdGFtcHMua2V5RnJhbWVJbmRleDtcbiAgICAgICAgdmFyIGluZGVwZW5kZW50ID0gZmlyc3RLZXlGcmFtZSAhPT0gLTE7XG4gICAgICAgIHRyYWNrLm5iID0gdmlkZW9TYW1wbGVDb3VudDtcbiAgICAgICAgdHJhY2suZHJvcHBlZCA9IGZpcnN0S2V5RnJhbWUgPT09IDAgfHwgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA/IDAgOiBpbmRlcGVuZGVudCA/IGZpcnN0S2V5RnJhbWUgOiB2aWRlb1NhbXBsZUNvdW50O1xuICAgICAgICB0cmFjay5pbmRlcGVuZGVudCA9IGluZGVwZW5kZW50O1xuICAgICAgICB0cmFjay5maXJzdEtleUZyYW1lID0gZmlyc3RLZXlGcmFtZTtcbiAgICAgICAgaWYgKGluZGVwZW5kZW50ICYmIHZpZGVvU2FtcGxlVGltZXN0YW1wcy5rZXlGcmFtZVN0YXJ0KSB7XG4gICAgICAgICAgdHJhY2suZmlyc3RLZXlGcmFtZVBUUyA9ICh2aWRlb1NhbXBsZVRpbWVzdGFtcHMua2V5RnJhbWVTdGFydCAtIGluaXRQVFMuYmFzZVRpbWUpIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzVmlkZW9Db250aWd1b3VzKSB7XG4gICAgICAgICAgcmVzdWx0LmluZGVwZW5kZW50ID0gaW5kZXBlbmRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyB8fCAodGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGluZGVwZW5kZW50KTtcbiAgICAgICAgaWYgKHRyYWNrLmRyb3BwZWQpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJmbXA0IGRvZXMgbm90IHN0YXJ0IHdpdGggSURSOiBmaXJzdElEUiBcIiArIGZpcnN0S2V5RnJhbWUgKyBcIi9cIiArIHZpZGVvU2FtcGxlQ291bnQgKyBcIiBkcm9wcGVkOiBcIiArIHRyYWNrLmRyb3BwZWQgKyBcIiBzdGFydDogXCIgKyAodHJhY2suZmlyc3RLZXlGcmFtZVBUUyB8fCAnTkEnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5pbml0U2VnbWVudCA9IGluaXRTZWdtZW50O1xuICAgICAgcmVzdWx0LmlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTLCBpbml0UFRTKTtcbiAgICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnRleHQgPSBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyh0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBQYXNzVGhyb3VnaFJlbXV4ZXI7XG4gIH0oTG9nZ2VyKTtcbiAgZnVuY3Rpb24gdG9TdGFydEVuZE9yRGVmYXVsdCh0cmFja1RpbWVzLCBkZWZhdWx0VmFsdWUsIGVuZCkge1xuICAgIGlmIChlbmQgPT09IHZvaWQgMCkge1xuICAgICAgZW5kID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAodHJhY2tUaW1lcyA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tUaW1lcy5zdGFydCkgIT09IHVuZGVmaW5lZCA/ICh0cmFja1RpbWVzLnN0YXJ0ICsgKGVuZCA/IHRyYWNrVGltZXMuZHVyYXRpb24gOiAwKSkgLyB0cmFja1RpbWVzLnRpbWVzY2FsZSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBpc0ludmFsaWRJbml0UHRzKGluaXRQVFMsIHN0YXJ0RFRTLCB0aW1lT2Zmc2V0LCBkdXJhdGlvbikge1xuICAgIGlmIChpbml0UFRTID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSW5pdFBUUyBpcyBpbnZhbGlkIHdoZW4gZGlzdGFuY2UgZnJvbSBwcm9ncmFtIHdvdWxkIGJlIG1vcmUgdGhhbiBzZWdtZW50IGR1cmF0aW9uIG9yIGEgbWluaW11bSBvZiBvbmUgc2Vjb25kXG4gICAgdmFyIG1pbkR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIDEpO1xuICAgIHZhciBzdGFydFRpbWUgPSBzdGFydERUUyAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICByZXR1cm4gTWF0aC5hYnMoc3RhcnRUaW1lIC0gdGltZU9mZnNldCkgPiBtaW5EdXJhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBnZXRQYXJzZWRUcmFja0NvZGVjKHRyYWNrLCB0eXBlLCBsb2dnZXIpIHtcbiAgICB2YXIgcGFyc2VkQ29kZWMgPSB0cmFjay5jb2RlYztcbiAgICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMubGVuZ3RoID4gNCkge1xuICAgICAgcmV0dXJuIHBhcnNlZENvZGVjO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKSB7XG4gICAgICBpZiAocGFyc2VkQ29kZWMgPT09ICdlYy0zJyB8fCBwYXJzZWRDb2RlYyA9PT0gJ2FjLTMnIHx8IHBhcnNlZENvZGVjID09PSAnYWxhYycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZENvZGVjO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZENvZGVjID09PSAnZkxhQycgfHwgcGFyc2VkQ29kZWMgPT09ICdPcHVzJykge1xuICAgICAgICAvLyBPcHRpbmcgbm90IHRvIGdldCBgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlYCBmcm9tIHBsYXllciBjb25maWcgZm9yIGlzU3VwcG9ydGVkKCkgY2hlY2sgZm9yIHNpbXBsaWNpdHlcbiAgICAgICAgdmFyIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShwYXJzZWRDb2RlYywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci53YXJuKFwiVW5oYW5kbGVkIGF1ZGlvIGNvZGVjIFxcXCJcIiArIHBhcnNlZENvZGVjICsgXCJcXFwiIGluIG1wNCBNQVBcIik7XG4gICAgICByZXR1cm4gcGFyc2VkQ29kZWMgfHwgJ21wNGEnO1xuICAgIH1cbiAgICAvLyBQcm92aWRlIGRlZmF1bHRzIGJhc2VkIG9uIGNvZGVjIHR5cGVcbiAgICAvLyBUaGlzIGFsbG93cyBmb3Igc29tZSBwbGF5YmFjayBvZiBzb21lIGZtcDQgcGxheWxpc3RzIHdpdGhvdXQgQ09ERUNTIGRlZmluZWQgaW4gbWFuaWZlc3RcbiAgICBsb2dnZXIud2FybihcIlVuaGFuZGxlZCB2aWRlbyBjb2RlYyBcXFwiXCIgKyBwYXJzZWRDb2RlYyArIFwiXFxcIiBpbiBtcDQgTUFQXCIpO1xuICAgIHJldHVybiBwYXJzZWRDb2RlYyB8fCAnYXZjMSc7XG4gIH1cblxuICB2YXIgbm93O1xuICAvLyBwZXJmb3JtYW5jZS5ub3coKSBub3QgYXZhaWxhYmxlIG9uIFdlYldvcmtlciwgYXQgbGVhc3Qgb24gU2FmYXJpIERlc2t0b3BcbiAgdHJ5IHtcbiAgICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBub3cgPSBEYXRlLm5vdztcbiAgfVxuICB2YXIgbXV4Q29uZmlnID0gW3tcbiAgICBkZW11eDogTVA0RGVtdXhlcixcbiAgICByZW11eDogUGFzc1Rocm91Z2hSZW11eGVyXG4gIH0sIHtcbiAgICBkZW11eDogVFNEZW11eGVyLFxuICAgIHJlbXV4OiBNUDRSZW11eGVyXG4gIH0sIHtcbiAgICBkZW11eDogQUFDRGVtdXhlcixcbiAgICByZW11eDogTVA0UmVtdXhlclxuICB9LCB7XG4gICAgZGVtdXg6IE1QM0RlbXV4ZXIsXG4gICAgcmVtdXg6IE1QNFJlbXV4ZXJcbiAgfV07XG4gIHtcbiAgICBtdXhDb25maWcuc3BsaWNlKDIsIDAsIHtcbiAgICAgIGRlbXV4OiBBQzNEZW11eGVyLFxuICAgICAgcmVtdXg6IE1QNFJlbXV4ZXJcbiAgICB9KTtcbiAgfVxuICB2YXIgVHJhbnNtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNtdXhlcihvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IsIGlkLCBsb2dnZXIpIHtcbiAgICAgIHRoaXMuYXN5bmNSZXN1bHQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZGVtdXhlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMucmVtdXhlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5wcm9iZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgdGhpcy50cmFuc211eENvbmZpZyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFRyYW5zbXV4ZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5jb25maWd1cmUgPSBmdW5jdGlvbiBjb25maWd1cmUodHJhbnNtdXhDb25maWcpIHtcbiAgICAgIHRoaXMudHJhbnNtdXhDb25maWcgPSB0cmFuc211eENvbmZpZztcbiAgICAgIGlmICh0aGlzLmRlY3J5cHRlcikge1xuICAgICAgICB0aGlzLmRlY3J5cHRlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnB1c2ggPSBmdW5jdGlvbiBwdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBjaHVua01ldGEsIHN0YXRlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIHN0YXRzID0gY2h1bmtNZXRhLnRyYW5zbXV4aW5nO1xuICAgICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgICB2YXIgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgIHZhciBjdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICAgIHRyYW5zbXV4Q29uZmlnID0gdGhpcy50cmFuc211eENvbmZpZztcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gc3RhdGU7XG4gICAgICB9XG4gICAgICB2YXIgX3JlZiA9IHN0YXRlIHx8IGN1cnJlbnRUcmFuc211eFN0YXRlLFxuICAgICAgICBjb250aWd1b3VzID0gX3JlZi5jb250aWd1b3VzLFxuICAgICAgICBkaXNjb250aW51aXR5ID0gX3JlZi5kaXNjb250aW51aXR5LFxuICAgICAgICB0cmFja1N3aXRjaCA9IF9yZWYudHJhY2tTd2l0Y2gsXG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCA9IF9yZWYuYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgICB0aW1lT2Zmc2V0ID0gX3JlZi50aW1lT2Zmc2V0LFxuICAgICAgICBpbml0U2VnbWVudENoYW5nZSA9IF9yZWYuaW5pdFNlZ21lbnRDaGFuZ2U7XG4gICAgICB2YXIgYXVkaW9Db2RlYyA9IHRyYW5zbXV4Q29uZmlnLmF1ZGlvQ29kZWMsXG4gICAgICAgIHZpZGVvQ29kZWMgPSB0cmFuc211eENvbmZpZy52aWRlb0NvZGVjLFxuICAgICAgICBkZWZhdWx0SW5pdFB0cyA9IHRyYW5zbXV4Q29uZmlnLmRlZmF1bHRJbml0UHRzLFxuICAgICAgICBkdXJhdGlvbiA9IHRyYW5zbXV4Q29uZmlnLmR1cmF0aW9uLFxuICAgICAgICBpbml0U2VnbWVudERhdGEgPSB0cmFuc211eENvbmZpZy5pbml0U2VnbWVudERhdGE7XG4gICAgICB2YXIga2V5RGF0YSA9IGdldEVuY3J5cHRpb25UeXBlKHVpbnREYXRhLCBkZWNyeXB0ZGF0YSk7XG4gICAgICBpZiAoa2V5RGF0YSAmJiBpc0Z1bGxTZWdtZW50RW5jcnlwdGlvbihrZXlEYXRhLm1ldGhvZCkpIHtcbiAgICAgICAgdmFyIGRlY3J5cHRlciA9IHRoaXMuZ2V0RGVjcnlwdGVyKCk7XG4gICAgICAgIHZhciBhZXNNb2RlID0gZ2V0QWVzTW9kZUZyb21GdWxsU2VnbWVudE1ldGhvZChrZXlEYXRhLm1ldGhvZCk7XG5cbiAgICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBzeW5jaHJvbm91czsgd2ViQ3J5cHRvIGlzIG5vdFxuICAgICAgICBpZiAoZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgICAgICAgICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICAgICAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLnNvZnR3YXJlRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlciwgYWVzTW9kZSk7XG4gICAgICAgICAgLy8gRm9yIExvdy1MYXRlbmN5IEhMUyBQYXJ0cywgZGVjcnlwdCBpbiBwbGFjZSwgc2luY2UgcGFydCBwYXJzaW5nIGlzIGV4cGVjdGVkIG9uIHB1c2ggcHJvZ3Jlc3NcbiAgICAgICAgICB2YXIgbG9hZGluZ1BhcnRzID0gY2h1bmtNZXRhLnBhcnQgPiAtMTtcbiAgICAgICAgICBpZiAobG9hZGluZ1BhcnRzKSB7XG4gICAgICAgICAgICB2YXIgX2RhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgICAgICAgIGRlY3J5cHRlZERhdGEgPSBfZGF0YSA/IF9kYXRhLmJ1ZmZlciA6IF9kYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eVJlc3VsdChjaHVua01ldGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXN5bmNSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBkZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlciwgYWVzTW9kZSkudGhlbihmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyBwdXNoIGhlcmUgaXMgaW1wb3J0YW50OyBpZiBmbHVzaCgpIGlzIGNhbGxlZCB3aGlsZSB0aGlzIGlzIHN0aWxsIHJlc29sdmluZywgdGhpcyBlbnN1cmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkZWNyeXB0ZWQgZGF0YSBoYXMgYmVlbiB0cmFuc211eGVkXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMucHVzaChkZWNyeXB0ZWREYXRhLCBudWxsLCBjaHVua01ldGEpO1xuICAgICAgICAgICAgX3RoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0aW9uUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJlc2V0TXV4ZXJzID0gdGhpcy5uZWVkc1Byb2JpbmcoZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpO1xuICAgICAgaWYgKHJlc2V0TXV4ZXJzKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcih1aW50RGF0YSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJbdHJhbnNtdXhlcl0gXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgICAgIHJldHVybiBlbXB0eVJlc3VsdChjaHVua01ldGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCB8fCBpbml0U2VnbWVudENoYW5nZSB8fCByZXNldE11eGVycykge1xuICAgICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbiwgZGVjcnlwdGRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UgfHwgcmVzZXRNdXhlcnMpIHtcbiAgICAgICAgdGhpcy5yZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgICAgfVxuICAgICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy50cmFuc211eCh1aW50RGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IGlzUHJvbWlzZShyZXN1bHQpO1xuICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgICBjdXJyZW50U3RhdGUuY29udGlndW91cyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUuZGlzY29udGludWl0eSA9IGZhbHNlO1xuICAgICAgY3VycmVudFN0YXRlLnRyYWNrU3dpdGNoID0gZmFsc2U7XG4gICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIER1ZSB0byBkYXRhIGNhY2hpbmcsIGZsdXNoIGNhbGxzIGNhbiBwcm9kdWNlIG1vcmUgdGhhbiBvbmUgVHJhbnNtdXhlclJlc3VsdCAoaGVuY2UgdGhlIEFycmF5IHR5cGUpXG4gICAgO1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKGNodW5rTWV0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgICBzdGF0cy5leGVjdXRlU3RhcnQgPSBub3coKTtcbiAgICAgIHZhciBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcixcbiAgICAgICAgY3VycmVudFRyYW5zbXV4U3RhdGUgPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlLFxuICAgICAgICBkZWNyeXB0aW9uUHJvbWlzZSA9IHRoaXMuZGVjcnlwdGlvblByb21pc2U7XG4gICAgICBpZiAoZGVjcnlwdGlvblByb21pc2UpIHtcbiAgICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IHRydWU7XG4gICAgICAgIC8vIFVwb24gcmVzb2x1dGlvbiwgdGhlIGRlY3J5cHRpb24gcHJvbWlzZSBjYWxscyBwdXNoKCkgYW5kIHJldHVybnMgaXRzIFRyYW5zbXV4ZXJSZXN1bHQgdXAgdGhlIHN0YWNrLiBUaGVyZWZvcmVcbiAgICAgICAgLy8gb25seSBmbHVzaGluZyBpcyByZXF1aXJlZCBmb3IgYXN5bmMgZGVjcnlwdGlvblxuICAgICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5mbHVzaChjaHVua01ldGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFuc211eFJlc3VsdHMgPSBbXTtcbiAgICAgIHZhciB0aW1lT2Zmc2V0ID0gY3VycmVudFRyYW5zbXV4U3RhdGUudGltZU9mZnNldDtcbiAgICAgIGlmIChkZWNyeXB0ZXIpIHtcbiAgICAgICAgLy8gVGhlIGRlY3J5cHRlciBtYXkgaGF2ZSBkYXRhIGNhY2hlZCwgd2hpY2ggbmVlZHMgdG8gYmUgZGVtdXhlZC4gSW4gdGhpcyBjYXNlIHdlJ2xsIGhhdmUgdHdvIFRyYW5zbXV4UmVzdWx0c1xuICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGNhc2UgdGhhdCB3ZSByZWNlaXZlIG9ubHkgMSBwdXNoIGNhbGwgZm9yIGEgc2VnbWVudCAoZWl0aGVyIGZvciBub24tcHJvZ3Jlc3NpdmUgZG93bmxvYWRzLFxuICAgICAgICAvLyBvciBmb3IgcHJvZ3Jlc3NpdmUgZG93bmxvYWRzIHdpdGggc21hbGwgc2VnbWVudHMpXG4gICAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLmZsdXNoKCk7XG4gICAgICAgIGlmIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgLy8gUHVzaCBhbHdheXMgcmV0dXJucyBhIFRyYW5zbXV4ZXJSZXN1bHQgaWYgZGVjcnlwdGRhdGEgaXMgbnVsbFxuICAgICAgICAgIHRyYW5zbXV4UmVzdWx0cy5wdXNoKHRoaXMucHVzaChkZWNyeXB0ZWREYXRhLmJ1ZmZlciwgbnVsbCwgY2h1bmtNZXRhKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuICAgICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICAgIC8vIElmIHByb2JpbmcgZmFpbGVkLCB0aGVuIEhscy5qcyBoYXMgYmVlbiBnaXZlbiBjb250ZW50IGl0cyBub3QgYWJsZSB0byBoYW5kbGVcbiAgICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgICB2YXIgZW1wdHlSZXN1bHRzID0gW2VtcHR5UmVzdWx0KGNodW5rTWV0YSldO1xuICAgICAgICBpZiAodGhpcy5hc3luY1Jlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW1wdHlSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHRzO1xuICAgICAgfVxuICAgICAgdmFyIGRlbXV4UmVzdWx0T3JQcm9taXNlID0gZGVtdXhlci5mbHVzaCh0aW1lT2Zmc2V0KTtcbiAgICAgIGlmIChpc1Byb21pc2UoZGVtdXhSZXN1bHRPclByb21pc2UpKSB7XG4gICAgICAgIHRoaXMuYXN5bmNSZXN1bHQgPSB0cnVlO1xuICAgICAgICAvLyBEZWNyeXB0IGZpbmFsIFNBTVBMRS1BRVMgc2FtcGxlc1xuICAgICAgICByZXR1cm4gZGVtdXhSZXN1bHRPclByb21pc2UudGhlbihmdW5jdGlvbiAoZGVtdXhSZXN1bHQpIHtcbiAgICAgICAgICBfdGhpczIuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpO1xuICAgICAgICAgIHJldHVybiB0cmFuc211eFJlc3VsdHM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5mbHVzaFJlbXV4KHRyYW5zbXV4UmVzdWx0cywgZGVtdXhSZXN1bHRPclByb21pc2UsIGNodW5rTWV0YSk7XG4gICAgICBpZiAodGhpcy5hc3luY1Jlc3VsdCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRyYW5zbXV4UmVzdWx0cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoUmVtdXggPSBmdW5jdGlvbiBmbHVzaFJlbXV4KHRyYW5zbXV4UmVzdWx0cywgZGVtdXhSZXN1bHQsIGNodW5rTWV0YSkge1xuICAgICAgdmFyIGF1ZGlvVHJhY2sgPSBkZW11eFJlc3VsdC5hdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrID0gZGVtdXhSZXN1bHQudmlkZW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2sgPSBkZW11eFJlc3VsdC5pZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrID0gZGVtdXhSZXN1bHQudGV4dFRyYWNrO1xuICAgICAgdmFyIF90aGlzJGN1cnJlbnRUcmFuc211eCA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCA9IF90aGlzJGN1cnJlbnRUcmFuc211eC5hY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICAgIHRpbWVPZmZzZXQgPSBfdGhpcyRjdXJyZW50VHJhbnNtdXgudGltZU9mZnNldDtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlt0cmFuc211eGVyLnRzXTogRmx1c2hlZCBcIiArIHRoaXMuaWQgKyBcIiBzbjogXCIgKyBjaHVua01ldGEuc24gKyAoY2h1bmtNZXRhLnBhcnQgPiAtMSA/ICcgcGFydDogJyArIGNodW5rTWV0YS5wYXJ0IDogJycpICsgXCIgb2YgXCIgKyAodGhpcy5pZCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/ICdsZXZlbCcgOiAndHJhY2snKSArIFwiIFwiICsgY2h1bmtNZXRhLmxldmVsKTtcbiAgICAgIHZhciByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRydWUsIHRoaXMuaWQpO1xuICAgICAgdHJhbnNtdXhSZXN1bHRzLnB1c2goe1xuICAgICAgICByZW11eFJlc3VsdDogcmVtdXhSZXN1bHQsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICB9KTtcbiAgICAgIGNodW5rTWV0YS50cmFuc211eGluZy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRJbml0aWFsVGltZXN0YW1wID0gZnVuY3Rpb24gcmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzKSB7XG4gICAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcixcbiAgICAgICAgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UHRzKTtcbiAgICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0Q29udGlndWl0eSA9IGZ1bmN0aW9uIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuICAgICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbXV4ZXIucmVzZXRDb250aWd1aXR5KCk7XG4gICAgICByZW11eGVyLnJlc2V0TmV4dFRpbWVzdGFtcCgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbiwgZGVjcnlwdGRhdGEpIHtcbiAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuICAgICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbXV4ZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgICAgcmVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZGVjcnlwdGRhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZW11eGVyKSB7XG4gICAgICAgIHRoaXMucmVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucmVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50cmFuc211eCA9IGZ1bmN0aW9uIHRyYW5zbXV4KGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnRyYW5zbXV4VW5lbmNyeXB0ZWQgPSBmdW5jdGlvbiB0cmFuc211eFVuZW5jcnlwdGVkKGRhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgICB2YXIgX2RlbXV4ID0gdGhpcy5kZW11eGVyLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIGZhbHNlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpLFxuICAgICAgICBhdWRpb1RyYWNrID0gX2RlbXV4LmF1ZGlvVHJhY2ssXG4gICAgICAgIHZpZGVvVHJhY2sgPSBfZGVtdXgudmlkZW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2sgPSBfZGVtdXguaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayA9IF9kZW11eC50ZXh0VHJhY2s7XG4gICAgICB2YXIgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBmYWxzZSwgdGhpcy5pZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW11eFJlc3VsdDogcmVtdXhSZXN1bHQsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnRyYW5zbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gdHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLmRlbXV4ZXIuZGVtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQpLnRoZW4oZnVuY3Rpb24gKGRlbXV4UmVzdWx0KSB7XG4gICAgICAgIHZhciByZW11eFJlc3VsdCA9IF90aGlzMy5yZW11eGVyLnJlbXV4KGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssIGRlbXV4UmVzdWx0LnZpZGVvVHJhY2ssIGRlbXV4UmVzdWx0LmlkM1RyYWNrLCBkZW11eFJlc3VsdC50ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmFsc2UsIF90aGlzMy5pZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVtdXhSZXN1bHQ6IHJlbXV4UmVzdWx0LFxuICAgICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5jb25maWd1cmVUcmFuc211eGVyID0gZnVuY3Rpb24gY29uZmlndXJlVHJhbnNtdXhlcihkYXRhKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcixcbiAgICAgICAgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICAgIC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcbiAgICAgIHZhciBtdXg7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbXV4Q29uZmlnLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBfbXV4Q29uZmlnJGkkZGVtdXg7XG4gICAgICAgIGlmICgoX211eENvbmZpZyRpJGRlbXV4ID0gbXV4Q29uZmlnW2ldLmRlbXV4KSAhPSBudWxsICYmIF9tdXhDb25maWckaSRkZW11eC5wcm9iZShkYXRhLCB0aGlzLmxvZ2dlcikpIHtcbiAgICAgICAgICBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbXV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnbWVudCBkYXRhJyk7XG4gICAgICB9XG4gICAgICAvLyBzbyBsZXQncyBjaGVjayB0aGF0IGN1cnJlbnQgcmVtdXhlciBhbmQgZGVtdXhlciBhcmUgc3RpbGwgdmFsaWRcbiAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgdmFyIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG4gICAgICB2YXIgUmVtdXhlciA9IG11eC5yZW11eDtcbiAgICAgIHZhciBEZW11eGVyID0gbXV4LmRlbXV4O1xuICAgICAgaWYgKCFyZW11eGVyIHx8ICEocmVtdXhlciBpbnN0YW5jZW9mIFJlbXV4ZXIpKSB7XG4gICAgICAgIHRoaXMucmVtdXhlciA9IG5ldyBSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHRoaXMubG9nZ2VyKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVtdXhlciB8fCAhKGRlbXV4ZXIgaW5zdGFuY2VvZiBEZW11eGVyKSkge1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIHRoaXMucHJvYmUgPSBEZW11eGVyLnByb2JlO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm5lZWRzUHJvYmluZyA9IGZ1bmN0aW9uIG5lZWRzUHJvYmluZyhkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCkge1xuICAgICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgb3IgdHJhY2sgc3dpdGNoXG4gICAgICAvLyB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyLCBvciBUUyB0byBmbXA0IGZvciBleGFtcGxlKVxuICAgICAgcmV0dXJuICF0aGlzLmRlbXV4ZXIgfHwgIXRoaXMucmVtdXhlciB8fCBkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoO1xuICAgIH07XG4gICAgX3Byb3RvLmdldERlY3J5cHRlciA9IGZ1bmN0aW9uIGdldERlY3J5cHRlcigpIHtcbiAgICAgIHZhciBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICAgIGlmICghZGVjcnlwdGVyKSB7XG4gICAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcih0aGlzLmNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVjcnlwdGVyO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zbXV4ZXI7XG4gIH0oKTtcbiAgZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblR5cGUoZGF0YSwgZGVjcnlwdERhdGEpIHtcbiAgICB2YXIgZW5jcnlwdGlvblR5cGUgPSBudWxsO1xuICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwICYmIChkZWNyeXB0RGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGVjcnlwdERhdGEua2V5KSAhPSBudWxsICYmIGRlY3J5cHREYXRhLml2ICE9PSBudWxsICYmIGRlY3J5cHREYXRhLm1ldGhvZCAhPSBudWxsKSB7XG4gICAgICBlbmNyeXB0aW9uVHlwZSA9IGRlY3J5cHREYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZW5jcnlwdGlvblR5cGU7XG4gIH1cbiAgdmFyIGVtcHR5UmVzdWx0ID0gZnVuY3Rpb24gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbXV4UmVzdWx0OiB7fSxcbiAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgICByZXR1cm4gJ3RoZW4nIGluIHAgJiYgcC50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH1cbiAgdmFyIFRyYW5zbXV4Q29uZmlnID0gZnVuY3Rpb24gVHJhbnNtdXhDb25maWcoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnREYXRhLCBkdXJhdGlvbiwgZGVmYXVsdEluaXRQdHMpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0SW5pdFB0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5pbml0U2VnbWVudERhdGEgPSBpbml0U2VnbWVudERhdGE7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuZGVmYXVsdEluaXRQdHMgPSBkZWZhdWx0SW5pdFB0cyB8fCBudWxsO1xuICB9O1xuICB2YXIgVHJhbnNtdXhTdGF0ZSA9IGZ1bmN0aW9uIFRyYW5zbXV4U3RhdGUoZGlzY29udGludWl0eSwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cmFja1N3aXRjaCwgdGltZU9mZnNldCwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICB0aGlzLmRpc2NvbnRpbnVpdHkgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250aWd1b3VzID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHRoaXMudHJhY2tTd2l0Y2ggPSB2b2lkIDA7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5kaXNjb250aW51aXR5ID0gZGlzY29udGludWl0eTtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSBjb250aWd1b3VzO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gYWNjdXJhdGVUaW1lT2Zmc2V0O1xuICAgIHRoaXMudHJhY2tTd2l0Y2ggPSB0cmFja1N3aXRjaDtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSBpbml0U2VnbWVudENoYW5nZTtcbiAgfTtcblxuICB2YXIgdHJhbnNtdXhlcnMgPSBbXTtcbiAgaWYgKHR5cGVvZiBfX0lOX1dPUktFUl9fICE9PSAndW5kZWZpbmVkJyAmJiBfX0lOX1dPUktFUl9fKSB7XG4gICAgc3RhcnRXb3JrZXIoKTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydFdvcmtlcigpIHtcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciBkYXRhID0gZXYuZGF0YTtcbiAgICAgIHZhciBpbnN0YW5jZU5vID0gZGF0YS5pbnN0YW5jZU5vO1xuICAgICAgaWYgKGluc3RhbmNlTm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdHJhbnNtdXhlciA9IHRyYW5zbXV4ZXJzW2luc3RhbmNlTm9dO1xuICAgICAgaWYgKGRhdGEuY21kID09PSAncmVzZXQnKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFuc211eGVyc1tkYXRhLnJlc2V0Tm9dO1xuICAgICAgICBpZiAodHJhbnNtdXhlcikge1xuICAgICAgICAgIHRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuY21kID0gJ2luaXQnO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuY21kID09PSAnaW5pdCcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IEpTT04ucGFyc2UoZGF0YS5jb25maWcpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIG9ic2VydmVyLm9uKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgICAgICBvYnNlcnZlci5vbihFdmVudHMuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgICAgdmFyIGxvZ2dlciA9IGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnLCBkYXRhLmlkKTtcbiAgICAgICAgZm9yd2FyZFdvcmtlckxvZ3MobG9nZ2VyLCBpbnN0YW5jZU5vKTtcbiAgICAgICAgdHJhbnNtdXhlcnNbaW5zdGFuY2VOb10gPSBuZXcgVHJhbnNtdXhlcihvYnNlcnZlciwgZGF0YS50eXBlU3VwcG9ydGVkLCBjb25maWcsICcnLCBkYXRhLmlkLCBsb2dnZXIpO1xuICAgICAgICBmb3J3YXJkTWVzc2FnZSgnaW5pdCcsIG51bGwsIGluc3RhbmNlTm8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zbXV4ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgICBjYXNlICdjb25maWd1cmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRyYW5zbXV4ZXIuY29uZmlndXJlKGRhdGEuY29uZmlnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVtdXgnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIucHVzaChkYXRhLmRhdGEsIGRhdGEuZGVjcnlwdGRhdGEsIGRhdGEuY2h1bmtNZXRhLCBkYXRhLnN0YXRlKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBlbWl0VHJhbnNtdXhDb21wbGV0ZShzZWxmLCBkYXRhLCBpbnN0YW5jZU5vKTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZE1lc3NhZ2UoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZU5vOiBpbnN0YW5jZU5vLFxuICAgICAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgICAgICAgICBjaHVua01ldGE6IGRhdGEuY2h1bmtNZXRhLFxuICAgICAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJ0cmFuc211eGVyLXdvcmtlciBwdXNoIGVycm9yXCJcbiAgICAgICAgICAgICAgICB9LCBpbnN0YW5jZU5vKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbWl0VHJhbnNtdXhDb21wbGV0ZShzZWxmLCB0cmFuc211eFJlc3VsdCwgaW5zdGFuY2VObyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ZsdXNoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY2h1bmtNZXRhID0gZGF0YS5jaHVua01ldGE7XG4gICAgICAgICAgICB2YXIgX3RyYW5zbXV4UmVzdWx0ID0gdHJhbnNtdXhlci5mbHVzaChjaHVua01ldGEpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShfdHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgICAgICAgIF90cmFuc211eFJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRmx1c2hSZXN1bHQoc2VsZiwgcmVzdWx0cywgY2h1bmtNZXRhLCBpbnN0YW5jZU5vKTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZm9yd2FyZE1lc3NhZ2UoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICAgICAgICAgIGNodW5rTWV0YTogZGF0YS5jaHVua01ldGEsXG4gICAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgcmVhc29uOiBcInRyYW5zbXV4ZXItd29ya2VyIGZsdXNoIGVycm9yXCJcbiAgICAgICAgICAgICAgICB9LCBpbnN0YW5jZU5vKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYW5kbGVGbHVzaFJlc3VsdChzZWxmLCBfdHJhbnNtdXhSZXN1bHQsIGNodW5rTWV0YSwgaW5zdGFuY2VObyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgdHJhbnNtdXhSZXN1bHQsIGluc3RhbmNlTm8pIHtcbiAgICBpZiAoaXNFbXB0eVJlc3VsdCh0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRyYW5zZmVyYWJsZSA9IFtdO1xuICAgIHZhciBfdHJhbnNtdXhSZXN1bHQkcmVtdXggPSB0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCxcbiAgICAgIGF1ZGlvID0gX3RyYW5zbXV4UmVzdWx0JHJlbXV4LmF1ZGlvLFxuICAgICAgdmlkZW8gPSBfdHJhbnNtdXhSZXN1bHQkcmVtdXgudmlkZW87XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIGF1ZGlvKTtcbiAgICB9XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIHZpZGVvKTtcbiAgICB9XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICBldmVudDogJ3RyYW5zbXV4Q29tcGxldGUnLFxuICAgICAgZGF0YTogdHJhbnNtdXhSZXN1bHQsXG4gICAgICBpbnN0YW5jZU5vOiBpbnN0YW5jZU5vXG4gICAgfSwgdHJhbnNmZXJhYmxlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGRhdGEgdG8gYSB0cmFuc2ZlcmFibGUgb2JqZWN0IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTEvMTIvVHJhbnNmZXJhYmxlLU9iamVjdHMtTGlnaHRuaW5nLUZhc3QpXG4gIC8vIGluIG9yZGVyIHRvIG1pbmltaXplIG1lc3NhZ2UgcGFzc2luZyBvdmVyaGVhZFxuICBmdW5jdGlvbiBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLmRhdGExKSB7XG4gICAgICB0cmFuc2ZlcmFibGUucHVzaCh0cmFjay5kYXRhMS5idWZmZXIpO1xuICAgIH1cbiAgICBpZiAodHJhY2suZGF0YTIpIHtcbiAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKHRyYWNrLmRhdGEyLmJ1ZmZlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUZsdXNoUmVzdWx0KHNlbGYsIHJlc3VsdHMsIGNodW5rTWV0YSwgaW5zdGFuY2VObykge1xuICAgIHZhciBwYXJzZWQgPSByZXN1bHRzLnJlZHVjZShmdW5jdGlvbiAocGFyc2VkLCByZXN1bHQpIHtcbiAgICAgIHJldHVybiBlbWl0VHJhbnNtdXhDb21wbGV0ZShzZWxmLCByZXN1bHQsIGluc3RhbmNlTm8pIHx8IHBhcnNlZDtcbiAgICB9LCBmYWxzZSk7XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIC8vIEVtaXQgYXQgbGVhc3Qgb25lIFwidHJhbnNtdXhDb21wbGV0ZVwiIG1lc3NhZ2UgZXZlbiBpZiBtZWRpYSBpcyBub3QgZm91bmQgdG8gdXBkYXRlIHN0cmVhbS1jb250cm9sbGVyIHN0YXRlIHRvIFBBUlNJTkdcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBldmVudDogJ3RyYW5zbXV4Q29tcGxldGUnLFxuICAgICAgICBkYXRhOiByZXN1bHRzWzBdLFxuICAgICAgICBpbnN0YW5jZU5vOiBpbnN0YW5jZU5vXG4gICAgICB9KTtcbiAgICB9XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICBldmVudDogJ2ZsdXNoJyxcbiAgICAgIGRhdGE6IGNodW5rTWV0YSxcbiAgICAgIGluc3RhbmNlTm86IGluc3RhbmNlTm9cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmb3J3YXJkTWVzc2FnZShldmVudCwgZGF0YSwgaW5zdGFuY2VObykge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGluc3RhbmNlTm86IGluc3RhbmNlTm9cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmb3J3YXJkV29ya2VyTG9ncyhsb2dnZXIsIGluc3RhbmNlTm8pIHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChsb2dGbikge1xuICAgICAgbG9nZ2VyW2xvZ0ZuXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGFyZ3VtZW50cywgJyAnKTtcbiAgICAgICAgZm9yd2FyZE1lc3NhZ2UoJ3dvcmtlckxvZycsIHtcbiAgICAgICAgICBsb2dUeXBlOiBsb2dGbixcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH0sIGluc3RhbmNlTm8pO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGZvciAodmFyIGxvZ0ZuIGluIGxvZ2dlcikge1xuICAgICAgX2xvb3AobG9nRm4pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0VtcHR5UmVzdWx0KHJlbXV4UmVzdWx0KSB7XG4gICAgcmV0dXJuICFyZW11eFJlc3VsdC5hdWRpbyAmJiAhcmVtdXhSZXN1bHQudmlkZW8gJiYgIXJlbXV4UmVzdWx0LnRleHQgJiYgIXJlbXV4UmVzdWx0LmlkMyAmJiAhcmVtdXhSZXN1bHQuaW5pdFNlZ21lbnQ7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IFwiMS42LjE1XCI7XG5cbiAgLy8gZW5zdXJlIHRoZSB3b3JrZXIgZW5kcyB1cCBpbiB0aGUgYnVuZGxlXG4gIC8vIElmIHRoZSB3b3JrZXIgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCB0aGlzIGdldHMgYWxpYXNlZCB0byBlbXB0eS5qc1xuICB2YXIgd29ya2VyU3RvcmUgPSB7fTtcbiAgZnVuY3Rpb24gaGFzVU1EV29ya2VyKCkge1xuICAgIHJldHVybiB0eXBlb2YgX19ITFNfV09SS0VSX0JVTkRMRV9fID09PSAnZnVuY3Rpb24nO1xuICB9XG4gIGZ1bmN0aW9uIGluamVjdFdvcmtlcigpIHtcbiAgICB2YXIgd29ya2VyQ29udGV4dCA9IHdvcmtlclN0b3JlW3ZlcnNpb25dO1xuICAgIGlmICh3b3JrZXJDb250ZXh0KSB7XG4gICAgICB3b3JrZXJDb250ZXh0LmNsaWVudENvdW50Kys7XG4gICAgICByZXR1cm4gd29ya2VyQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIGJsb2IgPSBuZXcgc2VsZi5CbG9iKFtcInZhciBleHBvcnRzPXt9O3ZhciBtb2R1bGU9e2V4cG9ydHM6ZXhwb3J0c307ZnVuY3Rpb24gZGVmaW5lKGYpe2YoKX07ZGVmaW5lLmFtZD10cnVlOyhcIiArIF9fSExTX1dPUktFUl9CVU5ETEVfXy50b1N0cmluZygpICsgXCIpKHRydWUpO1wiXSwge1xuICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCdcbiAgICB9KTtcbiAgICB2YXIgb2JqZWN0VVJMID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIHZhciB3b3JrZXIgPSBuZXcgc2VsZi5Xb3JrZXIob2JqZWN0VVJMKTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgd29ya2VyOiB3b3JrZXIsXG4gICAgICBvYmplY3RVUkw6IG9iamVjdFVSTCxcbiAgICAgIGNsaWVudENvdW50OiAxXG4gICAgfTtcbiAgICB3b3JrZXJTdG9yZVt2ZXJzaW9uXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGxvYWRXb3JrZXIocGF0aCkge1xuICAgIHZhciB3b3JrZXJDb250ZXh0ID0gd29ya2VyU3RvcmVbcGF0aF07XG4gICAgaWYgKHdvcmtlckNvbnRleHQpIHtcbiAgICAgIHdvcmtlckNvbnRleHQuY2xpZW50Q291bnQrKztcbiAgICAgIHJldHVybiB3b3JrZXJDb250ZXh0O1xuICAgIH1cbiAgICB2YXIgc2NyaXB0VVJMID0gbmV3IHNlbGYuVVJMKHBhdGgsIHNlbGYubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgICB2YXIgd29ya2VyID0gbmV3IHNlbGYuV29ya2VyKHNjcmlwdFVSTCk7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHdvcmtlcjogd29ya2VyLFxuICAgICAgc2NyaXB0VVJMOiBzY3JpcHRVUkwsXG4gICAgICBjbGllbnRDb3VudDogMVxuICAgIH07XG4gICAgd29ya2VyU3RvcmVbcGF0aF0gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVXb3JrZXJGcm9tU3RvcmUocGF0aCkge1xuICAgIHZhciB3b3JrZXJDb250ZXh0ID0gd29ya2VyU3RvcmVbcGF0aCB8fCB2ZXJzaW9uXTtcbiAgICBpZiAod29ya2VyQ29udGV4dCkge1xuICAgICAgdmFyIGNsaWVudENvdW50ID0gd29ya2VyQ29udGV4dC5jbGllbnRDb3VudC0tO1xuICAgICAgaWYgKGNsaWVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB3b3JrZXJDb250ZXh0LndvcmtlcixcbiAgICAgICAgICBvYmplY3RVUkwgPSB3b3JrZXJDb250ZXh0Lm9iamVjdFVSTDtcbiAgICAgICAgZGVsZXRlIHdvcmtlclN0b3JlW3BhdGggfHwgdmVyc2lvbl07XG4gICAgICAgIGlmIChvYmplY3RVUkwpIHtcbiAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdHJhbnNtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB0cmFuc211eGVySW5zdGFuY2VDb3VudCA9IDA7XG4gIHZhciBUcmFuc211eGVySW50ZXJmYWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc211eGVySW50ZXJmYWNlKF9obHMsIGlkLCBvblRyYW5zbXV4Q29tcGxldGUsIG9uRmx1c2gpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaW5zdGFuY2VObyA9IHRyYW5zbXV4ZXJJbnN0YW5jZUNvdW50Kys7XG4gICAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICAgIHRoaXMucGFydCA9IG51bGw7XG4gICAgICB0aGlzLnVzZVdvcmtlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLm9uRmx1c2ggPSB2b2lkIDA7XG4gICAgICB0aGlzLm9uV29ya2VyTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIHZhciBobHMgPSBfdGhpcy5obHM7XG4gICAgICAgIGlmICghaGxzIHx8ICEoZGF0YSAhPSBudWxsICYmIGRhdGEuZXZlbnQpIHx8IGRhdGEuaW5zdGFuY2VObyAhPT0gX3RoaXMuaW5zdGFuY2VObykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHtcbiAgICAgICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzJHdvcmtlckNvbnRleHQ7XG4gICAgICAgICAgICAgIHZhciBvYmplY3RVUkwgPSAoX3RoaXMkd29ya2VyQ29udGV4dCA9IF90aGlzLndvcmtlckNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR3b3JrZXJDb250ZXh0Lm9iamVjdFVSTDtcbiAgICAgICAgICAgICAgaWYgKG9iamVjdFVSTCkge1xuICAgICAgICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSB0cmFuc211eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICd0cmFuc211eENvbXBsZXRlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhLmRhdGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF90aGlzLm9uRmx1c2goZGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwYXNzIGxvZ3MgZnJvbSB0aGUgd29ya2VyIHRocmVhZCB0byB0aGUgbWFpbiBsb2dnZXJcbiAgICAgICAgICBjYXNlICd3b3JrZXJMb2cnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoaGxzLmxvZ2dlcltkYXRhLmRhdGEubG9nVHlwZV0pIHtcbiAgICAgICAgICAgICAgICBobHMubG9nZ2VyW2RhdGEuZGF0YS5sb2dUeXBlXShkYXRhLmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8IHt9O1xuICAgICAgICAgICAgICBkYXRhLmRhdGEuZnJhZyA9IF90aGlzLmZyYWc7XG4gICAgICAgICAgICAgIGRhdGEuZGF0YS5wYXJ0ID0gX3RoaXMucGFydDtcbiAgICAgICAgICAgICAgZGF0YS5kYXRhLmlkID0gX3RoaXMuaWQ7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5vbldvcmtlckVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghX3RoaXMuaGxzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihldmVudC5tZXNzYWdlICsgXCIgIChcIiArIGV2ZW50LmZpbGVuYW1lICsgXCI6XCIgKyBldmVudC5saW5lbm8gKyBcIilcIik7XG4gICAgICAgIF90aGlzLmhscy5jb25maWcuZW5hYmxlV29ya2VyID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmhscy5sb2dnZXIud2FybihcIkVycm9yIGluIFxcXCJcIiArIF90aGlzLmlkICsgXCJcXFwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZVwiKTtcbiAgICAgICAgX3RoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBldmVudDogJ2RlbXV4ZXJXb3JrZXInLFxuICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB2YXIgY29uZmlnID0gX2hscy5jb25maWc7XG4gICAgICB0aGlzLmhscyA9IF9obHM7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICB0aGlzLnVzZVdvcmtlciA9ICEhY29uZmlnLmVuYWJsZVdvcmtlcjtcbiAgICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gb25UcmFuc211eENvbXBsZXRlO1xuICAgICAgdGhpcy5vbkZsdXNoID0gb25GbHVzaDtcbiAgICAgIHZhciBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uIGZvcndhcmRNZXNzYWdlKGV2LCBkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICBkYXRhLmZyYWcgPSBfdGhpcy5mcmFnIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGV2ID09PSBFdmVudHMuRVJST1IpIHtcbiAgICAgICAgICBkYXRhID0gZGF0YTtcbiAgICAgICAgICBkYXRhLnBhcmVudCA9IF90aGlzLmlkO1xuICAgICAgICAgIGRhdGEucGFydCA9IF90aGlzLnBhcnQ7XG4gICAgICAgICAgX3RoaXMuZXJyb3IgPSBkYXRhLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmhscy50cmlnZ2VyKGV2LCBkYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gICAgICB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgdGhpcy5vYnNlcnZlci5vbihFdmVudHMuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIub24oRXZlbnRzLkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgICB2YXIgbTJ0c1R5cGVTdXBwb3J0ZWQgPSBnZXRNMlRTU3VwcG9ydGVkQXVkaW9UeXBlcyhjb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICAgIGlmICh0aGlzLnVzZVdvcmtlciAmJiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgbG9nZ2VyID0gdGhpcy5obHMubG9nZ2VyO1xuICAgICAgICB2YXIgY2FuQ3JlYXRlV29ya2VyID0gY29uZmlnLndvcmtlclBhdGggfHwgaGFzVU1EV29ya2VyKCk7XG4gICAgICAgIGlmIChjYW5DcmVhdGVXb3JrZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy53b3JrZXJQYXRoKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJsb2FkaW5nIFdlYiBXb3JrZXIgXCIgKyBjb25maWcud29ya2VyUGF0aCArIFwiIGZvciBcXFwiXCIgKyBpZCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbG9hZFdvcmtlcihjb25maWcud29ya2VyUGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiaW5qZWN0aW5nIFdlYiBXb3JrZXIgZm9yIFxcXCJcIiArIGlkICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQgPSBpbmplY3RXb3JrZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3b3JrZXIgPSB0aGlzLndvcmtlckNvbnRleHQud29ya2VyO1xuICAgICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9uV29ya2VyTWVzc2FnZSk7XG4gICAgICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VObzogdGhpcy5pbnN0YW5jZU5vLFxuICAgICAgICAgICAgICBjbWQ6ICdpbml0JyxcbiAgICAgICAgICAgICAgdHlwZVN1cHBvcnRlZDogbTJ0c1R5cGVTdXBwb3J0ZWQsXG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgY29uZmlnOiBzdHJpbmdpZnkoY29uZmlnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIkVycm9yIHNldHRpbmcgdXAgXFxcIlwiICsgaWQgKyBcIlxcXCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lXCIsIGVycik7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZVdvcmtlcigpO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcih0aGlzLm9ic2VydmVyLCBtMnRzVHlwZVN1cHBvcnRlZCwgY29uZmlnLCAnJywgaWQsIF9obHMubG9nZ2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcih0aGlzLm9ic2VydmVyLCBtMnRzVHlwZVN1cHBvcnRlZCwgY29uZmlnLCAnJywgaWQsIF9obHMubG9nZ2VyKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFRyYW5zbXV4ZXJJbnRlcmZhY2UucHJvdG90eXBlO1xuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICAgIHRoaXMucGFydCA9IG51bGw7XG4gICAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZU5vID0gdGhpcy5pbnN0YW5jZU5vO1xuICAgICAgICB0aGlzLmluc3RhbmNlTm8gPSB0cmFuc211eGVySW5zdGFuY2VDb3VudCsrO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgICB2YXIgbTJ0c1R5cGVTdXBwb3J0ZWQgPSBnZXRNMlRTU3VwcG9ydGVkQXVkaW9UeXBlcyhjb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgaW5zdGFuY2VObzogdGhpcy5pbnN0YW5jZU5vLFxuICAgICAgICAgIGNtZDogJ3Jlc2V0JyxcbiAgICAgICAgICByZXNldE5vOiBpbnN0YW5jZU5vLFxuICAgICAgICAgIHR5cGVTdXBwb3J0ZWQ6IG0ydHNUeXBlU3VwcG9ydGVkLFxuICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgIGNvbmZpZzogc3RyaW5naWZ5KGNvbmZpZylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udGVybWluYXRlV29ya2VyID0gZnVuY3Rpb24gdGVybWluYXRlV29ya2VyKCkge1xuICAgICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgICB2YXIgd29ya2VyID0gdGhpcy53b3JrZXJDb250ZXh0LndvcmtlcjtcbiAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9uV29ya2VyTWVzc2FnZSk7XG4gICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25Xb3JrZXJFcnJvcik7XG4gICAgICAgIHJlbW92ZVdvcmtlckZyb21TdG9yZSh0aGlzLmhscy5jb25maWcud29ya2VyUGF0aCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICAgIHRoaXMudGVybWluYXRlV29ya2VyKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5vbldvcmtlck1lc3NhZ2UgPSB0aGlzLm9uV29ya2VyRXJyb3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgICAgdHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgICB0aGlzLnBhcnQgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmhscyA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goZGF0YSwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBwYXJ0LCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGRlZmF1bHRJbml0UFRTKSB7XG4gICAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQsXG4gICAgICAgIF9sYXN0RnJhZyRpbml0U2VnbWVudCxcbiAgICAgICAgX3RoaXMyID0gdGhpcztcbiAgICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgaW5zdGFuY2VObyA9IHRoaXMuaW5zdGFuY2VObyxcbiAgICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIHZhciB0aW1lT2Zmc2V0ID0gcGFydCA/IHBhcnQuc3RhcnQgOiBmcmFnLnN0YXJ0O1xuICAgICAgLy8gVE9ETzogcHVzaCBcImNsZWFyLWxlYWRcIiBkZWNyeXB0IGRhdGEgZm9yIHVuZW5jcnlwdGVkIGZyYWdtZW50cyBpbiBzdHJlYW1zIHdpdGggZW5jcnlwdGVkIG9uZXNcbiAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgICB2YXIgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICB2YXIgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgZnJhZy5jYyA9PT0gbGFzdEZyYWcuY2MpO1xuICAgICAgdmFyIHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiBjaHVua01ldGEubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKTtcbiAgICAgIHZhciBzbkRpZmYgPSBsYXN0RnJhZyA/IGNodW5rTWV0YS5zbiAtIGxhc3RGcmFnLnNuIDogLTE7XG4gICAgICB2YXIgcGFydERpZmYgPSB0aGlzLnBhcnQgPyBjaHVua01ldGEucGFydCAtIHRoaXMucGFydC5pbmRleCA6IC0xO1xuICAgICAgdmFyIHByb2dyZXNzaXZlID0gc25EaWZmID09PSAwICYmIGNodW5rTWV0YS5pZCA+IDEgJiYgY2h1bmtNZXRhLmlkID09PSAobGFzdEZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RGcmFnLnN0YXRzLmNodW5rQ291bnQpO1xuICAgICAgdmFyIGNvbnRpZ3VvdXMgPSAhdHJhY2tTd2l0Y2ggJiYgKHNuRGlmZiA9PT0gMSB8fCBzbkRpZmYgPT09IDAgJiYgKHBhcnREaWZmID09PSAxIHx8IHByb2dyZXNzaXZlICYmIHBhcnREaWZmIDw9IDApKTtcbiAgICAgIHZhciBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgaWYgKHRyYWNrU3dpdGNoIHx8IHNuRGlmZiB8fCBmcmFnLnN0YXRzLnBhcnNpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgICAgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQgJiYgKHBhcnREaWZmIHx8ICFjb250aWd1b3VzKSkge1xuICAgICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgICB9XG4gICAgICB2YXIgaW5pdFNlZ21lbnRDaGFuZ2UgPSAhKGxhc3RGcmFnICYmICgoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQudXJsKSA9PT0gKChfbGFzdEZyYWckaW5pdFNlZ21lbnQgPSBsYXN0RnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sYXN0RnJhZyRpbml0U2VnbWVudC51cmwpKTtcbiAgICAgIHZhciBzdGF0ZSA9IG5ldyBUcmFuc211eFN0YXRlKGRpc2NvbnRpbnVpdHksIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJhY2tTd2l0Y2gsIHRpbWVPZmZzZXQsIGluaXRTZWdtZW50Q2hhbmdlKTtcbiAgICAgIGlmICghY29udGlndW91cyB8fCBkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlKSB7XG4gICAgICAgIHRoaXMuaGxzLmxvZ2dlci5sb2coXCJbdHJhbnNtdXhlci1pbnRlcmZhY2VdOiBTdGFydGluZyBuZXcgdHJhbnNtdXggc2Vzc2lvbiBmb3IgXCIgKyBmcmFnLnR5cGUgKyBcIiBzbjogXCIgKyBjaHVua01ldGEuc24gKyAoY2h1bmtNZXRhLnBhcnQgPiAtMSA/ICcgcGFydDogJyArIGNodW5rTWV0YS5wYXJ0IDogJycpICsgXCIgXCIgKyAodGhpcy5pZCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/ICdsZXZlbCcgOiAndHJhY2snKSArIFwiOiBcIiArIGNodW5rTWV0YS5sZXZlbCArIFwiIGlkOiBcIiArIGNodW5rTWV0YS5pZCArIFwiXFxuICAgICAgICBkaXNjb250aW51aXR5OiBcIiArIGRpc2NvbnRpbnVpdHkgKyBcIlxcbiAgICAgICAgdHJhY2tTd2l0Y2g6IFwiICsgdHJhY2tTd2l0Y2ggKyBcIlxcbiAgICAgICAgY29udGlndW91czogXCIgKyBjb250aWd1b3VzICsgXCJcXG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldDogXCIgKyBhY2N1cmF0ZVRpbWVPZmZzZXQgKyBcIlxcbiAgICAgICAgdGltZU9mZnNldDogXCIgKyB0aW1lT2Zmc2V0ICsgXCJcXG4gICAgICAgIGluaXRTZWdtZW50Q2hhbmdlOiBcIiArIGluaXRTZWdtZW50Q2hhbmdlKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IG5ldyBUcmFuc211eENvbmZpZyhhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBpbml0U2VnbWVudERhdGEsIGR1cmF0aW9uLCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcihjb25maWcpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICAgIHRoaXMucGFydCA9IHBhcnQ7XG5cbiAgICAgIC8vIEZyYWdzIHdpdGggc24gb2YgJ2luaXRTZWdtZW50JyBhcmUgbm90IHRyYW5zbXV4ZWRcbiAgICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgICAgLy8gcG9zdCBmcmFnbWVudCBwYXlsb2FkIGFzIHRyYW5zZmVyYWJsZSBvYmplY3RzIGZvciBBcnJheUJ1ZmZlciAobm8gY29weSlcbiAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgaW5zdGFuY2VObzogaW5zdGFuY2VObyxcbiAgICAgICAgICBjbWQ6ICdkZW11eCcsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBkZWNyeXB0ZGF0YTogZGVjcnlwdGRhdGEsXG4gICAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgIH0sIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IFtkYXRhXSA6IFtdKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgICB2YXIgdHJhbnNtdXhSZXN1bHQgPSB0cmFuc211eGVyLnB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGNodW5rTWV0YSwgc3RhdGUpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF90aGlzMi5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEpO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMyLnRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCAndHJhbnNtdXhlci1pbnRlcmZhY2UgcHVzaCBlcnJvcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKGNodW5rTWV0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdmFyIGluc3RhbmNlTm8gPSB0aGlzLmluc3RhbmNlTm8sXG4gICAgICAgIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGluc3RhbmNlTm86IGluc3RhbmNlTm8sXG4gICAgICAgICAgY21kOiAnZmx1c2gnLFxuICAgICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHZhciB0cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgICB0cmFuc211eFJlc3VsdC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBfdGhpczMuaGFuZGxlRmx1c2hSZXN1bHQoZGF0YSwgY2h1bmtNZXRhKTtcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzMy50cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIGZsdXNoIGVycm9yJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdCh0cmFuc211eFJlc3VsdCwgY2h1bmtNZXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRyYW5zbXV4ZXJFcnJvciA9IGZ1bmN0aW9uIHRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCByZWFzb24pIHtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgIGZyYWc6IHRoaXMuZnJhZyB8fCB1bmRlZmluZWQsXG4gICAgICAgIHBhcnQ6IHRoaXMucGFydCB8fCB1bmRlZmluZWQsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlRmx1c2hSZXN1bHQgPSBmdW5jdGlvbiBoYW5kbGVGbHVzaFJlc3VsdChyZXN1bHRzLCBjaHVua01ldGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgX3RoaXM0LmhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbkZsdXNoKGNodW5rTWV0YSk7XG4gICAgfTtcbiAgICBfcHJvdG8uY29uZmlndXJlVHJhbnNtdXhlciA9IGZ1bmN0aW9uIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKSB7XG4gICAgICB2YXIgaW5zdGFuY2VObyA9IHRoaXMuaW5zdGFuY2VObyxcbiAgICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgaW5zdGFuY2VObzogaW5zdGFuY2VObyxcbiAgICAgICAgICBjbWQ6ICdjb25maWd1cmUnLFxuICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuY29uZmlndXJlKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0KSB7XG4gICAgICByZXN1bHQuY2h1bmtNZXRhLnRyYW5zbXV4aW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zbXV4ZXJJbnRlcmZhY2U7XG4gIH0oKTtcblxuICB2YXIgVElDS19JTlRFUlZBTCQzID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuICB2YXIgQXVkaW9TdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICBmdW5jdGlvbiBBdWRpb1N0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfQmFzZVN0cmVhbUNvbnRyb2xsZXIuY2FsbCh0aGlzLCBobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXInLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTykgfHwgdGhpcztcbiAgICAgIF90aGlzLm1haW5BbmNob3IgPSBudWxsO1xuICAgICAgX3RoaXMubWFpbkZyYWdMb2FkaW5nID0gbnVsbDtcbiAgICAgIF90aGlzLmF1ZGlvT25seSA9IGZhbHNlO1xuICAgICAgX3RoaXMuYnVmZmVyZWRUcmFjayA9IG51bGw7XG4gICAgICBfdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgICBfdGhpcy50cmFja0lkID0gLTE7XG4gICAgICBfdGhpcy53YWl0aW5nRGF0YSA9IG51bGw7XG4gICAgICBfdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgICBfdGhpcy5mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgX3RoaXMuYnVmZmVyRmx1c2hlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbDtcbiAgICAgIF90aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKEF1ZGlvU3RyZWFtQ29udHJvbGxlciwgX0Jhc2VTdHJlYW1Db250cm9sbGVyKTtcbiAgICB2YXIgX3Byb3RvID0gQXVkaW9TdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWluZy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5yZXNldEl0ZW0oKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldEl0ZW0gPSBmdW5jdGlvbiByZXNldEl0ZW0oKSB7XG4gICAgICB0aGlzLm1haW5EZXRhaWxzID0gdGhpcy5tYWluQW5jaG9yID0gdGhpcy5tYWluRnJhZ0xvYWRpbmcgPSB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSB0aGlzLnN3aXRjaGluZ1RyYWNrID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5yZWdpc3Rlckxpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKCFobHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS51bnJlZ2lzdGVyTGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBJTklUX1BUU19GT1VORCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdmlkZW8gdHJhY2sgcGFyc2VkIGluIHRoZSBzdHJlYW0tY29udHJvbGxlciBoYXMgYSBuZXcgUFRTIHZhbHVlXG4gICAgO1xuICAgIF9wcm90by5vbkluaXRQdHNGb3VuZCA9IGZ1bmN0aW9uIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCBfcmVmKSB7XG4gICAgICB2YXIgZnJhZyA9IF9yZWYuZnJhZyxcbiAgICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgICBpbml0UFRTID0gX3JlZi5pbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGUgPSBfcmVmLnRpbWVzY2FsZSxcbiAgICAgICAgdHJhY2tJZCA9IF9yZWYudHJhY2tJZDtcbiAgICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgICAgLy8gQ2FuIGNoYW5nZSBkdWUgbGV2ZWwgc3dpdGNoXG4gICAgICBpZiAoaWQgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgICAgdmFyIGNjID0gZnJhZy5jYztcbiAgICAgICAgdmFyIGluRmxpZ2h0RnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIHRoaXMuaW5pdFBUU1tjY10gPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgdHJhY2tJZDogdHJhY2tJZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZyhcIkluaXRQVFMgZm9yIGNjOiBcIiArIGNjICsgXCIgZm91bmQgZnJvbSBtYWluOiBcIiArIGluaXRQVFMgLyB0aW1lc2NhbGUgKyBcIiAoXCIgKyBpbml0UFRTICsgXCIvXCIgKyB0aW1lc2NhbGUgKyBcIikgdHJhY2tJZDogXCIgKyB0cmFja0lkKTtcbiAgICAgICAgdGhpcy5tYWluQW5jaG9yID0gZnJhZztcbiAgICAgICAgLy8gSWYgd2UgYXJlIHdhaXRpbmcsIHRpY2sgaW1tZWRpYXRlbHkgdG8gdW5ibG9jayBhdWRpbyBmcmFnbWVudCB0cmFuc211eGluZ1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICAgIHZhciB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG4gICAgICAgICAgaWYgKCF3YWl0aW5nRGF0YSAmJiAhdGhpcy5sb2FkaW5nUGFydHMgfHwgd2FpdGluZ0RhdGEgJiYgd2FpdGluZ0RhdGEuZnJhZy5jYyAhPT0gY2MpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY1dpdGhBbmNob3IoZnJhZywgd2FpdGluZ0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHdhaXRpbmdEYXRhLmZyYWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5obHMuaGFzRW5vdWdoVG9TdGFydCAmJiBpbkZsaWdodEZyYWcgJiYgaW5GbGlnaHRGcmFnLmNjICE9PSBjYykge1xuICAgICAgICAgIGluRmxpZ2h0RnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICAgICAgdGhpcy5zeW5jV2l0aEFuY2hvcihmcmFnLCBpbkZsaWdodEZyYWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldExvYWRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldExvYWRQb3NpdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmdldExvYWRQb3NpdGlvbi5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnN5bmNXaXRoQW5jaG9yID0gZnVuY3Rpb24gc3luY1dpdGhBbmNob3IobWFpbkFuY2hvciwgd2FpdGluZ1RvQXBwZW5kKSB7XG4gICAgICB2YXIgX3RoaXMkbWFpbkZyYWdMb2FkaW5nO1xuICAgICAgLy8gRHJvcCB3YWl0aW5nIGZyYWdtZW50IGlmIHZpZGVvVHJhY2tDQyBoYXMgY2hhbmdlZCBzaW5jZSB3YWl0aW5nRnJhZ21lbnQgd2FzIHNldCBhbmQgaW5pdFBUUyB3YXMgbm90IGZvdW5kXG4gICAgICB2YXIgbWFpbkZyYWdMb2FkaW5nID0gKChfdGhpcyRtYWluRnJhZ0xvYWRpbmcgPSB0aGlzLm1haW5GcmFnTG9hZGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1haW5GcmFnTG9hZGluZy5mcmFnKSB8fCBudWxsO1xuICAgICAgaWYgKHdhaXRpbmdUb0FwcGVuZCkge1xuICAgICAgICBpZiAoKG1haW5GcmFnTG9hZGluZyA9PSBudWxsID8gdm9pZCAwIDogbWFpbkZyYWdMb2FkaW5nLmNjKSA9PT0gd2FpdGluZ1RvQXBwZW5kLmNjKSB7XG4gICAgICAgICAgLy8gV2FpdCBmb3IgbG9hZGluZyBmcmFnIHRvIGNvbXBsZXRlIGFuZCBJTklUX1BUU19GT1VORFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRhcmdldERpc2NvbnRpbnVpdHkgPSAobWFpbkZyYWdMb2FkaW5nIHx8IG1haW5BbmNob3IpLmNjO1xuICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgIHZhciBzeW5jRnJhZyA9IGZpbmROZWFyZXN0V2l0aENDKHRyYWNrRGV0YWlscywgdGFyZ2V0RGlzY29udGludWl0eSwgcG9zKTtcbiAgICAgIC8vIE9ubHkgc3RvcCB3YWl0aW5nIGZvciBhdWRpb0ZyYWcuY2MgaWYgYW4gYXVkaW8gc2VnbWVudCBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5IGRvbWFpbiAoY2MpIGlzIGZvdW5kXG4gICAgICBpZiAoc3luY0ZyYWcpIHtcbiAgICAgICAgdGhpcy5sb2coXCJTeW5jaW5nIHdpdGggbWFpbiBmcmFnIGF0IFwiICsgc3luY0ZyYWcuc3RhcnQgKyBcIiBjYyBcIiArIHN5bmNGcmFnLmNjKTtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gc3luY0ZyYWcuc3RhcnQ7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKCF0aGlzLmxldmVscykge1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDMpO1xuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5sb2coXCJPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEBcIiArIGxhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpKTtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGxhc3RDdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbiArIHRoaXMudGltZWxpbmVPZmZzZXQ7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbiA/IC0xIDogc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19UUkFDSzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgICAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG4gICAgICAgICAgICB2YXIgY3VycmVuVHJhY2sgPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsc1t0cmFja0lkXTtcbiAgICAgICAgICAgIHZhciBkZXRhaWxzID0gY3VycmVuVHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlblRyYWNrLmRldGFpbHM7XG4gICAgICAgICAgICBpZiAoZGV0YWlscyAmJiAhdGhpcy53YWl0Rm9yTGl2ZShjdXJyZW5UcmFjaykpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXRyeURhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBnZXQgc3R1Y2sgaW4gdGhlIFdBSVRJTkdfSU5JVF9QVFMgc3RhdGUgaWYgdGhlIHdhaXRpbmcgZnJhZyBDQyBkb2Vzbid0IG1hdGNoIGFueSBpbml0UFRTXG4gICAgICAgICAgICB2YXIgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuICAgICAgICAgICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBmcmFnID0gd2FpdGluZ0RhdGEuZnJhZyxcbiAgICAgICAgICAgICAgICBwYXJ0ID0gd2FpdGluZ0RhdGEucGFydCxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHdhaXRpbmdEYXRhLmNhY2hlLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gd2FpdGluZ0RhdGEuY29tcGxldGU7XG4gICAgICAgICAgICAgIHZhciBtYWluQW5jaG9yID0gdGhpcy5tYWluQW5jaG9yO1xuICAgICAgICAgICAgICBpZiAodGhpcy5pbml0UFRTW2ZyYWcuY2NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gY2FjaGUuZmx1c2goKS5idWZmZXI7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYWluQW5jaG9yICYmIG1haW5BbmNob3IuY2MgIT09IHdhaXRpbmdEYXRhLmZyYWcuY2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNXaXRoQW5jaG9yKG1haW5BbmNob3IsIHdhaXRpbmdEYXRhLmZyYWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uVGlja0VuZCgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0TG9hZGluZ1N0YXRlID0gZnVuY3Rpb24gcmVzZXRMb2FkaW5nU3RhdGUoKSB7XG4gICAgICB2YXIgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuICAgICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KHdhaXRpbmdEYXRhLmZyYWcpO1xuICAgICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUucmVzZXRMb2FkaW5nU3RhdGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5vblRpY2tFbmQgPSBmdW5jdGlvbiBvblRpY2tFbmQoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKCEobWVkaWEgIT0gbnVsbCAmJiBtZWRpYS5yZWFkeVN0YXRlKSkge1xuICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB9O1xuICAgIF9wcm90by5kb1RpY2tJZGxlID0gZnVuY3Rpb24gZG9UaWNrSWRsZSgpIHtcbiAgICAgIHZhciBfdGhpcyRtYWluRnJhZ0xvYWRpbmcyO1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgdmFyIGNvbmZpZyA9IGhscy5jb25maWc7XG5cbiAgICAgIC8vIDEuIGlmIGJ1ZmZlcmluZyBpcyBzdXNwZW5kZWRcbiAgICAgIC8vIDIuIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAgIC8vICAgIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAgIC8vIDMuIGlmIHRyYWNrcyBvciB0cmFjayBub3QgbG9hZGVkIGFuZCBzZWxlY3RlZFxuICAgICAgLy8gdGhlbiBleGl0IGxvb3BcbiAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICAgIGlmICghdGhpcy5idWZmZXJpbmcgfHwgIW1lZGlhICYmICF0aGlzLnByaW1hcnlQcmVmZXRjaCAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkgfHwgIShsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHNbdHJhY2tJZF0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgICB2YXIgdHJhY2tEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICBpZiAoIXRyYWNrRGV0YWlscyB8fCB0aGlzLndhaXRGb3JMaXZlKGxldmVsSW5mbykgfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKHRyYWNrRGV0YWlscykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXJhYmxlID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgaWYgKHRoaXMuYnVmZmVyRmx1c2hlZCAmJiBidWZmZXJhYmxlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChidWZmZXJhYmxlLCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKTtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKGJ1ZmZlcmFibGUsIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKTtcbiAgICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zd2l0Y2hpbmdUcmFjayAmJiB0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCB0cmFja0RldGFpbHMpKSB7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCB7XG4gICAgICAgICAgdHlwZTogJ2F1ZGlvJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgICB2YXIgbWF4QnVmTGVuID0gaGxzLm1heEJ1ZmZlckxlbmd0aDtcbiAgICAgIHZhciBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgdmFyIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgdmFyIGxvYWRQb3NpdGlvbiA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICB2YXIgdGFyZ2V0QnVmZmVyVGltZSA9IHRoaXMuZmx1c2hpbmcgPyBsb2FkUG9zaXRpb24gOiBidWZmZXJJbmZvLmVuZDtcbiAgICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyYWNrICYmIG1lZGlhKSB7XG4gICAgICAgIHZhciBwb3MgPSBsb2FkUG9zaXRpb247XG4gICAgICAgIC8vIGlmIGN1cnJlbnRUaW1lIChwb3MpIGlzIGxlc3MgdGhhbiBhbHQgYXVkaW8gcGxheWxpc3Qgc3RhcnQgdGltZSwgaXQgbWVhbnMgdGhhdCBhbHQgYXVkaW8gaXMgYWhlYWQgb2YgY3VycmVudFRpbWVcbiAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xuICAgICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgaXMgYnVmZmVyZWQgZnJvbSBwb3MgdG8gc3RhcnQgb3IgaWYgYXVkaW8gYnVmZmVyIHVwZnJvbnQsIGxldCdzIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgICBpZiAoYnVmZmVySW5mby5lbmQgPiBzdGFydCB8fCBidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ0FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydCArIDAuMDU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1Zkxlbiwgb3IgbmVhciB0aGUgZW5kLCBmaW5kIGEgZnJhZ21lbnQgdG8gbG9hZFxuICAgICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4gJiYgIXRoaXMuc3dpdGNoaW5nVHJhY2sgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCB0cmFja0RldGFpbHMpO1xuICAgICAgLy8gQXZvaWQgbG9vcCBsb2FkaW5nIGJ5IHVzaW5nIG5leHRMb2FkUG9zaXRpb24gc2V0IGZvciBiYWNrdHJhY2tpbmcgYW5kIHNraXBwaW5nIGNvbnNlY3V0aXZlIEdBUCB0YWdzXG4gICAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcoZnJhZywgdHJhY2tEZXRhaWxzLCBidWZmZXJJbmZvLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOLCBtYXhCdWZMZW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVxdWVzdCBhdWRpbyBzZWdtZW50cyB1cCB0byBvbmUgZnJhZ21lbnQgYWhlYWQgb2YgbWFpbiBzdHJlYW0tY29udHJvbGxlclxuICAgICAgdmFyIG1haW5GcmFnTG9hZGluZyA9ICgoX3RoaXMkbWFpbkZyYWdMb2FkaW5nMiA9IHRoaXMubWFpbkZyYWdMb2FkaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWFpbkZyYWdMb2FkaW5nMi5mcmFnKSB8fCBudWxsO1xuICAgICAgaWYgKCF0aGlzLmF1ZGlvT25seSAmJiB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiBtYWluRnJhZ0xvYWRpbmcgJiYgaXNNZWRpYUZyYWdtZW50KGZyYWcpICYmICFmcmFnLmVuZExpc3QgJiYgKCF0cmFja0RldGFpbHMubGl2ZSB8fCAhdGhpcy5sb2FkaW5nUGFydHMgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24pKSB7XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShtYWluRnJhZ0xvYWRpbmcpID09PSBGcmFnbWVudFN0YXRlLk9LKSB7XG4gICAgICAgICAgdGhpcy5tYWluRnJhZ0xvYWRpbmcgPSBtYWluRnJhZ0xvYWRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYWluRnJhZ0xvYWRpbmcgJiYgaXNNZWRpYUZyYWdtZW50KG1haW5GcmFnTG9hZGluZykpIHtcbiAgICAgICAgICBpZiAoZnJhZy5zdGFydCA+IG1haW5GcmFnTG9hZGluZy5lbmQpIHtcbiAgICAgICAgICAgIC8vIEdldCBidWZmZXJlZCBmcmFnIGF0IHRhcmdldCBwb3NpdGlvbiBmcm9tIHRyYWNrZXIgKGxvYWRlZCBvdXQgb2Ygc2VxdWVuY2UpXG4gICAgICAgICAgICB2YXIgbWFpbkZyYWdBdFBvcyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEZyYWdBdFBvcyh0YXJnZXRCdWZmZXJUaW1lLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgICAgIGlmIChtYWluRnJhZ0F0UG9zICYmIG1haW5GcmFnQXRQb3MuZW5kID4gbWFpbkZyYWdMb2FkaW5nLmVuZCkge1xuICAgICAgICAgICAgICBtYWluRnJhZ0xvYWRpbmcgPSBtYWluRnJhZ0F0UG9zO1xuICAgICAgICAgICAgICB0aGlzLm1haW5GcmFnTG9hZGluZyA9IHtcbiAgICAgICAgICAgICAgICBmcmFnOiBtYWluRnJhZ0F0UG9zLFxuICAgICAgICAgICAgICAgIHRhcmdldEJ1ZmZlclRpbWU6IG51bGxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGF0QnVmZmVyU3luY0xpbWl0ID0gZnJhZy5zdGFydCA+IG1haW5GcmFnTG9hZGluZy5lbmQ7XG4gICAgICAgICAgaWYgKGF0QnVmZmVyU3luY0xpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbEluZm8sIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcuY2FsbCh0aGlzLCBldmVudCwgZGF0YSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25BdWRpb1RyYWNrc1VwZGF0ZWQgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tzVXBkYXRlZChldmVudCwgX3JlZjIpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrcyA9IF9yZWYyLmF1ZGlvVHJhY2tzO1xuICAgICAgLy8gUmVzZXQgdHJhbnhtdXhlciBpcyBlc3NlbnRpYWwgZm9yIGxhcmdlIGNvbnRleHQgc3dpdGNoZXMgKENvbnRlbnQgU3RlZXJpbmcpXG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgdGhpcy5sZXZlbHMgPSBhdWRpb1RyYWNrcy5tYXAoZnVuY3Rpb24gKG1lZGlhUGxheWxpc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZXZlbChtZWRpYVBsYXlsaXN0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGluZyA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoZnJhZ0N1cnJlbnQuc3RhcnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuXG4gICAgICAvLyBzaG91bGQgd2Ugc3dpdGNoIHRyYWNrcyA/XG4gICAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgICAgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IGRhdGE7XG4gICAgICAgIC8vIG1haW4gYXVkaW8gdHJhY2sgYXJlIGhhbmRsZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXIsIGp1c3QgZG8gc29tZXRoaW5nIGlmIHN3aXRjaGluZyB0byBhbHQgYXVkaW8gdHJhY2tcbiAgICAgICAgdGhpcy5mbHVzaEF1ZGlvSWZOZWVkZWQoZGF0YSk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICAgICAgLy8gc3dpdGNoaW5nIHRvIGF1ZGlvIHRyYWNrLCBzdGFydCB0aW1lciBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAgICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDMpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZXN0cm95IHVzZWxlc3MgdHJhbnNtdXhlciB3aGVuIHN3aXRjaGluZyBhdWRpbyB0byBtYWluXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBkYXRhO1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1hbmlmZXN0TG9hZGluZy5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdGhpcy5mbHVzaGluZyA9IHRoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc2V0SXRlbSgpO1xuICAgICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMubWFpbkRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICB2YXIgY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGE7XG4gICAgICBpZiAoY2FjaGVkVHJhY2tMb2FkZWREYXRhKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgY2FjaGVkVHJhY2tMb2FkZWREYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkF1ZGlvVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdHJhY2tMZXZlbCRkZXRhaWxzO1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkLFxuICAgICAgICBncm91cElkID0gZGF0YS5ncm91cElkLFxuICAgICAgICB0cmFjayA9IGRhdGEudHJhY2s7XG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICB0aGlzLndhcm4oXCJBdWRpbyB0cmFja3MgcmVzZXQgd2hpbGUgbG9hZGluZyB0cmFjayBcIiArIHRyYWNrSWQgKyBcIiBcXFwiXCIgKyB0cmFjay5uYW1lICsgXCJcXFwiIG9mIFxcXCJcIiArIGdyb3VwSWQgKyBcIlxcXCJcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtYWluRGV0YWlscyA9IHRoaXMubWFpbkRldGFpbHM7XG4gICAgICBpZiAoIW1haW5EZXRhaWxzIHx8IG5ld0RldGFpbHMuZW5kQ0MgPiBtYWluRGV0YWlscy5lbmRDQyB8fCBtYWluRGV0YWlscy5leHBpcmVkKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmxvZyhcIkF1ZGlvIHRyYWNrIFwiICsgdHJhY2tJZCArIFwiIFxcXCJcIiArIHRyYWNrLm5hbWUgKyBcIlxcXCIgb2YgXFxcIlwiICsgZ3JvdXBJZCArIFwiXFxcIiBsb2FkZWQgW1wiICsgbmV3RGV0YWlscy5zdGFydFNOICsgXCIsXCIgKyBuZXdEZXRhaWxzLmVuZFNOICsgXCJdXCIgKyAobmV3RGV0YWlscy5sYXN0UGFydFNuID8gXCJbcGFydC1cIiArIG5ld0RldGFpbHMubGFzdFBhcnRTbiArIFwiLVwiICsgbmV3RGV0YWlscy5sYXN0UGFydEluZGV4ICsgXCJdXCIgOiAnJykgKyBcIixkdXJhdGlvbjpcIiArIG5ld0RldGFpbHMudG90YWxkdXJhdGlvbik7XG4gICAgICB2YXIgdHJhY2tMZXZlbCA9IGxldmVsc1t0cmFja0lkXTtcbiAgICAgIHZhciBzbGlkaW5nID0gMDtcbiAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF90cmFja0xldmVsJGRldGFpbHMgPSB0cmFja0xldmVsLmRldGFpbHMpICE9IG51bGwgJiYgX3RyYWNrTGV2ZWwkZGV0YWlscy5saXZlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tMaXZlVXBkYXRlKG5ld0RldGFpbHMpO1xuICAgICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2tMZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCB0cmFja0xldmVsLmRldGFpbHMsIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld0RldGFpbHMuYWxpZ25lZFNsaWRpbmcpIHtcbiAgICAgICAgICAvLyBBbGlnbiBhdWRpbyByZW5kaXRpb24gd2l0aCB0aGUgXCJtYWluXCIgcGxheWxpc3Qgb24gZGlzY29udGludWl0eSBjaGFuZ2VcbiAgICAgICAgICAvLyBvciBwcm9ncmFtLWRhdGUtdGltZSAoUERUKVxuICAgICAgICAgIGFsaWduRGlzY29udGludWl0aWVzKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgICBpZiAoIW5ld0RldGFpbHMuYWxpZ25lZFNsaWRpbmcpIHtcbiAgICAgICAgICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhY2tMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gdHJhY2tMZXZlbDtcblxuICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiB3ZSBhcmUgYWxpZ25lZCB3aXRoIHRoZSBtYWluIHBsYXlsaXN0XG4gICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbihtYWluRGV0YWlscywgc2xpZGluZyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19VUERBVEVELCB7XG4gICAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICAgIGlkOiB0cmFja0lkLFxuICAgICAgICBncm91cElkOiBkYXRhLmdyb3VwSWRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBvbmx5IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciB0cmFjayB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfVFJBQ0sgJiYgIXRoaXMud2FpdEZvckNkblR1bmVJbihuZXdEZXRhaWxzKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cblxuICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpIHtcbiAgICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgdmFyIHBhcnQgPSBkYXRhLnBhcnQsXG4gICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQsXG4gICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiQXVkaW8gdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIHdpbGwgbm90IGJlIGJ1ZmZlcmVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdHJhY2sgPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIHRoaXMud2FybignQXVkaW8gdHJhY2sgaXMgdW5kZWZpbmVkIG9uIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMud2FybignQXVkaW8gdHJhY2sgZGV0YWlscyB1bmRlZmluZWQgb24gZnJhZ21lbnQgbG9hZCBwcm9ncmVzcycpO1xuICAgICAgICB0aGlzLnJlbW92ZVVuYnVmZmVyZWRGcmFncyhmcmFnLnN0YXJ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGF1ZGlvQ29kZWMgPSBjb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgdHJhY2suYXVkaW9Db2RlYyB8fCAnbXA0YS40MC4yJztcbiAgICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuICAgICAgaWYgKCF0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlckludGVyZmFjZSh0aGlzLmhscywgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHZpZGVvIGluaXRQVFNcbiAgICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG4gICAgICB2YXIgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICAgIHZhciBpbml0U2VnbWVudERhdGEgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQuZGF0YTtcbiAgICAgIGlmIChpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhpcy5sb2coYFRyYW5zbXV4aW5nICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy8gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgICAgICB2YXIgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBwYXJ0SW5kZXggIT09IC0xO1xuICAgICAgICB2YXIgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50LCBwYXlsb2FkLmJ5dGVMZW5ndGgsIHBhcnRJbmRleCwgcGFydGlhbCk7XG4gICAgICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsICcnLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nKFwiVW5rbm93biB2aWRlbyBQVFMgZm9yIGNjIFwiICsgZnJhZy5jYyArIFwiLCB3YWl0aW5nIGZvciB2aWRlbyBQVFMgYmVmb3JlIGRlbXV4aW5nIGF1ZGlvIGZyYWcgXCIgKyBmcmFnLnNuICsgXCIgb2YgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCIgLFwiICsgZGV0YWlscy5lbmRTTiArIFwiXSx0cmFjayBcIiArIHRyYWNrSWQpO1xuICAgICAgICB2YXIgX3RoaXMkd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YSB8fCB7XG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgIGNhY2hlOiBuZXcgQ2h1bmtDYWNoZSgpLFxuICAgICAgICAgICAgY29tcGxldGU6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYWNoZSA9IF90aGlzJHdhaXRpbmdEYXRhLmNhY2hlO1xuICAgICAgICBjYWNoZS5wdXNoKG5ldyBVaW50OEFycmF5KHBheWxvYWQpKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSkge1xuICAgICAgaWYgKHRoaXMud2FpdGluZ0RhdGEpIHtcbiAgICAgICAgdGhpcy53YWl0aW5nRGF0YS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlLmNhbGwodGhpcywgZnJhZ0xvYWRlZERhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvbiBvbkJ1ZmZlclJlc2V0KC8qIGV2ZW50OiBFdmVudHMuQlVGRkVSX1JFU0VUICovXG4gICAgKSB7XG4gICAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gc291cmNlYnVmZmVyc1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICB2YXIgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IGF1ZGlvVHJhY2suYnVmZmVyIHx8IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnTG9hZGluZyA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIGlmICghdGhpcy5hdWRpb09ubHkgJiYgZGF0YS5mcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gJiYgaXNNZWRpYUZyYWdtZW50KGRhdGEuZnJhZykpIHtcbiAgICAgICAgdGhpcy5tYWluRnJhZ0xvYWRpbmcgPSBkYXRhO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSURMRSkge1xuICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG4gICAgICBpZiAoZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTykge1xuICAgICAgICBpZiAoIXRoaXMuYXVkaW9Pbmx5ICYmIGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiAhZnJhZy5lbGVtZW50YXJ5U3RyZWFtcy52aWRlbyAmJiAhZnJhZy5lbGVtZW50YXJ5U3RyZWFtcy5hdWRpb3ZpZGVvKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb09ubHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubWFpbkZyYWdMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBzdGF0ZSBiYWNrIHRvIElETEUgb3IgY29uY2x1ZGluZyB0aGUgYXVkaW8gc3dpdGNoOyBvdGhlcndpc2UsIHRoZSBzd2l0Y2hlZC10byB0cmFjayB3aWxsIG5vdCBidWZmZXJcbiAgICAgICAgdGhpcy53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgKHBhcnQgPyAnIHA6ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgZmluaXNoZWQgYnVmZmVyaW5nLCBidXQgd2FzIGFib3J0ZWQuIHN0YXRlOiBcIiArIHRoaXMuc3RhdGUgKyBcIiwgYXVkaW9Td2l0Y2g6IFwiICsgKHRoaXMuc3dpdGNoaW5nVHJhY2sgPyB0aGlzLnN3aXRjaGluZ1RyYWNrLm5hbWUgOiAnZmFsc2UnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc01lZGlhRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnN3aXRjaGluZ1RyYWNrO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSB0cmFjaztcbiAgICAgICAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgX29iamVjdFNwcmVhZDIoe30sIHRyYWNrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9kYXRhJGNvbnRleHQ7XG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfR0FQOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIGRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0cmFjaywgaWYgbm90IHJldHJ5aW5nIHRvIGxvYWQgdHJhY2ssIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLICYmICgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGNvbnRleHQudHlwZSkgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgICBpZiAoZGF0YS5wYXJlbnQgIT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgICBpZiAoZGF0YS5wYXJlbnQgIT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IG51bGw7XG4gICAgICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmZsdXNoTWFpbkJ1ZmZlci5jYWxsKHRoaXMsIDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJ2F1ZGlvJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT046XG4gICAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIF9yZWYzKSB7XG4gICAgICB2YXIgdHlwZSA9IF9yZWYzLnR5cGU7XG4gICAgICBpZiAodHlwZSAhPT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICAgIHRoaXMuZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uQnVmZmVyRmx1c2hlZCA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hlZChldmVudCwgX3JlZjQpIHtcbiAgICAgIHZhciB0eXBlID0gX3JlZjQudHlwZTtcbiAgICAgIGlmICh0eXBlICE9PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgdGhpcy5mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyIHx8IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYUJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhQnVmZmVyLCB0eXBlLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0KSB7XG4gICAgICB2YXIgX2lkMyRzYW1wbGVzO1xuICAgICAgdmFyIGlkID0gJ2F1ZGlvJztcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHZhciByZW11eFJlc3VsdCA9IHRyYW5zbXV4UmVzdWx0LnJlbXV4UmVzdWx0LFxuICAgICAgICBjaHVua01ldGEgPSB0cmFuc211eFJlc3VsdC5jaHVua01ldGE7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWw7XG4gICAgICB2YXIgZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICB2YXIgYXVkaW8gPSByZW11eFJlc3VsdC5hdWRpbyxcbiAgICAgICAgdGV4dCA9IHJlbXV4UmVzdWx0LnRleHQsXG4gICAgICAgIGlkMyA9IHJlbXV4UmVzdWx0LmlkMyxcbiAgICAgICAgaW5pdFNlZ21lbnQgPSByZW11eFJlc3VsdC5pbml0U2VnbWVudDtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgIC8vIElmIHdlIGFyZSwgc3Vic2VxdWVudGx5IGNoZWNrIGlmIHRoZSBjdXJyZW50bHkgbG9hZGluZyBmcmFnbWVudCAoZnJhZ0N1cnJlbnQpIGhhcyBjaGFuZ2VkLlxuICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpIHx8ICFkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyYWNrICYmIGF1ZGlvKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGVBdWRpb1N3aXRjaCh0aGlzLnN3aXRjaGluZ1RyYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LnRyYWNrcykge1xuICAgICAgICB2YXIgbWFwRnJhZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50IHx8IGZyYWc7XG4gICAgICAgIGlmICh0aGlzLnVuaGFuZGxlZEVuY3J5cHRpb25FcnJvcihpbml0U2VnbWVudCwgZnJhZykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIGluaXRTZWdtZW50LnRyYWNrcywgbWFwRnJhZ21lbnQsIGNodW5rTWV0YSk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgICAgZnJhZzogbWFwRnJhZ21lbnQsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICAgIH1cbiAgICAgIGlmIChhdWRpbykge1xuICAgICAgICB2YXIgc3RhcnRQVFMgPSBhdWRpby5zdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMgPSBhdWRpby5lbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMgPSBhdWRpby5zdGFydERUUyxcbiAgICAgICAgICBlbmREVFMgPSBhdWRpby5lbmREVFM7XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0ge1xuICAgICAgICAgICAgc3RhcnRQVFM6IHN0YXJ0UFRTLFxuICAgICAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgICAgICBzdGFydERUUzogc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFM6IGVuZERUU1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZDMgIT0gbnVsbCAmJiAoX2lkMyRzYW1wbGVzID0gaWQzLnNhbXBsZXMpICE9IG51bGwgJiYgX2lkMyRzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZW1pdHRlZElEMyA9IF9leHRlbmRzKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzXG4gICAgICAgIH0sIGlkMyk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGVtaXR0ZWRUZXh0ID0gX2V4dGVuZHMoe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGRldGFpbHM6IGRldGFpbHNcbiAgICAgICAgfSwgdGV4dCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5fYnVmZmVySW5pdFNlZ21lbnQgPSBmdW5jdGlvbiBfYnVmZmVySW5pdFNlZ21lbnQoY3VycmVudExldmVsLCB0cmFja3MsIGZyYWcsIGNodW5rTWV0YSkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZGVsZXRlIGFueSB2aWRlbyB0cmFjayBmb3VuZCBvbiBhdWRpbyB0cmFuc211eGVyXG4gICAgICBpZiAodHJhY2tzLnZpZGVvKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFja3MudmlkZW87XG4gICAgICB9XG4gICAgICBpZiAodHJhY2tzLmF1ZGlvdmlkZW8pIHtcbiAgICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpb3ZpZGVvO1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgaWYgKCF0cmFja3MuYXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgdHJhY2suaWQgPSBQbGF5bGlzdExldmVsVHlwZS5BVURJTztcbiAgICAgIHZhciB2YXJpYW50QXVkaW9Db2RlY3MgPSBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIHRyYWNrLmNvbnRhaW5lciArIFwiLCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bXCIgKyB2YXJpYW50QXVkaW9Db2RlY3MgKyBcIi9cIiArIHRyYWNrLmNvZGVjICsgXCJdXCIpO1xuICAgICAgLy8gU291cmNlQnVmZmVyIHdpbGwgdXNlIHRyYWNrLmxldmVsQ29kZWMgaWYgZGVmaW5lZFxuICAgICAgaWYgKHZhcmlhbnRBdWRpb0NvZGVjcyAmJiB2YXJpYW50QXVkaW9Db2RlY3Muc3BsaXQoJywnKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHZhcmlhbnRBdWRpb0NvZGVjcztcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgZGF0YTogaW5pdFNlZ21lbnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywgc2VnbWVudCk7XG4gICAgICB9XG4gICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkIG9yIGlmIGluIGF1ZGlvIHN3aXRjaFxuICAgICAgdmFyIGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuXG4gICAgICAvLyB3ZSBmb3JjZSBhIGZyYWcgbG9hZGluZyBpbiBhdWRpbyBzd2l0Y2ggYXMgZnJhZ21lbnQgdHJhY2tlciBtaWdodCBub3QgaGF2ZSBldmljdGVkIHByZXZpb3VzIGZyYWdzIGluIGNhc2Ugb2YgcXVpY2sgYXVkaW8gc3dpdGNoXG4gICAgICBpZiAodGhpcy5zd2l0Y2hpbmdUcmFjayB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgICB2YXIgX3RyYWNrJGRldGFpbHM7XG4gICAgICAgIGlmICghaXNNZWRpYUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICAgICAgdGhpcy5fbG9hZEluaXRTZWdtZW50KGZyYWcsIHRyYWNrKTtcbiAgICAgICAgfSBlbHNlIGlmICgoX3RyYWNrJGRldGFpbHMgPSB0cmFjay5kZXRhaWxzKSAhPSBudWxsICYmIF90cmFjayRkZXRhaWxzLmxpdmUgJiYgIXRoaXMuaW5pdFBUU1tmcmFnLmNjXSkge1xuICAgICAgICAgIHRoaXMubG9nKFwiV2FpdGluZyBmb3IgdmlkZW8gUFRTIGluIGNvbnRpbnVpdHkgY291bnRlciBcIiArIGZyYWcuY2MgKyBcIiBvZiBsaXZlIHN0cmVhbSBiZWZvcmUgbG9hZGluZyBhdWRpbyBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIHRoaXMudHJhY2tJZCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgICAgdmFyIG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgICAgICBpZiAobWFpbkRldGFpbHMgJiYgbWFpbkRldGFpbHMuZnJhZ21lbnRTdGFydCAhPT0gdHJhY2suZGV0YWlscy5mcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVCh0cmFjay5kZXRhaWxzLCBtYWluRGV0YWlscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUubG9hZEZyYWdtZW50LmNhbGwodGhpcywgZnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoQXVkaW9JZk5lZWRlZCA9IGZ1bmN0aW9uIGZsdXNoQXVkaW9JZk5lZWRlZChzd2l0Y2hpbmdUcmFjaykge1xuICAgICAgaWYgKHRoaXMubWVkaWEgJiYgdGhpcy5idWZmZXJlZFRyYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyRidWZmZXJlZFRyYWNrID0gdGhpcy5idWZmZXJlZFRyYWNrLFxuICAgICAgICAgIG5hbWUgPSBfdGhpcyRidWZmZXJlZFRyYWNrLm5hbWUsXG4gICAgICAgICAgbGFuZyA9IF90aGlzJGJ1ZmZlcmVkVHJhY2subGFuZyxcbiAgICAgICAgICBhc3NvY0xhbmcgPSBfdGhpcyRidWZmZXJlZFRyYWNrLmFzc29jTGFuZyxcbiAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3MgPSBfdGhpcyRidWZmZXJlZFRyYWNrLmNoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgICBhdWRpb0NvZGVjID0gX3RoaXMkYnVmZmVyZWRUcmFjay5hdWRpb0NvZGVjLFxuICAgICAgICAgIGNoYW5uZWxzID0gX3RoaXMkYnVmZmVyZWRUcmFjay5jaGFubmVscztcbiAgICAgICAgaWYgKCFtYXRjaGVzT3B0aW9uKHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgICAgYXNzb2NMYW5nOiBhc3NvY0xhbmcsXG4gICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgYXVkaW9Db2RlYzogYXVkaW9Db2RlYyxcbiAgICAgICAgICBjaGFubmVsczogY2hhbm5lbHNcbiAgICAgICAgfSwgc3dpdGNoaW5nVHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgICAgaWYgKHVzZUFsdGVybmF0ZUF1ZGlvKHN3aXRjaGluZ1RyYWNrLnVybCwgdGhpcy5obHMpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogZmx1c2hpbmcgYWxsIGF1ZGlvJyk7XG4gICAgICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmZsdXNoTWFpbkJ1ZmZlci5jYWxsKHRoaXMsIDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJ2F1ZGlvJyk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWluIGlzIGJlaW5nIGJ1ZmZlcmVkLiBTZXQgYnVmZmVyZWRUcmFjayBzbyB0aGF0IGl0IGlzIGZsdXNoZWQgd2hlbiBzd2l0Y2hpbmcgYmFjayB0byBhbHQtYXVkaW9cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IHN3aXRjaGluZ1RyYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNvbXBsZXRlQXVkaW9Td2l0Y2ggPSBmdW5jdGlvbiBjb21wbGV0ZUF1ZGlvU3dpdGNoKHN3aXRjaGluZ1RyYWNrKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICB0aGlzLmZsdXNoQXVkaW9JZk5lZWRlZChzd2l0Y2hpbmdUcmFjayk7XG4gICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBzd2l0Y2hpbmdUcmFjaztcbiAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBfb2JqZWN0U3ByZWFkMih7fSwgc3dpdGNoaW5nVHJhY2spKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4gIH0oQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIHZhciBCYXNlUGxheWxpc3RDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9nZ2VyKSB7XG4gICAgZnVuY3Rpb24gQmFzZVBsYXlsaXN0Q29udHJvbGxlcihobHMsIGxvZ1ByZWZpeCkge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfTG9nZ2VyLmNhbGwodGhpcywgbG9nUHJlZml4LCBobHMubG9nZ2VyKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgX3RoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgICAgX3RoaXMudGltZXIgPSAtMTtcbiAgICAgIF90aGlzLmhscyA9IGhscztcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoQmFzZVBsYXlsaXN0Q29udHJvbGxlciwgX0xvZ2dlcik7XG4gICAgdmFyIF9wcm90byA9IEJhc2VQbGF5bGlzdENvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYXJUaW1lciA9IGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XG4gICAgICBpZiAodGhpcy50aW1lciAhPT0gLTEpIHtcbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoKSB7XG4gICAgICB0aGlzLmNhbkxvYWQgPSB0cnVlO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgICB9O1xuICAgIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgICAgdGhpcy5jYW5Mb2FkID0gZmFsc2U7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9O1xuICAgIF9wcm90by5zd2l0Y2hQYXJhbXMgPSBmdW5jdGlvbiBzd2l0Y2hQYXJhbXMocGxheWxpc3RVcmksIHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgICB2YXIgcmVuZGl0aW9uUmVwb3J0cyA9IHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5yZW5kaXRpb25SZXBvcnRzO1xuICAgICAgaWYgKHJlbmRpdGlvblJlcG9ydHMpIHtcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW5kaXRpb25SZXBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICAgIHZhciB1cmkgPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVyaSA9IG5ldyBzZWxmLlVSTChhdHRyLlVSSSwgcHJldmlvdXMudXJsKS5ocmVmO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgZm9yIFJlbmRpdGlvbiBSZXBvcnQ6IFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgdXJpID0gYXR0ci5VUkkgfHwgJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVzZSBleGFjdCBtYXRjaC4gT3RoZXJ3aXNlLCB0aGUgbGFzdCBwYXJ0aWFsIG1hdGNoLCBpZiBhbnksIHdpbGwgYmUgdXNlZFxuICAgICAgICAgIC8vIChQbGF5bGlzdCBVUkkgaW5jbHVkZXMgYSBxdWVyeSBzdHJpbmcgdGhhdCB0aGUgUmVuZGl0aW9uIFJlcG9ydCBkb2VzIG5vdClcbiAgICAgICAgICBpZiAodXJpID09PSBwbGF5bGlzdFVyaSkge1xuICAgICAgICAgICAgZm91bmRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHVyaSA9PT0gcGxheWxpc3RVcmkuc3Vic3RyaW5nKDAsIHVyaS5sZW5ndGgpKSB7XG4gICAgICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgdmFyIF9hdHRyID0gcmVuZGl0aW9uUmVwb3J0c1tmb3VuZEluZGV4XTtcbiAgICAgICAgICB2YXIgbXNuID0gcGFyc2VJbnQoX2F0dHJbJ0xBU1QtTVNOJ10pIHx8IHByZXZpb3VzLmxhc3RQYXJ0U247XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJzZUludChfYXR0clsnTEFTVC1QQVJUJ10pIHx8IHByZXZpb3VzLmxhc3RQYXJ0SW5kZXg7XG4gICAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRHb2FsID0gTWF0aC5taW4ocHJldmlvdXMuYWdlIC0gcHJldmlvdXMucGFydFRhcmdldCwgcHJldmlvdXMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHBhcnQgPj0gMCAmJiBjdXJyZW50R29hbCA+IHByZXZpb3VzLnBhcnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgcGFydCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2tpcCA9IGN1cnJlbnQgJiYgZ2V0U2tpcFZhbHVlKGN1cnJlbnQpO1xuICAgICAgICAgIHJldHVybiBuZXcgSGxzVXJsUGFyYW1ldGVycyhtc24sIHBhcnQgPj0gMCA/IHBhcnQgOiB1bmRlZmluZWQsIHNraXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgIC8vIExvYWRpbmcgaXMgaGFuZGxlZCBieSB0aGUgc3ViY2xhc3Nlc1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZGluZ1BsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZGluZ1BsYXlsaXN0KHBsYXlsaXN0LCBobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAvLyBMb2FkaW5nIGlzIGhhbmRsZWQgYnkgdGhlIHN1YmNsYXNzZXNcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH07XG4gICAgX3Byb3RvLnNob3VsZExvYWRQbGF5bGlzdCA9IGZ1bmN0aW9uIHNob3VsZExvYWRQbGF5bGlzdChwbGF5bGlzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FuTG9hZCAmJiAhIXBsYXlsaXN0ICYmICEhcGxheWxpc3QudXJsICYmICghcGxheWxpc3QuZGV0YWlscyB8fCBwbGF5bGlzdC5kZXRhaWxzLmxpdmUpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFVybFdpdGhEaXJlY3RpdmVzID0gZnVuY3Rpb24gZ2V0VXJsV2l0aERpcmVjdGl2ZXModXJpLCBobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICBpZiAoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmk7XG4gICAgfTtcbiAgICBfcHJvdG8ucGxheWxpc3RMb2FkZWQgPSBmdW5jdGlvbiBwbGF5bGlzdExvYWRlZChpbmRleCwgZGF0YSwgcHJldmlvdXNEZXRhaWxzKSB7XG4gICAgICB2YXIgZGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgc3RhdHMgPSBkYXRhLnN0YXRzO1xuXG4gICAgICAvLyBTZXQgbGFzdCB1cGRhdGVkIGRhdGUtdGltZVxuICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgZWxhcHNlZCA9IHN0YXRzLmxvYWRpbmcuZmlyc3QgPyBNYXRoLm1heCgwLCBub3cgLSBzdGF0cy5sb2FkaW5nLmZpcnN0KSA6IDA7XG4gICAgICBkZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWUgPSBEYXRlLm5vdygpIC0gZWxhcHNlZDtcblxuICAgICAgLy8gc2hpZnQgZnJhZ21lbnQgc3RhcnRzIHdpdGggdGltZWxpbmVPZmZzZXRcbiAgICAgIHZhciB0aW1lbGluZU9mZnNldCA9IHRoaXMuaGxzLmNvbmZpZy50aW1lbGluZU9mZnNldDtcbiAgICAgIGlmICh0aW1lbGluZU9mZnNldCAhPT0gZGV0YWlscy5hcHBsaWVkVGltZWxpbmVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGgubWF4KHRpbWVsaW5lT2Zmc2V0IHx8IDAsIDApO1xuICAgICAgICBkZXRhaWxzLmFwcGxpZWRUaW1lbGluZU9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICAgIGZyYWcuc2V0U3RhcnQoZnJhZy5wbGF5bGlzdE9mZnNldCArIG9mZnNldCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdCwgYXJtIGEgdGltZXIgdG8gcmVsb2FkIGl0XG4gICAgICBpZiAoZGV0YWlscy5saXZlIHx8IHByZXZpb3VzRGV0YWlscyAhPSBudWxsICYmIHByZXZpb3VzRGV0YWlscy5saXZlKSB7XG4gICAgICAgIHZhciBsZXZlbE9yVHJhY2sgPSAnbGV2ZWxJbmZvJyBpbiBkYXRhID8gZGF0YS5sZXZlbEluZm8gOiBkYXRhLnRyYWNrO1xuICAgICAgICBkZXRhaWxzLnJlbG9hZGVkKHByZXZpb3VzRGV0YWlscyk7XG4gICAgICAgIC8vIE1lcmdlIGxpdmUgcGxheWxpc3RzIHRvIGFkanVzdCBmcmFnbWVudCBzdGFydHMgYW5kIGZpbGwgaW4gZGVsdGEgcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuICAgICAgICBpZiAocHJldmlvdXNEZXRhaWxzICYmIGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBtZXJnZURldGFpbHMocHJldmlvdXNEZXRhaWxzLCBkZXRhaWxzLCB0aGlzKTtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBkZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yO1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy53YXJuKGVycm9yKTtcbiAgICAgICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgICAgIGlmICghaGxzLmNvbmZpZy5pZ25vcmVQbGF5bGlzdFBhcnNpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgICAgdmFyIF9kZXRhaWxzJGZyYWdtZW50cyQ7XG4gICAgICAgICAgICAgIHZhciBuZXR3b3JrRGV0YWlscyA9IGRhdGEubmV0d29ya0RldGFpbHM7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdXJsOiBkZXRhaWxzLnVybCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGxldmVsOiBkYXRhLmxldmVsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IChfZGV0YWlscyRmcmFnbWVudHMkID0gZGV0YWlscy5mcmFnbWVudHNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZGV0YWlscyRmcmFnbWVudHMkLnR5cGUsXG4gICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICAgIHN0YXRzOiBzdGF0c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRhaWxzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xKSB7XG4gICAgICAgICAgZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8uZW5kIC0gYnVmZmVySW5mby5sZW4gOiAwO1xuICAgICAgICB2YXIgZGlzdGFuY2VUb0xpdmVFZGdlTXMgPSAoZGV0YWlscy5lZGdlIC0gcG9zaXRpb24pICogMTAwMDtcbiAgICAgICAgdmFyIHJlbG9hZEludGVydmFsID0gY29tcHV0ZVJlbG9hZEludGVydmFsKGRldGFpbHMsIGRpc3RhbmNlVG9MaXZlRWRnZU1zKTtcbiAgICAgICAgaWYgKGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZCArIHJlbG9hZEludGVydmFsIDwgbm93KSB7XG4gICAgICAgICAgZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID0gbm93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZCArPSByZWxvYWRJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZyhcImxpdmUgcGxheWxpc3QgXCIgKyBpbmRleCArIFwiIFwiICsgKGRldGFpbHMuYWR2YW5jZWQgPyAnUkVGUkVTSEVEICcgKyBkZXRhaWxzLmxhc3RQYXJ0U24gKyAnLScgKyBkZXRhaWxzLmxhc3RQYXJ0SW5kZXggOiBkZXRhaWxzLnVwZGF0ZWQgPyAnVVBEQVRFRCcgOiAnTUlTU0VEJykpO1xuICAgICAgICBpZiAoIXRoaXMuY2FuTG9hZCB8fCAhZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxpdmVyeURpcmVjdGl2ZXM7XG4gICAgICAgIHZhciBtc24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBwYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGV0YWlscy5jYW5CbG9ja1JlbG9hZCAmJiBkZXRhaWxzLmVuZFNOICYmIGRldGFpbHMuYWR2YW5jZWQpIHtcbiAgICAgICAgICAvLyBMb2FkIGxldmVsIHdpdGggTEwtSExTIGRlbGl2ZXJ5IGRpcmVjdGl2ZXNcbiAgICAgICAgICB2YXIgbG93TGF0ZW5jeU1vZGUgPSB0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gICAgICAgICAgdmFyIGxhc3RQYXJ0U24gPSBkZXRhaWxzLmxhc3RQYXJ0U247XG4gICAgICAgICAgdmFyIGVuZFNuID0gZGV0YWlscy5lbmRTTjtcbiAgICAgICAgICB2YXIgbGFzdFBhcnRJbmRleCA9IGRldGFpbHMubGFzdFBhcnRJbmRleDtcbiAgICAgICAgICB2YXIgaGFzUGFydHMgPSBsYXN0UGFydEluZGV4ICE9PSAtMTtcbiAgICAgICAgICB2YXIgYXRMYXN0UGFydE9mU2VnbWVudCA9IGxhc3RQYXJ0U24gPT09IGVuZFNuO1xuICAgICAgICAgIGlmIChoYXNQYXJ0cykge1xuICAgICAgICAgICAgLy8gV2hlbiBsb3cgbGF0ZW5jeSBtb2RlIGlzIGRpc2FibGVkLCByZXF1ZXN0IHRoZSBsYXN0IHBhcnQgb2YgdGhlIG5leHQgc2VnbWVudFxuICAgICAgICAgICAgaWYgKGF0TGFzdFBhcnRPZlNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgbXNuID0gZW5kU24gKyAxO1xuICAgICAgICAgICAgICBwYXJ0ID0gbG93TGF0ZW5jeU1vZGUgPyAwIDogbGFzdFBhcnRJbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1zbiA9IGxhc3RQYXJ0U247XG4gICAgICAgICAgICAgIHBhcnQgPSBsb3dMYXRlbmN5TW9kZSA/IGxhc3RQYXJ0SW5kZXggKyAxIDogZGV0YWlscy5tYXhQYXJ0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1zbiA9IGVuZFNuICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW46IFwiYWdlXCIgaGVhZGVyIGFuZCB0aW1lIHNpbmNlIGxvYWQgaW5kaWNhdGVzIHdlJ3JlIGJlaGluZCBieSBtb3JlIHRoYW4gb25lIHBhcnRcbiAgICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aXZlcyB0byBvYnRhaW4gdGhlIFBsYXlsaXN0IHRoYXQgaGFzIHRoZSBlc3RpbWF0ZWQgYWRkaXRpb25hbCBkdXJhdGlvbiBvZiBtZWRpYVxuICAgICAgICAgIHZhciBsYXN0QWR2YW5jZWQgPSBkZXRhaWxzLmFnZTtcbiAgICAgICAgICB2YXIgY2RuQWdlID0gbGFzdEFkdmFuY2VkICsgZGV0YWlscy5hZ2VIZWFkZXI7XG4gICAgICAgICAgdmFyIGN1cnJlbnRHb2FsID0gTWF0aC5taW4oY2RuQWdlIC0gZGV0YWlscy5wYXJ0VGFyZ2V0LCBkZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMS41KTtcbiAgICAgICAgICBpZiAoY3VycmVudEdvYWwgPiAwKSB7XG4gICAgICAgICAgICBpZiAoY2RuQWdlID4gZGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDMpIHtcbiAgICAgICAgICAgICAgLy8gT21pdCBzZWdtZW50IGFuZCBwYXJ0IGRpcmVjdGl2ZXMgd2hlbiB0aGUgbGFzdCByZXNwb25zZSB3YXMgbW9yZSB0aGFuIDMgdGFyZ2V0IGR1cmF0aW9ucyBhZ28sXG4gICAgICAgICAgICAgIHRoaXMubG9nKFwiUGxheWxpc3QgbGFzdCBhZHZhbmNlZCBcIiArIGxhc3RBZHZhbmNlZC50b0ZpeGVkKDIpICsgXCJzIGFnby4gT21pdHRpbmcgc2VnbWVudCBhbmQgcGFydCBkaXJlY3RpdmVzLlwiKTtcbiAgICAgICAgICAgICAgbXNuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBwYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c0RldGFpbHMgIT0gbnVsbCAmJiBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCAmJiBjZG5BZ2UgLSBkZXRhaWxzLnBhcnRUYXJnZXQgPiBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCkge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSBuZXh0IG9yIGxhdGVzdCBwbGF5bGlzdCB1cGRhdGUsIGJ1dCBjdXJyZW50R29hbCBpbmNyZWFzZWQsXG4gICAgICAgICAgICAgIC8vIHRoZW4gd2UgZWl0aGVyIGNhbid0IGNhdGNodXAsIG9yIHRoZSBcImFnZVwiIGhlYWRlciBjYW5ub3QgYmUgdHJ1c3RlZC5cbiAgICAgICAgICAgICAgdGhpcy53YXJuKFwiQ0ROIFR1bmUtaW4gZ29hbCBpbmNyZWFzZWQgZnJvbTogXCIgKyBwcmV2aW91c0RldGFpbHMudHVuZUluR29hbCArIFwiIHRvOiBcIiArIGN1cnJlbnRHb2FsICsgXCIgd2l0aCBwbGF5bGlzdCBhZ2U6IFwiICsgZGV0YWlscy5hZ2UpO1xuICAgICAgICAgICAgICBjdXJyZW50R29hbCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBNYXRoLmZsb29yKGN1cnJlbnRHb2FsIC8gZGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgICAgICAgIG1zbiArPSBzZWdtZW50cztcbiAgICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IE1hdGgucm91bmQoY3VycmVudEdvYWwgJSBkZXRhaWxzLnRhcmdldGR1cmF0aW9uIC8gZGV0YWlscy5wYXJ0VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBwYXJ0ICs9IHBhcnRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMubG9nKFwiQ0ROIFR1bmUtaW4gYWdlOiBcIiArIGRldGFpbHMuYWdlSGVhZGVyICsgXCJzIGxhc3QgYWR2YW5jZWQgXCIgKyBsYXN0QWR2YW5jZWQudG9GaXhlZCgyKSArIFwicyBnb2FsOiBcIiArIGN1cnJlbnRHb2FsICsgXCIgc2tpcCBzbiBcIiArIHNlZ21lbnRzICsgXCIgdG8gcGFydCBcIiArIHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0YWlscy50dW5lSW5Hb2FsID0gY3VycmVudEdvYWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpO1xuICAgICAgICAgIGlmIChsb3dMYXRlbmN5TW9kZSB8fCAhYXRMYXN0UGFydE9mU2VnbWVudCkge1xuICAgICAgICAgICAgZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID0gbm93O1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nUGxheWxpc3QobGV2ZWxPclRyYWNrLCBkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkIHx8IGRldGFpbHMuY2FuU2tpcFVudGlsKSB7XG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gdGhpcy5nZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGl2ZXJ5RGlyZWN0aXZlcyAmJiBtc24gIT09IHVuZGVmaW5lZCAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkKSB7XG4gICAgICAgICAgZGV0YWlscy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5maXJzdCArIE1hdGgubWF4KHJlbG9hZEludGVydmFsIC0gZWxhcHNlZCAqIDIsIHJlbG9hZEludGVydmFsIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZUxvYWRpbmcobGV2ZWxPclRyYWNrLCBkZWxpdmVyeURpcmVjdGl2ZXMsIGRldGFpbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc2NoZWR1bGVMb2FkaW5nID0gZnVuY3Rpb24gc2NoZWR1bGVMb2FkaW5nKGxldmVsT3JUcmFjaywgZGVsaXZlcnlEaXJlY3RpdmVzLCB1cGRhdGVkRGV0YWlscykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgZGV0YWlscyA9IHVwZGF0ZWREZXRhaWxzIHx8IGxldmVsT3JUcmFjay5kZXRhaWxzO1xuICAgICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1BsYXlsaXN0KGxldmVsT3JUcmFjaywgZGVsaXZlcnlEaXJlY3RpdmVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgcmVxdWVzdFNjaGVkdWxlZCA9IGRldGFpbHMucmVxdWVzdFNjaGVkdWxlZDtcbiAgICAgIGlmIChub3cgPj0gcmVxdWVzdFNjaGVkdWxlZCkge1xuICAgICAgICB0aGlzLmxvYWRpbmdQbGF5bGlzdChsZXZlbE9yVHJhY2ssIGRlbGl2ZXJ5RGlyZWN0aXZlcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSByZXF1ZXN0U2NoZWR1bGVkIC0gbm93O1xuICAgICAgdGhpcy5sb2coXCJyZWxvYWQgbGl2ZSBwbGF5bGlzdCBcIiArIChsZXZlbE9yVHJhY2submFtZSB8fCBsZXZlbE9yVHJhY2suYml0cmF0ZSArICdicHMnKSArIFwiIGluIFwiICsgTWF0aC5yb3VuZChlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpICsgXCIgbXNcIik7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmxvYWRpbmdQbGF5bGlzdChsZXZlbE9yVHJhY2ssIGRlbGl2ZXJ5RGlyZWN0aXZlcyk7XG4gICAgICB9LCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIGdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KSB7XG4gICAgICB2YXIgc2tpcCA9IGdldFNraXBWYWx1ZShkZXRhaWxzKTtcbiAgICAgIGlmIChwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcyAhPSBudWxsICYmIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnNraXAgJiYgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgICBtc24gPSBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcy5tc247XG4gICAgICAgIHBhcnQgPSBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcy5wYXJ0O1xuICAgICAgICBza2lwID0gSGxzU2tpcC5ObztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgSGxzVXJsUGFyYW1ldGVycyhtc24sIHBhcnQsIHNraXApO1xuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrUmV0cnkgPSBmdW5jdGlvbiBjaGVja1JldHJ5KGVycm9yRXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIGVycm9yRGV0YWlscyA9IGVycm9yRXZlbnQuZGV0YWlscztcbiAgICAgIHZhciBpc1RpbWVvdXQgPSBpc1RpbWVvdXRFcnJvcihlcnJvckV2ZW50KTtcbiAgICAgIHZhciBlcnJvckFjdGlvbiA9IGVycm9yRXZlbnQuZXJyb3JBY3Rpb247XG4gICAgICB2YXIgX3JlZiA9IGVycm9yQWN0aW9uIHx8IHt9LFxuICAgICAgICBhY3Rpb24gPSBfcmVmLmFjdGlvbixcbiAgICAgICAgX3JlZiRyZXRyeUNvdW50ID0gX3JlZi5yZXRyeUNvdW50LFxuICAgICAgICByZXRyeUNvdW50ID0gX3JlZiRyZXRyeUNvdW50ID09PSB2b2lkIDAgPyAwIDogX3JlZiRyZXRyeUNvdW50LFxuICAgICAgICByZXRyeUNvbmZpZyA9IF9yZWYucmV0cnlDb25maWc7XG4gICAgICB2YXIgcmV0cnkgPSAhIWVycm9yQWN0aW9uICYmICEhcmV0cnlDb25maWcgJiYgKGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCB8fCAhZXJyb3JBY3Rpb24ucmVzb2x2ZWQgJiYgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCk7XG4gICAgICBpZiAocmV0cnkpIHtcbiAgICAgICAgdmFyIF9lcnJvckV2ZW50JGNvbnRleHQ7XG4gICAgICAgIGlmIChyZXRyeUNvdW50ID49IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RpbWVvdXQgJiYgKF9lcnJvckV2ZW50JGNvbnRleHQgPSBlcnJvckV2ZW50LmNvbnRleHQpICE9IG51bGwgJiYgX2Vycm9yRXZlbnQkY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAvLyBUaGUgTEwtSExTIHJlcXVlc3QgYWxyZWFkeSB0aW1lZCBvdXQgc28gcmV0cnkgaW1tZWRpYXRlbHlcbiAgICAgICAgICB0aGlzLndhcm4oXCJSZXRyeWluZyBwbGF5bGlzdCBsb2FkaW5nIFwiICsgKHJldHJ5Q291bnQgKyAxKSArIFwiL1wiICsgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgKyBcIiBhZnRlciBcXFwiXCIgKyBlcnJvckRldGFpbHMgKyBcIlxcXCIgd2l0aG91dCBkZWxpdmVyeS1kaXJlY3RpdmVzXCIpO1xuICAgICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgbGV2ZWwvdHJhY2sgcmVsb2FkXG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmxvYWRQbGF5bGlzdCgpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICB0aGlzLndhcm4oXCJSZXRyeWluZyBwbGF5bGlzdCBsb2FkaW5nIFwiICsgKHJldHJ5Q291bnQgKyAxKSArIFwiL1wiICsgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgKyBcIiBhZnRlciBcXFwiXCIgKyBlcnJvckRldGFpbHMgKyBcIlxcXCIgaW4gXCIgKyBkZWxheSArIFwibXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYGxldmVsUmV0cnkgPSB0cnVlYCB1c2VkIHRvIGluZm9ybSBvdGhlciBjb250cm9sbGVycyB0aGF0IGEgcmV0cnkgaXMgaGFwcGVuaW5nXG4gICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRyeTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlUGxheWxpc3RDb250cm9sbGVyO1xuICB9KExvZ2dlcik7XG5cbiAgZnVuY3Rpb24gc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRyYWNrTGlzdDEsIHRyYWNrTGlzdDIpIHtcbiAgICBpZiAodHJhY2tMaXN0MS5sZW5ndGggIT09IHRyYWNrTGlzdDIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMaXN0MS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwodHJhY2tMaXN0MVtpXS5hdHRycywgdHJhY2tMaXN0MltpXS5hdHRycykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoYXR0cnMxLCBhdHRyczIsIGN1c3RvbUF0dHJpYnV0ZXMpIHtcbiAgICAvLyBNZWRpYSBvcHRpb25zIHdpdGggdGhlIHNhbWUgcmVuZGl0aW9uIElEIG11c3QgYmUgYml0IGlkZW50aWNhbFxuICAgIHZhciBzdGFibGVSZW5kaXRpb25JZCA9IGF0dHJzMVsnU1RBQkxFLVJFTkRJVElPTi1JRCddO1xuICAgIGlmIChzdGFibGVSZW5kaXRpb25JZCAmJiAhY3VzdG9tQXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIHN0YWJsZVJlbmRpdGlvbklkID09PSBhdHRyczJbJ1NUQUJMRS1SRU5ESVRJT04tSUQnXTtcbiAgICB9XG4gICAgLy8gV2hlbiByZW5kaXRpb24gSUQgaXMgbm90IHByZXNlbnQsIGNvbXBhcmUgYXR0cmlidXRlc1xuICAgIHJldHVybiAhKGN1c3RvbUF0dHJpYnV0ZXMgfHwgWydMQU5HVUFHRScsICdOQU1FJywgJ0NIQVJBQ1RFUklTVElDUycsICdBVVRPU0VMRUNUJywgJ0RFRkFVTFQnLCAnRk9SQ0VEJywgJ0FTU09DLUxBTkdVQUdFJ10pLnNvbWUoZnVuY3Rpb24gKHN1YnRpdGxlQXR0cmlidXRlKSB7XG4gICAgICByZXR1cm4gYXR0cnMxW3N1YnRpdGxlQXR0cmlidXRlXSAhPT0gYXR0cnMyW3N1YnRpdGxlQXR0cmlidXRlXTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayhzdWJ0aXRsZVRyYWNrLCB0ZXh0VHJhY2spIHtcbiAgICByZXR1cm4gdGV4dFRyYWNrLmxhYmVsLnRvTG93ZXJDYXNlKCkgPT09IHN1YnRpdGxlVHJhY2submFtZS50b0xvd2VyQ2FzZSgpICYmICghdGV4dFRyYWNrLmxhbmd1YWdlIHx8IHRleHRUcmFjay5sYW5ndWFnZS50b0xvd2VyQ2FzZSgpID09PSAoc3VidGl0bGVUcmFjay5sYW5nIHx8ICcnKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHZhciBBdWRpb1RyYWNrQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VQbGF5bGlzdENvbnRyb2xsKSB7XG4gICAgZnVuY3Rpb24gQXVkaW9UcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgICB2YXIgX3RoaXM7XG4gICAgICBfdGhpcyA9IF9CYXNlUGxheWxpc3RDb250cm9sbC5jYWxsKHRoaXMsIGhscywgJ2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXInKSB8fCB0aGlzO1xuICAgICAgX3RoaXMudHJhY2tzID0gW107XG4gICAgICBfdGhpcy5ncm91cElkcyA9IG51bGw7XG4gICAgICBfdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgICBfdGhpcy50cmFja0lkID0gLTE7XG4gICAgICBfdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgICAgX3RoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICAgIF90aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKEF1ZGlvVHJhY2tDb250cm9sbGVyLCBfQmFzZVBsYXlsaXN0Q29udHJvbGwpO1xuICAgIHZhciBfcHJvdG8gPSBBdWRpb1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgICAgdGhpcy5ncm91cElkcyA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzIHx8IFtdO1xuICAgIH07XG4gICAgX3Byb3RvLm9uQXVkaW9UcmFja0xvYWRlZCA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgZ3JvdXBJZCA9IGRhdGEuZ3JvdXBJZCxcbiAgICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIHZhciB0cmFja0luQWN0aXZlR3JvdXAgPSB0aGlzLnRyYWNrc0luR3JvdXBbaWRdO1xuICAgICAgaWYgKCF0cmFja0luQWN0aXZlR3JvdXAgfHwgdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWQgIT09IGdyb3VwSWQpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiQXVkaW8gdHJhY2sgd2l0aCBpZDpcIiArIGlkICsgXCIgYW5kIGdyb3VwOlwiICsgZ3JvdXBJZCArIFwiIG5vdCBmb3VuZCBpbiBhY3RpdmUgZ3JvdXAgXCIgKyAodHJhY2tJbkFjdGl2ZUdyb3VwID09IG51bGwgPyB2b2lkIDAgOiB0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY3VyRGV0YWlscyA9IHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzO1xuICAgICAgdHJhY2tJbkFjdGl2ZUdyb3VwLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICB0aGlzLmxvZyhcIkF1ZGlvIHRyYWNrIFwiICsgaWQgKyBcIiBcXFwiXCIgKyB0cmFja0luQWN0aXZlR3JvdXAubmFtZSArIFwiXFxcIiBsYW5nOlwiICsgdHJhY2tJbkFjdGl2ZUdyb3VwLmxhbmcgKyBcIiBncm91cDpcIiArIGdyb3VwSWQgKyBcIiBsb2FkZWQgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdXCIpO1xuICAgICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChpZCwgZGF0YSwgY3VyRGV0YWlscyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbExvYWRpbmcgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsU3dpdGNoaW5nID0gZnVuY3Rpb24gb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgICB9O1xuICAgIF9wcm90by5zd2l0Y2hMZXZlbCA9IGZ1bmN0aW9uIHN3aXRjaExldmVsKGxldmVsSW5kZXgpIHtcbiAgICAgIHZhciBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXVkaW9Hcm91cHMgPSBsZXZlbEluZm8uYXVkaW9Hcm91cHMgfHwgbnVsbDtcbiAgICAgIHZhciBjdXJyZW50R3JvdXBzID0gdGhpcy5ncm91cElkcztcbiAgICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICAgIGlmICghYXVkaW9Hcm91cHMgfHwgKGN1cnJlbnRHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRHcm91cHMubGVuZ3RoKSAhPT0gKGF1ZGlvR3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb0dyb3Vwcy5sZW5ndGgpIHx8IGF1ZGlvR3JvdXBzICE9IG51bGwgJiYgYXVkaW9Hcm91cHMuc29tZShmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJlbnRHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRHcm91cHMuaW5kZXhPZihncm91cElkKSkgPT09IC0xO1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhpcy5ncm91cElkcyA9IGF1ZGlvR3JvdXBzO1xuICAgICAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICAgICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgICAgICB2YXIgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuICFhdWRpb0dyb3VwcyB8fCBhdWRpb0dyb3Vwcy5pbmRleE9mKHRyYWNrLmdyb3VwSWQpICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEaXNhYmxlIHNlbGVjdERlZmF1bHRUcmFjayBpZiB0aGVyZSBhcmUgbm8gZGVmYXVsdCB0cmFja3NcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIWF1ZGlvVHJhY2tzLnNvbWUoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2suZGVmYXVsdDtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdHJhY2suaWQgc2hvdWxkIG1hdGNoIGhscy5hdWRpb1RyYWNrcyBpbmRleFxuICAgICAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrLCBpKSB7XG4gICAgICAgICAgICB0cmFjay5pZCA9IGk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRUcmFjayAmJiAhdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aCkge1xuICAgICAgICAgIC8vIERvIG5vdCBkaXNwYXRjaCBBVURJT19UUkFDS1NfVVBEQVRFRCB3aGVuIHRoZXJlIHdlcmUgYW5kIGFyZSBubyB0cmFja3NcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja3NJbkdyb3VwID0gYXVkaW9UcmFja3M7XG5cbiAgICAgICAgLy8gRmluZCBwcmVmZXJyZWQgdHJhY2tcbiAgICAgICAgdmFyIGF1ZGlvUHJlZmVyZW5jZSA9IHRoaXMuaGxzLmNvbmZpZy5hdWRpb1ByZWZlcmVuY2U7XG4gICAgICAgIGlmICghY3VycmVudFRyYWNrICYmIGF1ZGlvUHJlZmVyZW5jZSkge1xuICAgICAgICAgIHZhciBncm91cEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKGF1ZGlvUHJlZmVyZW5jZSwgYXVkaW9UcmFja3MsIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpO1xuICAgICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUcmFjayA9IGF1ZGlvVHJhY2tzW2dyb3VwSW5kZXhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWxsSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oYXVkaW9QcmVmZXJlbmNlLCB0aGlzLnRyYWNrcyk7XG4gICAgICAgICAgICBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1thbGxJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0IGluaXRpYWwgdHJhY2tcbiAgICAgICAgdmFyIHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKGN1cnJlbnRUcmFjayk7XG4gICAgICAgIGlmICh0cmFja0lkID09PSAtMSAmJiBjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGV2ZW50cyBhbmQgbG9hZCB0cmFjayBpZiBuZWVkZWRcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgICBhdWRpb1RyYWNrczogYXVkaW9UcmFja3NcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2coXCJVcGRhdGluZyBhdWRpbyB0cmFja3MsIFwiICsgYXVkaW9UcmFja3MubGVuZ3RoICsgXCIgdHJhY2socykgZm91bmQgaW4gZ3JvdXAocyk6IFwiICsgKGF1ZGlvR3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb0dyb3Vwcy5qb2luKCcsJykpKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURUQsIGF1ZGlvVHJhY2tzVXBkYXRlZCk7XG4gICAgICAgIHZhciBzZWxlY3RlZFRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG4gICAgICAgIGlmICh0cmFja0lkICE9PSAtMSAmJiBzZWxlY3RlZFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrKHRyYWNrSWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCAmJiBzZWxlY3RlZFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICAgICAgdmFyIF90aGlzJGdyb3VwSWRzO1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIk5vIGF1ZGlvIHRyYWNrIHNlbGVjdGVkIGZvciBjdXJyZW50IGF1ZGlvIGdyb3VwLUlEKHMpOiBcIiArICgoX3RoaXMkZ3JvdXBJZHMgPSB0aGlzLmdyb3VwSWRzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZ3JvdXBJZHMuam9pbignLCcpKSArIFwiIHRyYWNrIGNvdW50OiBcIiArIGF1ZGlvVHJhY2tzLmxlbmd0aCk7XG4gICAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmICghdGhpcy5ncm91cElkcyB8fCB0aGlzLmdyb3VwSWRzLmluZGV4T2YoZGF0YS5jb250ZXh0Lmdyb3VwSWQpICE9PSAtMSkpIHtcbiAgICAgICAgdGhpcy5jaGVja1JldHJ5KGRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnNldEF1ZGlvT3B0aW9uID0gZnVuY3Rpb24gc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5jb25maWcuYXVkaW9QcmVmZXJlbmNlID0gYXVkaW9PcHRpb247XG4gICAgICBpZiAoYXVkaW9PcHRpb24pIHtcbiAgICAgICAgdmFyIGFsbEF1ZGlvVHJhY2tzID0gdGhpcy5hbGxBdWRpb1RyYWNrcztcbiAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFsbEF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEZpcnN0IHNlZSBpZiBjdXJyZW50IG9wdGlvbiBtYXRjaGVzIChubyBzd2l0Y2ggb3ApXG4gICAgICAgICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgICAgICAgIGlmIChjdXJyZW50VHJhY2sgJiYgbWF0Y2hlc09wdGlvbihhdWRpb09wdGlvbiwgY3VycmVudFRyYWNrLCBhdWRpb01hdGNoUHJlZGljYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRUcmFjaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRmluZCBvcHRpb24gaW4gYXZhaWxhYmxlIHRyYWNrcyAodHJhY2tzSW5Hcm91cClcbiAgICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihhdWRpb09wdGlvbiwgdGhpcy50cmFja3NJbkdyb3VwLCBhdWRpb01hdGNoUHJlZGljYXRlKTtcbiAgICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICB0aGlzLnNldEF1ZGlvVHJhY2soZ3JvdXBJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICAgIC8vIEZpbmQgb3B0aW9uIGluIG5lYXJlc3QgbGV2ZWwgYXVkaW8gZ3JvdXBcbiAgICAgICAgICAgIHZhciBzZWFyY2hJbmRleCA9IGhscy5sb2FkTGV2ZWw7XG4gICAgICAgICAgICBpZiAoc2VhcmNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgIHNlYXJjaEluZGV4ID0gaGxzLmZpcnN0QXV0b0xldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN3aXRjaEluZGV4ID0gZmluZENsb3Nlc3RMZXZlbFdpdGhBdWRpb0dyb3VwKGF1ZGlvT3B0aW9uLCBobHMubGV2ZWxzLCBhbGxBdWRpb1RyYWNrcywgc2VhcmNoSW5kZXgsIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpO1xuICAgICAgICAgICAgaWYgKHN3aXRjaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAvLyBjb3VsZCBub3QgZmluZCBtYXRjaGluZyB2YXJpYW50XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5kIHN3aXRjaCBsZXZlbCB0byBhY2hlaXZlIHRoZSBhdWRpbyBncm91cCBzd2l0Y2hcbiAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gc3dpdGNoSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdWRpb09wdGlvbi5jaGFubmVscyB8fCBhdWRpb09wdGlvbi5hdWRpb0NvZGVjKSB7XG4gICAgICAgICAgICAvLyBDb3VsZCBub3QgZmluZCBhIG1hdGNoIHdpdGggY29kZWMgLyBjaGFubmVscyBwcmVkaWNhdGVcbiAgICAgICAgICAgIC8vIEZpbmQgYSBtYXRjaCB3aXRob3V0IGNoYW5uZWxzIG9yIGNvZGVjXG4gICAgICAgICAgICB2YXIgd2l0aG91dENvZGVjQW5kQ2hhbm5lbHNNYXRjaCA9IGZpbmRNYXRjaGluZ09wdGlvbihhdWRpb09wdGlvbiwgYWxsQXVkaW9UcmFja3MpO1xuICAgICAgICAgICAgaWYgKHdpdGhvdXRDb2RlY0FuZENoYW5uZWxzTWF0Y2ggPiAtMSkge1xuICAgICAgICAgICAgICByZXR1cm4gYWxsQXVkaW9UcmFja3Nbd2l0aG91dENvZGVjQW5kQ2hhbm5lbHNNYXRjaF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5zZXRBdWRpb1RyYWNrID0gZnVuY3Rpb24gc2V0QXVkaW9UcmFjayhuZXdJZCkge1xuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcblxuICAgICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgICBpZiAobmV3SWQgPCAwIHx8IG5ld0lkID49IHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiSW52YWxpZCBhdWRpbyB0cmFjayBpZDogXCIgKyBuZXdJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICB2YXIgbGFzdFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbbmV3SWRdO1xuICAgICAgdmFyIHRyYWNrTG9hZGVkID0gdHJhY2suZGV0YWlscyAmJiAhdHJhY2suZGV0YWlscy5saXZlO1xuICAgICAgaWYgKG5ld0lkID09PSB0aGlzLnRyYWNrSWQgJiYgdHJhY2sgPT09IGxhc3RUcmFjayAmJiB0cmFja0xvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcIlN3aXRjaGluZyB0byBhdWRpby10cmFjayBcIiArIG5ld0lkICsgXCIgXFxcIlwiICsgdHJhY2submFtZSArIFwiXFxcIiBsYW5nOlwiICsgdHJhY2subGFuZyArIFwiIGdyb3VwOlwiICsgdHJhY2suZ3JvdXBJZCArIFwiIGNoYW5uZWxzOlwiICsgdHJhY2suY2hhbm5lbHMpO1xuICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFjayA9IHRyYWNrO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCBfb2JqZWN0U3ByZWFkMih7fSwgdHJhY2spKTtcbiAgICAgIC8vIERvIG5vdCByZWxvYWQgdHJhY2sgdW5sZXNzIGxpdmVcbiAgICAgIGlmICh0cmFja0xvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKHRyYWNrLnVybCwgbGFzdFRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBsYXN0VHJhY2suZGV0YWlscywgdHJhY2suZGV0YWlscyk7XG4gICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICB9O1xuICAgIF9wcm90by5maW5kVHJhY2tJZCA9IGZ1bmN0aW9uIGZpbmRUcmFja0lkKGN1cnJlbnRUcmFjaykge1xuICAgICAgdmFyIGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSBhdWRpb1RyYWNrc1tpXTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrICYmICF0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50VHJhY2sgfHwgbWF0Y2hlc09wdGlvbihjdXJyZW50VHJhY2ssIHRyYWNrLCBhdWRpb01hdGNoUHJlZGljYXRlKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICAgIHZhciBuYW1lID0gY3VycmVudFRyYWNrLm5hbWUsXG4gICAgICAgICAgbGFuZyA9IGN1cnJlbnRUcmFjay5sYW5nLFxuICAgICAgICAgIGFzc29jTGFuZyA9IGN1cnJlbnRUcmFjay5hc3NvY0xhbmcsXG4gICAgICAgICAgY2hhcmFjdGVyaXN0aWNzID0gY3VycmVudFRyYWNrLmNoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgICBhdWRpb0NvZGVjID0gY3VycmVudFRyYWNrLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgY2hhbm5lbHMgPSBjdXJyZW50VHJhY2suY2hhbm5lbHM7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX3RyYWNrID0gYXVkaW9UcmFja3NbX2ldO1xuICAgICAgICAgIGlmIChtYXRjaGVzT3B0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBsYW5nOiBsYW5nLFxuICAgICAgICAgICAgYXNzb2NMYW5nOiBhc3NvY0xhbmcsXG4gICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IGNoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgICAgIGF1ZGlvQ29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgICAgICBjaGFubmVsczogY2hhbm5lbHNcbiAgICAgICAgICB9LCBfdHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gX2k7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGF1ZGlvVHJhY2tzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX3RyYWNrMiA9IGF1ZGlvVHJhY2tzW19pMl07XG4gICAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIF90cmFjazIuYXR0cnMsIFsnTEFOR1VBR0UnLCAnQVNTT0MtTEFOR1VBR0UnLCAnQ0hBUkFDVEVSSVNUSUNTJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gX2kyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF90cmFjazMgPSBhdWRpb1RyYWNrc1tfaTNdO1xuICAgICAgICAgIGlmIChtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoY3VycmVudFRyYWNrLmF0dHJzLCBfdHJhY2szLmF0dHJzLCBbJ0xBTkdVQUdFJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gX2kzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRQbGF5bGlzdCA9IGZ1bmN0aW9uIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLmxvYWRQbGF5bGlzdC5jYWxsKHRoaXMpO1xuICAgICAgdmFyIGF1ZGlvVHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICAgIGlmICghdGhpcy5zaG91bGRMb2FkUGxheWxpc3QoYXVkaW9UcmFjaykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gRG8gbm90IGxvYWQgYXVkaW8gcmVuZGl0aW9uIHdpdGggVVJJIG1hdGNoaW5nIG1haW4gdmFyaWFudCBVUklcbiAgICAgIGlmICh1c2VBbHRlcm5hdGVBdWRpbyhhdWRpb1RyYWNrLnVybCwgdGhpcy5obHMpKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVMb2FkaW5nKGF1ZGlvVHJhY2ssIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWRpbmdQbGF5bGlzdCA9IGZ1bmN0aW9uIGxvYWRpbmdQbGF5bGlzdChhdWRpb1RyYWNrLCBobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLmxvYWRpbmdQbGF5bGlzdC5jYWxsKHRoaXMsIGF1ZGlvVHJhY2ssIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgICAgdmFyIGlkID0gYXVkaW9UcmFjay5pZDtcbiAgICAgIHZhciBncm91cElkID0gYXVkaW9UcmFjay5ncm91cElkO1xuICAgICAgdmFyIHVybCA9IHRoaXMuZ2V0VXJsV2l0aERpcmVjdGl2ZXMoYXVkaW9UcmFjay51cmwsIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgICAgdmFyIGRldGFpbHMgPSBhdWRpb1RyYWNrLmRldGFpbHM7XG4gICAgICB2YXIgYWdlID0gZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5hZ2U7XG4gICAgICB0aGlzLmxvZyhcIkxvYWRpbmcgYXVkaW8tdHJhY2sgXCIgKyBpZCArIFwiIFxcXCJcIiArIGF1ZGlvVHJhY2submFtZSArIFwiXFxcIiBsYW5nOlwiICsgYXVkaW9UcmFjay5sYW5nICsgXCIgZ3JvdXA6XCIgKyBncm91cElkICsgKChobHNVcmxQYXJhbWV0ZXJzID09IG51bGwgPyB2b2lkIDAgOiBobHNVcmxQYXJhbWV0ZXJzLm1zbikgIT09IHVuZGVmaW5lZCA/ICcgYXQgc24gJyArIGhsc1VybFBhcmFtZXRlcnMubXNuICsgJyBwYXJ0ICcgKyBobHNVcmxQYXJhbWV0ZXJzLnBhcnQgOiAnJykgKyAoYWdlICYmIGRldGFpbHMubGl2ZSA/ICcgYWdlICcgKyBhZ2UudG9GaXhlZCgxKSArIChkZXRhaWxzLnR5cGUgPyAnICcgKyBkZXRhaWxzLnR5cGUgfHwgJycgOiAnJykgOiAnJykgKyBcIiBcIiArIHVybCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsLFxuICAgICAgICB0cmFjazogYXVkaW9UcmFja1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF1ZGlvVHJhY2tDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcImFsbEF1ZGlvVHJhY2tzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhdWRpb1RyYWNrc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0lkKSB7XG4gICAgICAgIC8vIElmIGF1ZGlvIHRyYWNrIGlzIHNlbGVjdGVkIGZyb20gQVBJIHRoZW4gZG9uJ3QgY2hvb3NlIGZyb20gdGhlIG1hbmlmZXN0IGRlZmF1bHQgdHJhY2tcbiAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrKG5ld0lkKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oQmFzZVBsYXlsaXN0Q29udHJvbGxlcik7XG5cbiAgdmFyIEJ1ZmZlck9wZXJhdGlvblF1ZXVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJPcGVyYXRpb25RdWV1ZShzb3VyY2VCdWZmZXJSZWZlcmVuY2UpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gdm9pZCAwO1xuICAgICAgdGhpcy5xdWV1ZXMgPSB7XG4gICAgICAgIHZpZGVvOiBbXSxcbiAgICAgICAgYXVkaW86IFtdLFxuICAgICAgICBhdWRpb3ZpZGVvOiBbXVxuICAgICAgfTtcbiAgICAgIHRoaXMudHJhY2tzID0gc291cmNlQnVmZmVyUmVmZXJlbmNlO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQnVmZmVyT3BlcmF0aW9uUXVldWUucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gdGhpcy5xdWV1ZXMgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChvcGVyYXRpb24sIHR5cGUsIHBlbmRpbmcpIHtcbiAgICAgIGlmICh0aGlzLnF1ZXVlcyA9PT0gbnVsbCB8fCB0aGlzLnRyYWNrcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICAgIHF1ZXVlLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIXBlbmRpbmcpIHtcbiAgICAgICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5hcHBlbmRCbG9ja2VyID0gZnVuY3Rpb24gYXBwZW5kQmxvY2tlcih0eXBlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICAgICAgbGFiZWw6ICdhc3luYy1ibG9ja2VyJyxcbiAgICAgICAgICBleGVjdXRlOiByZXNvbHZlLFxuICAgICAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7fSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge30sXG4gICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcigpIHt9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlcGVuZEJsb2NrZXIgPSBmdW5jdGlvbiBwcmVwZW5kQmxvY2tlcih0eXBlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBpZiAoX3RoaXMyLnF1ZXVlcykge1xuICAgICAgICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICAgICAgICBsYWJlbDogJ2FzeW5jLWJsb2NrZXItcHJlcGVuZCcsXG4gICAgICAgICAgICBleGVjdXRlOiByZXNvbHZlLFxuICAgICAgICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHt9LFxuICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHt9LFxuICAgICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcigpIHt9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdGhpczIucXVldWVzW3R5cGVdLnVuc2hpZnQob3BlcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlQmxvY2tlcnMgPSBmdW5jdGlvbiByZW1vdmVCbG9ja2VycygpIHtcbiAgICAgIGlmICh0aGlzLnF1ZXVlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBbdGhpcy5xdWV1ZXMudmlkZW8sIHRoaXMucXVldWVzLmF1ZGlvLCB0aGlzLnF1ZXVlcy5hdWRpb3ZpZGVvXS5mb3JFYWNoKGZ1bmN0aW9uIChxdWV1ZSkge1xuICAgICAgICB2YXIgX3F1ZXVlJDtcbiAgICAgICAgdmFyIGxhYmVsID0gKF9xdWV1ZSQgPSBxdWV1ZVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9xdWV1ZSQubGFiZWw7XG4gICAgICAgIGlmIChsYWJlbCA9PT0gJ2FzeW5jLWJsb2NrZXInIHx8IGxhYmVsID09PSAnYXN5bmMtYmxvY2tlci1wcmVwZW5kJykge1xuICAgICAgICAgIHF1ZXVlWzBdLmV4ZWN1dGUoKTtcbiAgICAgICAgICBxdWV1ZS5zcGxpY2UoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVuYmxvY2tBdWRpbyA9IGZ1bmN0aW9uIHVuYmxvY2tBdWRpbyhvcCkge1xuICAgICAgaWYgKHRoaXMucXVldWVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWVzLmF1ZGlvO1xuICAgICAgaWYgKHF1ZXVlWzBdID09PSBvcCkge1xuICAgICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQoJ2F1ZGlvJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZXhlY3V0ZU5leHQgPSBmdW5jdGlvbiBleGVjdXRlTmV4dCh0eXBlKSB7XG4gICAgICBpZiAodGhpcy5xdWV1ZXMgPT09IG51bGwgfHwgdGhpcy50cmFja3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBxdWV1ZVswXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBPcGVyYXRpb25zIGFyZSBleHBlY3RlZCB0byByZXN1bHQgaW4gYW4gJ3VwZGF0ZWVuZCcgZXZlbnQgYmVpbmcgZmlyZWQuIElmIG5vdCwgdGhlIHF1ZXVlIHdpbGwgbG9jay4gT3BlcmF0aW9uc1xuICAgICAgICAgIC8vIHdoaWNoIGRvIG5vdCBlbmQgd2l0aCB0aGlzIGV2ZW50IG11c3QgY2FsbCBfb25TQlVwZGF0ZUVuZCBtYW51YWxseVxuICAgICAgICAgIG9wZXJhdGlvbi5leGVjdXRlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdmFyIF90aGlzJHRyYWNrcyR0eXBlO1xuICAgICAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICBpZiAodGhpcy5xdWV1ZXMgPT09IG51bGwgfHwgdGhpcy50cmFja3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPbmx5IHNoaWZ0IHRoZSBjdXJyZW50IG9wZXJhdGlvbiBvZmYsIG90aGVyd2lzZSB0aGUgdXBkYXRlZW5kIGhhbmRsZXIgd2lsbCBkbyB0aGlzIGZvciB1c1xuICAgICAgICAgIHZhciBzYiA9IChfdGhpcyR0cmFja3MkdHlwZSA9IHRoaXMudHJhY2tzW3R5cGVdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHJhY2tzJHR5cGUuYnVmZmVyO1xuICAgICAgICAgIGlmICghKHNiICE9IG51bGwgJiYgc2IudXBkYXRpbmcpKSB7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc2hpZnRBbmRFeGVjdXRlTmV4dCA9IGZ1bmN0aW9uIHNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSkge1xuICAgICAgaWYgKHRoaXMucXVldWVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucXVldWVzW3R5cGVdLnNoaWZ0KCk7XG4gICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH07XG4gICAgX3Byb3RvLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50KHR5cGUpIHtcbiAgICAgIHZhciBfdGhpcyRxdWV1ZXM7XG4gICAgICByZXR1cm4gKChfdGhpcyRxdWV1ZXMgPSB0aGlzLnF1ZXVlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHF1ZXVlc1t0eXBlXVswXSkgfHwgbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHF1ZXVlcyA9IHRoaXMucXVldWVzLFxuICAgICAgICB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICAgIGlmIChxdWV1ZXMgPT09IG51bGwgfHwgdHJhY2tzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIjxkZXN0cm95ZWQ+XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHRoaXMubGlzdCgndmlkZW8nKSArIFwiXFxuXCIgKyB0aGlzLmxpc3QoJ2F1ZGlvJykgKyBcIlxcblwiICsgdGhpcy5saXN0KCdhdWRpb3ZpZGVvJykgKyBcIn1cIjtcbiAgICB9O1xuICAgIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdCh0eXBlKSB7XG4gICAgICB2YXIgX3RoaXMkcXVldWVzMiwgX3RoaXMkdHJhY2tzO1xuICAgICAgcmV0dXJuIChfdGhpcyRxdWV1ZXMyID0gdGhpcy5xdWV1ZXMpICE9IG51bGwgJiYgX3RoaXMkcXVldWVzMlt0eXBlXSB8fCAoX3RoaXMkdHJhY2tzID0gdGhpcy50cmFja3MpICE9IG51bGwgJiYgX3RoaXMkdHJhY2tzW3R5cGVdID8gdHlwZSArIFwiOiAoXCIgKyB0aGlzLmxpc3RTYkluZm8odHlwZSkgKyBcIikgXCIgKyB0aGlzLmxpc3RPcHModHlwZSkgOiAnJztcbiAgICB9O1xuICAgIF9wcm90by5saXN0U2JJbmZvID0gZnVuY3Rpb24gbGlzdFNiSW5mbyh0eXBlKSB7XG4gICAgICB2YXIgX3RoaXMkdHJhY2tzMjtcbiAgICAgIHZhciB0cmFjayA9IChfdGhpcyR0cmFja3MyID0gdGhpcy50cmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFja3MyW3R5cGVdO1xuICAgICAgdmFyIHNiID0gdHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrLmJ1ZmZlcjtcbiAgICAgIGlmICghc2IpIHtcbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlNvdXJjZUJ1ZmZlclwiICsgKHNiLnVwZGF0aW5nID8gJyB1cGRhdGluZycgOiAnJykgKyAodHJhY2suZW5kZWQgPyAnIGVuZGVkJyA6ICcnKSArICh0cmFjay5lbmRpbmcgPyAnIGVuZGluZycgOiAnJyk7XG4gICAgfTtcbiAgICBfcHJvdG8ubGlzdE9wcyA9IGZ1bmN0aW9uIGxpc3RPcHModHlwZSkge1xuICAgICAgdmFyIF90aGlzJHF1ZXVlczM7XG4gICAgICByZXR1cm4gKChfdGhpcyRxdWV1ZXMzID0gdGhpcy5xdWV1ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRxdWV1ZXMzW3R5cGVdLm1hcChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIG9wLmxhYmVsO1xuICAgICAgfSkuam9pbignLCAnKSkgfHwgJyc7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyT3BlcmF0aW9uUXVldWU7XG4gIH0oKTtcblxuICB2YXIgVklERU9fQ09ERUNfUFJPRklMRV9SRVBMQUNFID0gLyhhdmNbMTIzNF18aHZjMXxoZXYxfGR2aFsxZV18dnAwOXxhdjAxKSg/OlxcLlteLixdKykrLztcbiAgdmFyIFRSQUNLX1JFTU9WRURfRVJST1JfTkFNRSA9ICdIbHNKc1RyYWNrUmVtb3ZlZEVycm9yJztcbiAgdmFyIEhsc0pzVHJhY2tSZW1vdmVkRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICAgIGZ1bmN0aW9uIEhsc0pzVHJhY2tSZW1vdmVkRXJyb3IobWVzc2FnZSkge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgX3RoaXMubmFtZSA9IFRSQUNLX1JFTU9WRURfRVJST1JfTkFNRTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoSGxzSnNUcmFja1JlbW92ZWRFcnJvciwgX0Vycm9yKTtcbiAgICByZXR1cm4gSGxzSnNUcmFja1JlbW92ZWRFcnJvcjtcbiAgfSgvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuICB2YXIgQnVmZmVyQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvZ2dlcikge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlckNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICAgIHZhciBfdGhpczI7XG4gICAgICBfdGhpczIgPSBfTG9nZ2VyLmNhbGwodGhpcywgJ2J1ZmZlci1jb250cm9sbGVyJywgaGxzLmxvZ2dlcikgfHwgdGhpcztcbiAgICAgIF90aGlzMi5obHMgPSB2b2lkIDA7XG4gICAgICBfdGhpczIuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgICAgLy8gVGhlIGxldmVsIGRldGFpbHMgdXNlZCB0byBkZXRlcm1pbmUgZHVyYXRpb24sIHRhcmdldC1kdXJhdGlvbiBhbmQgbGl2ZVxuICAgICAgX3RoaXMyLmRldGFpbHMgPSBudWxsO1xuICAgICAgLy8gY2FjaGUgdGhlIHNlbGYgZ2VuZXJhdGVkIG9iamVjdCB1cmwgdG8gZGV0ZWN0IGhpamFjayBvZiB2aWRlbyB0YWdcbiAgICAgIF90aGlzMi5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAgIC8vIEEgcXVldWUgb2YgYnVmZmVyIG9wZXJhdGlvbnMgd2hpY2ggcmVxdWlyZSB0aGUgU291cmNlQnVmZmVyIHRvIG5vdCBiZSB1cGRhdGluZyB1cG9uIGV4ZWN1dGlvblxuICAgICAgX3RoaXMyLm9wZXJhdGlvblF1ZXVlID0gbnVsbDtcbiAgICAgIC8vIFRoZSB0b3RhbCBudW1iZXIgdHJhY2sgY29kZWNzIGV4cGVjdGVkIGJlZm9yZSBhbnkgc291cmNlQnVmZmVycyBhcmUgY3JlYXRlZCAoMjogYXVkaW8gYW5kIHZpZGVvIG9yIDE6IGF1ZGlvdmlkZW8gfCBhdWRpbyB8IHZpZGVvKVxuICAgICAgX3RoaXMyLmJ1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGF0dGFjaGVkIG1lZGlhIGVsZW1lbnRcbiAgICAgIF90aGlzMi5tZWRpYSA9IG51bGw7XG4gICAgICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYWN0aXZlIG1lZGlhIHNvdXJjZVxuICAgICAgX3RoaXMyLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgIC8vIExhc3QgTVAzIGF1ZGlvIGNodW5rIGFwcGVuZGVkXG4gICAgICBfdGhpczIubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgICAgIC8vIEF1ZGlvIGZyYWdtZW50IGJsb2NrZWQgZnJvbSBhcHBlbmRpbmcgdW50aWwgY29ycmVzcG9uZGluZyB2aWRlbyBhcHBlbmRzIG9yIGNvbnRleHQgY2hhbmdlc1xuICAgICAgX3RoaXMyLmJsb2NrZWRBdWRpb0FwcGVuZCA9IG51bGw7XG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHZpZGVvIGFwcGVuZCBwb3NpdGlvbiBmb3IgdW5ibG9ja2luZyBhdWRpb1xuICAgICAgX3RoaXMyLmxhc3RWaWRlb0FwcGVuZEVuZCA9IDA7XG4gICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0byB1c2UgTWFuYWdlZE1lZGlhU291cmNlIEFQSSBhbmQgYXBwZW5kIHNvdXJjZSBlbGVtZW50IHRvIG1lZGlhIGVsZW1lbnQuXG4gICAgICBfdGhpczIuYXBwZW5kU291cmNlID0gdm9pZCAwO1xuICAgICAgLy8gVHJhbnNmZXJyZWQgTWVkaWFTb3VyY2UgaW5mb3JtYXRpb24gdXNlZCB0byBkZXRtZXJpbmUgaWYgZHVyYXRpb24gZW5kIGVuZHN0cmVhbSBtYXkgYmUgYXBwZW5kZWRcbiAgICAgIF90aGlzMi50cmFuc2ZlckRhdGEgPSB2b2lkIDA7XG4gICAgICAvLyBEaXJlY3RpdmVzIHVzZWQgdG8gb3ZlcnJpZGUgZGVmYXVsdCBNZWRpYVNvdXJjZSBoYW5kbGluZ1xuICAgICAgX3RoaXMyLm92ZXJyaWRlcyA9IHZvaWQgMDtcbiAgICAgIC8vIEVycm9yIGNvdW50ZXJzXG4gICAgICBfdGhpczIuYXBwZW5kRXJyb3JzID0ge1xuICAgICAgICBhdWRpbzogMCxcbiAgICAgICAgdmlkZW86IDAsXG4gICAgICAgIGF1ZGlvdmlkZW86IDBcbiAgICAgIH07XG4gICAgICAvLyBSZWNvcmQgb2YgcmVxdWlyZWQgb3IgY3JlYXRlZCBidWZmZXJzIGJ5IHR5cGUuIFNvdXJjZUJ1ZmZlciBpcyBzdG9yZWQgaW4gVHJhY2suYnVmZmVyIG9uY2UgY3JlYXRlZC5cbiAgICAgIF90aGlzMi50cmFja3MgPSB7fTtcbiAgICAgIC8vIEFycmF5IG9mIFNvdXJjZUJ1ZmZlciB0eXBlIGFuZCBTb3VyY2VCdWZmZXIgKG9yIG51bGwpLiBPbmUgZW50cnkgcGVyIFRyYWNrU2V0IGluIHRoaXMudHJhY2tzLlxuICAgICAgX3RoaXMyLnNvdXJjZUJ1ZmZlcnMgPSBbW251bGwsIG51bGxdLCBbbnVsbCwgbnVsbF1dO1xuICAgICAgX3RoaXMyLl9vbkVuZFN0cmVhbWluZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMyJG1lZGlhU291cmNlO1xuICAgICAgICBpZiAoIV90aGlzMi5obHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX3RoaXMyJG1lZGlhU291cmNlID0gX3RoaXMyLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMyJG1lZGlhU291cmNlLnJlYWR5U3RhdGUpICE9PSAnb3BlbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyLmhscy5wYXVzZUJ1ZmZlcmluZygpO1xuICAgICAgfTtcbiAgICAgIF90aGlzMi5fb25TdGFydFN0cmVhbWluZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIV90aGlzMi5obHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyLmhscy5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgICAgIH07XG4gICAgICAvLyBLZWVwIGFzIGFycm93IGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNhbiBkaXJlY3RseSByZWZlcmVuY2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGFzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgX3RoaXMyLl9vbk1lZGlhU291cmNlT3BlbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSBfdGhpczIsXG4gICAgICAgICAgbWVkaWEgPSBfdGhpczMubWVkaWEsXG4gICAgICAgICAgbWVkaWFTb3VyY2UgPSBfdGhpczMubWVkaWFTb3VyY2U7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgX3RoaXMyLmxvZygnTWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVkaWEgfHwgIW1lZGlhU291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIF90aGlzMi5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgX3RoaXMyLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgICAgIF90aGlzMi51cGRhdGVEdXJhdGlvbigpO1xuICAgICAgICBfdGhpczIuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB7XG4gICAgICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgICAgIG1lZGlhU291cmNlOiBtZWRpYVNvdXJjZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKF90aGlzMi5tZWRpYVNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMi5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF90aGlzMi5fb25NZWRpYVNvdXJjZUNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIubG9nKCdNZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gICAgICB9O1xuICAgICAgX3RoaXMyLl9vbk1lZGlhU291cmNlRW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5sb2coJ01lZGlhIHNvdXJjZSBlbmRlZCcpO1xuICAgICAgfTtcbiAgICAgIF90aGlzMi5fb25NZWRpYUVtcHRpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSBfdGhpczIsXG4gICAgICAgICAgbWVkaWFTcmMgPSBfdGhpczQubWVkaWFTcmMsXG4gICAgICAgICAgX29iamVjdFVybCA9IF90aGlzNC5fb2JqZWN0VXJsO1xuICAgICAgICBpZiAobWVkaWFTcmMgIT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBfdGhpczIuZXJyb3IoXCJNZWRpYSBlbGVtZW50IHNyYyB3YXMgc2V0IHdoaWxlIGF0dGFjaGluZyBNZWRpYVNvdXJjZSAoXCIgKyBfb2JqZWN0VXJsICsgXCIgPiBcIiArIG1lZGlhU3JjICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMyLmhscyA9IGhscztcbiAgICAgIF90aGlzMi5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgICBfdGhpczIuYXBwZW5kU291cmNlID0gaXNNYW5hZ2VkTWVkaWFTb3VyY2UoZ2V0TWVkaWFTb3VyY2UoaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpKTtcbiAgICAgIF90aGlzMi5pbml0VHJhY2tzKCk7XG4gICAgICBfdGhpczIucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKEJ1ZmZlckNvbnRyb2xsZXIsIF9Mb2dnZXIpO1xuICAgIHZhciBfcHJvdG8gPSBCdWZmZXJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uaGFzU291cmNlVHlwZXMgPSBmdW5jdGlvbiBoYXNTb3VyY2VUeXBlcygpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYWNrcykubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQgPSBudWxsO1xuICAgICAgdGhpcy50cmFuc2ZlckRhdGEgPSB0aGlzLm92ZXJyaWRlcyA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm9wZXJhdGlvblF1ZXVlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4gPSB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkID0gbnVsbDtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcgPSB0aGlzLl9vbkVuZFN0cmVhbWluZyA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8udHJhbnNmZXJNZWRpYSA9IGZ1bmN0aW9uIHRyYW5zZmVyTWVkaWEoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgdHJhY2tzID0ge307XG4gICAgICBpZiAodGhpcy5vcGVyYXRpb25RdWV1ZSkge1xuICAgICAgICB2YXIgdXBkYXRpbmcgPSB0aGlzLmlzVXBkYXRpbmcoKTtcbiAgICAgICAgaWYgKCF1cGRhdGluZykge1xuICAgICAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUucmVtb3ZlQmxvY2tlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVldWVkID0gdGhpcy5pc1F1ZXVlZCgpO1xuICAgICAgICBpZiAodXBkYXRpbmcgfHwgcXVldWVkKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwiVHJhbnNmZXJpbmcgTWVkaWFTb3VyY2Ugd2l0aFwiICsgKHF1ZXVlZCA/ICcgb3BlcmF0aW9ucyBpbiBxdWV1ZScgOiAnJykgKyAodXBkYXRpbmcgPyAnIHVwZGF0aW5nIFNvdXJjZUJ1ZmZlcihzKScgOiAnJykgKyBcIiBcIiArIHRoaXMub3BlcmF0aW9uUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdmFyIHRyYW5zZmVyRGF0YSA9IHRoaXMudHJhbnNmZXJEYXRhO1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZUJ1ZmZlckNvdW50ICYmIHRyYW5zZmVyRGF0YSAmJiB0cmFuc2ZlckRhdGEubWVkaWFTb3VyY2UgPT09IG1lZGlhU291cmNlKSB7XG4gICAgICAgIF9leHRlbmRzKHRyYWNrcywgdHJhbnNmZXJEYXRhLnRyYWNrcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHR1cGxlWzBdO1xuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0cmFja3NbdHlwZV0gPSBfZXh0ZW5kcyh7fSwgX3RoaXM1LnRyYWNrc1t0eXBlXSk7XG4gICAgICAgICAgICBfdGhpczUucmVtb3ZlQnVmZmVyKHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0dXBsZVswXSA9IHR1cGxlWzFdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWRpYTogbWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlOiBtZWRpYVNvdXJjZSxcbiAgICAgICAgdHJhY2tzOiB0cmFja3NcbiAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uaW5pdFRyYWNrcyA9IGZ1bmN0aW9uIGluaXRUcmFja3MoKSB7XG4gICAgICB2YXIgdHJhY2tzID0ge307XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMgPSBbW251bGwsIG51bGxdLCBbbnVsbCwgbnVsbF1dO1xuICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICB0aGlzLnJlc2V0UXVldWUoKTtcbiAgICAgIHRoaXMucmVzZXRBcHBlbmRFcnJvcnMoKTtcbiAgICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0VmlkZW9BcHBlbmRFbmQgPSAwO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzJHRyYW5zZmVyRGF0YTtcbiAgICAgIC8vIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIDIgQlVGRkVSX0NPREVDUyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQsIG9uZSBwZXIgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgIC8vIHNvdXJjZWJ1ZmZlcnMgd2lsbCBiZSBjcmVhdGVkIGFsbCBhdCBvbmNlIHdoZW4gdGhlIGV4cGVjdGVkIG5iIG9mIHRyYWNrcyB3aWxsIGJlIHJlYWNoZWRcbiAgICAgIC8vIGluIGNhc2UgYWx0IGF1ZGlvIGlzIG5vdCB1c2VkLCBvbmx5IG9uZSBCVUZGRVJfQ09ERUMgZXZlbnQgd2lsbCBiZSBmaXJlZCBmcm9tIG1haW4gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAgIC8vIGl0IHdpbGwgY29udGFpbiB0aGUgZXhwZWN0ZWQgbmIgb2Ygc291cmNlIGJ1ZmZlcnMsIG5vIG5lZWQgdG8gY29tcHV0ZSBpdFxuICAgICAgdmFyIGNvZGVjRXZlbnRzID0gMjtcbiAgICAgIGlmIChkYXRhLmF1ZGlvICYmICFkYXRhLnZpZGVvIHx8ICFkYXRhLmFsdEF1ZGlvKSB7XG4gICAgICAgIGNvZGVjRXZlbnRzID0gMTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IGNvZGVjRXZlbnRzO1xuICAgICAgdGhpcy5sb2coY29kZWNFdmVudHMgKyBcIiBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZC5cIik7XG4gICAgICBpZiAoKF90aGlzJHRyYW5zZmVyRGF0YSA9IHRoaXMudHJhbnNmZXJEYXRhKSAhPSBudWxsICYmIF90aGlzJHRyYW5zZmVyRGF0YS5tZWRpYVNvdXJjZSAmJiB0aGlzLnNvdXJjZUJ1ZmZlckNvdW50ICYmIGNvZGVjRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyQ3JlYXRlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgIHRoaXMudHJhbnNmZXJEYXRhID0gdGhpcy5vdmVycmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSh0aGlzLmFwcGVuZFNvdXJjZSk7XG4gICAgICBpZiAoTWVkaWFTb3VyY2UpIHtcbiAgICAgICAgdmFyIHRyYW5zZmVycmluZ01lZGlhID0gISFkYXRhLm1lZGlhU291cmNlO1xuICAgICAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEgfHwgZGF0YS5vdmVycmlkZXMpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zZmVyRGF0YSA9IGRhdGE7XG4gICAgICAgICAgdGhpcy5vdmVycmlkZXMgPSBkYXRhLm92ZXJyaWRlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gZGF0YS5tZWRpYVNvdXJjZSB8fCBuZXcgTWVkaWFTb3VyY2UoKTtcbiAgICAgICAgdGhpcy5hc3NpZ25NZWRpYVNvdXJjZShtcyk7XG4gICAgICAgIGlmICh0cmFuc2ZlcnJpbmdNZWRpYSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdFVybCA9IG1lZGlhLnNyYztcbiAgICAgICAgICB0aGlzLmF0dGFjaFRyYW5zZmVycmVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcbiAgICAgICAgICB2YXIgb2JqZWN0VXJsID0gdGhpcy5fb2JqZWN0VXJsID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTtcbiAgICAgICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICAgIC8vIE1hbmFnZWRNZWRpYVNvdXJjZSB3aWxsIG5vdCBvcGVuIHdpdGhvdXQgZGlzYWJsZVJlbW90ZVBsYXliYWNrIHNldCB0byBmYWxzZSBvciBzb3VyY2UgYWx0ZXJuYXRpdmVzXG4gICAgICAgICAgICAgIHZhciBNTVMgPSBzZWxmLk1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgICAgICAgICAgICAgbWVkaWEuZGlzYWJsZVJlbW90ZVBsYXliYWNrID0gbWVkaWEuZGlzYWJsZVJlbW90ZVBsYXliYWNrIHx8IE1NUyAmJiBtcyBpbnN0YW5jZW9mIE1NUztcbiAgICAgICAgICAgICAgcmVtb3ZlU291cmNlQ2hpbGRyZW4obWVkaWEpO1xuICAgICAgICAgICAgICBhZGRTb3VyY2UobWVkaWEsIG9iamVjdFVybCk7XG4gICAgICAgICAgICAgIG1lZGlhLmxvYWQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIG1lZGlhLnNyYyA9IG9iamVjdFVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVkaWEuc3JjID0gb2JqZWN0VXJsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFzc2lnbk1lZGlhU291cmNlID0gZnVuY3Rpb24gYXNzaWduTWVkaWFTb3VyY2UobXMpIHtcbiAgICAgIHZhciBfdGhpcyR0cmFuc2ZlckRhdGEyLCBfbXMkY29uc3RydWN0b3I7XG4gICAgICB0aGlzLmxvZygoKChfdGhpcyR0cmFuc2ZlckRhdGEyID0gdGhpcy50cmFuc2ZlckRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFuc2ZlckRhdGEyLm1lZGlhU291cmNlKSA9PT0gbXMgPyAndHJhbnNmZXJyZWQnIDogJ2NyZWF0ZWQnKSArIFwiIG1lZGlhIHNvdXJjZTogXCIgKyAoKF9tcyRjb25zdHJ1Y3RvciA9IG1zLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX21zJGNvbnN0cnVjdG9yLm5hbWUpKTtcbiAgICAgIC8vIE1lZGlhU291cmNlIGxpc3RlbmVycyBhcmUgYXJyb3cgZnVuY3Rpb25zIHdpdGggYSBsZXhpY2FsIHNjb3BlLCBhbmQgZG8gbm90IG5lZWQgdG8gYmUgYm91bmRcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7XG4gICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc3RhcnRzdHJlYW1pbmcnLCB0aGlzLl9vblN0YXJ0U3RyZWFtaW5nKTtcbiAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignZW5kc3RyZWFtaW5nJywgdGhpcy5fb25FbmRTdHJlYW1pbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmF0dGFjaFRyYW5zZmVycmVkID0gZnVuY3Rpb24gYXR0YWNoVHJhbnNmZXJyZWQoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMudHJhbnNmZXJEYXRhO1xuICAgICAgaWYgKCFkYXRhIHx8ICFtZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVxdWlyZWRUcmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICAgIHZhciB0cmFuc2ZlcnJlZFRyYWNrcyA9IGRhdGEudHJhY2tzO1xuICAgICAgdmFyIHRyYWNrTmFtZXMgPSB0cmFuc2ZlcnJlZFRyYWNrcyA/IE9iamVjdC5rZXlzKHRyYW5zZmVycmVkVHJhY2tzKSA6IG51bGw7XG4gICAgICB2YXIgdHJhY2tDb3VudCA9IHRyYWNrTmFtZXMgPyB0cmFja05hbWVzLmxlbmd0aCA6IDA7XG4gICAgICB2YXIgbWVkaWFTb3VyY2VPcGVuQ2FsbGJhY2sgPSBmdW5jdGlvbiBtZWRpYVNvdXJjZU9wZW5DYWxsYmFjaygpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXM2Lm1lZGlhICYmIF90aGlzNi5tZWRpYVNvdXJjZU9wZW5PckVuZGVkKSB7XG4gICAgICAgICAgICBfdGhpczYuX29uTWVkaWFTb3VyY2VPcGVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBpZiAodHJhbnNmZXJyZWRUcmFja3MgJiYgdHJhY2tOYW1lcyAmJiB0cmFja0NvdW50KSB7XG4gICAgICAgIGlmICghdGhpcy50cmFja3NSZWFkeSkge1xuICAgICAgICAgIC8vIFdhaXQgZm9yIENPREVDUyBldmVudChzKVxuICAgICAgICAgIHRoaXMuaGxzLmNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb2coXCJhdHRhY2hUcmFuc2ZlcnJlZDogd2FpdGluZyBmb3IgU291cmNlQnVmZmVyIHRyYWNrIGluZm9cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKFwiYXR0YWNoVHJhbnNmZXJyZWQ6IChidWZmZXJDb2RlY0V2ZW50c1RvdGFsIFwiICsgdGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsICsgXCIpXFxucmVxdWlyZWQgdHJhY2tzOiBcIiArIHN0cmluZ2lmeShyZXF1aXJlZFRyYWNrcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ID09PSAnaW5pdFNlZ21lbnQnID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgICAgIH0pICsgXCI7XFxudHJhbnNmZXIgdHJhY2tzOiBcIiArIHN0cmluZ2lmeSh0cmFuc2ZlcnJlZFRyYWNrcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ID09PSAnaW5pdFNlZ21lbnQnID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgICAgIH0pICsgXCJ9XCIpO1xuICAgICAgICBpZiAoIWlzQ29tcGF0aWJsZVRyYWNrQ2hhbmdlKHRyYW5zZmVycmVkVHJhY2tzLCByZXF1aXJlZFRyYWNrcykpIHtcbiAgICAgICAgICAvLyBkZXN0cm95IGF0dGFjaGluZyBtZWRpYSBzb3VyY2VcbiAgICAgICAgICBkYXRhLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgICAgICBkYXRhLnRyYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgICB2YXIgZGV0YWlscyA9IHRoaXMuZGV0YWlscztcbiAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gTWF0aC5tYXgoY3VycmVudFRpbWUsIChkZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydCkgfHwgMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lID4gMSkge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJhdHRhY2hUcmFuc2ZlcnJlZDogd2FpdGluZyBmb3IgcGxheWJhY2sgdG8gcmVhY2ggbmV3IHRyYWNrcyBzdGFydCB0aW1lIFwiICsgY3VycmVudFRpbWUgKyBcIiAtPiBcIiArIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud2FybihcImF0dGFjaFRyYW5zZmVycmVkOiByZXNldHRpbmcgTWVkaWFTb3VyY2UgZm9yIGluY29tcGF0aWJsZSB0cmFja3MgKFxcXCJcIiArIE9iamVjdC5rZXlzKHRyYW5zZmVycmVkVHJhY2tzKSArIFwiXFxcIi0+XFxcIlwiICsgT2JqZWN0LmtleXMocmVxdWlyZWRUcmFja3MpICsgXCJcXFwiKSBzdGFydCB0aW1lOiBcIiArIHN0YXJ0VGltZSArIFwiIGN1cnJlbnRUaW1lOiBcIiArIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoRXZlbnRzLk1FRElBX0RFVEFDSElORywge30pO1xuICAgICAgICAgIHRoaXMub25NZWRpYUF0dGFjaGluZyhFdmVudHMuTUVESUFfQVRUQUNISU5HLCBkYXRhKTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2ZlckRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyYWNrTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0cmFja05hbWU7XG4gICAgICAgICAgdmFyIHRyYWNrID0gdHJhbnNmZXJyZWRUcmFja3NbdHlwZV07XG4gICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgc2IgPSB0cmFjay5idWZmZXI7XG4gICAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgICAgLy8gUHVyZ2UgZnJhZ21lbnQgdHJhY2tlciBvZiBlamVjdGVkIHNlZ21lbnRzIGZvciBleGlzdGluZyBidWZmZXJcbiAgICAgICAgICAgICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IF90aGlzNi5mcmFnbWVudFRyYWNrZXI7XG4gICAgICAgICAgICAgIHZhciBwbGF5bGlzdFR5cGUgPSB0cmFjay5pZDtcbiAgICAgICAgICAgICAgaWYgKGZyYWdtZW50VHJhY2tlci5oYXNGcmFnbWVudHMocGxheWxpc3RUeXBlKSB8fCBmcmFnbWVudFRyYWNrZXIuaGFzUGFydHMocGxheWxpc3RUeXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXJlZFRpbWVSYW5nZXMgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc2IpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50VHJhY2tlci5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKHR5cGUsIGJ1ZmZlcmVkVGltZVJhbmdlcywgcGxheWxpc3RUeXBlLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBUcmFuc2ZlciBTb3VyY2VCdWZmZXJcbiAgICAgICAgICAgICAgdmFyIHNiSW5kZXggPSBzb3VyY2VCdWZmZXJOYW1lVG9JbmRleCh0eXBlKTtcbiAgICAgICAgICAgICAgdmFyIHNiVHVwbGUgPSBbdHlwZSwgc2JdO1xuICAgICAgICAgICAgICBfdGhpczYuc291cmNlQnVmZmVyc1tzYkluZGV4XSA9IHNiVHVwbGU7XG4gICAgICAgICAgICAgIGlmIChzYi51cGRhdGluZyAmJiBfdGhpczYub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICAgICAgX3RoaXM2Lm9wZXJhdGlvblF1ZXVlLnByZXBlbmRCbG9ja2VyKHR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzNi50cmFja1NvdXJjZUJ1ZmZlcih0eXBlLCB0cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVkaWFTb3VyY2VPcGVuQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5idWZmZXJDcmVhdGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZyhcImF0dGFjaFRyYW5zZmVycmVkOiBNZWRpYVNvdXJjZSB3L28gU291cmNlQnVmZmVyc1wiKTtcbiAgICAgICAgbWVkaWFTb3VyY2VPcGVuQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgICB2YXIgdHJhbnNmZXJyaW5nTWVkaWEgPSAhIWRhdGEudHJhbnNmZXJNZWRpYTtcbiAgICAgIHRoaXMudHJhbnNmZXJEYXRhID0gdGhpcy5vdmVycmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXG4gICAgICAgIF9vYmplY3RVcmwgPSB0aGlzLl9vYmplY3RVcmw7XG4gICAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5sb2coXCJtZWRpYSBzb3VyY2UgXCIgKyAodHJhbnNmZXJyaW5nTWVkaWEgPyAndHJhbnNmZXJyaW5nJyA6ICdkZXRhY2hpbmcnKSk7XG4gICAgICAgIGlmICh0cmFuc2ZlcnJpbmdNZWRpYSkge1xuICAgICAgICAgIC8vIERldGFjaCBTb3VyY2VCdWZmZXJzIHdpdGhvdXQgcmVtb3ZpbmcgZnJvbSBNZWRpYVNvdXJjZVxuICAgICAgICAgIC8vIGFuZCBsZWF2ZSBgdHJhY2tzYCAocmVxdWlyZWQgU291cmNlQnVmZmVycyBjb25maWd1cmF0aW9uKVxuICAgICAgICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9yZWZbMF07XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICBfdGhpczcucmVtb3ZlQnVmZmVyKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucmVzZXRRdWV1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLm1lZGlhU291cmNlT3Blbk9yRW5kZWQpIHtcbiAgICAgICAgICAgIHZhciBvcGVuID0gbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZUJ1ZmZlcnMgPSBtZWRpYVNvdXJjZS5zb3VyY2VCdWZmZXJzO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc291cmNlQnVmZmVycy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgICAgc291cmNlQnVmZmVyc1tpXS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc291cmNlQnVmZmVyc1tpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBlbmRPZlN0cmVhbSBjb3VsZCB0cmlnZ2VyIGV4Y2VwdGlvbiBpZiBhbnkgc291cmNlYnVmZmVyIGlzIGluIHVwZGF0aW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgY2hlY2tpbmcgc291cmNlYnVmZmVyIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gYXMgd2UgYXJlIGFueXdheSBkZXRhY2hpbmcgdGhlIE1lZGlhU291cmNlXG4gICAgICAgICAgICAgICAgLy8gbGV0J3MganVzdCBhdm9pZCB0aGlzIGV4Y2VwdGlvbiB0byBwcm9wYWdhdGVcbiAgICAgICAgICAgICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhpcy53YXJuKFwib25NZWRpYURldGFjaGluZzogXCIgKyBlcnIubWVzc2FnZSArIFwiIHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBTb3VyY2VCdWZmZXJzIGJ5IGludm9raW5nIG9uQnVmZmVyUmVzZXRcbiAgICAgICAgICBpZiAodGhpcy5zb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5vbkJ1ZmZlclJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpO1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGFydHN0cmVhbWluZycsIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcpO1xuICAgICAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZHN0cmVhbWluZycsIHRoaXMuX29uRW5kU3RyZWFtaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgICAgIGlmICghdHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgICAgICBpZiAoX29iamVjdFVybCkge1xuICAgICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKF9vYmplY3RVcmwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNsZWFuIHVwIHZpZGVvIHRhZyBzcmMgb25seSBpZiBpdCdzIG91ciBvd24gdXJsLiBzb21lIGV4dGVybmFsIGxpYnJhcmllcyBtaWdodFxuICAgICAgICAgIC8vIGhpamFjayB0aGUgdmlkZW8gdGFnIGFuZCBjaGFuZ2UgaXRzICdzcmMnIHdpdGhvdXQgZGVzdHJveWluZyB0aGUgSGxzIGluc3RhbmNlIGZpcnN0XG4gICAgICAgICAgaWYgKHRoaXMubWVkaWFTcmMgPT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlU291cmNlQ2hpbGRyZW4obWVkaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVkaWEubG9hZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oJ21lZGlhfHNvdXJjZS5zcmMgd2FzIGNoYW5nZWQgYnkgYSB0aGlyZCBwYXJ0eSAtIHNraXAgY2xlYW51cCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0RFVEFDSEVELCBkYXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlclJlc2V0ID0gZnVuY3Rpb24gb25CdWZmZXJSZXNldCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZjJbMF07XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgX3RoaXM4LnJlc2V0QnVmZmVyKHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5pdFRyYWNrcygpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0QnVmZmVyID0gZnVuY3Rpb24gcmVzZXRCdWZmZXIodHlwZSkge1xuICAgICAgdmFyIF90aGlzJHRyYWNrcyR0eXBlO1xuICAgICAgdmFyIHNiID0gKF90aGlzJHRyYWNrcyR0eXBlID0gdGhpcy50cmFja3NbdHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFja3MkdHlwZS5idWZmZXI7XG4gICAgICB0aGlzLnJlbW92ZUJ1ZmZlcih0eXBlKTtcbiAgICAgIGlmIChzYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTtcbiAgICAgICAgICBpZiAoKF90aGlzJG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYVNvdXJjZS5zb3VyY2VCdWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwib25CdWZmZXJSZXNldCBcIiArIHR5cGUsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVCdWZmZXIgPSBmdW5jdGlvbiByZW1vdmVCdWZmZXIodHlwZSkge1xuICAgICAgdGhpcy5yZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSk7XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnNbc291cmNlQnVmZmVyTmFtZVRvSW5kZXgodHlwZSldID0gW251bGwsIG51bGxdO1xuICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgdHJhY2suYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0UXVldWUgPSBmdW5jdGlvbiByZXNldFF1ZXVlKCkge1xuICAgICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wZXJhdGlvblF1ZXVlID0gbmV3IEJ1ZmZlck9wZXJhdGlvblF1ZXVlKHRoaXMudHJhY2tzKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckNvZGVjcyA9IGZ1bmN0aW9uIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcyxcbiAgICAgICAgX2RhdGEkYXVkaW87XG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICB2YXIgdHJhY2tOYW1lcyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgdGhpcy5sb2coXCJCVUZGRVJfQ09ERUNTOiBcXFwiXCIgKyB0cmFja05hbWVzICsgXCJcXFwiIChjdXJyZW50IFNCIGNvdW50IFwiICsgdGhpcy5zb3VyY2VCdWZmZXJDb3VudCArIFwiKVwiKTtcbiAgICAgIHZhciB1bm11eGVkVG9NdXhlZCA9ICdhdWRpb3ZpZGVvJyBpbiBkYXRhICYmICh0cmFja3MuYXVkaW8gfHwgdHJhY2tzLnZpZGVvKSB8fCB0cmFja3MuYXVkaW92aWRlbyAmJiAoJ2F1ZGlvJyBpbiBkYXRhIHx8ICd2aWRlbycgaW4gZGF0YSk7XG4gICAgICB2YXIgbXV4ZWRUb1VubXV4ZWQgPSAhdW5tdXhlZFRvTXV4ZWQgJiYgdGhpcy5zb3VyY2VCdWZmZXJDb3VudCAmJiB0aGlzLm1lZGlhICYmIHRyYWNrTmFtZXMuc29tZShmdW5jdGlvbiAoc2JOYW1lKSB7XG4gICAgICAgIHJldHVybiAhdHJhY2tzW3NiTmFtZV07XG4gICAgICB9KTtcbiAgICAgIGlmICh1bm11eGVkVG9NdXhlZCB8fCBtdXhlZFRvVW5tdXhlZCkge1xuICAgICAgICB0aGlzLndhcm4oXCJVbnN1cHBvcnRlZCB0cmFuc2l0aW9uIGJldHdlZW4gXFxcIlwiICsgT2JqZWN0LmtleXModHJhY2tzKSArIFwiXFxcIiBhbmQgXFxcIlwiICsgdHJhY2tOYW1lcyArIFwiXFxcIiBTb3VyY2VCdWZmZXJzXCIpO1xuICAgICAgICAvLyBEbyBub3QgYWRkIGluY29tcGF0aWJsZSB0cmFjayAoJ2F1ZGlvdmlkZW8nIDwtPiAndmlkZW8nLydhdWRpbycpLlxuICAgICAgICAvLyBBbGxvdyBmb2xsb3dpbmcgb25CdWZmZXJBcHBlbmRpbmcgaGFuZGxlIHRvIHRyaWdnZXIgQlVGRkVSX0FQUEVORF9FUlJPUi5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGVpdGhlciBiZSByZXNvbHZlZCBieSBsZXZlbCBzd2l0Y2ggb3IgY291bGQgYmUgaGFuZGxlZCB3aXRoIHJlY292ZXJNZWRpYUVycm9yKCkuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWNrTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgIHZhciBfdGhpczkkdHJhbnNmZXJEYXRhLCBfdHJhY2tDb2RlYztcbiAgICAgICAgdmFyIHBhcnNlZFRyYWNrID0gZGF0YVt0cmFja05hbWVdO1xuICAgICAgICB2YXIgaWQgPSBwYXJzZWRUcmFjay5pZCxcbiAgICAgICAgICBjb2RlYyA9IHBhcnNlZFRyYWNrLmNvZGVjLFxuICAgICAgICAgIGxldmVsQ29kZWMgPSBwYXJzZWRUcmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgIGNvbnRhaW5lciA9IHBhcnNlZFRyYWNrLmNvbnRhaW5lcixcbiAgICAgICAgICBtZXRhZGF0YSA9IHBhcnNlZFRyYWNrLm1ldGFkYXRhLFxuICAgICAgICAgIHN1cHBsZW1lbnRhbCA9IHBhcnNlZFRyYWNrLnN1cHBsZW1lbnRhbDtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIHZhciB0cmFuc2ZlcnJlZFRyYWNrID0gKF90aGlzOSR0cmFuc2ZlckRhdGEgPSBfdGhpczkudHJhbnNmZXJEYXRhKSA9PSBudWxsIHx8IChfdGhpczkkdHJhbnNmZXJEYXRhID0gX3RoaXM5JHRyYW5zZmVyRGF0YS50cmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpczkkdHJhbnNmZXJEYXRhW3RyYWNrTmFtZV07XG4gICAgICAgIHZhciBzYlRyYWNrID0gdHJhbnNmZXJyZWRUcmFjayAhPSBudWxsICYmIHRyYW5zZmVycmVkVHJhY2suYnVmZmVyID8gdHJhbnNmZXJyZWRUcmFjayA6IHRyYWNrO1xuICAgICAgICB2YXIgc2JDb2RlYyA9IChzYlRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBzYlRyYWNrLnBlbmRpbmdDb2RlYykgfHwgKHNiVHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHNiVHJhY2suY29kZWMpO1xuICAgICAgICB2YXIgdHJhY2tMZXZlbENvZGVjID0gc2JUcmFjayA9PSBudWxsID8gdm9pZCAwIDogc2JUcmFjay5sZXZlbENvZGVjO1xuICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXSA9IHtcbiAgICAgICAgICAgIGJ1ZmZlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgICAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgICAgICAgIHN1cHBsZW1lbnRhbDogc3VwcGxlbWVudGFsLFxuICAgICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiBsZXZlbENvZGVjLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiBTb3VyY2VCdWZmZXIgY29kZWMgbmVlZHMgdG8gY2hhbmdlXG4gICAgICAgIHZhciBjdXJyZW50Q29kZWNGdWxsID0gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZShzYkNvZGVjLCB0cmFja0xldmVsQ29kZWMpO1xuICAgICAgICB2YXIgY3VycmVudENvZGVjID0gY3VycmVudENvZGVjRnVsbCA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudENvZGVjRnVsbC5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSwgJyQxJyk7XG4gICAgICAgIHZhciB0cmFja0NvZGVjID0gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZShjb2RlYywgbGV2ZWxDb2RlYyk7XG4gICAgICAgIHZhciBuZXh0Q29kZWMgPSAoX3RyYWNrQ29kZWMgPSB0cmFja0NvZGVjKSA9PSBudWxsID8gdm9pZCAwIDogX3RyYWNrQ29kZWMucmVwbGFjZShWSURFT19DT0RFQ19QUk9GSUxFX1JFUExBQ0UsICckMScpO1xuICAgICAgICBpZiAodHJhY2tDb2RlYyAmJiBjdXJyZW50Q29kZWNGdWxsICYmIGN1cnJlbnRDb2RlYyAhPT0gbmV4dENvZGVjKSB7XG4gICAgICAgICAgaWYgKHRyYWNrTmFtZS5zbGljZSgwLCA1KSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdHJhY2tDb2RlYyA9IGdldENvZGVjQ29tcGF0aWJsZU5hbWUodHJhY2tDb2RlYywgX3RoaXM5LmFwcGVuZFNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzOS5sb2coXCJzd2l0Y2hpbmcgY29kZWMgXCIgKyBzYkNvZGVjICsgXCIgdG8gXCIgKyB0cmFja0NvZGVjKTtcbiAgICAgICAgICBpZiAodHJhY2tDb2RlYyAhPT0gKHRyYWNrLnBlbmRpbmdDb2RlYyB8fCB0cmFjay5jb2RlYykpIHtcbiAgICAgICAgICAgIHRyYWNrLnBlbmRpbmdDb2RlYyA9IHRyYWNrQ29kZWM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYWNrLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgICBfdGhpczkuYXBwZW5kQ2hhbmdlVHlwZSh0cmFja05hbWUsIGNvbnRhaW5lciwgdHJhY2tDb2RlYyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudHJhY2tzUmVhZHkgfHwgdGhpcy5zb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgICBkYXRhLnRyYWNrcyA9IHRoaXMuc291cmNlQnVmZmVyVHJhY2tzO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBzb3VyY2VidWZmZXJzIGFscmVhZHkgY3JlYXRlZCwgZG8gbm90aGluZyAuLi5cbiAgICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzVG90YWwgPiAxICYmICF0aGlzLnRyYWNrcy52aWRlbyAmJiAhZGF0YS52aWRlbyAmJiAoKF9kYXRhJGF1ZGlvID0gZGF0YS5hdWRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGF1ZGlvLmlkKSA9PT0gJ21haW4nKSB7XG4gICAgICAgIC8vIE1WUCBpcyBtaXNzaW5nIENPREVDUyBhbmQgb25seSBhdWRpbyB3YXMgZm91bmQgaW4gbWFpbiBzZWdtZW50ICgjNzUyNClcbiAgICAgICAgdGhpcy5sb2coXCJNYWluIGF1ZGlvLW9ubHlcIik7XG4gICAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZU9wZW5PckVuZGVkKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYXBwZW5kQ2hhbmdlVHlwZSA9IGZ1bmN0aW9uIGFwcGVuZENoYW5nZVR5cGUodHlwZSwgY29udGFpbmVyLCBjb2RlYykge1xuICAgICAgdmFyIF90aGlzMCA9IHRoaXM7XG4gICAgICB2YXIgbWltZVR5cGUgPSBjb250YWluZXIgKyBcIjtjb2RlY3M9XCIgKyBjb2RlYztcbiAgICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICAgIGxhYmVsOiBcImNoYW5nZS10eXBlPVwiICsgbWltZVR5cGUsXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgICAgICAgdmFyIHRyYWNrID0gX3RoaXMwLnRyYWNrc1t0eXBlXTtcbiAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIHZhciBzYiA9IHRyYWNrLmJ1ZmZlcjtcbiAgICAgICAgICAgIGlmIChzYiAhPSBudWxsICYmIHNiLmNoYW5nZVR5cGUpIHtcbiAgICAgICAgICAgICAgX3RoaXMwLmxvZyhcImNoYW5naW5nIFwiICsgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciB0eXBlIHRvIFwiICsgbWltZVR5cGUpO1xuICAgICAgICAgICAgICBzYi5jaGFuZ2VUeXBlKG1pbWVUeXBlKTtcbiAgICAgICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlYztcbiAgICAgICAgICAgICAgdHJhY2suY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczAuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHt9LFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge30sXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczAud2FybihcIkZhaWxlZCB0byBjaGFuZ2UgXCIgKyB0eXBlICsgXCIgU291cmNlQnVmZmVyIHR5cGVcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5hcHBlbmQob3BlcmF0aW9uLCB0eXBlLCB0aGlzLmlzUGVuZGluZyh0aGlzLnRyYWNrc1t0eXBlXSkpO1xuICAgIH07XG4gICAgX3Byb3RvLmJsb2NrQXVkaW8gPSBmdW5jdGlvbiBibG9ja0F1ZGlvKHBhcnRPckZyYWcpIHtcbiAgICAgIHZhciBfdGhpcyRmcmFnbWVudFRyYWNrZXIsXG4gICAgICAgIF90aGlzMSA9IHRoaXM7XG4gICAgICB2YXIgcFN0YXJ0ID0gcGFydE9yRnJhZy5zdGFydDtcbiAgICAgIHZhciBwVGltZSA9IHBTdGFydCArIHBhcnRPckZyYWcuZHVyYXRpb24gKiAwLjA1O1xuICAgICAgdmFyIGF0R2FwID0gKChfdGhpcyRmcmFnbWVudFRyYWNrZXIgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcocFN0YXJ0LCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGZyYWdtZW50VHJhY2tlci5nYXApID09PSB0cnVlO1xuICAgICAgaWYgKGF0R2FwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvcCA9IHtcbiAgICAgICAgbGFiZWw6ICdibG9jay1hdWRpbycsXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgICAgICAgdmFyIF90aGlzMSRmcmFnbWVudFRyYWNrZTtcbiAgICAgICAgICB2YXIgdmlkZW9UcmFjayA9IF90aGlzMS50cmFja3MudmlkZW87XG4gICAgICAgICAgaWYgKF90aGlzMS5sYXN0VmlkZW9BcHBlbmRFbmQgPiBwVGltZSB8fCB2aWRlb1RyYWNrICE9IG51bGwgJiYgdmlkZW9UcmFjay5idWZmZXIgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW9UcmFjay5idWZmZXIsIHBUaW1lKSB8fCAoKF90aGlzMSRmcmFnbWVudFRyYWNrZSA9IF90aGlzMS5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHBUaW1lLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzMSRmcmFnbWVudFRyYWNrZS5nYXApID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfdGhpczEuYmxvY2tlZEF1ZGlvQXBwZW5kID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzMS5zaGlmdEFuZEV4ZWN1dGVOZXh0KCdhdWRpbycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHt9LFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge30sXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczEud2FybignRXJyb3IgZXhlY3V0aW5nIGJsb2NrLWF1ZGlvIG9wZXJhdGlvbicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kID0ge1xuICAgICAgICBvcDogb3AsXG4gICAgICAgIGZyYWc6IHBhcnRPckZyYWdcbiAgICAgIH07XG4gICAgICB0aGlzLmFwcGVuZChvcCwgJ2F1ZGlvJywgdHJ1ZSk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5ibG9ja0F1ZGlvID0gZnVuY3Rpb24gdW5ibG9ja0F1ZGlvKCkge1xuICAgICAgdmFyIGJsb2NrZWRBdWRpb0FwcGVuZCA9IHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kLFxuICAgICAgICBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7XG4gICAgICBpZiAoYmxvY2tlZEF1ZGlvQXBwZW5kICYmIG9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICAgIHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kID0gbnVsbDtcbiAgICAgICAgb3BlcmF0aW9uUXVldWUudW5ibG9ja0F1ZGlvKGJsb2NrZWRBdWRpb0FwcGVuZC5vcCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJBcHBlbmRpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckFwcGVuZGluZyhldmVudCwgZXZlbnREYXRhKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICB2YXIgZGF0YSA9IGV2ZW50RGF0YS5kYXRhLFxuICAgICAgICB0eXBlID0gZXZlbnREYXRhLnR5cGUsXG4gICAgICAgIHBhcmVudCA9IGV2ZW50RGF0YS5wYXJlbnQsXG4gICAgICAgIGZyYWcgPSBldmVudERhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGV2ZW50RGF0YS5wYXJ0LFxuICAgICAgICBjaHVua01ldGEgPSBldmVudERhdGEuY2h1bmtNZXRhLFxuICAgICAgICBvZmZzZXQgPSBldmVudERhdGEub2Zmc2V0O1xuICAgICAgdmFyIGNodW5rU3RhdHMgPSBjaHVua01ldGEuYnVmZmVyaW5nW3R5cGVdO1xuICAgICAgdmFyIHNuID0gZnJhZy5zbixcbiAgICAgICAgY2MgPSBmcmFnLmNjO1xuICAgICAgdmFyIGJ1ZmZlckFwcGVuZGluZ1N0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNodW5rU3RhdHMuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICAgIHZhciBmcmFnQnVmZmVyaW5nID0gZnJhZy5zdGF0cy5idWZmZXJpbmc7XG4gICAgICB2YXIgcGFydEJ1ZmZlcmluZyA9IHBhcnQgPyBwYXJ0LnN0YXRzLmJ1ZmZlcmluZyA6IG51bGw7XG4gICAgICBpZiAoZnJhZ0J1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgICBmcmFnQnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgIHBhcnRCdWZmZXJpbmcuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogT25seSB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0IHdoZW4gYXVkaW8vbXBlZyBmcmFnbWVudCBvciBwYXJ0IGlzIG5vdCBjb250aWd1b3VzIHdpdGggcHJldmlvdXNseSBhcHBlbmRlZFxuICAgICAgLy8gQWRqdXN0aW5nIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YCAoZGVzaXJlZCBwb2ludCBpbiB0aGUgdGltZWxpbmUgd2hlcmUgdGhlIG5leHQgZnJhbWVzIHNob3VsZCBiZSBhcHBlbmRlZClcbiAgICAgIC8vIGluIENocm9tZSBicm93c2VyIHdoZW4gd2UgZGV0ZWN0IE1QRUcgYXVkaW8gY29udGFpbmVyIGFuZCB0aW1lIGRlbHRhIGJldHdlZW4gbGV2ZWwgUFRTIGFuZCBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGBcbiAgICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS5cbiAgICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzMyI2lzc3VlY29tbWVudC0yNTc5ODY0ODZcbiAgICAgIHZhciBhdWRpb1RyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgdmFyIGNoZWNrVGltZXN0YW1wT2Zmc2V0ID0gZmFsc2U7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiAoYXVkaW9UcmFjayA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9UcmFjay5jb250YWluZXIpID09PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgICAgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSAhdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgfHwgY2h1bmtNZXRhLmlkID09PSAxIHx8IHRoaXMubGFzdE1wZWdBdWRpb0NodW5rLnNuICE9PSBjaHVua01ldGEuc247XG4gICAgICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gY2h1bmtNZXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBCbG9jayBhdWRpbyBhcHBlbmQgdW50aWwgb3ZlcmxhcHBpbmcgdmlkZW8gYXBwZW5kXG4gICAgICB2YXIgdmlkZW9UcmFjayA9IHRyYWNrcy52aWRlbztcbiAgICAgIHZhciB2aWRlb1NiID0gdmlkZW9UcmFjayA9PSBudWxsID8gdm9pZCAwIDogdmlkZW9UcmFjay5idWZmZXI7XG4gICAgICBpZiAodmlkZW9TYiAmJiBzbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB2YXIgcGFydE9yRnJhZyA9IHBhcnQgfHwgZnJhZztcbiAgICAgICAgdmFyIGJsb2NrZWRBdWRpb0FwcGVuZCA9IHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBwYXJlbnQgIT09ICdtYWluJyAmJiAhdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQgJiYgISh2aWRlb1RyYWNrLmVuZGluZyB8fCB2aWRlb1RyYWNrLmVuZGVkKSkge1xuICAgICAgICAgIHZhciBwU3RhcnQgPSBwYXJ0T3JGcmFnLnN0YXJ0O1xuICAgICAgICAgIHZhciBwVGltZSA9IHBTdGFydCArIHBhcnRPckZyYWcuZHVyYXRpb24gKiAwLjA1O1xuICAgICAgICAgIHZhciB2YnVmZmVyZWQgPSB2aWRlb1NiLmJ1ZmZlcmVkO1xuICAgICAgICAgIHZhciB2YXBwZW5kaW5nID0gdGhpcy5jdXJyZW50T3AoJ3ZpZGVvJyk7XG4gICAgICAgICAgaWYgKCF2YnVmZmVyZWQubGVuZ3RoICYmICF2YXBwZW5kaW5nKSB7XG4gICAgICAgICAgICAvLyB3YWl0IGZvciB2aWRlbyBiZWZvcmUgYXBwZW5kaW5nIGF1ZGlvXG4gICAgICAgICAgICB0aGlzLmJsb2NrQXVkaW8ocGFydE9yRnJhZyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdmFwcGVuZGluZyAmJiAhQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW9TYiwgcFRpbWUpICYmIHRoaXMubGFzdFZpZGVvQXBwZW5kRW5kIDwgcFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGF1ZGlvIGlzIGFoZWFkIG9mIHZpZGVvXG4gICAgICAgICAgICB0aGlzLmJsb2NrQXVkaW8ocGFydE9yRnJhZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICB2YXIgdmlkZW9BcHBlbmRFbmQgPSBwYXJ0T3JGcmFnLmVuZDtcbiAgICAgICAgICBpZiAoYmxvY2tlZEF1ZGlvQXBwZW5kKSB7XG4gICAgICAgICAgICB2YXIgYXVkaW9TdGFydCA9IGJsb2NrZWRBdWRpb0FwcGVuZC5mcmFnLnN0YXJ0O1xuICAgICAgICAgICAgaWYgKHZpZGVvQXBwZW5kRW5kID4gYXVkaW9TdGFydCB8fCB2aWRlb0FwcGVuZEVuZCA8IHRoaXMubGFzdFZpZGVvQXBwZW5kRW5kIHx8IEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvU2IsIGF1ZGlvU3RhcnQpKSB7XG4gICAgICAgICAgICAgIHRoaXMudW5ibG9ja0F1ZGlvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGFzdFZpZGVvQXBwZW5kRW5kID0gdmlkZW9BcHBlbmRFbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBmcmFnU3RhcnQgPSAocGFydCB8fCBmcmFnKS5zdGFydDtcbiAgICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICAgIGxhYmVsOiBcImFwcGVuZC1cIiArIHR5cGUsXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgICAgICAgdmFyIF90aGlzMTAkdHJhY2tzJHR5cGU7XG4gICAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlU3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIHZhciBzYiA9IChfdGhpczEwJHRyYWNrcyR0eXBlID0gX3RoaXMxMC50cmFja3NbdHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpczEwJHRyYWNrcyR0eXBlLmJ1ZmZlcjtcbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIGlmIChjaGVja1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICAgICAgICBfdGhpczEwLnVwZGF0ZVRpbWVzdGFtcE9mZnNldChzYiwgZnJhZ1N0YXJ0LCAwLjEsIHR5cGUsIHNuLCBjYyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIGlzRmluaXRlTnVtYmVyKG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgX3RoaXMxMC51cGRhdGVUaW1lc3RhbXBPZmZzZXQoc2IsIG9mZnNldCwgMC4wMDAwMDEsIHR5cGUsIHNuLCBjYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMTAuYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke3R5cGV9IFNvdXJjZUJ1ZmZlciB1cGRhdGVzdGFydGApO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlZW5kYCk7XG4gICAgICAgICAgdmFyIGVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlRW5kID0gY2h1bmtTdGF0cy5lbmQgPSBlbmQ7XG4gICAgICAgICAgaWYgKGZyYWdCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICAgIGZyYWdCdWZmZXJpbmcuZmlyc3QgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICAgIHBhcnRCdWZmZXJpbmcuZmlyc3QgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0aW1lUmFuZ2VzID0ge307XG4gICAgICAgICAgX3RoaXMxMC5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9yZWYzWzBdLFxuICAgICAgICAgICAgICBzYiA9IF9yZWYzWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgdGltZVJhbmdlc1t0eXBlXSA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChzYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXMxMC5hcHBlbmRFcnJvcnNbdHlwZV0gPSAwO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIF90aGlzMTAuYXBwZW5kRXJyb3JzLmF1ZGlvdmlkZW8gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczEwLmFwcGVuZEVycm9ycy5hdWRpbyA9IDA7XG4gICAgICAgICAgICBfdGhpczEwLmFwcGVuZEVycm9ycy52aWRlbyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMTAuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICAgIHRpbWVSYW5nZXM6IHRpbWVSYW5nZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICAgIHZhciBfdGhpczEwJG1lZGlhO1xuICAgICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXG4gICAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IsXG4gICAgICAgICAgICBzb3VyY2VCdWZmZXJOYW1lOiB0eXBlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIGVycjogZXJyb3IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBtZWRpYUVycm9yID0gKF90aGlzMTAkbWVkaWEgPSBfdGhpczEwLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMxMCRtZWRpYS5lcnJvcjtcbiAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gRE9NRXhjZXB0aW9uLlFVT1RBX0VYQ0VFREVEX0VSUiB8fCBlcnJvci5uYW1lID09ICdRdW90YUV4Y2VlZGVkRXJyb3InIHx8IFwicXVvdGFcIiBpbiBlcnJvcikge1xuICAgICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXG4gICAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuY29kZSA9PT0gRE9NRXhjZXB0aW9uLklOVkFMSURfU1RBVEVfRVJSICYmIF90aGlzMTAubWVkaWFTb3VyY2VPcGVuT3JFbmRlZCAmJiAhbWVkaWFFcnJvcikge1xuICAgICAgICAgICAgLy8gQWxsb3cgcmV0cnkgZm9yIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2FwcGVuZEJ1ZmZlcicgb24gJ1NvdXJjZUJ1ZmZlcic6IFRoaXMgU291cmNlQnVmZmVyIGlzIHN0aWxsIHByb2Nlc3NpbmdcIiBlcnJvcnNcbiAgICAgICAgICAgIGV2ZW50LmVycm9yQWN0aW9uID0gY3JlYXRlRG9Ob3RoaW5nRXJyb3JBY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5uYW1lID09PSBUUkFDS19SRU1PVkVEX0VSUk9SX05BTUUgJiYgX3RoaXMxMC5zb3VyY2VCdWZmZXJDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBzb3VyY2VCdWZmZXJzIHdlcmUgcmVtb3ZlZCAobWVkaWEgaXMgZGV0YWNoZWQgYW5kIGFwcGVuZCB3YXMgbm90IGFib3J0ZWQpXG4gICAgICAgICAgICBldmVudC5lcnJvckFjdGlvbiA9IGNyZWF0ZURvTm90aGluZ0Vycm9yQWN0aW9uKHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXBwZW5kRXJyb3JDb3VudCA9ICsrX3RoaXMxMC5hcHBlbmRFcnJvcnNbdHlwZV07XG4gICAgICAgICAgICAvKiB3aXRoIFVIRCBjb250ZW50LCB3ZSBjb3VsZCBnZXQgbG9vcCBvZiBxdW90YSBleGNlZWRlZCBlcnJvciB1bnRpbFxuICAgICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiBSZXRyeWluZyBjYW4gaGVscCByZWNvdmVyLlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzMTAud2FybihcIkZhaWxlZCBcIiArIGFwcGVuZEVycm9yQ291bnQgKyBcIi9cIiArIF90aGlzMTAuaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5ICsgXCIgdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gXFxcIlwiICsgdHlwZSArIFwiXFxcIiBzb3VyY2VCdWZmZXIgKFwiICsgKG1lZGlhRXJyb3IgPyBtZWRpYUVycm9yIDogJ25vIG1lZGlhIGVycm9yJykgKyBcIilcIik7XG4gICAgICAgICAgICBpZiAoYXBwZW5kRXJyb3JDb3VudCA+PSBfdGhpczEwLmhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSB8fCAhIW1lZGlhRXJyb3IpIHtcbiAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczEwLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coXCJxdWV1aW5nIFxcXCJcIiArIHR5cGUgKyBcIlxcXCIgYXBwZW5kIHNuOiBcIiArIHNuICsgKHBhcnQgPyAnIHA6ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgXCIgKyAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCIgXCIgKyBmcmFnLmxldmVsICsgXCIgY2M6IFwiICsgY2MpO1xuICAgICAgdGhpcy5hcHBlbmQob3BlcmF0aW9uLCB0eXBlLCB0aGlzLmlzUGVuZGluZyh0aGlzLnRyYWNrc1t0eXBlXSkpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEZsdXNoT3AgPSBmdW5jdGlvbiBnZXRGbHVzaE9wKHR5cGUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcbiAgICAgIHRoaXMubG9nKFwicXVldWluZyBcXFwiXCIgKyB0eXBlICsgXCJcXFwiIHJlbW92ZSBcIiArIHN0YXJ0ICsgXCItXCIgKyBlbmQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWw6ICdyZW1vdmUnLFxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICAgIF90aGlzMTEucmVtb3ZlRXhlY3V0b3IodHlwZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBTdGFydGVkIGZsdXNoaW5nICR7ZGF0YS5zdGFydE9mZnNldH0gLT4gJHtkYXRhLmVuZE9mZnNldH0gZm9yICR7dHlwZX0gU291cmNlIEJ1ZmZlcmApO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogRmluaXNoZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICAgICAgX3RoaXMxMS5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICAgIF90aGlzMTEud2FybihcIkZhaWxlZCB0byByZW1vdmUgXCIgKyBzdGFydCArIFwiLVwiICsgZW5kICsgXCIgZnJvbSBcXFwiXCIgKyB0eXBlICsgXCJcXFwiIFNvdXJjZUJ1ZmZlclwiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcbiAgICAgIHZhciB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICBzdGFydE9mZnNldCA9IGRhdGEuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldCA9IGRhdGEuZW5kT2Zmc2V0O1xuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQodGhpcy5nZXRGbHVzaE9wKHR5cGUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICAgIHZhciB0eXBlID0gX3JlZjRbMF07XG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzMTIuYXBwZW5kKF90aGlzMTIuZ2V0Rmx1c2hPcCh0eXBlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSwgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkZyYWdQYXJzZWQgPSBmdW5jdGlvbiBvbkZyYWdQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczEzID0gdGhpcztcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuICAgICAgdmFyIGJ1ZmZlcnNBcHBlbmRlZFRvID0gW107XG4gICAgICB2YXIgZWxlbWVudGFyeVN0cmVhbXMgPSBwYXJ0ID8gcGFydC5lbGVtZW50YXJ5U3RyZWFtcyA6IGZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dKSB7XG4gICAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ2F1ZGlvdmlkZW8nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dKSB7XG4gICAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSkge1xuICAgICAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ3ZpZGVvJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvblVuYmxvY2tlZCA9IGZ1bmN0aW9uIG9uVW5ibG9ja2VkKCkge1xuICAgICAgICB2YXIgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgZnJhZy5zdGF0cy5idWZmZXJpbmcuZW5kID0gbm93O1xuICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgIHBhcnQuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICAgIF90aGlzMTMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgIGlkOiBmcmFnLnR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKGJ1ZmZlcnNBcHBlbmRlZFRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLndhcm4oXCJGcmFnbWVudHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBFbGVtZW50YXJ5U3RyZWFtVHlwZSBzZXQuIHR5cGU6IFwiICsgZnJhZy50eXBlICsgXCIgbGV2ZWw6IFwiICsgZnJhZy5sZXZlbCArIFwiIHNuOiBcIiArIGZyYWcuc24pO1xuICAgICAgfVxuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnMob25VbmJsb2NrZWQsIGJ1ZmZlcnNBcHBlbmRlZFRvKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMxMy53YXJuKFwiRnJhZ21lbnQgYnVmZmVyZWQgY2FsbGJhY2sgXCIgKyBlcnJvcik7XG4gICAgICAgIF90aGlzMTMuc3RlcE9wZXJhdGlvblF1ZXVlKF90aGlzMTMuc291cmNlQnVmZmVyVHlwZXMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnQ2hhbmdlZCA9IGZ1bmN0aW9uIG9uRnJhZ0NoYW5nZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMudHJpbUJ1ZmZlcnMoKTtcbiAgICB9O1xuICAgIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgXCJlbmRpbmdcIiBhbmQgXCJlbmRlZFwiIGFuZCBxdWV1ZSBlbmRPZlN0cmVhbSBhZnRlciByZW1haW5pbmcgb3BlcmF0aW9ucyhzKVxuICAgIC8vIGFuIHVuZGVmaW5lZCBkYXRhLnR5cGUgd2lsbCBtYXJrIGFsbCBidWZmZXJzIGFzIEVPUy5cbiAgICBfcHJvdG8ub25CdWZmZXJFb3MgPSBmdW5jdGlvbiBvbkJ1ZmZlckVvcyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzLFxuICAgICAgICBfdGhpcyRvdmVycmlkZXM7XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfcmVmNVswXTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICB2YXIgdHJhY2sgPSBfdGhpczE0LnRyYWNrc1t0eXBlXTtcbiAgICAgICAgICBpZiAoIWRhdGEudHlwZSB8fCBkYXRhLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRyYWNrLmVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRyYWNrLmVuZGVkKSB7XG4gICAgICAgICAgICAgIHRyYWNrLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX3RoaXMxNC5sb2codHlwZSArIFwiIGJ1ZmZlciByZWFjaGVkIEVPU1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGFsbG93RW5kT2ZTdHJlYW0gPSAoKF90aGlzJG92ZXJyaWRlcyA9IHRoaXMub3ZlcnJpZGVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3ZlcnJpZGVzLmVuZE9mU3RyZWFtKSAhPT0gZmFsc2U7XG4gICAgICB2YXIgYWxsVHJhY2tzRW5kaW5nID0gdGhpcy5zb3VyY2VCdWZmZXJDb3VudCA+IDAgJiYgIXRoaXMuc291cmNlQnVmZmVycy5zb21lKGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgICB2YXIgX3RoaXMxNCR0cmFja3MkdHlwZTtcbiAgICAgICAgdmFyIHR5cGUgPSBfcmVmNlswXTtcbiAgICAgICAgcmV0dXJuIHR5cGUgJiYgISgoX3RoaXMxNCR0cmFja3MkdHlwZSA9IF90aGlzMTQudHJhY2tzW3R5cGVdKSAhPSBudWxsICYmIF90aGlzMTQkdHJhY2tzJHR5cGUuZW5kZWQpO1xuICAgICAgfSk7XG4gICAgICBpZiAoYWxsVHJhY2tzRW5kaW5nKSB7XG4gICAgICAgIGlmIChhbGxvd0VuZE9mU3RyZWFtKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJRdWV1ZWluZyBFT1NcIik7XG4gICAgICAgICAgdGhpcy5ibG9ja1VudGlsT3BlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczE0LnRyYWNrc0VuZGVkKCk7XG4gICAgICAgICAgICB2YXIgbWVkaWFTb3VyY2UgPSBfdGhpczE0Lm1lZGlhU291cmNlO1xuICAgICAgICAgICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgaWYgKG1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMxNC5sb2coXCJDb3VsZCBub3QgY2FsbCBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpLiBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlOiBcIiArIG1lZGlhU291cmNlLnJlYWR5U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzMTQubG9nKFwiQ2FsbGluZyBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpXCIpO1xuICAgICAgICAgICAgLy8gQWxsb3cgdGhpcyB0byB0aHJvdyBhbmQgYmUgY2F1Z2h0IGJ5IHRoZSBlbnF1ZXVlaW5nIGZ1bmN0aW9uXG4gICAgICAgICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgICAgICAgICAgX3RoaXMxNC5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSRURfVE9fRU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHJhY2tzRW5kZWQoKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJFRF9UT19FTkQsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwZW5kaW5nIGF1ZGlvIGFwcGVuZHMgYXJlIHVuYmxvY2tlZCB3aGVuIHZpZGVvIHJlYWNoZXMgZW5kXG4gICAgICAgIHRoaXMudW5ibG9ja0F1ZGlvKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udHJhY2tzRW5kZWQgPSBmdW5jdGlvbiB0cmFja3NFbmRlZCgpIHtcbiAgICAgIHZhciBfdGhpczE1ID0gdGhpcztcbiAgICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICB2YXIgdHlwZSA9IF9yZWY3WzBdO1xuICAgICAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0cmFjayA9IF90aGlzMTUudHJhY2tzW3R5cGVdO1xuICAgICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgdHJhY2suZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCBfcmVmOCkge1xuICAgICAgdmFyIGRldGFpbHMgPSBfcmVmOC5kZXRhaWxzO1xuICAgICAgaWYgKCFkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgIHRoaXMudXBkYXRlRHVyYXRpb24oKTtcbiAgICB9O1xuICAgIF9wcm90by51cGRhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZUR1cmF0aW9uKCkge1xuICAgICAgdmFyIF90aGlzMTYgPSB0aGlzO1xuICAgICAgdGhpcy5ibG9ja1VudGlsT3BlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbkFuZFJhbmdlID0gX3RoaXMxNi5nZXREdXJhdGlvbkFuZFJhbmdlKCk7XG4gICAgICAgIGlmICghZHVyYXRpb25BbmRSYW5nZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczE2LnVwZGF0ZU1lZGlhU291cmNlKGR1cmF0aW9uQW5kUmFuZ2UpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SICYmIGRhdGEuZnJhZykge1xuICAgICAgICB2YXIgX2RhdGEkZXJyb3JBY3Rpb247XG4gICAgICAgIHZhciBuZXh0QXV0b0xldmVsID0gKF9kYXRhJGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGVycm9yQWN0aW9uLm5leHRBdXRvTGV2ZWw7XG4gICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihuZXh0QXV0b0xldmVsKSAmJiBuZXh0QXV0b0xldmVsICE9PSBkYXRhLmZyYWcubGV2ZWwpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0QXBwZW5kRXJyb3JzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZXNldEFwcGVuZEVycm9ycyA9IGZ1bmN0aW9uIHJlc2V0QXBwZW5kRXJyb3JzKCkge1xuICAgICAgdGhpcy5hcHBlbmRFcnJvcnMgPSB7XG4gICAgICAgIGF1ZGlvOiAwLFxuICAgICAgICB2aWRlbzogMCxcbiAgICAgICAgYXVkaW92aWRlbzogMFxuICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by50cmltQnVmZmVycyA9IGZ1bmN0aW9uIHRyaW1CdWZmZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBkZXRhaWxzID0gdGhpcy5kZXRhaWxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhIHx8IGRldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICB2YXIgdGFyZ2V0RHVyYXRpb24gPSBkZXRhaWxzLmxldmVsVGFyZ2V0RHVyYXRpb247XG5cbiAgICAgIC8vIFN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgbGl2ZUJhY2tCdWZmZXJMZW5ndGhcbiAgICAgIHZhciBiYWNrQnVmZmVyTGVuZ3RoID0gZGV0YWlscy5saXZlICYmIGNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aCAhPT0gbnVsbCA/IGNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aCA6IGNvbmZpZy5iYWNrQnVmZmVyTGVuZ3RoO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGJhY2tCdWZmZXJMZW5ndGgpICYmIGJhY2tCdWZmZXJMZW5ndGggPj0gMCkge1xuICAgICAgICB2YXIgbWF4QmFja0J1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGJhY2tCdWZmZXJMZW5ndGgsIHRhcmdldER1cmF0aW9uKTtcbiAgICAgICAgdmFyIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA9IE1hdGguZmxvb3IoY3VycmVudFRpbWUgLyB0YXJnZXREdXJhdGlvbikgKiB0YXJnZXREdXJhdGlvbiAtIG1heEJhY2tCdWZmZXJMZW5ndGg7XG4gICAgICAgIHRoaXMuZmx1c2hCYWNrQnVmZmVyKGN1cnJlbnRUaW1lLCB0YXJnZXREdXJhdGlvbiwgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHZhciBmcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkID0gY29uZmlnLmZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQ7XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZCkgJiYgZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZCA+IDApIHtcbiAgICAgICAgdmFyIGZyb250QnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoY29uZmlnLm1heEJ1ZmZlckxlbmd0aCwgZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZCk7XG4gICAgICAgIHZhciBtYXhGcm9udEJ1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGZyb250QnVmZmVyTGVuZ3RoLCB0YXJnZXREdXJhdGlvbik7XG4gICAgICAgIHZhciB0YXJnZXRGcm9udEJ1ZmZlclBvc2l0aW9uID0gTWF0aC5mbG9vcihjdXJyZW50VGltZSAvIHRhcmdldER1cmF0aW9uKSAqIHRhcmdldER1cmF0aW9uICsgbWF4RnJvbnRCdWZmZXJMZW5ndGg7XG4gICAgICAgIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoQmFja0J1ZmZlciA9IGZ1bmN0aW9uIGZsdXNoQmFja0J1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbikge1xuICAgICAgdmFyIF90aGlzMTcgPSB0aGlzO1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWY5KSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZjlbMF0sXG4gICAgICAgICAgc2IgPSBfcmVmOVsxXTtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgICAvLyB3aGVuIHRhcmdldCBidWZmZXIgc3RhcnQgZXhjZWVkcyBhY3R1YWwgYnVmZmVyIHN0YXJ0XG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA+IDAgJiYgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID4gYnVmZmVyZWQuc3RhcnQoMCkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczE3JGRldGFpbHM7XG4gICAgICAgICAgICBfdGhpczE3Lmhscy50cmlnZ2VyKEV2ZW50cy5CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBldmVudDpcbiAgICAgICAgICAgIHZhciB0cmFjayA9IF90aGlzMTcudHJhY2tzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKChfdGhpczE3JGRldGFpbHMgPSBfdGhpczE3LmRldGFpbHMpICE9IG51bGwgJiYgX3RoaXMxNyRkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgICAgX3RoaXMxNy5obHMudHJpZ2dlcihFdmVudHMuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICAgICAgYnVmZmVyRW5kOiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrICE9IG51bGwgJiYgdHJhY2suZW5kZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMxNy5sb2coXCJDYW5ub3QgZmx1c2ggXCIgKyB0eXBlICsgXCIgYmFjayBidWZmZXIgd2hpbGUgU291cmNlQnVmZmVyIGlzIGluIGVuZGVkIHN0YXRlXCIpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpczE3Lmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgIGVuZE9mZnNldDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoRnJvbnRCdWZmZXIgPSBmdW5jdGlvbiBmbHVzaEZyb250QnVmZmVyKGN1cnJlbnRUaW1lLCB0YXJnZXREdXJhdGlvbiwgdGFyZ2V0RnJvbnRCdWZmZXJQb3NpdGlvbikge1xuICAgICAgdmFyIF90aGlzMTggPSB0aGlzO1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYwKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZjBbMF0sXG4gICAgICAgICAgc2IgPSBfcmVmMFsxXTtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgICB2YXIgbnVtQnVmZmVyZWRSYW5nZXMgPSBidWZmZXJlZC5sZW5ndGg7XG4gICAgICAgICAgLy8gVGhlIGJ1ZmZlciBpcyBlaXRoZXIgZW1wdHkgb3IgY29udGlndW91c1xuICAgICAgICAgIGlmIChudW1CdWZmZXJlZFJhbmdlcyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQobnVtQnVmZmVyZWRSYW5nZXMgLSAxKTtcbiAgICAgICAgICB2YXIgYnVmZmVyRW5kID0gYnVmZmVyZWQuZW5kKG51bUJ1ZmZlcmVkUmFuZ2VzIC0gMSk7XG4gICAgICAgICAgLy8gTm8gZmx1c2ggaWYgd2UgY2FuIHRvbGVyYXRlIHRoZSBjdXJyZW50IGJ1ZmZlciBsZW5ndGggb3IgdGhlIGN1cnJlbnQgYnVmZmVyIHJhbmdlIHdlIHdvdWxkIGZsdXNoIGlzIGNvbnRpZ3VvdXMgd2l0aCBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgaWYgKHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24gPiBidWZmZXJTdGFydCB8fCBjdXJyZW50VGltZSA+PSBidWZmZXJTdGFydCAmJiBjdXJyZW50VGltZSA8PSBidWZmZXJFbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMxOC5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogYnVmZmVyU3RhcnQsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IEluZmluaXR5LFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIGN1cnJlbnQgbGV2ZWwgZHVyYXRpb24gb3Igb3ZlcnJpZGUgdG8gSW5maW5pdHkgaWYgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKiAnbGl2ZUR1cmF0aW9uSW5maW5pdHlgIGlzIHNldCB0byBgdHJ1ZWBcbiAgICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcbiAgICAgKi87XG4gICAgX3Byb3RvLmdldER1cmF0aW9uQW5kUmFuZ2UgPSBmdW5jdGlvbiBnZXREdXJhdGlvbkFuZFJhbmdlKCkge1xuICAgICAgdmFyIF90aGlzJG92ZXJyaWRlczI7XG4gICAgICB2YXIgZGV0YWlscyA9IHRoaXMuZGV0YWlscyxcbiAgICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgaWYgKCFkZXRhaWxzIHx8ICF0aGlzLm1lZGlhIHx8IChtZWRpYVNvdXJjZSA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSkgIT09ICdvcGVuJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBwbGF5bGlzdEVuZCA9IGRldGFpbHMuZWRnZTtcbiAgICAgIGlmIChkZXRhaWxzLmxpdmUgJiYgdGhpcy5obHMuY29uZmlnLmxpdmVEdXJhdGlvbkluZmluaXR5KSB7XG4gICAgICAgIHZhciBsZW4gPSBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gJiYgISFtZWRpYVNvdXJjZS5zZXRMaXZlU2Vla2FibGVSYW5nZSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KDAsIGRldGFpbHMuZnJhZ21lbnRTdGFydCk7XG4gICAgICAgICAgdmFyIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBwbGF5bGlzdEVuZCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGR1cmF0aW9uOiBJbmZpbml0eVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIG92ZXJyaWRlRHVyYXRpb24gPSAoX3RoaXMkb3ZlcnJpZGVzMiA9IHRoaXMub3ZlcnJpZGVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3ZlcnJpZGVzMi5kdXJhdGlvbjtcbiAgICAgIGlmIChvdmVycmlkZUR1cmF0aW9uKSB7XG4gICAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIob3ZlcnJpZGVEdXJhdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGR1cmF0aW9uOiBvdmVycmlkZUR1cmF0aW9uXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgbWVkaWFEdXJhdGlvbiA9IHRoaXMubWVkaWEuZHVyYXRpb247XG4gICAgICB2YXIgbXNEdXJhdGlvbiA9IGlzRmluaXRlTnVtYmVyKG1lZGlhU291cmNlLmR1cmF0aW9uKSA/IG1lZGlhU291cmNlLmR1cmF0aW9uIDogMDtcbiAgICAgIGlmIChwbGF5bGlzdEVuZCA+IG1zRHVyYXRpb24gJiYgcGxheWxpc3RFbmQgPiBtZWRpYUR1cmF0aW9uIHx8ICFpc0Zpbml0ZU51bWJlcihtZWRpYUR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGR1cmF0aW9uOiBwbGF5bGlzdEVuZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlTWVkaWFTb3VyY2UgPSBmdW5jdGlvbiB1cGRhdGVNZWRpYVNvdXJjZShfcmVmMSkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gX3JlZjEuZHVyYXRpb24sXG4gICAgICAgIHN0YXJ0ID0gX3JlZjEuc3RhcnQsXG4gICAgICAgIGVuZCA9IF9yZWYxLmVuZDtcbiAgICAgIHZhciBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgICBpZiAoIXRoaXMubWVkaWEgfHwgIW1lZGlhU291cmNlIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobWVkaWFTb3VyY2UuZHVyYXRpb24gIT09IGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihkdXJhdGlvbikpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcIlVwZGF0aW5nIE1lZGlhU291cmNlIGR1cmF0aW9uIHRvIFwiICsgZHVyYXRpb24udG9GaXhlZCgzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkICYmIGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubG9nKFwiTWVkaWFTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvIFwiICsgbWVkaWFTb3VyY2UuZHVyYXRpb24gKyBcIi4gU2V0dGluZyBzZWVrYWJsZSByYW5nZSB0byBcIiArIHN0YXJ0ICsgXCItXCIgKyBlbmQgKyBcIi5cIik7XG4gICAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrUGVuZGluZ1RyYWNrcyA9IGZ1bmN0aW9uIGNoZWNrUGVuZGluZ1RyYWNrcygpIHtcbiAgICAgIHZhciBidWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gdGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsLFxuICAgICAgICBwZW5kaW5nVHJhY2tDb3VudCA9IHRoaXMucGVuZGluZ1RyYWNrQ291bnQsXG4gICAgICAgIHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgICAgdGhpcy5sb2coXCJjaGVja1BlbmRpbmdUcmFja3MgKHBlbmRpbmc6IFwiICsgcGVuZGluZ1RyYWNrQ291bnQgKyBcIiBjb2RlYyBldmVudHMgZXhwZWN0ZWQ6IFwiICsgYnVmZmVyQ29kZWNFdmVudHNUb3RhbCArIFwiKSBcIiArIHN0cmluZ2lmeSh0cmFja3MpKTtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgZXhwZWN0ZWQgYnVmZmVyQ29kZWMgZXZlbnRzLiBXaGVuIG5vbmUgcmVtYWluLCBjcmVhdGUgYWxsIHRoZSBzb3VyY2VCdWZmZXJzIGF0IG9uY2UuXG4gICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBNU0Ugc3BlYyBhbGxvd3MgaW1wbGVtZW50YXRpb25zIHRvIHRocm93IFF1b3RhRXhjZWVkZWRFcnJvcnMgaWYgY3JlYXRpbmcgbmV3IHNvdXJjZUJ1ZmZlcnMgYWZ0ZXJcbiAgICAgIC8vIGRhdGEgaGFzIGJlZW4gYXBwZW5kZWQgdG8gZXhpc3Rpbmcgb25lcy5cbiAgICAgIC8vIDIgdHJhY2tzIGlzIHRoZSBtYXggKG9uZSBmb3IgYXVkaW8sIG9uZSBmb3IgdmlkZW8pLiBJZiB3ZSd2ZSByZWFjaCB0aGlzIG1heCBnbyBhaGVhZCBhbmQgY3JlYXRlIHRoZSBidWZmZXJzLlxuICAgICAgaWYgKHRoaXMudHJhY2tzUmVhZHkpIHtcbiAgICAgICAgdmFyIF90aGlzJHRyYW5zZmVyRGF0YTM7XG4gICAgICAgIHZhciB0cmFuc2ZlcnJlZFRyYWNrcyA9IChfdGhpcyR0cmFuc2ZlckRhdGEzID0gdGhpcy50cmFuc2ZlckRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFuc2ZlckRhdGEzLnRyYWNrcztcbiAgICAgICAgaWYgKHRyYW5zZmVycmVkVHJhY2tzICYmIE9iamVjdC5rZXlzKHRyYW5zZmVycmVkVHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmF0dGFjaFRyYW5zZmVycmVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXG4gICAgICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5idWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gYnVmZmVyQ3JlYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpczE5ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYxMCkge1xuICAgICAgICAgIHZhciB0eXBlID0gX3JlZjEwWzBdLFxuICAgICAgICAgICAgYnVmZmVyID0gX3JlZjEwWzFdO1xuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSBfdGhpczE5LnRyYWNrc1t0eXBlXTtcbiAgICAgICAgICAgIHRyYWNrc1t0eXBlXSA9IHtcbiAgICAgICAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgICAgICAgIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyLFxuICAgICAgICAgICAgICBjb2RlYzogdHJhY2suY29kZWMsXG4gICAgICAgICAgICAgIHN1cHBsZW1lbnRhbDogdHJhY2suc3VwcGxlbWVudGFsLFxuICAgICAgICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgICAgICBpZDogdHJhY2suaWQsXG4gICAgICAgICAgICAgIG1ldGFkYXRhOiB0cmFjay5tZXRhZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwge1xuICAgICAgICAgIHRyYWNrczogdHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxvZyhcIlNvdXJjZUJ1ZmZlcnMgY3JlYXRlZC4gUnVubmluZyBxdWV1ZTogXCIgKyB0aGlzLm9wZXJhdGlvblF1ZXVlKTtcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYxMSkge1xuICAgICAgICAgIHZhciB0eXBlID0gX3JlZjExWzBdO1xuICAgICAgICAgIF90aGlzMTkuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdjb3VsZCBub3QgY3JlYXRlIHNvdXJjZSBidWZmZXIgZm9yIG1lZGlhIGNvZGVjKHMpJyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVTb3VyY2VCdWZmZXJzID0gZnVuY3Rpb24gY3JlYXRlU291cmNlQnVmZmVycygpIHtcbiAgICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrcyxcbiAgICAgICAgc291cmNlQnVmZmVycyA9IHRoaXMuc291cmNlQnVmZmVycyxcbiAgICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVNvdXJjZUJ1ZmZlcnMgY2FsbGVkIHdoZW4gbWVkaWFTb3VyY2Ugd2FzIG51bGwnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0cmFja05hbWU7XG4gICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgICAgaWYgKHRoaXMuaXNQZW5kaW5nKHRyYWNrKSkge1xuICAgICAgICAgIHZhciBjb2RlYyA9IHRoaXMuZ2V0VHJhY2tDb2RlYyh0cmFjaywgdHlwZSk7XG4gICAgICAgICAgdmFyIG1pbWVUeXBlID0gdHJhY2suY29udGFpbmVyICsgXCI7Y29kZWNzPVwiICsgY29kZWM7XG4gICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlYztcbiAgICAgICAgICB0aGlzLmxvZyhcImNyZWF0aW5nIHNvdXJjZUJ1ZmZlcihcIiArIG1pbWVUeXBlICsgXCIpXCIgKyAodGhpcy5jdXJyZW50T3AodHlwZSkgPyAnIFF1ZXVlZCcgOiAnJykgKyBcIiBcIiArIHN0cmluZ2lmeSh0cmFjaykpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc2IgPSBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpO1xuICAgICAgICAgICAgdmFyIHNiSW5kZXggPSBzb3VyY2VCdWZmZXJOYW1lVG9JbmRleCh0eXBlKTtcbiAgICAgICAgICAgIHZhciBzYlR1cGxlID0gW3R5cGUsIHNiXTtcbiAgICAgICAgICAgIHNvdXJjZUJ1ZmZlcnNbc2JJbmRleF0gPSBzYlR1cGxlO1xuICAgICAgICAgICAgdHJhY2suYnVmZmVyID0gc2I7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRvcGVyYXRpb25RdWV1ZTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJlcnJvciB3aGlsZSB0cnlpbmcgdG8gYWRkIHNvdXJjZUJ1ZmZlcjogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpbml0IHNlZ21lbnQgZnJvbSBxdWV1ZSBhbmQgZGVsZXRlIHRyYWNrIGluZm9cbiAgICAgICAgICAgIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgICAgIChfdGhpcyRvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWUpID09IG51bGwgfHwgX3RoaXMkb3BlcmF0aW9uUXVldWUucmVtb3ZlQmxvY2tlcnMoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgc291cmNlQnVmZmVyTmFtZTogdHlwZSxcbiAgICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICAgICAgICBwYXJlbnQ6IHRyYWNrLmlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50cmFja1NvdXJjZUJ1ZmZlcih0eXBlLCB0cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyQ3JlYXRlZCgpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFRyYWNrQ29kZWMgPSBmdW5jdGlvbiBnZXRUcmFja0NvZGVjKHRyYWNrLCB0cmFja05hbWUpIHtcbiAgICAgIC8vIFVzZSBzdXBwbGVtZW50YWwgdmlkZW8gY29kZWMgd2hlbiBzdXBwb3J0ZWQgd2hlbiBhZGRpbmcgU291cmNlQnVmZmVyICgjNTU1OClcbiAgICAgIHZhciBzdXBwbGVtZW50YWxDb2RlYyA9IHRyYWNrLnN1cHBsZW1lbnRhbDtcbiAgICAgIHZhciB0cmFja0NvZGVjID0gdHJhY2suY29kZWM7XG4gICAgICBpZiAoc3VwcGxlbWVudGFsQ29kZWMgJiYgKHRyYWNrTmFtZSA9PT0gJ3ZpZGVvJyB8fCB0cmFja05hbWUgPT09ICdhdWRpb3ZpZGVvJykgJiYgYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQoc3VwcGxlbWVudGFsQ29kZWMsICd2aWRlbycpKSB7XG4gICAgICAgIHRyYWNrQ29kZWMgPSByZXBsYWNlVmlkZW9Db2RlYyh0cmFja0NvZGVjLCBzdXBwbGVtZW50YWxDb2RlYyk7XG4gICAgICB9XG4gICAgICB2YXIgY29kZWMgPSBwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lKHRyYWNrQ29kZWMsIHRyYWNrLmxldmVsQ29kZWMpO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGlmICh0cmFja05hbWUuc2xpY2UoMCwgNSkgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShjb2RlYywgdGhpcy5hcHBlbmRTb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlYztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIF9wcm90by50cmFja1NvdXJjZUJ1ZmZlciA9IGZ1bmN0aW9uIHRyYWNrU291cmNlQnVmZmVyKHR5cGUsIHRyYWNrKSB7XG4gICAgICB2YXIgX3RoaXMyMCA9IHRoaXM7XG4gICAgICB2YXIgYnVmZmVyID0gdHJhY2suYnVmZmVyO1xuICAgICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGVjID0gdGhpcy5nZXRUcmFja0NvZGVjKHRyYWNrLCB0eXBlKTtcbiAgICAgIHRoaXMudHJhY2tzW3R5cGVdID0ge1xuICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgY29kZWM6IGNvZGVjLFxuICAgICAgICBjb250YWluZXI6IHRyYWNrLmNvbnRhaW5lcixcbiAgICAgICAgbGV2ZWxDb2RlYzogdHJhY2subGV2ZWxDb2RlYyxcbiAgICAgICAgc3VwcGxlbWVudGFsOiB0cmFjay5zdXBwbGVtZW50YWwsXG4gICAgICAgIG1ldGFkYXRhOiB0cmFjay5tZXRhZGF0YSxcbiAgICAgICAgaWQ6IHRyYWNrLmlkLFxuICAgICAgICBsaXN0ZW5lcnM6IFtdXG4gICAgICB9O1xuICAgICAgdGhpcy5yZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSk7XG4gICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsICd1cGRhdGVzdGFydCcsIHRoaXMub25TQlVwZGF0ZVN0YXJ0KTtcbiAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIodHlwZSwgJ3VwZGF0ZWVuZCcsIHRoaXMub25TQlVwZGF0ZUVuZCk7XG4gICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsICdlcnJvcicsIHRoaXMub25TQlVwZGF0ZUVycm9yKTtcbiAgICAgIC8vIE1hbmFnZWRTb3VyY2VCdWZmZXIgYnVmZmVyZWRjaGFuZ2UgZXZlbnRcbiAgICAgIGlmICh0aGlzLmFwcGVuZFNvdXJjZSkge1xuICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsICdidWZmZXJlZGNoYW5nZScsIGZ1bmN0aW9uICh0eXBlLCBldmVudCkge1xuICAgICAgICAgIC8vIElmIG1lZGlhIHdhcyBlamVjdGVkIGNoZWNrIGZvciBhIGNoYW5nZS4gQWRkZWQgcmFuZ2VzIGFyZSByZWR1bmRhbnQgd2l0aCBjaGFuZ2VzIG9uICd1cGRhdGVlbmQnIGV2ZW50LlxuICAgICAgICAgIHZhciByZW1vdmVkUmFuZ2VzID0gZXZlbnQucmVtb3ZlZFJhbmdlcztcbiAgICAgICAgICBpZiAocmVtb3ZlZFJhbmdlcyAhPSBudWxsICYmIHJlbW92ZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpczIwLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwge1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uU0JVcGRhdGVTdGFydCA9IGZ1bmN0aW9uIG9uU0JVcGRhdGVTdGFydCh0eXBlKSB7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5jdXJyZW50T3AodHlwZSk7XG4gICAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvcGVyYXRpb24ub25TdGFydCgpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uU0JVcGRhdGVFbmQgPSBmdW5jdGlvbiBvblNCVXBkYXRlRW5kKHR5cGUpIHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTI7XG4gICAgICBpZiAoKChfdGhpcyRtZWRpYVNvdXJjZTIgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTb3VyY2UyLnJlYWR5U3RhdGUpID09PSAnY2xvc2VkJykge1xuICAgICAgICB0aGlzLnJlc2V0QnVmZmVyKHR5cGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5jdXJyZW50T3AodHlwZSk7XG4gICAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvcGVyYXRpb24ub25Db21wbGV0ZSgpO1xuICAgICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uU0JVcGRhdGVFcnJvciA9IGZ1bmN0aW9uIG9uU0JVcGRhdGVFcnJvcih0eXBlLCBldmVudCkge1xuICAgICAgdmFyIF90aGlzJG1lZGlhU291cmNlMztcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcih0eXBlICsgXCIgU291cmNlQnVmZmVyIGVycm9yLiBNZWRpYVNvdXJjZSByZWFkeVN0YXRlOiBcIiArICgoX3RoaXMkbWVkaWFTb3VyY2UzID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU291cmNlMy5yZWFkeVN0YXRlKSk7XG4gICAgICB0aGlzLmVycm9yKFwiXCIgKyBlcnJvciwgZXZlbnQpO1xuICAgICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgICAgLy8gU291cmNlQnVmZmVyIGVycm9ycyBhcmUgbm90IG5lY2Vzc2FyaWx5IGZhdGFsOyBpZiBzbywgdGhlIEhUTUxNZWRpYUVsZW1lbnQgd2lsbCBmaXJlIGFuIGVycm9yIGV2ZW50XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUixcbiAgICAgICAgc291cmNlQnVmZmVyTmFtZTogdHlwZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gdXBkYXRlZW5kIGlzIGFsd2F5cyBmaXJlZCBhZnRlciBlcnJvciwgc28gd2UnbGwgYWxsb3cgdGhhdCB0byBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmIG9mIHRoZSBxdWV1ZVxuICAgICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMuY3VycmVudE9wKHR5cGUpO1xuICAgICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgICBvcGVyYXRpb24ub25FcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlVGltZXN0YW1wT2Zmc2V0ID0gZnVuY3Rpb24gdXBkYXRlVGltZXN0YW1wT2Zmc2V0KHNiLCB0aW1lc3RhbXBPZmZzZXQsIHRvbGVyYW5jZSwgdHlwZSwgc24sIGNjKSB7XG4gICAgICB2YXIgZGVsdGEgPSB0aW1lc3RhbXBPZmZzZXQgLSBzYi50aW1lc3RhbXBPZmZzZXQ7XG4gICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IHRvbGVyYW5jZSkge1xuICAgICAgICB0aGlzLmxvZyhcIlVwZGF0aW5nIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciB0aW1lc3RhbXBPZmZzZXQgdG8gXCIgKyB0aW1lc3RhbXBPZmZzZXQgKyBcIiAoc246IFwiICsgc24gKyBcIiBjYzogXCIgKyBjYyArIFwiKVwiKTtcbiAgICAgICAgc2IudGltZXN0YW1wT2Zmc2V0ID0gdGltZXN0YW1wT2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgcmVtb3ZlIGlzIG5vdCBjYWxsZWQsIG9uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgICA7XG4gICAgX3Byb3RvLnJlbW92ZUV4ZWN1dG9yID0gZnVuY3Rpb24gcmVtb3ZlRXhlY3V0b3IodHlwZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgICB2YXIgc2IgPSB0cmFjayA9PSBudWxsID8gdm9pZCAwIDogdHJhY2suYnVmZmVyO1xuICAgICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNiKSB7XG4gICAgICAgIHRoaXMud2FybihcIkF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtZWRpYUR1cmF0aW9uID0gaXNGaW5pdGVOdW1iZXIobWVkaWEuZHVyYXRpb24pID8gbWVkaWEuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICAgIHZhciBtc0R1cmF0aW9uID0gaXNGaW5pdGVOdW1iZXIobWVkaWFTb3VyY2UuZHVyYXRpb24pID8gbWVkaWFTb3VyY2UuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICAgIHZhciByZW1vdmVTdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgIHZhciByZW1vdmVFbmQgPSBNYXRoLm1pbihlbmRPZmZzZXQsIG1lZGlhRHVyYXRpb24sIG1zRHVyYXRpb24pO1xuICAgICAgaWYgKHJlbW92ZUVuZCA+IHJlbW92ZVN0YXJ0ICYmICghdHJhY2suZW5kaW5nIHx8IHRyYWNrLmVuZGVkKSkge1xuICAgICAgICB0cmFjay5lbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZyhcIlJlbW92aW5nIFtcIiArIHJlbW92ZVN0YXJ0ICsgXCIsXCIgKyByZW1vdmVFbmQgKyBcIl0gZnJvbSB0aGUgXCIgKyB0eXBlICsgXCIgU291cmNlQnVmZmVyXCIpO1xuICAgICAgICBzYi5yZW1vdmUocmVtb3ZlU3RhcnQsIHJlbW92ZUVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDeWNsZSB0aGUgcXVldWVcbiAgICAgICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgYXBwZW5kIGlzIG5vdCBjYWxsZWQsIG9uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgICA7XG4gICAgX3Byb3RvLmFwcGVuZEV4ZWN1dG9yID0gZnVuY3Rpb24gYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSkge1xuICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgICB2YXIgc2IgPSB0cmFjayA9PSBudWxsID8gdm9pZCAwIDogdHJhY2suYnVmZmVyO1xuICAgICAgaWYgKCFzYikge1xuICAgICAgICB0aHJvdyBuZXcgSGxzSnNUcmFja1JlbW92ZWRFcnJvcihcIkF0dGVtcHRpbmcgdG8gYXBwZW5kIHRvIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIHRyYWNrLmVuZGluZyA9IGZhbHNlO1xuICAgICAgdHJhY2suZW5kZWQgPSBmYWxzZTtcbiAgICAgIHNiLmFwcGVuZEJ1ZmZlcihkYXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5ibG9ja1VudGlsT3BlbiA9IGZ1bmN0aW9uIGJsb2NrVW50aWxPcGVuKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMyMSA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5pc1VwZGF0aW5nKCkgfHwgdGhpcy5pc1F1ZXVlZCgpKSB7XG4gICAgICAgIHRoaXMuYmxvY2tCdWZmZXJzKGNhbGxiYWNrKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczIxLndhcm4oXCJTb3VyY2VCdWZmZXIgYmxvY2tlZCBjYWxsYmFjayBcIiArIGVycm9yKTtcbiAgICAgICAgICBfdGhpczIxLnN0ZXBPcGVyYXRpb25RdWV1ZShfdGhpczIxLnNvdXJjZUJ1ZmZlclR5cGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwiQ2FsbGJhY2sgcnVuIHdpdGhvdXQgYmxvY2tpbmcgXCIgKyB0aGlzLm9wZXJhdGlvblF1ZXVlICsgXCIgXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5pc1VwZGF0aW5nID0gZnVuY3Rpb24gaXNVcGRhdGluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZUJ1ZmZlcnMuc29tZShmdW5jdGlvbiAoX3JlZjEyKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZjEyWzBdLFxuICAgICAgICAgIHNiID0gX3JlZjEyWzFdO1xuICAgICAgICByZXR1cm4gdHlwZSAmJiBzYi51cGRhdGluZztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmlzUXVldWVkID0gZnVuY3Rpb24gaXNRdWV1ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMyMiA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VCdWZmZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYxMykge1xuICAgICAgICB2YXIgdHlwZSA9IF9yZWYxM1swXTtcbiAgICAgICAgcmV0dXJuIHR5cGUgJiYgISFfdGhpczIyLmN1cnJlbnRPcCh0eXBlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmlzUGVuZGluZyA9IGZ1bmN0aW9uIGlzUGVuZGluZyh0cmFjaykge1xuICAgICAgcmV0dXJuICEhdHJhY2sgJiYgIXRyYWNrLmJ1ZmZlcjtcbiAgICB9XG5cbiAgICAvLyBFbnF1ZXVlcyBhbiBvcGVyYXRpb24gdG8gZWFjaCBTb3VyY2VCdWZmZXIgcXVldWUgd2hpY2gsIHVwb24gZXhlY3V0aW9uLCByZXNvbHZlcyBhIHByb21pc2UuIFdoZW4gYWxsIHByb21pc2VzXG4gICAgLy8gcmVzb2x2ZSwgdGhlIG9uVW5ibG9ja2VkIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLiBGdW5jdGlvbnMgY2FsbGluZyB0aGlzIG1ldGhvZCBkbyBub3QgbmVlZCB0byB1bmJsb2NrIHRoZSBxdWV1ZVxuICAgIC8vIHVwb24gY29tcGxldGlvbiwgc2luY2Ugd2UgYWxyZWFkeSBkbyBpdCBoZXJlXG4gICAgO1xuICAgIF9wcm90by5ibG9ja0J1ZmZlcnMgPSBmdW5jdGlvbiBibG9ja0J1ZmZlcnMob25VbmJsb2NrZWQsIGJ1ZmZlck5hbWVzKSB7XG4gICAgICB2YXIgX3RoaXMyMyA9IHRoaXM7XG4gICAgICBpZiAoYnVmZmVyTmFtZXMgPT09IHZvaWQgMCkge1xuICAgICAgICBidWZmZXJOYW1lcyA9IHRoaXMuc291cmNlQnVmZmVyVHlwZXM7XG4gICAgICB9XG4gICAgICBpZiAoIWJ1ZmZlck5hbWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxvZygnQmxvY2tpbmcgb3BlcmF0aW9uIHJlcXVlc3RlZCwgYnV0IG5vIFNvdXJjZUJ1ZmZlcnMgZXhpc3QnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4ob25VbmJsb2NrZWQpO1xuICAgICAgfVxuICAgICAgdmFyIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZTtcblxuICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyAke2J1ZmZlcnN9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgdmFyIGJsb2NraW5nT3BlcmF0aW9ucyA9IGJ1ZmZlck5hbWVzLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMyMy5hcHBlbmRCbG9ja2VyKHR5cGUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgYXVkaW9CbG9ja2VkID0gYnVmZmVyTmFtZXMubGVuZ3RoID4gMSAmJiAhIXRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kO1xuICAgICAgaWYgKGF1ZGlvQmxvY2tlZCkge1xuICAgICAgICB0aGlzLnVuYmxvY2tBdWRpbygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGJsb2NraW5nT3BlcmF0aW9ucykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChvcGVyYXRpb25RdWV1ZSAhPT0gX3RoaXMyMy5vcGVyYXRpb25RdWV1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXNvbHZlZDsgdW5ibG9ja2luZyAke2J1ZmZlcnN9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgICBvblVuYmxvY2tlZCgpO1xuICAgICAgICBfdGhpczIzLnN0ZXBPcGVyYXRpb25RdWV1ZShfdGhpczIzLnNvdXJjZUJ1ZmZlclR5cGVzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnN0ZXBPcGVyYXRpb25RdWV1ZSA9IGZ1bmN0aW9uIHN0ZXBPcGVyYXRpb25RdWV1ZShidWZmZXJOYW1lcykge1xuICAgICAgdmFyIF90aGlzMjQgPSB0aGlzO1xuICAgICAgYnVmZmVyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMyNCR0cmFja3MkdHlwZTtcbiAgICAgICAgdmFyIHNiID0gKF90aGlzMjQkdHJhY2tzJHR5cGUgPSBfdGhpczI0LnRyYWNrc1t0eXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzMjQkdHJhY2tzJHR5cGUuYnVmZmVyO1xuICAgICAgICAvLyBPbmx5IGN5Y2xlIHRoZSBxdWV1ZSBpZiB0aGUgU0IgaXMgbm90IHVwZGF0aW5nLiBUaGVyZSdzIGEgYnVnIGluIENocm9tZSB3aGljaCBzZXRzIHRoZSBTQiB1cGRhdGluZyBmbGFnIHRvXG4gICAgICAgIC8vIHRydWUgd2hlbiBjaGFuZ2luZyB0aGUgTWVkaWFTb3VyY2UgZHVyYXRpb24gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk1OTM1OSZjYW49MiZxPW1lZGlhc291cmNlJTIwZHVyYXRpb24pXG4gICAgICAgIC8vIFdoaWxlIHRoaXMgaXMgYSB3b3JrYXJvdW5kLCBpdCdzIHByb2JhYmx5IHVzZWZ1bCB0byBoYXZlIGFyb3VuZFxuICAgICAgICBpZiAoIXNiIHx8IHNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMjQuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChvcGVyYXRpb24sIHR5cGUsIHBlbmRpbmcpIHtcbiAgICAgIGlmICh0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSwgcGVuZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYXBwZW5kQmxvY2tlciA9IGZ1bmN0aW9uIGFwcGVuZEJsb2NrZXIodHlwZSkge1xuICAgICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0aW9uUXVldWUuYXBwZW5kQmxvY2tlcih0eXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jdXJyZW50T3AgPSBmdW5jdGlvbiBjdXJyZW50T3AodHlwZSkge1xuICAgICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmV4ZWN1dGVOZXh0ID0gZnVuY3Rpb24gZXhlY3V0ZU5leHQodHlwZSkge1xuICAgICAgaWYgKHR5cGUgJiYgdGhpcy5vcGVyYXRpb25RdWV1ZSkge1xuICAgICAgICB0aGlzLm9wZXJhdGlvblF1ZXVlLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnNoaWZ0QW5kRXhlY3V0ZU5leHQgPSBmdW5jdGlvbiBzaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICAgIGlmICh0aGlzLm9wZXJhdGlvblF1ZXVlKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5hZGRCdWZmZXJMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsIGV2ZW50LCBmbikge1xuICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFja3NbdHlwZV07XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXIgPSB0cmFjay5idWZmZXI7XG4gICAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmbi5iaW5kKHRoaXMsIHR5cGUpO1xuICAgICAgdHJhY2subGlzdGVuZXJzLnB1c2goe1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgICAgfSk7XG4gICAgICBidWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUJ1ZmZlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1t0eXBlXTtcbiAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlciA9IHRyYWNrLmJ1ZmZlcjtcbiAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWNrLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIGJ1ZmZlci5yZW1vdmVFdmVudExpc3RlbmVyKGwuZXZlbnQsIGwubGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICB0cmFjay5saXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQnVmZmVyQ29udHJvbGxlciwgW3tcbiAgICAgIGtleTogXCJtZWRpYVNvdXJjZU9wZW5PckVuZGVkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJG1lZGlhU291cmNlNDtcbiAgICAgICAgdmFyIHJlYWR5U3RhdGUgPSAoX3RoaXMkbWVkaWFTb3VyY2U0ID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU291cmNlNC5yZWFkeVN0YXRlO1xuICAgICAgICByZXR1cm4gcmVhZHlTdGF0ZSA9PT0gJ29wZW4nIHx8IHJlYWR5U3RhdGUgPT09ICdlbmRlZCc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNvdXJjZUJ1ZmZlclRyYWNrc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpczI1ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhY2tzKS5yZWR1Y2UoZnVuY3Rpb24gKGJhc2VUcmFja3MsIHR5cGUpIHtcbiAgICAgICAgICB2YXIgdHJhY2sgPSBfdGhpczI1LnRyYWNrc1t0eXBlXTtcbiAgICAgICAgICBiYXNlVHJhY2tzW3R5cGVdID0ge1xuICAgICAgICAgICAgaWQ6IHRyYWNrLmlkLFxuICAgICAgICAgICAgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgICBjb2RlYzogdHJhY2suY29kZWMsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gYmFzZVRyYWNrcztcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJidWZmZXJlZFRvRW5kXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzMjYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VCdWZmZXJDb3VudCA+IDAgJiYgIXRoaXMuc291cmNlQnVmZmVycy5zb21lKGZ1bmN0aW9uIChfcmVmMTQpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IF9yZWYxNFswXTtcbiAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdmFyIHRyYWNrID0gX3RoaXMyNi50cmFja3NbdHlwZV07XG4gICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgcmV0dXJuICF0cmFjay5lbmRlZCB8fCB0cmFjay5lbmRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRyYWNrc1JlYWR5XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdUcmFja0NvdW50ID0gdGhpcy5wZW5kaW5nVHJhY2tDb3VudDtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdUcmFja0NvdW50ID4gMCAmJiAocGVuZGluZ1RyYWNrQ291bnQgPj0gdGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsIHx8IHRoaXMuaXNQZW5kaW5nKHRoaXMudHJhY2tzLmF1ZGlvdmlkZW8pKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWVkaWFTcmNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkbWVkaWEsIF90aGlzJG1lZGlhJHF1ZXJ5U2VsZTtcbiAgICAgICAgdmFyIG1lZGlhID0gKChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpID09IG51bGwgfHwgKF90aGlzJG1lZGlhJHF1ZXJ5U2VsZSA9IF90aGlzJG1lZGlhLnF1ZXJ5U2VsZWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYSRxdWVyeVNlbGUuY2FsbChfdGhpcyRtZWRpYSwgJ3NvdXJjZScpKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgICByZXR1cm4gbWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnNyYztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGVuZGluZ1RyYWNrQ291bnRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMyNyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYWNrcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gYWNjICsgKF90aGlzMjcuaXNQZW5kaW5nKF90aGlzMjcudHJhY2tzW3R5cGVdKSA/IDEgOiAwKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNvdXJjZUJ1ZmZlckNvdW50XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlQnVmZmVycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX3JlZjE1KSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBfcmVmMTVbMF07XG4gICAgICAgICAgcmV0dXJuIGFjYyArICh0eXBlID8gMSA6IDApO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic291cmNlQnVmZmVyVHlwZXNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VCdWZmZXJzLm1hcChmdW5jdGlvbiAoX3JlZjE2KSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBfcmVmMTZbMF07XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHJldHVybiAhIXR5cGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShMb2dnZXIpO1xuICBmdW5jdGlvbiByZW1vdmVTb3VyY2VDaGlsZHJlbihub2RlKSB7XG4gICAgdmFyIHNvdXJjZUNoaWxkcmVuID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdzb3VyY2UnKTtcbiAgICBbXS5zbGljZS5jYWxsKHNvdXJjZUNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoc291cmNlKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhZGRTb3VyY2UobWVkaWEsIHVybCkge1xuICAgIHZhciBzb3VyY2UgPSBzZWxmLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuICAgIHNvdXJjZS50eXBlID0gJ3ZpZGVvL21wNCc7XG4gICAgc291cmNlLnNyYyA9IHVybDtcbiAgICBtZWRpYS5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICB9XG4gIGZ1bmN0aW9uIHNvdXJjZUJ1ZmZlck5hbWVUb0luZGV4KHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2F1ZGlvJyA/IDEgOiAwO1xuICB9XG5cbiAgdmFyIENhcExldmVsQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FwTGV2ZWxDb250cm9sbGVyKGhscykge1xuICAgICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSB2b2lkIDA7XG4gICAgICB0aGlzLmZpcnN0TGV2ZWwgPSB2b2lkIDA7XG4gICAgICB0aGlzLm1lZGlhID0gdm9pZCAwO1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gdm9pZCAwO1xuICAgICAgdGhpcy50aW1lciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGxzID0gaGxzO1xuICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBDYXBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRTdHJlYW1Db250cm9sbGVyID0gZnVuY3Rpb24gc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuaGxzKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmhscyA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXIoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcHNEcm9wTGV2ZWxDYXBwaW5nID0gZnVuY3Rpb24gb25GcHNEcm9wTGV2ZWxDYXBwaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZGF0YS5kcm9wcGVkTGV2ZWxdO1xuICAgICAgaWYgKHRoaXMuaXNMZXZlbEFsbG93ZWQobGV2ZWwpKSB7XG4gICAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKHtcbiAgICAgICAgICBiaXRyYXRlOiBsZXZlbC5iaXRyYXRlLFxuICAgICAgICAgIGhlaWdodDogbGV2ZWwuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBsZXZlbC53aWR0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgICAgaWYgKHRoaXMudGltZXIgJiYgdGhpcy5obHMubGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG4gICAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAgIC8vIFN0YXJ0IGNhcHBpbmcgaW1tZWRpYXRlbHkgaWYgdGhlIG1hbmlmZXN0IGhhcyBzaWduYWxlZCB2aWRlbyBjb2RlY3NcbiAgICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsc1VwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLnRpbWVyICYmIGlzRmluaXRlTnVtYmVyKHRoaXMuYXV0b0xldmVsQ2FwcGluZykpIHtcbiAgICAgICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25seSBhY3RpdmF0ZSBjYXBwaW5nIHdoZW4gcGxheWluZyBhIHZpZGVvIHN0cmVhbTsgb3RoZXJ3aXNlLCBtdWx0aS1iaXRyYXRlIGF1ZGlvLW9ubHkgc3RyZWFtcyB3aWxsIGJlIHJlc3RyaWN0ZWRcbiAgICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgICA7XG4gICAgX3Byb3RvLm9uQnVmZmVyQ29kZWNzID0gZnVuY3Rpb24gb25CdWZmZXJDb2RlY3MoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgICAgLy8gSWYgdGhlIG1hbmlmZXN0IGRpZCBub3Qgc2lnbmFsIGEgdmlkZW8gY29kZWMgY2FwcGluZyBoYXMgYmVlbiBkZWZlcnJlZCB1bnRpbCB3ZSdyZSBjZXJ0YWluIHZpZGVvIGlzIHByZXNlbnRcbiAgICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmRldGVjdFBsYXllclNpemUgPSBmdW5jdGlvbiBkZXRlY3RQbGF5ZXJTaXplKCkge1xuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFIZWlnaHQgPD0gMCB8fCB0aGlzLm1lZGlhV2lkdGggPD0gMCkge1xuICAgICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICAgIGlmIChsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAgIHZhciBtYXhMZXZlbCA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGlmIChtYXhMZXZlbCAhPT0gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XG4gICAgICAgICAgICBobHMubG9nZ2VyLmxvZyhcIlNldHRpbmcgYXV0b0xldmVsQ2FwcGluZyB0byBcIiArIG1heExldmVsICsgXCI6IFwiICsgbGV2ZWxzW21heExldmVsXS5oZWlnaHQgKyBcInBAXCIgKyBsZXZlbHNbbWF4TGV2ZWxdLmJpdHJhdGUgKyBcIiBmb3IgbWVkaWEgXCIgKyB0aGlzLm1lZGlhV2lkdGggKyBcInhcIiArIHRoaXMubWVkaWFIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IG1heExldmVsO1xuICAgICAgICAgIGlmIChobHMuYXV0b0xldmVsRW5hYmxlZCAmJiBobHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZyAmJiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgICAvLyB1c3VhbGx5IGhhcHBlbiB3aGVuIHRoZSB1c2VyIGdvIHRvIHRoZSBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAgICAqLztcbiAgICBfcHJvdG8uZ2V0TWF4TGV2ZWwgPSBmdW5jdGlvbiBnZXRNYXhMZXZlbChjYXBMZXZlbEluZGV4KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgdmFsaWRMZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChsZXZlbCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmlzTGV2ZWxBbGxvd2VkKGxldmVsKSAmJiBpbmRleCA8PSBjYXBMZXZlbEluZGV4O1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplKHZhbGlkTGV2ZWxzLCB0aGlzLm1lZGlhV2lkdGgsIHRoaXMubWVkaWFIZWlnaHQpO1xuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0Q2FwcGluZyA9IGZ1bmN0aW9uIHN0YXJ0Q2FwcGluZygpIHtcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgIC8vIERvbid0IHJlc2V0IGNhcHBpbmcgaWYgc3RhcnRlZCB0d2ljZTsgdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtYW5pZmVzdCBzaWduYWxzIGEgdmlkZW8gY29kZWNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDEwMDApO1xuICAgICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RvcENhcHBpbmcgPSBmdW5jdGlvbiBzdG9wQ2FwcGluZygpIHtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoKSB7XG4gICAgICBpZiAodGhpcy5jbGllbnRSZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3Q7XG4gICAgICB9XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgdmFyIGJvdW5kc1JlY3QgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSBtZWRpYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgICAgIGJvdW5kc1JlY3QuaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmICghYm91bmRzUmVjdC53aWR0aCAmJiAhYm91bmRzUmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAvLyBXaGVuIHRoZSBtZWRpYSBlbGVtZW50IGhhcyBubyB3aWR0aCBvciBoZWlnaHQgKGVxdWl2YWxlbnQgdG8gbm90IGJlaW5nIGluIHRoZSBET00pLFxuICAgICAgICAgIC8vIHRoZW4gdXNlIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXMgKG1lZGlhLndpZHRoLCBtZWRpYS5oZWlnaHQpXG4gICAgICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRSZWN0LmxlZnQgfHwgbWVkaWEud2lkdGggfHwgMDtcbiAgICAgICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuYm90dG9tIC0gY2xpZW50UmVjdC50b3AgfHwgbWVkaWEuaGVpZ2h0IHx8IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2xpZW50UmVjdCA9IGJvdW5kc1JlY3Q7XG4gICAgICByZXR1cm4gYm91bmRzUmVjdDtcbiAgICB9O1xuICAgIF9wcm90by5pc0xldmVsQWxsb3dlZCA9IGZ1bmN0aW9uIGlzTGV2ZWxBbGxvd2VkKGxldmVsKSB7XG4gICAgICB2YXIgcmVzdHJpY3RlZExldmVscyA9IHRoaXMucmVzdHJpY3RlZExldmVscztcbiAgICAgIHJldHVybiAhcmVzdHJpY3RlZExldmVscy5zb21lKGZ1bmN0aW9uIChyZXN0cmljdGVkTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGxldmVsLmJpdHJhdGUgPT09IHJlc3RyaWN0ZWRMZXZlbC5iaXRyYXRlICYmIGxldmVsLndpZHRoID09PSByZXN0cmljdGVkTGV2ZWwud2lkdGggJiYgbGV2ZWwuaGVpZ2h0ID09PSByZXN0cmljdGVkTGV2ZWwuaGVpZ2h0O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSA9IGZ1bmN0aW9uIGdldE1heExldmVsQnlNZWRpYVNpemUobGV2ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoIShsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHMubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcbiAgICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIHdlJ3ZlIGNob3NlbiB0aGUgZ3JlYXRlc3QgYmFuZHdpZHRoIGZvciB0aGUgbWVkaWEncyBkaW1lbnNpb25zXG4gICAgICB2YXIgYXRHcmVhdGVzdEJhbmR3aWR0aCA9IGZ1bmN0aW9uIGF0R3JlYXRlc3RCYW5kd2lkdGgoY3VyTGV2ZWwsIG5leHRMZXZlbCkge1xuICAgICAgICBpZiAoIW5leHRMZXZlbCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJMZXZlbC53aWR0aCAhPT0gbmV4dExldmVsLndpZHRoIHx8IGN1ckxldmVsLmhlaWdodCAhPT0gbmV4dExldmVsLmhlaWdodDtcbiAgICAgIH07XG5cbiAgICAgIC8vIElmIHdlIHJ1biB0aHJvdWdoIHRoZSBsb29wIHdpdGhvdXQgYnJlYWtpbmcsIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnMgYXJlIGdyZWF0ZXIgdGhhbiBldmVyeSBsZXZlbCwgc28gZGVmYXVsdCB0b1xuICAgICAgLy8gdGhlIG1heCBsZXZlbFxuICAgICAgdmFyIG1heExldmVsSW5kZXggPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIFByZXZlbnQgY2hhbmdlcyBpbiBhc3BlY3QtcmF0aW8gZnJvbSBjYXVzaW5nIGNhcHBpbmcgdG8gdG9nZ2xlIGJhY2sgYW5kIGZvcnRoXG4gICAgICB2YXIgc3F1YXJlU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgICBpZiAoKGxldmVsLndpZHRoID49IHNxdWFyZVNpemUgfHwgbGV2ZWwuaGVpZ2h0ID49IHNxdWFyZVNpemUpICYmIGF0R3JlYXRlc3RCYW5kd2lkdGgobGV2ZWwsIGxldmVsc1tpICsgMV0pKSB7XG4gICAgICAgICAgbWF4TGV2ZWxJbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhMZXZlbEluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDYXBMZXZlbENvbnRyb2xsZXIsIFt7XG4gICAgICBrZXk6IFwibWVkaWFXaWR0aFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS53aWR0aCAqIHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtZWRpYUhlaWdodFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS5oZWlnaHQgKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29udGVudFNjYWxlRmFjdG9yXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSAxO1xuICAgICAgICBpZiAoIXRoaXMuaGxzLmNvbmZpZy5pZ25vcmVEZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBzZWxmLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHBpeGVsUmF0aW8sIHRoaXMuaGxzLmNvbmZpZy5tYXhEZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcblxuICAvKipcbiAgICogQ29tbW9uIE1lZGlhIE9iamVjdCBUeXBlXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIENtT2JqZWN0VHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiB0ZXh0IGZpbGUsIHN1Y2ggYXMgYSBtYW5pZmVzdCBvciBwbGF5bGlzdFxuICAgICAqL1xuICAgIE1BTklGRVNUOiAnbScsXG4gICAgLyoqXG4gICAgICogYXVkaW8gb25seVxuICAgICAqL1xuICAgIEFVRElPOiAnYScsXG4gICAgLyoqXG4gICAgICogdmlkZW8gb25seVxuICAgICAqL1xuICAgIFZJREVPOiAndicsXG4gICAgLyoqXG4gICAgICogbXV4ZWQgYXVkaW8gYW5kIHZpZGVvXG4gICAgICovXG4gICAgTVVYRUQ6ICdhdicsXG4gICAgLyoqXG4gICAgICogaW5pdCBzZWdtZW50XG4gICAgICovXG4gICAgSU5JVDogJ2knLFxuICAgIC8qKlxuICAgICAqIGNhcHRpb24gb3Igc3VidGl0bGVcbiAgICAgKi9cbiAgICBDQVBUSU9OOiAnYycsXG4gICAgLyoqXG4gICAgICogSVNPQk1GRiB0aW1lZCB0ZXh0IHRyYWNrXG4gICAgICovXG4gICAgVElNRURfVEVYVDogJ3R0JyxcbiAgICAvKipcbiAgICAgKiBjcnlwdG9ncmFwaGljIGtleSwgbGljZW5zZSBvciBjZXJ0aWZpY2F0ZS5cbiAgICAgKi9cbiAgICBLRVk6ICdrJyxcbiAgICAvKipcbiAgICAgKiBvdGhlclxuICAgICAqL1xuICAgIE9USEVSOiAnbydcbiAgfTtcblxuICAvKipcbiAgICogQ29tbW9uIE1lZGlhIENsaWVudCBEYXRhIE9iamVjdCBUeXBlXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqXG4gICAqIEBlbnVtXG4gICAqL1xuICB2YXIgQ21jZE9iamVjdFR5cGUgPSBDbU9iamVjdFR5cGU7XG5cbiAgLyoqXG4gICAqIENvbW1vbiBNZWRpYSBTdHJlYW1pbmcgRm9ybWF0XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIENtU3RyZWFtaW5nRm9ybWF0ID0ge1xuICAgIC8qKlxuICAgICAqIEhUVFAgTGl2ZSBTdHJlYW1pbmcgKEhMUylcbiAgICAgKi9cbiAgICBITFM6ICdoJ307XG5cbiAgLyoqXG4gICAqIENvbW1vbiBNZWRpYSBDbGllbnQgRGF0YSBTdHJlYW1pbmcgRm9ybWF0XG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBlbnVtXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICB2YXIgQ21jZFN0cmVhbWluZ0Zvcm1hdCA9IENtU3RyZWFtaW5nRm9ybWF0O1xuXG4gIC8qKlxuICAgKiBTdHJ1Y3R1cmVkIEZpZWxkIEl0ZW1cbiAgICpcbiAgICogQGdyb3VwIFN0cnVjdHVyZWQgRmllbGRcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBTZkl0ZW0gPSBmdW5jdGlvbiBTZkl0ZW0odmFsdWUsIHBhcmFtcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgaW5zdGFuY2VvZiBTZkl0ZW0gPyB2IDogbmV3IFNmSXRlbSh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIH07XG5cbiAgdmFyIERJQ1QgPSAnRGljdCc7XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIHJldHVybiAnTWFwe30nO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIHJldHVybiAnU2V0e30nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdGhyb3dFcnJvcihhY3Rpb24sIHNyYywgdHlwZSwgY2F1c2UpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiZmFpbGVkIHRvIFwiICsgYWN0aW9uICsgXCIgXFxcIlwiICsgZm9ybWF0KHNyYykgKyBcIlxcXCIgYXMgXCIgKyB0eXBlLCB7XG4gICAgICBjYXVzZTogY2F1c2VcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKHNyYywgdHlwZSwgY2F1c2UpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvcignc2VyaWFsaXplJywgc3JjLCB0eXBlLCBjYXVzZSk7XG4gIH1cblxuICAvKipcbiAgICogQSBjbGFzcyB0byByZXByZXNlbnQgc3RydWN0dXJlZCBmaWVsZCB0b2tlbnMgd2hlbiBgU3ltYm9sYCBpcyBub3QgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAZ3JvdXAgU3RydWN0dXJlZCBGaWVsZFxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgdmFyIFNmVG9rZW4gPSBmdW5jdGlvbiBTZlRva2VuKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICB9O1xuXG4gIHZhciBCQVJFX0lURU0gPSAnQmFyZSBJdGVtJztcblxuICB2YXIgQk9PTEVBTiA9ICdCb29sZWFuJztcblxuICAvLyA0LjEuOS4gIFNlcmlhbGl6aW5nIGEgQm9vbGVhblxuICAvL1xuICAvLyBHaXZlbiBhIEJvb2xlYW4gYXMgaW5wdXRfYm9vbGVhbiwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3JcbiAgLy8gdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbiAgLy9cbiAgLy8gMS4gIElmIGlucHV0X2Jvb2xlYW4gaXMgbm90IGEgYm9vbGVhbiwgZmFpbCBzZXJpYWxpemF0aW9uLlxuICAvL1xuICAvLyAyLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vXG4gIC8vIDMuICBBcHBlbmQgXCI/XCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA0LiAgSWYgaW5wdXRfYm9vbGVhbiBpcyB0cnVlLCBhcHBlbmQgXCIxXCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA1LiAgSWYgaW5wdXRfYm9vbGVhbiBpcyBmYWxzZSwgYXBwZW5kIFwiMFwiIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNi4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJvb2xlYW4odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBCT09MRUFOKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID8gJz8xJyA6ICc/MCc7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyBiaW5hcnkgZGF0YSB0byBiYXNlNjRcbiAgICpcbiAgICogQHBhcmFtIGJpbmFyeSAtIFRoZSBiaW5hcnkgZGF0YSB0byBlbmNvZGVcbiAgICogQHJldHVybnMgVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICAgKlxuICAgKiBAZ3JvdXAgVXRpbHNcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIGZ1bmN0aW9uIGVuY29kZUJhc2U2NChiaW5hcnkpIHtcbiAgICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYmluYXJ5KSk7XG4gIH1cblxuICB2YXIgQllURVMgPSAnQnl0ZSBTZXF1ZW5jZSc7XG5cbiAgLy8gNC4xLjguICBTZXJpYWxpemluZyBhIEJ5dGUgU2VxdWVuY2VcbiAgLy9cbiAgLy8gR2l2ZW4gYSBCeXRlIFNlcXVlbmNlIGFzIGlucHV0X2J5dGVzLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlXG4gIC8vIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgSWYgaW5wdXRfYnl0ZXMgaXMgbm90IGEgc2VxdWVuY2Ugb2YgYnl0ZXMsIGZhaWwgc2VyaWFsaXphdGlvbi5cbiAgLy9cbiAgLy8gMi4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAvL1xuICAvLyAzLiAgQXBwZW5kIFwiOlwiIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNC4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGJhc2U2NC1lbmNvZGluZyBpbnB1dF9ieXRlcyBhcyBwZXJcbiAgLy8gICAgIFtSRkM0NjQ4XSwgU2VjdGlvbiA0LCB0YWtpbmcgYWNjb3VudCBvZiB0aGUgcmVxdWlyZW1lbnRzIGJlbG93LlxuICAvL1xuICAvLyA1LiAgQXBwZW5kIFwiOlwiIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNi4gIFJldHVybiBvdXRwdXQuXG4gIC8vXG4gIC8vIFRoZSBlbmNvZGVkIGRhdGEgaXMgcmVxdWlyZWQgdG8gYmUgcGFkZGVkIHdpdGggXCI9XCIsIGFzIHBlciBbUkZDNDY0OF0sXG4gIC8vIFNlY3Rpb24gMy4yLlxuICAvL1xuICAvLyBMaWtld2lzZSwgZW5jb2RlZCBkYXRhIFNIT1VMRCBoYXZlIHBhZCBiaXRzIHNldCB0byB6ZXJvLCBhcyBwZXJcbiAgLy8gW1JGQzQ2NDhdLCBTZWN0aW9uIDMuNSwgdW5sZXNzIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBkbyBzbyBkdWUgdG9cbiAgLy8gaW1wbGVtZW50YXRpb24gY29uc3RyYWludHMuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJ5dGVTZXF1ZW5jZSh2YWx1ZSkge1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIEJZVEVTKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiOlwiICsgZW5jb2RlQmFzZTY0KHZhbHVlKSArIFwiOlwiO1xuICB9XG5cbiAgdmFyIElOVEVHRVIgPSAnSW50ZWdlcic7XG5cbiAgZnVuY3Rpb24gaXNJbnZhbGlkSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgLTk5OTk5OTk5OTk5OTk5OSB8fCA5OTk5OTk5OTk5OTk5OTkgPCB2YWx1ZTtcbiAgfVxuXG4gIC8vIDQuMS40LiAgU2VyaWFsaXppbmcgYW4gSW50ZWdlclxuICAvL1xuICAvLyBHaXZlbiBhbiBJbnRlZ2VyIGFzIGlucHV0X2ludGVnZXIsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGVcbiAgLy8gZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4gIC8vXG4gIC8vIDEuICBJZiBpbnB1dF9pbnRlZ2VyIGlzIG5vdCBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZlxuICAvLyAgICAgLTk5OSw5OTksOTk5LDk5OSw5OTkgdG8gOTk5LDk5OSw5OTksOTk5LDk5OSBpbmNsdXNpdmUsIGZhaWxcbiAgLy8gICAgIHNlcmlhbGl6YXRpb24uXG4gIC8vXG4gIC8vIDIuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgLy9cbiAgLy8gMy4gIElmIGlucHV0X2ludGVnZXIgaXMgbGVzcyB0aGFuIChidXQgbm90IGVxdWFsIHRvKSAwLCBhcHBlbmQgXCItXCIgdG9cbiAgLy8gICAgIG91dHB1dC5cbiAgLy9cbiAgLy8gNC4gIEFwcGVuZCBpbnB1dF9pbnRlZ2VyJ3MgbnVtZXJpYyB2YWx1ZSByZXByZXNlbnRlZCBpbiBiYXNlIDEwIHVzaW5nXG4gIC8vICAgICBvbmx5IGRlY2ltYWwgZGlnaXRzIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNS4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUludGVnZXIodmFsdWUpIHtcbiAgICBpZiAoaXNJbnZhbGlkSW50KHZhbHVlKSkge1xuICAgICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIElOVEVHRVIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8vIDQuMS4xMC4gIFNlcmlhbGl6aW5nIGEgRGF0ZVxuICAvL1xuICAvLyBHaXZlbiBhIERhdGUgYXMgaW5wdXRfaW50ZWdlciwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3JcbiAgLy8gdXNlIGluIGFuIEhUVFAgZmllbGQgdmFsdWUuXG4gIC8vIDEuICBMZXQgb3V0cHV0IGJlIFwiQFwiLlxuICAvLyAyLiAgQXBwZW5kIHRvIG91dHB1dCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYW4gSW50ZWdlclxuICAvLyAgICAgd2l0aCBpbnB1dF9kYXRlIChTZWN0aW9uIDQuMS40KS5cbiAgLy8gMy4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gXCJAXCIgKyBzZXJpYWxpemVJbnRlZ2VyKHZhbHVlLmdldFRpbWUoKSAvIDEwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaW1wbGVtZW50cyB0aGUgcm91bmRpbmcgcHJvY2VkdXJlIGRlc2NyaWJlZCBpbiBzdGVwIDIgb2YgdGhlIFwiU2VyaWFsaXppbmcgYSBEZWNpbWFsXCIgc3BlY2lmaWNhdGlvbi5cbiAgICogVGhpcyByb3VuZGluZyBzdHlsZSBpcyBrbm93biBhcyBcImV2ZW4gcm91bmRpbmdcIiwgXCJiYW5rZXIncyByb3VuZGluZ1wiLCBvciBcImNvbW1lcmNpYWwgcm91bmRpbmdcIi5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJvdW5kXG4gICAqIEBwYXJhbSBwcmVjaXNpb24gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kIHRvXG4gICAqIEByZXR1cm5zIFRoZSByb3VuZGVkIHZhbHVlXG4gICAqXG4gICAqIEBncm91cCBVdGlsc1xuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgZnVuY3Rpb24gcm91bmRUb0V2ZW4odmFsdWUsIHByZWNpc2lvbikge1xuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIHJldHVybiAtcm91bmRUb0V2ZW4oLXZhbHVlLCBwcmVjaXNpb24pO1xuICAgIH1cbiAgICB2YXIgZGVjaW1hbFNoaWZ0ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgdmFyIGlzRXF1aWRpc3RhbnQgPSBNYXRoLmFicyh2YWx1ZSAqIGRlY2ltYWxTaGlmdCAlIDEgLSAwLjUpIDwgTnVtYmVyLkVQU0lMT047XG4gICAgaWYgKGlzRXF1aWRpc3RhbnQpIHtcbiAgICAgIC8vIElmIHRoZSB0YWlsIG9mIHRoZSBkZWNpbWFsIHBsYWNlIGlzICdlcXVpZGlzdGFudCcgd2Ugcm91bmQgdG8gdGhlIG5lYXJlc3QgZXZlbiB2YWx1ZVxuICAgICAgdmFyIGZsb29yZWRWYWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgKiBkZWNpbWFsU2hpZnQpO1xuICAgICAgcmV0dXJuIChmbG9vcmVkVmFsdWUgJSAyID09PSAwID8gZmxvb3JlZFZhbHVlIDogZmxvb3JlZFZhbHVlICsgMSkgLyBkZWNpbWFsU2hpZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgcHJvY2VlZCBhcyBub3JtYWxcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZGVjaW1hbFNoaWZ0KSAvIGRlY2ltYWxTaGlmdDtcbiAgICB9XG4gIH1cblxuICB2YXIgREVDSU1BTCA9ICdEZWNpbWFsJztcblxuICAvLyA0LjEuNS4gIFNlcmlhbGl6aW5nIGEgRGVjaW1hbFxuICAvL1xuICAvLyBHaXZlbiBhIGRlY2ltYWwgbnVtYmVyIGFzIGlucHV0X2RlY2ltYWwsIHJldHVybiBhbiBBU0NJSSBzdHJpbmdcbiAgLy8gc3VpdGFibGUgZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4gIC8vXG4gIC8vIDEuICAgSWYgaW5wdXRfZGVjaW1hbCBpcyBub3QgYSBkZWNpbWFsIG51bWJlciwgZmFpbCBzZXJpYWxpemF0aW9uLlxuICAvL1xuICAvLyAyLiAgIElmIGlucHV0X2RlY2ltYWwgaGFzIG1vcmUgdGhhbiB0aHJlZSBzaWduaWZpY2FudCBkaWdpdHMgdG8gdGhlXG4gIC8vICAgICAgcmlnaHQgb2YgdGhlIGRlY2ltYWwgcG9pbnQsIHJvdW5kIGl0IHRvIHRocmVlIGRlY2ltYWwgcGxhY2VzLFxuICAvLyAgICAgIHJvdW5kaW5nIHRoZSBmaW5hbCBkaWdpdCB0byB0aGUgbmVhcmVzdCB2YWx1ZSwgb3IgdG8gdGhlIGV2ZW5cbiAgLy8gICAgICB2YWx1ZSBpZiBpdCBpcyBlcXVpZGlzdGFudC5cbiAgLy9cbiAgLy8gMy4gICBJZiBpbnB1dF9kZWNpbWFsIGhhcyBtb3JlIHRoYW4gMTIgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIHRoZSBsZWZ0XG4gIC8vICAgICAgb2YgdGhlIGRlY2ltYWwgcG9pbnQgYWZ0ZXIgcm91bmRpbmcsIGZhaWwgc2VyaWFsaXphdGlvbi5cbiAgLy9cbiAgLy8gNC4gICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgLy9cbiAgLy8gNS4gICBJZiBpbnB1dF9kZWNpbWFsIGlzIGxlc3MgdGhhbiAoYnV0IG5vdCBlcXVhbCB0bykgMCwgYXBwZW5kIFwiLVwiXG4gIC8vICAgICAgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA2LiAgIEFwcGVuZCBpbnB1dF9kZWNpbWFsJ3MgaW50ZWdlciBjb21wb25lbnQgcmVwcmVzZW50ZWQgaW4gYmFzZSAxMFxuICAvLyAgICAgICh1c2luZyBvbmx5IGRlY2ltYWwgZGlnaXRzKSB0byBvdXRwdXQ7IGlmIGl0IGlzIHplcm8sIGFwcGVuZFxuICAvLyAgICAgIFwiMFwiLlxuICAvL1xuICAvLyA3LiAgIEFwcGVuZCBcIi5cIiB0byBvdXRwdXQuXG4gIC8vXG4gIC8vIDguICAgSWYgaW5wdXRfZGVjaW1hbCdzIGZyYWN0aW9uYWwgY29tcG9uZW50IGlzIHplcm8sIGFwcGVuZCBcIjBcIiB0b1xuICAvLyAgICAgIG91dHB1dC5cbiAgLy9cbiAgLy8gOS4gICBPdGhlcndpc2UsIGFwcGVuZCB0aGUgc2lnbmlmaWNhbnQgZGlnaXRzIG9mIGlucHV0X2RlY2ltYWwnc1xuICAvLyAgICAgIGZyYWN0aW9uYWwgY29tcG9uZW50IHJlcHJlc2VudGVkIGluIGJhc2UgMTAgKHVzaW5nIG9ubHkgZGVjaW1hbFxuICAvLyAgICAgIGRpZ2l0cykgdG8gb3V0cHV0LlxuICAvL1xuICAvLyAxMC4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZURlY2ltYWwodmFsdWUpIHtcbiAgICB2YXIgcm91bmRlZFZhbHVlID0gcm91bmRUb0V2ZW4odmFsdWUsIDMpOyAvLyByb3VuZCB0byAzIGRlY2ltYWwgcGxhY2VzXG4gICAgaWYgKE1hdGguZmxvb3IoTWF0aC5hYnMocm91bmRlZFZhbHVlKSkudG9TdHJpbmcoKS5sZW5ndGggPiAxMikge1xuICAgICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIERFQ0lNQUwpO1xuICAgIH1cbiAgICB2YXIgc3RyaW5nVmFsdWUgPSByb3VuZGVkVmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gc3RyaW5nVmFsdWUuaW5jbHVkZXMoJy4nKSA/IHN0cmluZ1ZhbHVlIDogc3RyaW5nVmFsdWUgKyBcIi4wXCI7XG4gIH1cblxuICB2YXIgU1RSSU5HID0gJ1N0cmluZyc7XG5cbiAgdmFyIFNUUklOR19SRUdFWCA9IC9bXFx4MDAtXFx4MWZcXHg3Zl0rLztcblxuICAvLyA0LjEuNi4gIFNlcmlhbGl6aW5nIGEgU3RyaW5nXG4gIC8vXG4gIC8vIEdpdmVuIGEgU3RyaW5nIGFzIGlucHV0X3N0cmluZywgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3JcbiAgLy8gdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbiAgLy9cbiAgLy8gMS4gIENvbnZlcnQgaW5wdXRfc3RyaW5nIGludG8gYSBzZXF1ZW5jZSBvZiBBU0NJSSBjaGFyYWN0ZXJzOyBpZlxuICAvLyAgICAgY29udmVyc2lvbiBmYWlscywgZmFpbCBzZXJpYWxpemF0aW9uLlxuICAvL1xuICAvLyAyLiAgSWYgaW5wdXRfc3RyaW5nIGNvbnRhaW5zIGNoYXJhY3RlcnMgaW4gdGhlIHJhbmdlICV4MDAtMWYgb3IgJXg3ZlxuICAvLyAgICAgKGkuZS4sIG5vdCBpbiBWQ0hBUiBvciBTUCksIGZhaWwgc2VyaWFsaXphdGlvbi5cbiAgLy9cbiAgLy8gMy4gIExldCBvdXRwdXQgYmUgdGhlIHN0cmluZyBEUVVPVEUuXG4gIC8vXG4gIC8vIDQuICBGb3IgZWFjaCBjaGFyYWN0ZXIgY2hhciBpbiBpbnB1dF9zdHJpbmc6XG4gIC8vXG4gIC8vICAgICAxLiAgSWYgY2hhciBpcyBcIlxcXCIgb3IgRFFVT1RFOlxuICAvL1xuICAvLyAgICAgICAgIDEuICBBcHBlbmQgXCJcXFwiIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gICAgIDIuICBBcHBlbmQgY2hhciB0byBvdXRwdXQuXG4gIC8vXG4gIC8vIDUuICBBcHBlbmQgRFFVT1RFIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNi4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVN0cmluZyh2YWx1ZSkge1xuICAgIGlmIChTVFJJTkdfUkVHRVgudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBTVFJJTkcpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXFwiXCIgKyB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIikucmVwbGFjZSgvXCIvZywgXCJcXFxcXFxcIlwiKSArIFwiXFxcIlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgc3ltYm9sIHRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gc3ltYm9sIC0gVGhlIHN5bWJvbCB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzeW1ib2wuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZnVuY3Rpb24gc3ltYm9sVG9TdHIoc3ltYm9sKSB7XG4gICAgcmV0dXJuIHN5bWJvbC5kZXNjcmlwdGlvbiB8fCBzeW1ib2wudG9TdHJpbmcoKS5zbGljZSg3LCAtMSk7XG4gIH1cblxuICB2YXIgVE9LRU4gPSAnVG9rZW4nO1xuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVRva2VuKHRva2VuKSB7XG4gICAgdmFyIHZhbHVlID0gc3ltYm9sVG9TdHIodG9rZW4pO1xuICAgIGlmICgvXihbYS16QS1aKl0pKFshIyQlJicqK1xcLS5eX2B8flxcdzovXSopJC8udGVzdCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgVE9LRU4pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyA0LjEuMy4xLiAgU2VyaWFsaXppbmcgYSBCYXJlIEl0ZW1cbiAgLy9cbiAgLy8gR2l2ZW4gYW4gSXRlbSBhcyBpbnB1dF9pdGVtLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2VcbiAgLy8gaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgSWYgaW5wdXRfaXRlbSBpcyBhbiBJbnRlZ2VyLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gIC8vICAgICBTZXJpYWxpemluZyBhbiBJbnRlZ2VyIChTZWN0aW9uIDQuMS40KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDIuICBJZiBpbnB1dF9pdGVtIGlzIGEgRGVjaW1hbCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyAgICAgU2VyaWFsaXppbmcgYSBEZWNpbWFsIChTZWN0aW9uIDQuMS41KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDMuICBJZiBpbnB1dF9pdGVtIGlzIGEgU3RyaW5nLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gIC8vICAgICBTZXJpYWxpemluZyBhIFN0cmluZyAoU2VjdGlvbiA0LjEuNikgd2l0aCBpbnB1dF9pdGVtLlxuICAvL1xuICAvLyA0LiAgSWYgaW5wdXRfaXRlbSBpcyBhIFRva2VuLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gIC8vICAgICBTZXJpYWxpemluZyBhIFRva2VuIChTZWN0aW9uIDQuMS43KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDUuICBJZiBpbnB1dF9pdGVtIGlzIGEgQm9vbGVhbiwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyAgICAgU2VyaWFsaXppbmcgYSBCb29sZWFuIChTZWN0aW9uIDQuMS45KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDYuICBJZiBpbnB1dF9pdGVtIGlzIGEgQnl0ZSBTZXF1ZW5jZSwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyAgICAgU2VyaWFsaXppbmcgYSBCeXRlIFNlcXVlbmNlIChTZWN0aW9uIDQuMS44KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDcuICBJZiBpbnB1dF9pdGVtIGlzIGEgRGF0ZSwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZ1xuICAvLyAgICAgYSBEYXRlIChTZWN0aW9uIDQuMS4xMCkgd2l0aCBpbnB1dF9pdGVtLlxuICAvL1xuICAvLyA4LiAgT3RoZXJ3aXNlLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJhcmVJdGVtKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIEJBUkVfSVRFTSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUludGVnZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVEZWNpbWFsKHZhbHVlKTtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVTdHJpbmcodmFsdWUpO1xuICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRva2VuKHZhbHVlKTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gc2VyaWFsaXplQm9vbGVhbih2YWx1ZSk7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZURhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplQnl0ZVNlcXVlbmNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZlRva2VuKSB7XG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRva2VuKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZmFpbFxuICAgICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQkFSRV9JVEVNKTtcbiAgICB9XG4gIH1cblxuICB2YXIgS0VZID0gJ0tleSc7XG5cbiAgLy8gNC4xLjEuMy4gIFNlcmlhbGl6aW5nIGEgS2V5XG4gIC8vXG4gIC8vIEdpdmVuIGEga2V5IGFzIGlucHV0X2tleSwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlIGluXG4gIC8vIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbiAgLy9cbiAgLy8gMS4gIENvbnZlcnQgaW5wdXRfa2V5IGludG8gYSBzZXF1ZW5jZSBvZiBBU0NJSSBjaGFyYWN0ZXJzOyBpZlxuICAvLyAgICAgY29udmVyc2lvbiBmYWlscywgZmFpbCBzZXJpYWxpemF0aW9uLlxuICAvL1xuICAvLyAyLiAgSWYgaW5wdXRfa2V5IGNvbnRhaW5zIGNoYXJhY3RlcnMgbm90IGluIGxjYWxwaGEsIERJR0lULCBcIl9cIiwgXCItXCIsXG4gIC8vICAgICBcIi5cIiwgb3IgXCIqXCIgZmFpbCBzZXJpYWxpemF0aW9uLlxuICAvL1xuICAvLyAzLiAgSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBpbnB1dF9rZXkgaXMgbm90IGxjYWxwaGEgb3IgXCIqXCIsIGZhaWxcbiAgLy8gICAgIHNlcmlhbGl6YXRpb24uXG4gIC8vXG4gIC8vIDQuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgLy9cbiAgLy8gNS4gIEFwcGVuZCBpbnB1dF9rZXkgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA2LiAgUmV0dXJuIG91dHB1dC5cbiAgZnVuY3Rpb24gc2VyaWFsaXplS2V5KHZhbHVlKSB7XG4gICAgaWYgKC9eW2EteipdW2EtejAtOVxcLV8uKl0qJC8udGVzdCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgS0VZKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gNC4xLjEuMi4gIFNlcmlhbGl6aW5nIFBhcmFtZXRlcnNcbiAgLy9cbiAgLy8gR2l2ZW4gYW4gb3JkZXJlZCBEaWN0aW9uYXJ5IGFzIGlucHV0X3BhcmFtZXRlcnMgKGVhY2ggbWVtYmVyIGhhdmluZyBhXG4gIC8vIHBhcmFtX25hbWUgYW5kIGEgcGFyYW1fdmFsdWUpLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvclxuICAvLyB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vXG4gIC8vIDIuICBGb3IgZWFjaCBwYXJhbV9uYW1lIHdpdGggYSB2YWx1ZSBvZiBwYXJhbV92YWx1ZSBpblxuICAvLyAgICAgaW5wdXRfcGFyYW1ldGVyczpcbiAgLy9cbiAgLy8gICAgIDEuICBBcHBlbmQgXCI7XCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyAgICAgMi4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYSBLZXlcbiAgLy8gICAgICAgICAoU2VjdGlvbiA0LjEuMS4zKSB3aXRoIHBhcmFtX25hbWUgdG8gb3V0cHV0LlxuICAvL1xuICAvLyAgICAgMy4gIElmIHBhcmFtX3ZhbHVlIGlzIG5vdCBCb29sZWFuIHRydWU6XG4gIC8vXG4gIC8vICAgICAgICAgMS4gIEFwcGVuZCBcIj1cIiB0byBvdXRwdXQuXG4gIC8vXG4gIC8vICAgICAgICAgMi4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYSBiYXJlIEl0ZW1cbiAgLy8gICAgICAgICAgICAgKFNlY3Rpb24gNC4xLjMuMSkgd2l0aCBwYXJhbV92YWx1ZSB0byBvdXRwdXQuXG4gIC8vXG4gIC8vIDMuICBSZXR1cm4gb3V0cHV0LlxuICBmdW5jdGlvbiBzZXJpYWxpemVQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwYXJhbXMpLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGtleSA9IF9yZWZbMF0sXG4gICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gXCI7XCIgKyBzZXJpYWxpemVLZXkoa2V5KTsgLy8gb21pdCB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gXCI7XCIgKyBzZXJpYWxpemVLZXkoa2V5KSArIFwiPVwiICsgc2VyaWFsaXplQmFyZUl0ZW0odmFsdWUpO1xuICAgIH0pLmpvaW4oJycpO1xuICB9XG5cbiAgLy8gNC4xLjMuICBTZXJpYWxpemluZyBhbiBJdGVtXG4gIC8vXG4gIC8vIEdpdmVuIGFuIEl0ZW0gYXMgYmFyZV9pdGVtIGFuZCBQYXJhbWV0ZXJzIGFzIGl0ZW1fcGFyYW1ldGVycywgcmV0dXJuXG4gIC8vIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbiAgLy9cbiAgLy8gMS4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAvL1xuICAvLyAyLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhIEJhcmUgSXRlbVxuICAvLyAgICAgU2VjdGlvbiA0LjEuMy4xIHdpdGggYmFyZV9pdGVtIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gMy4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgUGFyYW1ldGVyc1xuICAvLyAgICAgU2VjdGlvbiA0LjEuMS4yIHdpdGggaXRlbV9wYXJhbWV0ZXJzIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNC4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUl0ZW0odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZkl0ZW0pIHtcbiAgICAgIHJldHVybiBcIlwiICsgc2VyaWFsaXplQmFyZUl0ZW0odmFsdWUudmFsdWUpICsgc2VyaWFsaXplUGFyYW1zKHZhbHVlLnBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVCYXJlSXRlbSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gNC4xLjEuMS4gIFNlcmlhbGl6aW5nIGFuIElubmVyIExpc3RcbiAgLy9cbiAgLy8gR2l2ZW4gYW4gYXJyYXkgb2YgKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgdHVwbGVzIGFzIGlubmVyX2xpc3QsXG4gIC8vIGFuZCBwYXJhbWV0ZXJzIGFzIGxpc3RfcGFyYW1ldGVycywgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZVxuICAvLyBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbiAgLy9cbiAgLy8gMS4gIExldCBvdXRwdXQgYmUgdGhlIHN0cmluZyBcIihcIi5cbiAgLy9cbiAgLy8gMi4gIEZvciBlYWNoIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIG9mIGlubmVyX2xpc3Q6XG4gIC8vXG4gIC8vICAgICAxLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhbiBJdGVtXG4gIC8vICAgICAgICAgKFNlY3Rpb24gNC4xLjMpIHdpdGggKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgdG8gb3V0cHV0LlxuICAvL1xuICAvLyAgICAgMi4gIElmIG1vcmUgdmFsdWVzIHJlbWFpbiBpbiBpbm5lcl9saXN0LCBhcHBlbmQgYSBzaW5nbGUgU1AgdG9cbiAgLy8gICAgICAgICBvdXRwdXQuXG4gIC8vXG4gIC8vIDMuICBBcHBlbmQgXCIpXCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA0LiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBQYXJhbWV0ZXJzXG4gIC8vICAgICAoU2VjdGlvbiA0LjEuMS4yKSB3aXRoIGxpc3RfcGFyYW1ldGVycyB0byBvdXRwdXQuXG4gIC8vXG4gIC8vIDUuICBSZXR1cm4gb3V0cHV0LlxuICBmdW5jdGlvbiBzZXJpYWxpemVJbm5lckxpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gXCIoXCIgKyB2YWx1ZS52YWx1ZS5tYXAoc2VyaWFsaXplSXRlbSkuam9pbignICcpICsgXCIpXCIgKyBzZXJpYWxpemVQYXJhbXModmFsdWUucGFyYW1zKTtcbiAgfVxuXG4gIC8vIDQuMS4yLiAgU2VyaWFsaXppbmcgYSBEaWN0aW9uYXJ5XG4gIC8vXG4gIC8vIEdpdmVuIGFuIG9yZGVyZWQgRGljdGlvbmFyeSBhcyBpbnB1dF9kaWN0aW9uYXJ5IChlYWNoIG1lbWJlciBoYXZpbmcgYVxuICAvLyBtZW1iZXJfbmFtZSBhbmQgYSB0dXBsZSB2YWx1ZSBvZiAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSksIHJldHVyblxuICAvLyBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4gIC8vXG4gIC8vIDEuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgLy9cbiAgLy8gMi4gIEZvciBlYWNoIG1lbWJlcl9uYW1lIHdpdGggYSB2YWx1ZSBvZiAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKVxuICAvLyAgICAgaW4gaW5wdXRfZGljdGlvbmFyeTpcbiAgLy9cbiAgLy8gICAgIDEuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGEgS2V5XG4gIC8vICAgICAgICAgKFNlY3Rpb24gNC4xLjEuMykgd2l0aCBtZW1iZXIncyBtZW1iZXJfbmFtZSB0byBvdXRwdXQuXG4gIC8vXG4gIC8vICAgICAyLiAgSWYgbWVtYmVyX3ZhbHVlIGlzIEJvb2xlYW4gdHJ1ZTpcbiAgLy9cbiAgLy8gICAgICAgICAxLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBQYXJhbWV0ZXJzXG4gIC8vICAgICAgICAgICAgIChTZWN0aW9uIDQuMS4xLjIpIHdpdGggcGFyYW1ldGVycyB0byBvdXRwdXQuXG4gIC8vXG4gIC8vICAgICAzLiAgT3RoZXJ3aXNlOlxuICAvL1xuICAvLyAgICAgICAgIDEuICBBcHBlbmQgXCI9XCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyAgICAgICAgIDIuICBJZiBtZW1iZXJfdmFsdWUgaXMgYW4gYXJyYXksIGFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgLy8gICAgICAgICAgICAgU2VyaWFsaXppbmcgYW4gSW5uZXIgTGlzdCAoU2VjdGlvbiA0LjEuMS4xKSB3aXRoXG4gIC8vICAgICAgICAgICAgIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gICAgICAgICAzLiAgT3RoZXJ3aXNlLCBhcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGFuXG4gIC8vICAgICAgICAgICAgIEl0ZW0gKFNlY3Rpb24gNC4xLjMpIHdpdGggKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgdG9cbiAgLy8gICAgICAgICAgICAgb3V0cHV0LlxuICAvL1xuICAvLyAgICAgNC4gIElmIG1vcmUgbWVtYmVycyByZW1haW4gaW4gaW5wdXRfZGljdGlvbmFyeTpcbiAgLy9cbiAgLy8gICAgICAgICAxLiAgQXBwZW5kIFwiLFwiIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gICAgICAgICAyLiAgQXBwZW5kIGEgc2luZ2xlIFNQIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gMy4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZURpY3QoZGljdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHdoaXRlc3BhY2U6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGljdCAhPT0gJ29iamVjdCcgfHwgZGljdCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcihkaWN0LCBESUNUKTtcbiAgICB9XG4gICAgdmFyIGVudHJpZXMgPSBkaWN0IGluc3RhbmNlb2YgTWFwID8gZGljdC5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhkaWN0KTtcbiAgICB2YXIgb3B0aW9uYWxXaGl0ZVNwYWNlID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53aGl0ZXNwYWNlKSA/ICcgJyA6ICcnO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVudHJpZXMpLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGtleSA9IF9yZWZbMF0sXG4gICAgICAgIGl0ZW0gPSBfcmVmWzFdO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTZkl0ZW0gPT09IGZhbHNlKSB7XG4gICAgICAgIGl0ZW0gPSBuZXcgU2ZJdGVtKGl0ZW0pO1xuICAgICAgfVxuICAgICAgdmFyIG91dHB1dCA9IHNlcmlhbGl6ZUtleShrZXkpO1xuICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgb3V0cHV0ICs9IHNlcmlhbGl6ZVBhcmFtcyhpdGVtLnBhcmFtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgKz0gJz0nO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtLnZhbHVlKSkge1xuICAgICAgICAgIG91dHB1dCArPSBzZXJpYWxpemVJbm5lckxpc3QoaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0ICs9IHNlcmlhbGl6ZUl0ZW0oaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSkuam9pbihcIixcIiArIG9wdGlvbmFsV2hpdGVTcGFjZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIG9iamVjdCBpbnRvIGEgc3RydWN0dXJlZCBmaWVsZCBkaWN0aW9uYXJ5XG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJ1Y3R1cmVkIGZpZWxkIGRpY3Rpb25hcnkgdG8gZW5jb2RlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgc3RydWN0dXJlZCBmaWVsZCBzdHJpbmdcbiAgICpcbiAgICogQGdyb3VwIFN0cnVjdHVyZWQgRmllbGRcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIGZ1bmN0aW9uIGVuY29kZVNmRGljdCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBzZXJpYWxpemVEaWN0KHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDTUNEIG9iamVjdCBoZWFkZXIgbmFtZS5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDTUNEX09CSkVDVCA9ICdDTUNELU9iamVjdCc7XG5cbiAgLyoqXG4gICAqIENNQ0QgcmVxdWVzdCBoZWFkZXIgbmFtZS5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDTUNEX1JFUVVFU1QgPSAnQ01DRC1SZXF1ZXN0JztcblxuICAvKipcbiAgICogQ01DRCBzZXNzaW9uIGhlYWRlciBuYW1lLlxuICAgKlxuICAgKiBAZ3JvdXAgQ01DRFxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgdmFyIENNQ0RfU0VTU0lPTiA9ICdDTUNELVNlc3Npb24nO1xuXG4gIC8qKlxuICAgKiBDTUNEIHN0YXR1cyBoZWFkZXIgbmFtZS5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDTUNEX1NUQVRVUyA9ICdDTUNELVN0YXR1cyc7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXAgb2YgQ01DRCBrZXlzIHRvIHRoZWlyIGFwcHJvcHJpYXRlIGhlYWRlciBzaGFyZC5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgQ01DRF9IRUFERVJfTUFQID0ge1xuICAgIC8vIE9iamVjdFxuICAgIGJyOiBDTUNEX09CSkVDVCxcbiAgICBhYjogQ01DRF9PQkpFQ1QsXG4gICAgZDogQ01DRF9PQkpFQ1QsXG4gICAgb3Q6IENNQ0RfT0JKRUNULFxuICAgIHRiOiBDTUNEX09CSkVDVCxcbiAgICB0cGI6IENNQ0RfT0JKRUNULFxuICAgIGxiOiBDTUNEX09CSkVDVCxcbiAgICB0YWI6IENNQ0RfT0JKRUNULFxuICAgIGxhYjogQ01DRF9PQkpFQ1QsXG4gICAgdXJsOiBDTUNEX09CSkVDVCxcbiAgICAvLyBSZXF1ZXN0XG4gICAgcGI6IENNQ0RfUkVRVUVTVCxcbiAgICBibDogQ01DRF9SRVFVRVNULFxuICAgIHRibDogQ01DRF9SRVFVRVNULFxuICAgIGRsOiBDTUNEX1JFUVVFU1QsXG4gICAgbHRjOiBDTUNEX1JFUVVFU1QsXG4gICAgbXRwOiBDTUNEX1JFUVVFU1QsXG4gICAgbm9yOiBDTUNEX1JFUVVFU1QsXG4gICAgbnJyOiBDTUNEX1JFUVVFU1QsXG4gICAgcmM6IENNQ0RfUkVRVUVTVCxcbiAgICBzbjogQ01DRF9SRVFVRVNULFxuICAgIHN0YTogQ01DRF9SRVFVRVNULFxuICAgIHN1OiBDTUNEX1JFUVVFU1QsXG4gICAgdHRmYjogQ01DRF9SRVFVRVNULFxuICAgIHR0ZmJiOiBDTUNEX1JFUVVFU1QsXG4gICAgdHRsYjogQ01DRF9SRVFVRVNULFxuICAgIGNtc2RkOiBDTUNEX1JFUVVFU1QsXG4gICAgY21zZHM6IENNQ0RfUkVRVUVTVCxcbiAgICBzbXJ0OiBDTUNEX1JFUVVFU1QsXG4gICAgZGY6IENNQ0RfUkVRVUVTVCxcbiAgICBjczogQ01DRF9SRVFVRVNULFxuICAgIC8vIFRPRE86IFdoaWNoIGhlYWRlciB0byBwdXQgdGhlIGB0c2AgZmllbGQgaXMgbm90IGRlZmluZWQgeWV0LlxuICAgIHRzOiBDTUNEX1JFUVVFU1QsXG4gICAgLy8gU2Vzc2lvblxuICAgIGNpZDogQ01DRF9TRVNTSU9OLFxuICAgIHByOiBDTUNEX1NFU1NJT04sXG4gICAgc2Y6IENNQ0RfU0VTU0lPTixcbiAgICBzaWQ6IENNQ0RfU0VTU0lPTixcbiAgICBzdDogQ01DRF9TRVNTSU9OLFxuICAgIHY6IENNQ0RfU0VTU0lPTixcbiAgICBtc2Q6IENNQ0RfU0VTU0lPTixcbiAgICAvLyBTdGF0dXNcbiAgICBiczogQ01DRF9TVEFUVVMsXG4gICAgYnNkOiBDTUNEX1NUQVRVUyxcbiAgICBjZG46IENNQ0RfU1RBVFVTLFxuICAgIHJ0cDogQ01DRF9TVEFUVVMsXG4gICAgYmc6IENNQ0RfU1RBVFVTLFxuICAgIHB0OiBDTUNEX1NUQVRVUyxcbiAgICBlYzogQ01DRF9TVEFUVVMsXG4gICAgZTogQ01DRF9TVEFUVVNcbiAgfTtcblxuICAvKipcbiAgICogQ01DRCBoZWFkZXIgZmllbGRzLlxuICAgKlxuICAgKiBAZ3JvdXAgQ01DRFxuICAgKlxuICAgKiBAZW51bVxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgdmFyIENtY2RIZWFkZXJGaWVsZCA9IHtcbiAgICAvKipcbiAgICAgKiBrZXlzIHdob3NlIHZhbHVlcyB2YXJ5IHdpdGggZWFjaCByZXF1ZXN0LlxuICAgICAqL1xuICAgIFJFUVVFU1Q6IENNQ0RfUkVRVUVTVH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlSGVhZGVyTWFwKGhlYWRlck1hcCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhoZWFkZXJNYXApLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmaWVsZCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gaGVhZGVyTWFwW2ZpZWxkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gYWNjW2tleV0gPSBmaWVsZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cbiAgLyoqXG4gICAqIEdyb3VwIGEgQ01DRCBkYXRhIG9iamVjdCBpbnRvIGhlYWRlciBzaGFyZHNcbiAgICpcbiAgICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBkYXRhIG9iamVjdCB0byBjb252ZXJ0LlxuICAgKiBAcGFyYW0gY3VzdG9tSGVhZGVyTWFwIC0gQSBtYXAgb2YgQ01DRCBoZWFkZXIgZmllbGRzIHRvIGN1c3RvbSBDTUNEIGtleXMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBDTUNEIGhlYWRlciBzaGFyZHMuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICBmdW5jdGlvbiBncm91cENtY2RIZWFkZXJzKGNtY2QsIGN1c3RvbUhlYWRlck1hcCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAoIWNtY2QpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY21jZCk7XG4gICAgdmFyIGN1c3RvbSA9IGN1c3RvbUhlYWRlck1hcCA/IGNyZWF0ZUhlYWRlck1hcChjdXN0b21IZWFkZXJNYXApIDoge307XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgdmFyIGZpZWxkID0gQ01DRF9IRUFERVJfTUFQW2tleV0gfHwgY3VzdG9tW2tleV0gfHwgQ21jZEhlYWRlckZpZWxkLlJFUVVFU1Q7XG4gICAgICB2YXIgZGF0YSA9IChfYSA9IGFjY1tmaWVsZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGFjY1tmaWVsZF0gPSB7fTtcbiAgICAgIGRhdGFba2V5XSA9IGNtY2Rba2V5XTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGtleSBpcyBhIHRva2VuIGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBrZXkgaXMgYSB0b2tlbiBmaWVsZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBmdW5jdGlvbiBpc1Rva2VuRmllbGQoa2V5KSB7XG4gICAgcmV0dXJuIFsnb3QnLCAnc2YnLCAnc3QnLCAnZScsICdzdGEnXS5pbmNsdWRlcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGtleSBpcyBhIHZhbHVlIGlzIHZhbGlkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDTUNEIGV2ZW50IG1vZGUgdmFyaWFibGUgbmFtZS5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDTUNEX0VWRU5UX01PREUgPSAnZXZlbnQnO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgcmVsYXRpdmUgcGF0aCBmcm9tIGEgVVJMLlxuICAgKlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIGRlc3RpbmF0aW9uIFVSTFxuICAgKiBAcGFyYW0gYmFzZSAtIFRoZSBiYXNlIFVSTFxuICAgKiBAcmV0dXJucyBUaGUgcmVsYXRpdmUgcGF0aFxuICAgKlxuICAgKiBAZ3JvdXAgVXRpbHNcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIGZ1bmN0aW9uIHVybFRvUmVsYXRpdmVQYXRoKHVybCwgYmFzZSkge1xuICAgIHZhciB0byA9IG5ldyBVUkwodXJsKTtcbiAgICB2YXIgZnJvbSA9IG5ldyBVUkwoYmFzZSk7XG4gICAgaWYgKHRvLm9yaWdpbiAhPT0gZnJvbS5vcmlnaW4pIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHZhciB0b1BhdGggPSB0by5wYXRobmFtZS5zcGxpdCgnLycpLnNsaWNlKDEpO1xuICAgIHZhciBmcm9tUGF0aCA9IGZyb20ucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgxLCAtMSk7XG4gICAgLy8gcmVtb3ZlIGNvbW1vbiBwYXJlbnRzXG4gICAgd2hpbGUgKHRvUGF0aFswXSA9PT0gZnJvbVBhdGhbMF0pIHtcbiAgICAgIHRvUGF0aC5zaGlmdCgpO1xuICAgICAgZnJvbVBhdGguc2hpZnQoKTtcbiAgICB9XG4gICAgLy8gYWRkIGJhY2sgcGF0aHNcbiAgICB3aGlsZSAoZnJvbVBhdGgubGVuZ3RoKSB7XG4gICAgICBmcm9tUGF0aC5zaGlmdCgpO1xuICAgICAgdG9QYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICAgIHZhciByZWxhdGl2ZVBhdGggPSB0b1BhdGguam9pbignLycpO1xuICAgIC8vIHByZXNlcnZlIHF1ZXJ5IHBhcmFtZXRlcnMgYW5kIGhhc2ggb2YgdGhlIGRlc3RpbmF0aW9uIHVybFxuICAgIHJldHVybiByZWxhdGl2ZVBhdGggKyB0by5zZWFyY2ggKyB0by5oYXNoO1xuICB9XG5cbiAgdmFyIHRvUm91bmRlZCA9IGZ1bmN0aW9uIHRvUm91bmRlZCh2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgfTtcbiAgdmFyIF90b1VybFNhZmUgPSBmdW5jdGlvbiB0b1VybFNhZmUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIF90b1VybFNhZmUoaXRlbSwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2ZJdGVtICYmIHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgU2ZJdGVtKF90b1VybFNhZmUodmFsdWUudmFsdWUsIG9wdGlvbnMpLCB2YWx1ZS5wYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5iYXNlVXJsKSB7XG4gICAgICAgIHZhbHVlID0gdXJsVG9SZWxhdGl2ZVBhdGgodmFsdWUsIG9wdGlvbnMuYmFzZVVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy52ZXJzaW9uID09PSAxID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cbiAgfTtcbiAgdmFyIHRvSHVuZHJlZCA9IGZ1bmN0aW9uIHRvSHVuZHJlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1JvdW5kZWQodmFsdWUgLyAxMDApICogMTAwO1xuICB9O1xuICB2YXIgbm9yID0gZnVuY3Rpb24gbm9yKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vclZhbHVlID0gdmFsdWU7XG4gICAgaWYgKG9wdGlvbnMudmVyc2lvbiA+PSAyKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZkl0ZW0gJiYgdHlwZW9mIHZhbHVlLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBub3JWYWx1ZSA9IG5ldyBTZkl0ZW0oW3ZhbHVlXSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9yVmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3RvVXJsU2FmZShub3JWYWx1ZSwgb3B0aW9ucyk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBmb3JtYXR0ZXJzIGZvciBDTUNEIHZhbHVlcy5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDTUNEX0ZPUk1BVFRFUl9NQVAgPSB7XG4gICAgLyoqXG4gICAgICogQml0cmF0ZSAoa2Jwcykgcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgYnI6IHRvUm91bmRlZCxcbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiAobWlsbGlzZWNvbmRzKSByb3VuZGVkIGludGVnZXJcbiAgICAgKi9cbiAgICBkOiB0b1JvdW5kZWQsXG4gICAgLyoqXG4gICAgICogQnVmZmVyIExlbmd0aCAobWlsbGlzZWNvbmRzKSByb3VuZGVkIG5lYXJlc3QgMTAwbXNcbiAgICAgKi9cbiAgICBibDogdG9IdW5kcmVkLFxuICAgIC8qKlxuICAgICAqIERlYWRsaW5lIChtaWxsaXNlY29uZHMpIHJvdW5kZWQgbmVhcmVzdCAxMDBtc1xuICAgICAqL1xuICAgIGRsOiB0b0h1bmRyZWQsXG4gICAgLyoqXG4gICAgICogTWVhc3VyZWQgVGhyb3VnaHB1dCAoa2Jwcykgcm91bmRlZCBuZWFyZXN0IDEwMGticHNcbiAgICAgKi9cbiAgICBtdHA6IHRvSHVuZHJlZCxcbiAgICAvKipcbiAgICAgKiBOZXh0IE9iamVjdCBSZXF1ZXN0IFVSTCBlbmNvZGVkXG4gICAgICovXG4gICAgbm9yOiBub3IsXG4gICAgLyoqXG4gICAgICogUmVxdWVzdGVkIG1heGltdW0gdGhyb3VnaHB1dCAoa2Jwcykgcm91bmRlZCBuZWFyZXN0IDEwMGticHNcbiAgICAgKi9cbiAgICBydHA6IHRvSHVuZHJlZCxcbiAgICAvKipcbiAgICAgKiBUb3AgQml0cmF0ZSAoa2Jwcykgcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgdGI6IHRvUm91bmRlZFxuICB9O1xuXG4gIC8qKlxuICAgKiBDTUNEIHJlcXVlc3QgbW9kZSB2YXJpYWJsZSBuYW1lLlxuICAgKlxuICAgKiBAZ3JvdXAgQ01DRFxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgdmFyIENNQ0RfUkVRVUVTVF9NT0RFID0gJ3JlcXVlc3QnO1xuXG4gIC8qKlxuICAgKiBDTUNEIHJlc3BvbnNlIG1vZGUgdmFyaWFibGUgbmFtZS5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDTUNEX1JFU1BPTlNFX01PREUgPSAncmVzcG9uc2UnO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBjb21tb24ga2V5cyBmb3IgQ01DRCAoQ29tbW9uIE1lZGlhIENsaWVudCBEYXRhKSB2ZXJzaW9uIDIuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICB2YXIgQ01DRF9DT01NT05fS0VZUyA9IFsnYWInLCAnYmcnLCAnYmwnLCAnYnInLCAnYnMnLCAnYnNkJywgJ2NkbicsICdjaWQnLCAnY3MnLCAnZGYnLCAnZWMnLCAnbGFiJywgJ2xiJywgJ2x0YycsICdtc2QnLCAnbXRwJywgJ3BiJywgJ3ByJywgJ3B0JywgJ3NmJywgJ3NpZCcsICdzbicsICdzdCcsICdzdGEnLCAndGFiJywgJ3RiJywgJ3RibCcsICd0cGInLCAndHMnLCAndiddO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBldmVudC1zcGVjaWZpYyBrZXlzIGZvciBDTUNEIChDb21tb24gTWVkaWEgQ2xpZW50IERhdGEpIHZlcnNpb24gMi5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDTUNEX0VWRU5UX0tFWVMgPSBbJ2UnXTtcblxuICB2YXIgQ1VTVE9NX0tFWV9SRUdFWCA9IC9eW2EtekEtWjAtOS0uXSstW2EtekEtWjAtOS0uXSskLztcbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2V5IGlzIGEgY3VzdG9tIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUga2V5IGlzIGEgY3VzdG9tIGtleSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICBmdW5jdGlvbiBpc0NtY2RDdXN0b21LZXkoa2V5KSB7XG4gICAgcmV0dXJuIENVU1RPTV9LRVlfUkVHRVgudGVzdChrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2V5IGlzIGEgdmFsaWQgQ01DRCBldmVudCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGtleSBpcyBhIHZhbGlkIENNQ0QgZXZlbnQga2V5LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICoge0BpbmNsdWRlQ29kZSAuLi8uLi90ZXN0L2NtY2QvaXNDbWNkRXZlbnRLZXkudGVzdC50cyNleGFtcGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gaXNDbWNkRXZlbnRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIENNQ0RfQ09NTU9OX0tFWVMuaW5jbHVkZXMoa2V5KSB8fCBDTUNEX0VWRU5UX0tFWVMuaW5jbHVkZXMoa2V5KSB8fCBpc0NtY2RDdXN0b21LZXkoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSByZXF1ZXN0LXNwZWNpZmljIGtleXMgZm9yIENNQ0QgKENvbW1vbiBNZWRpYSBDbGllbnQgRGF0YSkgdmVyc2lvbiAyLlxuICAgKlxuICAgKiBAZ3JvdXAgQ01DRFxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgdmFyIENNQ0RfUkVRVUVTVF9LRVlTID0gWydkJywgJ2RsJywgJ25vcicsICdvdCcsICdydHAnLCAnc3UnXTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXkgaXMgYSB2YWxpZCBDTUNEIHJlcXVlc3Qga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBrZXkgaXMgYSB2YWxpZCBDTUNEIHJlcXVlc3Qga2V5LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICoge0BpbmNsdWRlQ29kZSAuLi8uLi90ZXN0L2NtY2QvaXNDbWNkUmVxdWVzdEtleS50ZXN0LnRzI2V4YW1wbGV9XG4gICAqL1xuICBmdW5jdGlvbiBpc0NtY2RSZXF1ZXN0S2V5KGtleSkge1xuICAgIHJldHVybiBDTUNEX0NPTU1PTl9LRVlTLmluY2x1ZGVzKGtleSkgfHwgQ01DRF9SRVFVRVNUX0tFWVMuaW5jbHVkZXMoa2V5KSB8fCBpc0NtY2RDdXN0b21LZXkoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDTUNEIHYyIC0gUmVzcG9uc2Utb25seSBhbmQgdGltaW5nIGtleXMuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICB2YXIgQ01DRF9SRVNQT05TRV9LRVlTID0gWydjbXNkZCcsICdjbXNkcycsICdyYycsICdzbXJ0JywgJ3R0ZmInLCAndHRmYmInLCAndHRsYicsICd1cmwnXTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXkgaXMgYSB2YWxpZCBDTUNEIHJlc3BvbnNlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUga2V5IGlzIGEgdmFsaWQgQ01DRCByZXF1ZXN0IGtleSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHtAaW5jbHVkZUNvZGUgLi4vLi4vdGVzdC9jbWNkL2lzQ21jZFJlc3BvbnNlS2V5LnRlc3QudHMjZXhhbXBsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGlzQ21jZFJlc3BvbnNlS2V5KGtleSkge1xuICAgIHJldHVybiBDTUNEX0NPTU1PTl9LRVlTLmluY2x1ZGVzKGtleSkgfHwgQ01DRF9SRVFVRVNUX0tFWVMuaW5jbHVkZXMoa2V5KSB8fCBDTUNEX1JFU1BPTlNFX0tFWVMuaW5jbHVkZXMoa2V5KSB8fCBpc0NtY2RDdXN0b21LZXkoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBrZXlzIGZvciBDTUNEIChDb21tb24gTWVkaWEgQ2xpZW50IERhdGEpIHZlcnNpb24gMS5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDTUNEX1YxX0tFWVMgPSBbJ2JsJywgJ2JyJywgJ2JzJywgJ2NpZCcsICdkJywgJ2RsJywgJ210cCcsICdub3InLCAnbnJyJywgJ290JywgJ3ByJywgJ3J0cCcsICdzZicsICdzaWQnLCAnc3QnLCAnc3UnLCAndGInLCAndiddO1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgZnVuY3Rpb24gZm9yIENNQ0QgdjEga2V5cy5cbiAgICpcbiAgICogQHBhcmFtIGtleSAtIFRoZSBDTUNEIGtleSB0byBmaWx0ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUga2V5IHNob3VsZCBiZSBpbmNsdWRlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHtAaW5jbHVkZUNvZGUgLi4vLi4vdGVzdC9jbWNkL2lzQ21jZFYxS2V5LnRlc3QudHMjZXhhbXBsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGlzQ21jZFYxS2V5KGtleSkge1xuICAgIHJldHVybiBDTUNEX1YxX0tFWVMuaW5jbHVkZXMoa2V5KSB8fCBpc0NtY2RDdXN0b21LZXkoa2V5KTtcbiAgfVxuXG4gIHZhciBfZmlsdGVyTWFwO1xuICB2YXIgZmlsdGVyTWFwID0gKF9maWx0ZXJNYXAgPSB7fSwgX2ZpbHRlck1hcFtDTUNEX1JFU1BPTlNFX01PREVdID0gaXNDbWNkUmVzcG9uc2VLZXksIF9maWx0ZXJNYXBbQ01DRF9FVkVOVF9NT0RFXSA9IGlzQ21jZEV2ZW50S2V5LCBfZmlsdGVyTWFwW0NNQ0RfUkVRVUVTVF9NT0RFXSA9IGlzQ21jZFJlcXVlc3RLZXksIF9maWx0ZXJNYXApO1xuICAvKipcbiAgICogQ29udmVydCBhIGdlbmVyaWMgb2JqZWN0IHRvIENNQ0QgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIG9iaiAtIFRoZSBDTUNEIG9iamVjdCB0byBwcm9jZXNzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nLlxuICAgKlxuICAgKiBAZ3JvdXAgQ01DRFxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgZnVuY3Rpb24gcHJlcGFyZUNtY2REYXRhKG9iaiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiB8fCBvYmpbJ3YnXSB8fCAxO1xuICAgIHZhciByZXBvcnRpbmdNb2RlID0gb3B0aW9ucy5yZXBvcnRpbmdNb2RlIHx8IENNQ0RfUkVRVUVTVF9NT0RFO1xuICAgIHZhciBrZXlGaWx0ZXIgPSB2ZXJzaW9uID09PSAxID8gaXNDbWNkVjFLZXkgOiBmaWx0ZXJNYXBbcmVwb3J0aW5nTW9kZV07XG4gICAgLy8gRmlsdGVyIGtleXMgYmFzZWQgb24gdGhlIHZlcnNpb24sIHJlcG9ydGluZyBtb2RlIGFuZCBvcHRpb25zXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihrZXlGaWx0ZXIpO1xuICAgIHZhciBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGZpbHRlcik7XG4gICAgfVxuICAgIC8vIEVuc3VyZSBhbGwgcmVxdWlyZWQga2V5cyBhcmUgcHJlc2VudCBiZWZvcmUgc29ydGluZ1xuICAgIHZhciBuZWVkc1RpbWVzdGFtcCA9IHJlcG9ydGluZ01vZGUgPT09IENNQ0RfUkVTUE9OU0VfTU9ERSB8fCByZXBvcnRpbmdNb2RlID09PSBDTUNEX0VWRU5UX01PREU7XG4gICAgaWYgKG5lZWRzVGltZXN0YW1wICYmICFrZXlzLmluY2x1ZGVzKCd0cycpKSB7XG4gICAgICBrZXlzLnB1c2goJ3RzJyk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uID4gMSAmJiAha2V5cy5pbmNsdWRlcygndicpKSB7XG4gICAgICBrZXlzLnB1c2goJ3YnKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlcnMgPSBfZXh0ZW5kcyh7fSwgQ01DRF9GT1JNQVRURVJfTUFQLCBvcHRpb25zLmZvcm1hdHRlcnMpO1xuICAgIHZhciBmb3JtYXR0ZXJPcHRpb25zID0ge1xuICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgIHJlcG9ydGluZ01vZGU6IHJlcG9ydGluZ01vZGUsXG4gICAgICBiYXNlVXJsOiBvcHRpb25zLmJhc2VVcmxcbiAgICB9O1xuICAgIGtleXMuc29ydCgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXR0ZXIodmFsdWUsIGZvcm1hdHRlck9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgLy8gVmVyc2lvbiBzaG91bGQgb25seSBiZSByZXBvcnRlZCBpZiBub3QgZXF1YWwgdG8gMS5cbiAgICAgIGlmIChrZXkgPT09ICd2Jykge1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHZlcnNpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFBsYXliYWNrIHJhdGUgc2hvdWxkIG9ubHkgYmUgc2VudCBpZiBub3QgZXF1YWwgdG8gMS5cbiAgICAgIGlmIChrZXkgPT0gJ3ByJyAmJiB2YWx1ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBFbnN1cmUgYSB0aW1lc3RhbXAgaXMgc2V0IGZvciByZXNwb25zZSBhbmQgZXZlbnQgbW9kZXNcbiAgICAgIGlmIChuZWVkc1RpbWVzdGFtcCAmJiBrZXkgPT09ICd0cycgJiYgIWlzRmluaXRlTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IERhdGUubm93KCk7XG4gICAgICB9XG4gICAgICAvLyBpZ25vcmUgaW52YWxpZCB2YWx1ZXNcbiAgICAgIGlmICghaXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVG9rZW5GaWVsZChrZXkpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgU2ZUb2tlbih2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXN1bHRzW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgQ01DRCBkYXRhIG9iamVjdCB0byByZXF1ZXN0IGhlYWRlcnNcbiAgICpcbiAgICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBkYXRhIG9iamVjdCB0byBjb252ZXJ0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nIHRoZSBDTUNEIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIENNQ0QgaGVhZGVyIHNoYXJkcy5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICoge0BpbmNsdWRlQ29kZSAuLi8uLi90ZXN0L2NtY2QvdG9DbWNkSGVhZGVycy50ZXN0LnRzI2V4YW1wbGV9XG4gICAqL1xuICBmdW5jdGlvbiB0b0NtY2RIZWFkZXJzKGNtY2QsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAoIWNtY2QpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBkYXRhID0gcHJlcGFyZUNtY2REYXRhKGNtY2QsIG9wdGlvbnMpO1xuICAgIHZhciBzaGFyZHMgPSBncm91cENtY2RIZWFkZXJzKGRhdGEsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jdXN0b21IZWFkZXJNYXApO1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhzaGFyZHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfcmVmKSB7XG4gICAgICB2YXIgZmllbGQgPSBfcmVmWzBdLFxuICAgICAgICB2YWx1ZSA9IF9yZWZbMV07XG4gICAgICB2YXIgc2hhcmQgPSBlbmNvZGVTZkRpY3QodmFsdWUsIHtcbiAgICAgICAgd2hpdGVzcGFjZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaWYgKHNoYXJkKSB7XG4gICAgICAgIGFjY1tmaWVsZF0gPSBzaGFyZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgQ01DRCBxdWVyeSBhcmdzIHRvIGEgaGVhZGVyIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGhlYWRlcnMgLSBUaGUgaGVhZGVycyB0byBhcHBlbmQgdG8uXG4gICAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIGFwcGVuZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGUgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGhlYWRlcnMgd2l0aCB0aGUgQ01DRCBoZWFkZXIgc2hhcmRzIGFwcGVuZGVkLlxuICAgKlxuICAgKiBAZ3JvdXAgQ01DRFxuICAgKlxuICAgKiBAYmV0YVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB7QGluY2x1ZGVDb2RlIC4uLy4uL3Rlc3QvY21jZC9hcHBlbmRDbWNkSGVhZGVycy50ZXN0LnRzI2V4YW1wbGV9XG4gICAqL1xuICBmdW5jdGlvbiBhcHBlbmRDbWNkSGVhZGVycyhoZWFkZXJzLCBjbWNkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKGhlYWRlcnMsIHRvQ21jZEhlYWRlcnMoY21jZCwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENNQ0QgcGFyYW1ldGVyIG5hbWUuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICB2YXIgQ01DRF9QQVJBTSA9ICdDTUNEJztcblxuICAvKipcbiAgICogRW5jb2RlIGEgQ01DRCBvYmplY3QgdG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIGVuY29kZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGVuY29kZWQgQ01DRCBzdHJpbmcuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHtAaW5jbHVkZUNvZGUgLi4vLi4vdGVzdC9jbWNkL2VuY29kZUNtY2QudGVzdC50cyNleGFtcGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW5jb2RlQ21jZChjbWNkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIWNtY2QpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZVNmRGljdChwcmVwYXJlQ21jZERhdGEoY21jZCwgb3B0aW9ucyksIHtcbiAgICAgIHdoaXRlc3BhY2U6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gYSBVUkwgZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIGNvbnZlcnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZW5jb2RpbmcgdGhlIENNQ0Qgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgVVJMIGVuY29kZWQgQ01DRCBkYXRhLlxuICAgKlxuICAgKiBAZ3JvdXAgQ01DRFxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgZnVuY3Rpb24gdG9DbWNkVXJsKGNtY2QsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICghY21jZCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgcGFyYW1zID0gZW5jb2RlQ21jZChjbWNkLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gYSBxdWVyeSBhcmcuXG4gICAqXG4gICAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIGNvbnZlcnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZW5jb2RpbmcgdGhlIENNQ0Qgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgQ01DRCBxdWVyeSBhcmcuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHtAaW5jbHVkZUNvZGUgLi4vLi4vdGVzdC9jbWNkL3RvQ21jZFF1ZXJ5LnRlc3QudHMjZXhhbXBsZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRvQ21jZFF1ZXJ5KGNtY2QsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICghY21jZCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSB0b0NtY2RVcmwoY21jZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIENNQ0RfUEFSQU0gKyBcIj1cIiArIHZhbHVlO1xuICB9XG5cbiAgdmFyIFJFR0VYID0gL0NNQ0Q9W14mI10rLztcbiAgLyoqXG4gICAqIEFwcGVuZCBDTUNEIHF1ZXJ5IGFyZ3MgdG8gYSBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGFwcGVuZCB0by5cbiAgICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gYXBwZW5kLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nIHRoZSBDTUNEIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIFVSTCB3aXRoIHRoZSBDTUNEIHF1ZXJ5IGFyZ3MgYXBwZW5kZWQuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHtAaW5jbHVkZUNvZGUgLi4vLi4vdGVzdC9jbWNkL2FwcGVuZENtY2RRdWVyeS50ZXN0LnRzI2V4YW1wbGV9XG4gICAqL1xuICBmdW5jdGlvbiBhcHBlbmRDbWNkUXVlcnkodXJsLCBjbWNkLCBvcHRpb25zKSB7XG4gICAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIFVSTFNlYXJjaFBhcmFtcyBvbmNlIHdlIGRyb3AgU2FmYXJpIDwgMTAuMSAmIENocm9tZSA8IDQ5IHN1cHBvcnQuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTFNlYXJjaFBhcmFtc1xuICAgIHZhciBxdWVyeSA9IHRvQ21jZFF1ZXJ5KGNtY2QsIG9wdGlvbnMpO1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGlmIChSRUdFWC50ZXN0KHVybCkpIHtcbiAgICAgIHJldHVybiB1cmwucmVwbGFjZShSRUdFWCwgcXVlcnkpO1xuICAgIH1cbiAgICB2YXIgc2VwYXJhdG9yID0gdXJsLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyc7XG4gICAgcmV0dXJuIFwiXCIgKyB1cmwgKyBzZXBhcmF0b3IgKyBxdWVyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBDb21tb24gTWVkaWEgQ2xpZW50IERhdGEgKENNQ0QpXG4gICAqIEBzZWUgaHR0cHM6Ly9jZG4uY3RhLnRlY2gvY3RhL21lZGlhL21lZGlhL3Jlc291cmNlcy9zdGFuZGFyZHMvcGRmcy9jdGEtNTAwNC1maW5hbC5wZGZcbiAgICovXG4gIHZhciBDTUNEQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ01DRENvbnRyb2xsZXIoaGxzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgICB0aGlzLnNpZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY2lkID0gdm9pZCAwO1xuICAgICAgdGhpcy51c2VIZWFkZXJzID0gZmFsc2U7XG4gICAgICB0aGlzLmluY2x1ZGVLZXlzID0gdm9pZCAwO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFydmVkID0gZmFsc2U7XG4gICAgICB0aGlzLmJ1ZmZlcmluZyA9IHRydWU7XG4gICAgICB0aGlzLmF1ZGlvQnVmZmVyID0gdm9pZCAwO1xuICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMub25XYWl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5idWZmZXJpbmcgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIHRoaXMub25QbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmJ1ZmZlcmluZyA9IGZhbHNlO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgbWFuaWZlc3QgcmVxdWVzdC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5hcHBseVBsYXlsaXN0RGF0YSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3RoaXMuYXBwbHkoY29udGV4dCwge1xuICAgICAgICAgICAgb3Q6IENtY2RPYmplY3RUeXBlLk1BTklGRVNULFxuICAgICAgICAgICAgc3U6ICFfdGhpcy5pbml0aWFsaXplZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIF90aGlzLmhscy5sb2dnZXIud2FybignQ291bGQgbm90IGdlbmVyYXRlIG1hbmlmZXN0IENNQ0QgZGF0YS4nLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIHNlZ21lbnQgcmVxdWVzdFxuICAgICAgICovXG4gICAgICB0aGlzLmFwcGx5RnJhZ21lbnREYXRhID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgICAgICAgIHBhcnQgPSBjb250ZXh0LnBhcnQ7XG4gICAgICAgICAgdmFyIGxldmVsID0gX3RoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgICB2YXIgb3QgPSBfdGhpcy5nZXRPYmplY3RUeXBlKGZyYWcpO1xuICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgZDogKHBhcnQgfHwgZnJhZykuZHVyYXRpb24gKiAxMDAwLFxuICAgICAgICAgICAgb3Q6IG90XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAob3QgPT09IENtY2RPYmplY3RUeXBlLlZJREVPIHx8IG90ID09PSBDbWNkT2JqZWN0VHlwZS5BVURJTyB8fCBvdCA9PSBDbWNkT2JqZWN0VHlwZS5NVVhFRCkge1xuICAgICAgICAgICAgZGF0YS5iciA9IGxldmVsLmJpdHJhdGUgLyAxMDAwO1xuICAgICAgICAgICAgZGF0YS50YiA9IF90aGlzLmdldFRvcEJhbmR3aWR0aChvdCkgLyAxMDAwO1xuICAgICAgICAgICAgZGF0YS5ibCA9IF90aGlzLmdldEJ1ZmZlckxlbmd0aChvdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXh0ID0gcGFydCA/IF90aGlzLmdldE5leHRQYXJ0KHBhcnQpIDogX3RoaXMuZ2V0TmV4dEZyYWcoZnJhZyk7XG4gICAgICAgICAgaWYgKG5leHQgIT0gbnVsbCAmJiBuZXh0LnVybCAmJiBuZXh0LnVybCAhPT0gZnJhZy51cmwpIHtcbiAgICAgICAgICAgIGRhdGEubm9yID0gbmV4dC51cmw7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIF90aGlzLmhscy5sb2dnZXIud2FybignQ291bGQgbm90IGdlbmVyYXRlIHNlZ21lbnQgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzID0gaGxzO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgIHZhciBjbWNkID0gY29uZmlnLmNtY2Q7XG4gICAgICBpZiAoY21jZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5wTG9hZGVyID0gdGhpcy5jcmVhdGVQbGF5bGlzdExvYWRlcigpO1xuICAgICAgICBjb25maWcuZkxvYWRlciA9IHRoaXMuY3JlYXRlRnJhZ21lbnRMb2FkZXIoKTtcbiAgICAgICAgdGhpcy5zaWQgPSBjbWNkLnNlc3Npb25JZCB8fCBobHMuc2Vzc2lvbklkO1xuICAgICAgICB0aGlzLmNpZCA9IGNtY2QuY29udGVudElkO1xuICAgICAgICB0aGlzLnVzZUhlYWRlcnMgPSBjbWNkLnVzZUhlYWRlcnMgPT09IHRydWU7XG4gICAgICAgIHRoaXMuaW5jbHVkZUtleXMgPSBjbWNkLmluY2x1ZGVLZXlzO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBDTUNEQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMub25NZWRpYURldGFjaGVkKCk7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gdGhpcy5jb25maWcgPSB0aGlzLmF1ZGlvQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm9uV2FpdGluZyA9IHRoaXMub25QbGF5aW5nID0gdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHRoaXMub25XYWl0aW5nKTtcbiAgICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub25QbGF5aW5nKTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoZWQoKSB7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgdGhpcy5vbldhaXRpbmcpO1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vblBsYXlpbmcpO1xuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckNyZWF0ZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfZGF0YSR0cmFja3MkYXVkaW8sIF9kYXRhJHRyYWNrcyR2aWRlbztcbiAgICAgIHRoaXMuYXVkaW9CdWZmZXIgPSAoX2RhdGEkdHJhY2tzJGF1ZGlvID0gZGF0YS50cmFja3MuYXVkaW8pID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSR0cmFja3MkYXVkaW8uYnVmZmVyO1xuICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IChfZGF0YSR0cmFja3MkdmlkZW8gPSBkYXRhLnRyYWNrcy52aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHRyYWNrcyR2aWRlby5idWZmZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYmFzZWxpbmUgQ01DRCBkYXRhXG4gICAgICovXG4gICAgX3Byb3RvLmNyZWF0ZURhdGEgPSBmdW5jdGlvbiBjcmVhdGVEYXRhKCkge1xuICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdjogMSxcbiAgICAgICAgc2Y6IENtY2RTdHJlYW1pbmdGb3JtYXQuSExTLFxuICAgICAgICBzaWQ6IHRoaXMuc2lkLFxuICAgICAgICBjaWQ6IHRoaXMuY2lkLFxuICAgICAgICBwcjogKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhLnBsYXliYWNrUmF0ZSxcbiAgICAgICAgbXRwOiB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSAvIDEwMDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgcmVxdWVzdC5cbiAgICAgKi87XG4gICAgX3Byb3RvLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoY29udGV4dCwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBiYXNlbGluZSBkYXRhXG4gICAgICBfZXh0ZW5kcyhkYXRhLCB0aGlzLmNyZWF0ZURhdGEoKSk7XG4gICAgICB2YXIgaXNWaWRlbyA9IGRhdGEub3QgPT09IENtY2RPYmplY3RUeXBlLklOSVQgfHwgZGF0YS5vdCA9PT0gQ21jZE9iamVjdFR5cGUuVklERU8gfHwgZGF0YS5vdCA9PT0gQ21jZE9iamVjdFR5cGUuTVVYRUQ7XG4gICAgICBpZiAodGhpcy5zdGFydmVkICYmIGlzVmlkZW8pIHtcbiAgICAgICAgZGF0YS5icyA9IHRydWU7XG4gICAgICAgIGRhdGEuc3UgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXJ2ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnN1ID09IG51bGwpIHtcbiAgICAgICAgZGF0YS5zdSA9IHRoaXMuYnVmZmVyaW5nO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgcnRwLCBucnIsIGRsXG5cbiAgICAgIHZhciBpbmNsdWRlS2V5cyA9IHRoaXMuaW5jbHVkZUtleXM7XG4gICAgICBpZiAoaW5jbHVkZUtleXMpIHtcbiAgICAgICAgZGF0YSA9IE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgICBpbmNsdWRlS2V5cy5pbmNsdWRlcyhrZXkpICYmIChhY2Nba2V5XSA9IGRhdGFba2V5XSk7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGJhc2VVcmw6IGNvbnRleHQudXJsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMudXNlSGVhZGVycykge1xuICAgICAgICBpZiAoIWNvbnRleHQuaGVhZGVycykge1xuICAgICAgICAgIGNvbnRleHQuaGVhZGVycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZENtY2RIZWFkZXJzKGNvbnRleHQuaGVhZGVycywgZGF0YSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnVybCA9IGFwcGVuZENtY2RRdWVyeShjb250ZXh0LnVybCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TmV4dEZyYWcgPSBmdW5jdGlvbiBnZXROZXh0RnJhZyhmcmFnbWVudCkge1xuICAgICAgdmFyIF90aGlzJGhscyRsZXZlbHMkZnJhZztcbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSAoX3RoaXMkaGxzJGxldmVscyRmcmFnID0gdGhpcy5obHMubGV2ZWxzW2ZyYWdtZW50LmxldmVsXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscyRsZXZlbHMkZnJhZy5kZXRhaWxzO1xuICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICB2YXIgaW5kZXggPSBmcmFnbWVudC5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tpbmRleCArIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIF9wcm90by5nZXROZXh0UGFydCA9IGZ1bmN0aW9uIGdldE5leHRQYXJ0KHBhcnQpIHtcbiAgICAgIHZhciBfdGhpcyRobHMkbGV2ZWxzJGZyYWcyO1xuICAgICAgdmFyIGluZGV4ID0gcGFydC5pbmRleCxcbiAgICAgICAgZnJhZ21lbnQgPSBwYXJ0LmZyYWdtZW50O1xuICAgICAgdmFyIHBhcnRMaXN0ID0gKF90aGlzJGhscyRsZXZlbHMkZnJhZzIgPSB0aGlzLmhscy5sZXZlbHNbZnJhZ21lbnQubGV2ZWxdKSA9PSBudWxsIHx8IChfdGhpcyRobHMkbGV2ZWxzJGZyYWcyID0gX3RoaXMkaGxzJGxldmVscyRmcmFnMi5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzJGxldmVscyRmcmFnMi5wYXJ0TGlzdDtcbiAgICAgIGlmIChwYXJ0TGlzdCkge1xuICAgICAgICB2YXIgc24gPSBmcmFnbWVudC5zbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhcnRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIHAgPSBwYXJ0TGlzdFtpXTtcbiAgICAgICAgICBpZiAocC5pbmRleCA9PT0gaW5kZXggJiYgcC5mcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0TGlzdFtpICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBDTUNEIG9iamVjdCB0eXBlLlxuICAgICAqLztcbiAgICBfcHJvdG8uZ2V0T2JqZWN0VHlwZSA9IGZ1bmN0aW9uIGdldE9iamVjdFR5cGUoZnJhZ21lbnQpIHtcbiAgICAgIHZhciB0eXBlID0gZnJhZ21lbnQudHlwZTtcbiAgICAgIGlmICh0eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICAgIHJldHVybiBDbWNkT2JqZWN0VHlwZS5USU1FRF9URVhUO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdtZW50LnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHJldHVybiBDbWNkT2JqZWN0VHlwZS5JTklUO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmV0dXJuIENtY2RPYmplY3RUeXBlLkFVRElPO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdtYWluJykge1xuICAgICAgICBpZiAoIXRoaXMuaGxzLmF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBDbWNkT2JqZWN0VHlwZS5NVVhFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ21jZE9iamVjdFR5cGUuVklERU87XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGlnaGVzdCBiaXRyYXRlLlxuICAgICAqLztcbiAgICBfcHJvdG8uZ2V0VG9wQmFuZHdpZHRoID0gZnVuY3Rpb24gZ2V0VG9wQmFuZHdpZHRoKHR5cGUpIHtcbiAgICAgIHZhciBiaXRyYXRlID0gMDtcbiAgICAgIHZhciBsZXZlbHM7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAodHlwZSA9PT0gQ21jZE9iamVjdFR5cGUuQVVESU8pIHtcbiAgICAgICAgbGV2ZWxzID0gaGxzLmF1ZGlvVHJhY2tzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heCA9IGhscy5tYXhBdXRvTGV2ZWw7XG4gICAgICAgIHZhciBsZW4gPSBtYXggPiAtMSA/IG1heCArIDEgOiBobHMubGV2ZWxzLmxlbmd0aDtcbiAgICAgICAgbGV2ZWxzID0gaGxzLmxldmVscy5zbGljZSgwLCBsZW4pO1xuICAgICAgfVxuICAgICAgbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbC5iaXRyYXRlID4gYml0cmF0ZSkge1xuICAgICAgICAgIGJpdHJhdGUgPSBsZXZlbC5iaXRyYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiaXRyYXRlID4gMCA/IGJpdHJhdGUgOiBOYU47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBidWZmZXIgbGVuZ3RoIGZvciBhIG1lZGlhIHR5cGUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovO1xuICAgIF9wcm90by5nZXRCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiBnZXRCdWZmZXJMZW5ndGgodHlwZSkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIHZhciBidWZmZXIgPSB0eXBlID09PSBDbWNkT2JqZWN0VHlwZS5BVURJTyA/IHRoaXMuYXVkaW9CdWZmZXIgOiB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgaWYgKCFidWZmZXIgfHwgIW1lZGlhKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG4gICAgICB2YXIgaW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlciwgbWVkaWEuY3VycmVudFRpbWUsIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgcmV0dXJuIGluZm8ubGVuICogMTAwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICAgKi87XG4gICAgX3Byb3RvLmNyZWF0ZVBsYXlsaXN0TG9hZGVyID0gZnVuY3Rpb24gY3JlYXRlUGxheWxpc3RMb2FkZXIoKSB7XG4gICAgICB2YXIgcExvYWRlciA9IHRoaXMuY29uZmlnLnBMb2FkZXI7XG4gICAgICB2YXIgYXBwbHkgPSB0aGlzLmFwcGx5UGxheWxpc3REYXRhO1xuICAgICAgdmFyIEN0b3IgPSBwTG9hZGVyIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDbWNkUGxheWxpc3RMb2FkZXIoY29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDA7XG4gICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgQ3Rvcihjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfcHJvdG8yID0gQ21jZFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZTtcbiAgICAgICAgX3Byb3RvMi5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgICAgIF9wcm90bzIuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9O1xuICAgICAgICBfcHJvdG8yLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgYXBwbHkoY29udGV4dCk7XG4gICAgICAgICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQ21jZFBsYXlsaXN0TG9hZGVyLCBbe1xuICAgICAgICAgIGtleTogXCJzdGF0c1wiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjb250ZXh0XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuY29udGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICAgKi87XG4gICAgX3Byb3RvLmNyZWF0ZUZyYWdtZW50TG9hZGVyID0gZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRMb2FkZXIoKSB7XG4gICAgICB2YXIgZkxvYWRlciA9IHRoaXMuY29uZmlnLmZMb2FkZXI7XG4gICAgICB2YXIgYXBwbHkgPSB0aGlzLmFwcGx5RnJhZ21lbnREYXRhO1xuICAgICAgdmFyIEN0b3IgPSBmTG9hZGVyIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDbWNkRnJhZ21lbnRMb2FkZXIoY29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDA7XG4gICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgQ3Rvcihjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfcHJvdG8zID0gQ21jZEZyYWdtZW50TG9hZGVyLnByb3RvdHlwZTtcbiAgICAgICAgX3Byb3RvMy5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgICAgIF9wcm90bzMuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9O1xuICAgICAgICBfcHJvdG8zLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgYXBwbHkoY29udGV4dCk7XG4gICAgICAgICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoQ21jZEZyYWdtZW50TG9hZGVyLCBbe1xuICAgICAgICAgIGtleTogXCJzdGF0c1wiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGtleTogXCJjb250ZXh0XCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuY29udGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgIH0oKTtcbiAgICB9O1xuICAgIHJldHVybiBDTUNEQ29udHJvbGxlcjtcbiAgfSgpO1xuXG4gIHZhciBQQVRIV0FZX1BFTkFMVFlfRFVSQVRJT05fTVMgPSAzMDAwMDA7XG4gIHZhciBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9nZ2VyKSB7XG4gICAgZnVuY3Rpb24gQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcihobHMpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX0xvZ2dlci5jYWxsKHRoaXMsICdjb250ZW50LXN0ZWVyaW5nJywgaGxzLmxvZ2dlcikgfHwgdGhpcztcbiAgICAgIF90aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIF90aGlzLmxvYWRlciA9IG51bGw7XG4gICAgICBfdGhpcy51cmkgPSBudWxsO1xuICAgICAgX3RoaXMucGF0aHdheUlkID0gJy4nO1xuICAgICAgX3RoaXMuX3BhdGh3YXlQcmlvcml0eSA9IG51bGw7XG4gICAgICBfdGhpcy50aW1lVG9Mb2FkID0gMzAwO1xuICAgICAgX3RoaXMucmVsb2FkVGltZXIgPSAtMTtcbiAgICAgIF90aGlzLnVwZGF0ZWQgPSAwO1xuICAgICAgX3RoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICBfdGhpcy5sZXZlbHMgPSBudWxsO1xuICAgICAgX3RoaXMuYXVkaW9UcmFja3MgPSBudWxsO1xuICAgICAgX3RoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICAgICAgX3RoaXMucGVuYWxpemVkUGF0aHdheXMgPSB7fTtcbiAgICAgIF90aGlzLmhscyA9IGhscztcbiAgICAgIF90aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIsIF9Mb2dnZXIpO1xuICAgIHZhciBfcHJvdG8gPSBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmICghaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ucGF0aHdheXMgPSBmdW5jdGlvbiBwYXRod2F5cygpIHtcbiAgICAgIHJldHVybiAodGhpcy5sZXZlbHMgfHwgW10pLnJlZHVjZShmdW5jdGlvbiAocGF0aHdheXMsIGxldmVsKSB7XG4gICAgICAgIGlmIChwYXRod2F5cy5pbmRleE9mKGxldmVsLnBhdGh3YXlJZCkgPT09IC0xKSB7XG4gICAgICAgICAgcGF0aHdheXMucHVzaChsZXZlbC5wYXRod2F5SWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRod2F5cztcbiAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgdGhpcy51cmkpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlZCkge1xuICAgICAgICAgIHZhciB0dGwgPSB0aGlzLnRpbWVUb0xvYWQgKiAxMDAwIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy51cGRhdGVkKTtcbiAgICAgICAgICBpZiAodHRsID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmksIHR0bCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZFN0ZWVyaW5nTWFuaWZlc3QodGhpcy51cmkpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gY2xlYXJUaW1lb3V0KCkge1xuICAgICAgaWYgKHRoaXMucmVsb2FkVGltZXIgIT09IC0xKSB7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkVGltZXIpO1xuICAgICAgICB0aGlzLnJlbG9hZFRpbWVyID0gLTE7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUxldmVsID0gZnVuY3Rpb24gcmVtb3ZlTGV2ZWwobGV2ZWxUb1JlbW92ZSkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgaWYgKGxldmVscykge1xuICAgICAgICB0aGlzLmxldmVscyA9IGxldmVscy5maWx0ZXIoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGxldmVsICE9PSBsZXZlbFRvUmVtb3ZlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudGltZVRvTG9hZCA9IDMwMDtcbiAgICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgICB0aGlzLnVyaSA9IG51bGw7XG4gICAgICB0aGlzLnBhdGh3YXlJZCA9ICcuJztcbiAgICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgY29udGVudFN0ZWVyaW5nID0gZGF0YS5jb250ZW50U3RlZXJpbmc7XG4gICAgICBpZiAoY29udGVudFN0ZWVyaW5nID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGF0aHdheUlkID0gY29udGVudFN0ZWVyaW5nLnBhdGh3YXlJZDtcbiAgICAgIHRoaXMudXJpID0gY29udGVudFN0ZWVyaW5nLnVyaTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5zdGFydExvYWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5hdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICAgIGlmICgoZXJyb3JBY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yQWN0aW9uLmFjdGlvbikgPT09IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94ICYmIGVycm9yQWN0aW9uLmZsYWdzID09PSBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0KSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICAgICAgdmFyIHBhdGh3YXlQcmlvcml0eSA9IHRoaXMuX3BhdGh3YXlQcmlvcml0eTtcbiAgICAgICAgdmFyIGVycm9yUGF0aHdheSA9IHRoaXMucGF0aHdheUlkO1xuICAgICAgICBpZiAoZGF0YS5jb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF9kYXRhJGNvbnRleHQgPSBkYXRhLmNvbnRleHQsXG4gICAgICAgICAgICBncm91cElkID0gX2RhdGEkY29udGV4dC5ncm91cElkLFxuICAgICAgICAgICAgcGF0aHdheUlkID0gX2RhdGEkY29udGV4dC5wYXRod2F5SWQsXG4gICAgICAgICAgICB0eXBlID0gX2RhdGEkY29udGV4dC50eXBlO1xuICAgICAgICAgIGlmIChncm91cElkICYmIGxldmVscykge1xuICAgICAgICAgICAgZXJyb3JQYXRod2F5ID0gdGhpcy5nZXRQYXRod2F5Rm9yR3JvdXBJZChncm91cElkLCB0eXBlLCBlcnJvclBhdGh3YXkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGF0aHdheUlkKSB7XG4gICAgICAgICAgICBlcnJvclBhdGh3YXkgPSBwYXRod2F5SWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKGVycm9yUGF0aHdheSBpbiB0aGlzLnBlbmFsaXplZFBhdGh3YXlzKSkge1xuICAgICAgICAgIHRoaXMucGVuYWxpemVkUGF0aHdheXNbZXJyb3JQYXRod2F5XSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0aHdheVByaW9yaXR5ICYmIGxldmVscykge1xuICAgICAgICAgIC8vIElmIFBBVEhXQVktUFJJT1JJVFkgd2FzIG5vdCBwcm92aWRlZCwgbGlzdCBwYXRod2F5cyBmb3IgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICBwYXRod2F5UHJpb3JpdHkgPSB0aGlzLnBhdGh3YXlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGh3YXlQcmlvcml0eSAmJiBwYXRod2F5UHJpb3JpdHkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSk7XG4gICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0aGlzLnBhdGh3YXlJZCAhPT0gZXJyb3JQYXRod2F5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SICYmICFkYXRhLmZhdGFsKSB7XG4gICAgICAgICAgLy8gRXJyb3Igd2lsbCBiZWNvbWUgZmF0YWwgaW4gYnVmZmVyLWNvbnRyb2xsZXIgd2hlbiByZWFjaGluZyBgYXBwZW5kRXJyb3JNYXhSZXRyeWBcbiAgICAgICAgICAvLyBTdHJlYW0tY29udHJvbGxlcnMgYXJlIGV4cGVjdGVkIHRvIHJlZHVjZSBidWZmZXIgbGVuZ3RoIGV2ZW4gaWYgdGhpcyBpcyBub3QgZGVlbWVkIGEgUXVvdGFFeGNlZWRlZEVycm9yXG4gICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFlcnJvckFjdGlvbi5yZXNvbHZlZCkge1xuICAgICAgICAgIHRoaXMud2FybihcIkNvdWxkIG5vdCByZXNvbHZlIFwiICsgZGF0YS5kZXRhaWxzICsgXCIgKFxcXCJcIiArIGRhdGEuZXJyb3IubWVzc2FnZSArIFwiXFxcIikgd2l0aCBjb250ZW50LXN0ZWVyaW5nIGZvciBQYXRod2F5OiBcIiArIGVycm9yUGF0aHdheSArIFwiIGxldmVsczogXCIgKyAobGV2ZWxzID8gbGV2ZWxzLmxlbmd0aCA6IGxldmVscykgKyBcIiBwcmlvcml0aWVzOiBcIiArIHN0cmluZ2lmeShwYXRod2F5UHJpb3JpdHkpICsgXCIgcGVuYWxpemVkOiBcIiArIHN0cmluZ2lmeSh0aGlzLnBlbmFsaXplZFBhdGh3YXlzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5maWx0ZXJQYXJzZWRMZXZlbHMgPSBmdW5jdGlvbiBmaWx0ZXJQYXJzZWRMZXZlbHMobGV2ZWxzKSB7XG4gICAgICAvLyBGaWx0ZXIgbGV2ZWxzIHRvIG9ubHkgaW5jbHVkZSB0aG9zZSB0aGF0IGFyZSBpbiB0aGUgaW5pdGlhbCBwYXRod2F5XG4gICAgICB0aGlzLmxldmVscyA9IGxldmVscztcbiAgICAgIHZhciBwYXRod2F5TGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHRoaXMucGF0aHdheUlkKTtcbiAgICAgIGlmIChwYXRod2F5TGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgcGF0aHdheUlkID0gbGV2ZWxzWzBdLnBhdGh3YXlJZDtcbiAgICAgICAgdGhpcy5sb2coXCJObyBsZXZlbHMgZm91bmQgaW4gUGF0aHdheSBcIiArIHRoaXMucGF0aHdheUlkICsgXCIuIFNldHRpbmcgaW5pdGlhbCBQYXRod2F5IHRvIFxcXCJcIiArIHBhdGh3YXlJZCArIFwiXFxcIlwiKTtcbiAgICAgICAgcGF0aHdheUxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShwYXRod2F5SWQpO1xuICAgICAgICB0aGlzLnBhdGh3YXlJZCA9IHBhdGh3YXlJZDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRod2F5TGV2ZWxzLmxlbmd0aCAhPT0gbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxvZyhcIkZvdW5kIFwiICsgcGF0aHdheUxldmVscy5sZW5ndGggKyBcIi9cIiArIGxldmVscy5sZW5ndGggKyBcIiBsZXZlbHMgaW4gUGF0aHdheSBcXFwiXCIgKyB0aGlzLnBhdGh3YXlJZCArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRod2F5TGV2ZWxzO1xuICAgIH07XG4gICAgX3Byb3RvLmdldExldmVsc0ZvclBhdGh3YXkgPSBmdW5jdGlvbiBnZXRMZXZlbHNGb3JQYXRod2F5KHBhdGh3YXlJZCkge1xuICAgICAgaWYgKHRoaXMubGV2ZWxzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxldmVscy5maWx0ZXIoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIHJldHVybiBwYXRod2F5SWQgPT09IGxldmVsLnBhdGh3YXlJZDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVwZGF0ZVBhdGh3YXlQcmlvcml0eSA9IGZ1bmN0aW9uIHVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpIHtcbiAgICAgIHRoaXMuX3BhdGh3YXlQcmlvcml0eSA9IHBhdGh3YXlQcmlvcml0eTtcbiAgICAgIHZhciBsZXZlbHM7XG5cbiAgICAgIC8vIEV2YWx1YXRlIGlmIHdlIHNob3VsZCByZW1vdmUgdGhlIHBhdGh3YXkgZnJvbSB0aGUgcGVuYWxpemVkIGxpc3RcbiAgICAgIHZhciBwZW5hbGl6ZWRQYXRod2F5cyA9IHRoaXMucGVuYWxpemVkUGF0aHdheXM7XG4gICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBPYmplY3Qua2V5cyhwZW5hbGl6ZWRQYXRod2F5cykuZm9yRWFjaChmdW5jdGlvbiAocGF0aHdheUlkKSB7XG4gICAgICAgIGlmIChub3cgLSBwZW5hbGl6ZWRQYXRod2F5c1twYXRod2F5SWRdID4gUEFUSFdBWV9QRU5BTFRZX0RVUkFUSU9OX01TKSB7XG4gICAgICAgICAgZGVsZXRlIHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRod2F5UHJpb3JpdHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGh3YXlJZCA9IHBhdGh3YXlQcmlvcml0eVtpXTtcbiAgICAgICAgaWYgKHBhdGh3YXlJZCBpbiBwZW5hbGl6ZWRQYXRod2F5cykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRod2F5SWQgPT09IHRoaXMucGF0aHdheUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgICAgdmFyIHNlbGVjdGVkTGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIGxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShwYXRod2F5SWQpO1xuICAgICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmxvZyhcIlNldHRpbmcgUGF0aHdheSB0byBcXFwiXCIgKyBwYXRod2F5SWQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgdGhpcy5wYXRod2F5SWQgPSBwYXRod2F5SWQ7XG4gICAgICAgICAgcmVhc3NpZ25GcmFnbWVudExldmVsSW5kZXhlcyhsZXZlbHMpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMU19VUERBVEVELCB7XG4gICAgICAgICAgICBsZXZlbHM6IGxldmVsc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFNldCBMZXZlbENvbnRyb2xsZXIncyBsZXZlbCB0byB0cmlnZ2VyIExFVkVMX1NXSVRDSElORyB3aGljaCBsb2FkcyBwbGF5bGlzdCBpZiBuZWVkZWRcbiAgICAgICAgICB2YXIgbGV2ZWxBZnRlckNoYW5nZSA9IHRoaXMuaGxzLmxldmVsc1tzZWxlY3RlZEluZGV4XTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRMZXZlbCAmJiBsZXZlbEFmdGVyQ2hhbmdlICYmIHRoaXMubGV2ZWxzKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWxBZnRlckNoYW5nZS5hdHRyc1snU1RBQkxFLVZBUklBTlQtSUQnXSAhPT0gc2VsZWN0ZWRMZXZlbC5hdHRyc1snU1RBQkxFLVZBUklBTlQtSUQnXSAmJiBsZXZlbEFmdGVyQ2hhbmdlLmJpdHJhdGUgIT09IHNlbGVjdGVkTGV2ZWwuYml0cmF0ZSkge1xuICAgICAgICAgICAgICB0aGlzLmxvZyhcIlVuc3RhYmxlIFBhdGh3YXlzIGNoYW5nZSBmcm9tIGJpdHJhdGUgXCIgKyBzZWxlY3RlZExldmVsLmJpdHJhdGUgKyBcIiB0byBcIiArIGxldmVsQWZ0ZXJDaGFuZ2UuYml0cmF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZXRQYXRod2F5Rm9yR3JvdXBJZCA9IGZ1bmN0aW9uIGdldFBhdGh3YXlGb3JHcm91cElkKGdyb3VwSWQsIHR5cGUsIGRlZmF1bHRQYXRod2F5KSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KGRlZmF1bHRQYXRod2F5KS5jb25jYXQodGhpcy5sZXZlbHMgfHwgW10pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgbGV2ZWxzW2ldLmhhc0F1ZGlvR3JvdXAoZ3JvdXBJZCkgfHwgdHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBsZXZlbHNbaV0uaGFzU3VidGl0bGVHcm91cChncm91cElkKSkge1xuICAgICAgICAgIHJldHVybiBsZXZlbHNbaV0ucGF0aHdheUlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmYXVsdFBhdGh3YXk7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmVQYXRod2F5cyA9IGZ1bmN0aW9uIGNsb25lUGF0aHdheXMocGF0aHdheUNsb25lcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXVkaW9Hcm91cENsb25lTWFwID0ge307XG4gICAgICB2YXIgc3VidGl0bGVHcm91cENsb25lTWFwID0ge307XG4gICAgICBwYXRod2F5Q2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhdGh3YXlDbG9uZSkge1xuICAgICAgICB2YXIgY2xvbmVJZCA9IHBhdGh3YXlDbG9uZS5JRCxcbiAgICAgICAgICBiYXNlSWQgPSBwYXRod2F5Q2xvbmVbJ0JBU0UtSUQnXSxcbiAgICAgICAgICB1cmlSZXBsYWNlbWVudCA9IHBhdGh3YXlDbG9uZVsnVVJJLVJFUExBQ0VNRU5UJ107XG4gICAgICAgIGlmIChsZXZlbHMuc29tZShmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICByZXR1cm4gbGV2ZWwucGF0aHdheUlkID09PSBjbG9uZUlkO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xvbmVkVmFyaWFudHMgPSBfdGhpczIuZ2V0TGV2ZWxzRm9yUGF0aHdheShiYXNlSWQpLm1hcChmdW5jdGlvbiAoYmFzZUxldmVsKSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYmFzZUxldmVsLmF0dHJzKTtcbiAgICAgICAgICBhdHRyaWJ1dGVzWydQQVRIV0FZLUlEJ10gPSBjbG9uZUlkO1xuICAgICAgICAgIHZhciBjbG9uZWRBdWRpb0dyb3VwSWQgPSBhdHRyaWJ1dGVzLkFVRElPICYmIGF0dHJpYnV0ZXMuQVVESU8gKyBcIl9jbG9uZV9cIiArIGNsb25lSWQ7XG4gICAgICAgICAgdmFyIGNsb25lZFN1YnRpdGxlR3JvdXBJZCA9IGF0dHJpYnV0ZXMuU1VCVElUTEVTICYmIGF0dHJpYnV0ZXMuU1VCVElUTEVTICsgXCJfY2xvbmVfXCIgKyBjbG9uZUlkO1xuICAgICAgICAgIGlmIChjbG9uZWRBdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICAgIGF1ZGlvR3JvdXBDbG9uZU1hcFthdHRyaWJ1dGVzLkFVRElPXSA9IGNsb25lZEF1ZGlvR3JvdXBJZDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuQVVESU8gPSBjbG9uZWRBdWRpb0dyb3VwSWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbG9uZWRTdWJ0aXRsZUdyb3VwSWQpIHtcbiAgICAgICAgICAgIHN1YnRpdGxlR3JvdXBDbG9uZU1hcFthdHRyaWJ1dGVzLlNVQlRJVExFU10gPSBjbG9uZWRTdWJ0aXRsZUdyb3VwSWQ7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLlNVQlRJVExFUyA9IGNsb25lZFN1YnRpdGxlR3JvdXBJZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVybCA9IHBlcmZvcm1VcmlSZXBsYWNlbWVudChiYXNlTGV2ZWwudXJpLCBhdHRyaWJ1dGVzWydTVEFCTEUtVkFSSUFOVC1JRCddLCAnUEVSLVZBUklBTlQtVVJJUycsIHVyaVJlcGxhY2VtZW50KTtcbiAgICAgICAgICB2YXIgY2xvbmVkTGV2ZWwgPSBuZXcgTGV2ZWwoe1xuICAgICAgICAgICAgYXR0cnM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBhdWRpb0NvZGVjOiBiYXNlTGV2ZWwuYXVkaW9Db2RlYyxcbiAgICAgICAgICAgIGJpdHJhdGU6IGJhc2VMZXZlbC5iaXRyYXRlLFxuICAgICAgICAgICAgaGVpZ2h0OiBiYXNlTGV2ZWwuaGVpZ2h0LFxuICAgICAgICAgICAgbmFtZTogYmFzZUxldmVsLm5hbWUsXG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIHZpZGVvQ29kZWM6IGJhc2VMZXZlbC52aWRlb0NvZGVjLFxuICAgICAgICAgICAgd2lkdGg6IGJhc2VMZXZlbC53aWR0aFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChiYXNlTGV2ZWwuYXVkaW9Hcm91cHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmFzZUxldmVsLmF1ZGlvR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNsb25lZExldmVsLmFkZEdyb3VwSWQoJ2F1ZGlvJywgYmFzZUxldmVsLmF1ZGlvR3JvdXBzW2ldICsgXCJfY2xvbmVfXCIgKyBjbG9uZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJhc2VMZXZlbC5zdWJ0aXRsZUdyb3Vwcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGJhc2VMZXZlbC5zdWJ0aXRsZUdyb3Vwcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgY2xvbmVkTGV2ZWwuYWRkR3JvdXBJZCgndGV4dCcsIGJhc2VMZXZlbC5zdWJ0aXRsZUdyb3Vwc1tfaV0gKyBcIl9jbG9uZV9cIiArIGNsb25lSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2xvbmVkTGV2ZWw7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXZlbHMucHVzaC5hcHBseShsZXZlbHMsIGNsb25lZFZhcmlhbnRzKTtcbiAgICAgICAgY2xvbmVSZW5kaXRpb25Hcm91cHMoX3RoaXMyLmF1ZGlvVHJhY2tzLCBhdWRpb0dyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKTtcbiAgICAgICAgY2xvbmVSZW5kaXRpb25Hcm91cHMoX3RoaXMyLnN1YnRpdGxlVHJhY2tzLCBzdWJ0aXRsZUdyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRTdGVlcmluZ01hbmlmZXN0ID0gZnVuY3Rpb24gbG9hZFN0ZWVyaW5nTWFuaWZlc3QodXJpKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICB2YXIgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICAgIHZhciB1cmw7XG4gICAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgc2VsZi5VUkwodXJpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBTdGVlcmluZyBNYW5pZmVzdCBVUkk6IFwiICsgdXJpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2RhdGE6Jykge1xuICAgICAgICB2YXIgdGhyb3VnaHB1dCA9ICh0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSB8fCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkgfCAwO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXRod2F5JywgdGhpcy5wYXRod2F5SWQpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU190aHJvdWdocHV0JywgJycgKyB0aHJvdWdocHV0KTtcbiAgICAgIH1cbiAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgdXJsOiB1cmwuaHJlZlxuICAgICAgfTtcbiAgICAgIHZhciBsb2FkUG9saWN5ID0gY29uZmlnLnN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICB2YXIgbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5ID0gbG9hZFBvbGljeS5lcnJvclJldHJ5IHx8IGxvYWRQb2xpY3kudGltZW91dFJldHJ5IHx8IHt9O1xuICAgICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgbG9hZFBvbGljeTogbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heE51bVJldHJ5IHx8IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5yZXRyeURlbGF5TXMgfHwgMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgICB9O1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHtcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIF90aGlzMy5sb2coXCJMb2FkZWQgc3RlZXJpbmcgbWFuaWZlc3Q6IFxcXCJcIiArIHVybCArIFwiXFxcIlwiKTtcbiAgICAgICAgICB2YXIgc3RlZXJpbmdEYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICBpZiAoKHN0ZWVyaW5nRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3RlZXJpbmdEYXRhLlZFUlNJT04pICE9PSAxKSB7XG4gICAgICAgICAgICBfdGhpczMubG9nKFwiU3RlZXJpbmcgVkVSU0lPTiBcIiArIHN0ZWVyaW5nRGF0YS5WRVJTSU9OICsgXCIgbm90IHN1cHBvcnRlZCFcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMy51cGRhdGVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgX3RoaXMzLnRpbWVUb0xvYWQgPSBzdGVlcmluZ0RhdGEuVFRMO1xuICAgICAgICAgIHZhciByZWxvYWRVcmkgPSBzdGVlcmluZ0RhdGFbJ1JFTE9BRC1VUkknXSxcbiAgICAgICAgICAgIHBhdGh3YXlDbG9uZXMgPSBzdGVlcmluZ0RhdGFbJ1BBVEhXQVktQ0xPTkVTJ10sXG4gICAgICAgICAgICBwYXRod2F5UHJpb3JpdHkgPSBzdGVlcmluZ0RhdGFbJ1BBVEhXQVktUFJJT1JJVFknXTtcbiAgICAgICAgICBpZiAocmVsb2FkVXJpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBfdGhpczMudXJpID0gbmV3IHNlbGYuVVJMKHJlbG9hZFVyaSwgdXJsKS5ocmVmO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXMzLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBTdGVlcmluZyBNYW5pZmVzdCBSRUxPQUQtVVJJOiBcIiArIHJlbG9hZFVyaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMzLnNjaGVkdWxlUmVmcmVzaChfdGhpczMudXJpIHx8IGNvbnRleHQudXJsKTtcbiAgICAgICAgICBpZiAocGF0aHdheUNsb25lcykge1xuICAgICAgICAgICAgX3RoaXMzLmNsb25lUGF0aHdheXMocGF0aHdheUNsb25lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsb2FkZWRTdGVlcmluZ0RhdGEgPSB7XG4gICAgICAgICAgICBzdGVlcmluZ01hbmlmZXN0OiBzdGVlcmluZ0RhdGEsXG4gICAgICAgICAgICB1cmw6IHVybC50b1N0cmluZygpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdGhpczMuaGxzLnRyaWdnZXIoRXZlbnRzLlNURUVSSU5HX01BTklGRVNUX0xPQURFRCwgbG9hZGVkU3RlZXJpbmdEYXRhKTtcbiAgICAgICAgICBpZiAocGF0aHdheVByaW9yaXR5KSB7XG4gICAgICAgICAgICBfdGhpczMudXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpIHtcbiAgICAgICAgICBfdGhpczMubG9nKFwiRXJyb3IgbG9hZGluZyBzdGVlcmluZyBtYW5pZmVzdDogXCIgKyBlcnJvci5jb2RlICsgXCIgXCIgKyBlcnJvci50ZXh0ICsgXCIgKFwiICsgY29udGV4dC51cmwgKyBcIilcIik7XG4gICAgICAgICAgX3RoaXMzLnN0b3BMb2FkKCk7XG4gICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQxMCkge1xuICAgICAgICAgICAgX3RoaXMzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzMy5sb2coXCJTdGVlcmluZyBtYW5pZmVzdCBcIiArIGNvbnRleHQudXJsICsgXCIgbm8gbG9uZ2VyIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHR0bCA9IF90aGlzMy50aW1lVG9Mb2FkICogMTAwMDtcbiAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gX3RoaXMzLmxvYWRlcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGxvYWRlciA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB2YXIgcmV0cnlBZnRlciA9IGxvYWRlci5nZXRSZXNwb25zZUhlYWRlcignUmV0cnktQWZ0ZXInKTtcbiAgICAgICAgICAgICAgaWYgKHJldHJ5QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICB0dGwgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXIpICogMTAwMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMzLmxvZyhcIlN0ZWVyaW5nIG1hbmlmZXN0IFwiICsgY29udGV4dC51cmwgKyBcIiByYXRlIGxpbWl0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMy5zY2hlZHVsZVJlZnJlc2goX3RoaXMzLnVyaSB8fCBjb250ZXh0LnVybCwgdHRsKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiBmdW5jdGlvbiBvblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMzLmxvZyhcIlRpbWVvdXQgbG9hZGluZyBzdGVlcmluZyBtYW5pZmVzdCAoXCIgKyBjb250ZXh0LnVybCArIFwiKVwiKTtcbiAgICAgICAgICBfdGhpczMuc2NoZWR1bGVSZWZyZXNoKF90aGlzMy51cmkgfHwgY29udGV4dC51cmwpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coXCJSZXF1ZXN0aW5nIHN0ZWVyaW5nIG1hbmlmZXN0OiBcIiArIHVybCk7XG4gICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICB9O1xuICAgIF9wcm90by5zY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiBzY2hlZHVsZVJlZnJlc2godXJpLCB0dGxNcykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBpZiAodHRsTXMgPT09IHZvaWQgMCkge1xuICAgICAgICB0dGxNcyA9IHRoaXMudGltZVRvTG9hZCAqIDEwMDA7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgdGhpcy5yZWxvYWRUaW1lciA9IHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpczQkaGxzO1xuICAgICAgICB2YXIgbWVkaWEgPSAoX3RoaXM0JGhscyA9IF90aGlzNC5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpczQkaGxzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWEgJiYgIW1lZGlhLmVuZGVkKSB7XG4gICAgICAgICAgX3RoaXM0LmxvYWRTdGVlcmluZ01hbmlmZXN0KHVyaSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzNC5zY2hlZHVsZVJlZnJlc2godXJpLCBfdGhpczQudGltZVRvTG9hZCAqIDEwMDApO1xuICAgICAgfSwgdHRsTXMpO1xuICAgIH07XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDb250ZW50U3RlZXJpbmdDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcInBhdGh3YXlQcmlvcml0eVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRod2F5UHJpb3JpdHk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocGF0aHdheVByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KExvZ2dlcik7XG4gIGZ1bmN0aW9uIGNsb25lUmVuZGl0aW9uR3JvdXBzKHRyYWNrcywgZ3JvdXBDbG9uZU1hcCwgdXJpUmVwbGFjZW1lbnQsIGNsb25lSWQpIHtcbiAgICBpZiAoIXRyYWNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhncm91cENsb25lTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChhdWRpb0dyb3VwSWQpIHtcbiAgICAgIHZhciBjbG9uZWRUcmFja3MgPSB0cmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gdHJhY2suZ3JvdXBJZCA9PT0gYXVkaW9Hcm91cElkO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB2YXIgY2xvbmVkVHJhY2sgPSBfZXh0ZW5kcyh7fSwgdHJhY2spO1xuICAgICAgICBjbG9uZWRUcmFjay5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICBjbG9uZWRUcmFjay5hdHRycyA9IG5ldyBBdHRyTGlzdChjbG9uZWRUcmFjay5hdHRycyk7XG4gICAgICAgIGNsb25lZFRyYWNrLnVybCA9IGNsb25lZFRyYWNrLmF0dHJzLlVSSSA9IHBlcmZvcm1VcmlSZXBsYWNlbWVudCh0cmFjay51cmwsIHRyYWNrLmF0dHJzWydTVEFCTEUtUkVORElUSU9OLUlEJ10sICdQRVItUkVORElUSU9OLVVSSVMnLCB1cmlSZXBsYWNlbWVudCk7XG4gICAgICAgIGNsb25lZFRyYWNrLmdyb3VwSWQgPSBjbG9uZWRUcmFjay5hdHRyc1snR1JPVVAtSUQnXSA9IGdyb3VwQ2xvbmVNYXBbYXVkaW9Hcm91cElkXTtcbiAgICAgICAgY2xvbmVkVHJhY2suYXR0cnNbJ1BBVEhXQVktSUQnXSA9IGNsb25lSWQ7XG4gICAgICAgIHJldHVybiBjbG9uZWRUcmFjaztcbiAgICAgIH0pO1xuICAgICAgdHJhY2tzLnB1c2guYXBwbHkodHJhY2tzLCBjbG9uZWRUcmFja3MpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHBlcmZvcm1VcmlSZXBsYWNlbWVudCh1cmksIHN0YWJsZUlkLCBwZXJPcHRpb25LZXksIHVyaVJlcGxhY2VtZW50KSB7XG4gICAgdmFyIGhvc3QgPSB1cmlSZXBsYWNlbWVudC5IT1NULFxuICAgICAgcGFyYW1zID0gdXJpUmVwbGFjZW1lbnQuUEFSQU1TLFxuICAgICAgcGVyT3B0aW9uVXJpcyA9IHVyaVJlcGxhY2VtZW50W3Blck9wdGlvbktleV07XG4gICAgdmFyIHBlclZhcmlhbnRVcmk7XG4gICAgaWYgKHN0YWJsZUlkKSB7XG4gICAgICBwZXJWYXJpYW50VXJpID0gcGVyT3B0aW9uVXJpcyA9PSBudWxsID8gdm9pZCAwIDogcGVyT3B0aW9uVXJpc1tzdGFibGVJZF07XG4gICAgICBpZiAocGVyVmFyaWFudFVyaSkge1xuICAgICAgICB1cmkgPSBwZXJWYXJpYW50VXJpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gICAgaWYgKGhvc3QgJiYgIXBlclZhcmlhbnRVcmkpIHtcbiAgICAgIHVybC5ob3N0ID0gaG9zdDtcbiAgICB9XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5zb3J0KCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHBhcmFtc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cmwuaHJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucyAoRU1FKVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbmNyeXB0ZWRfTWVkaWFfRXh0ZW5zaW9uc19BUElcbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdmFyIEVNRUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Mb2dnZXIpIHtcbiAgICBmdW5jdGlvbiBFTUVDb250cm9sbGVyKGhscykge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfTG9nZ2VyLmNhbGwodGhpcywgJ2VtZScsIGhscy5sb2dnZXIpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICBfdGhpcy5tZWRpYVJlc29sdmVkID0gdm9pZCAwO1xuICAgICAgX3RoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IG51bGw7XG4gICAgICBfdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHt9O1xuICAgICAgX3RoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgIF90aGlzLm1lZGlhS2V5U2Vzc2lvbnMgPSBbXTtcbiAgICAgIF90aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IHt9O1xuICAgICAgX3RoaXMubWVkaWFLZXlzID0gbnVsbDtcbiAgICAgIF90aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA/IFtFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlXSA6IFtdO1xuICAgICAgX3RoaXMuYmFubmVkS2V5SWRzID0ge307XG4gICAgICBfdGhpcy5vbk1lZGlhRW5jcnlwdGVkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBpbml0RGF0YVR5cGUgPSBldmVudC5pbml0RGF0YVR5cGUsXG4gICAgICAgICAgaW5pdERhdGEgPSBldmVudC5pbml0RGF0YTtcbiAgICAgICAgdmFyIGxvZ01lc3NhZ2UgPSBcIlxcXCJcIiArIGV2ZW50LnR5cGUgKyBcIlxcXCIgZXZlbnQ6IGluaXQgZGF0YSB0eXBlOiBcXFwiXCIgKyBpbml0RGF0YVR5cGUgKyBcIlxcXCJcIjtcbiAgICAgICAgX3RoaXMuZGVidWcobG9nTWVzc2FnZSk7XG5cbiAgICAgICAgLy8gSWdub3JlIGV2ZW50IHdoZW4gaW5pdERhdGEgaXMgbnVsbFxuICAgICAgICBpZiAoaW5pdERhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICAgICAgdmFyIGtleVN5c3RlbXMgPSBPYmplY3Qua2V5cyhfdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyk7XG4gICAgICAgICAgaWYgKCFrZXlTeXN0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAga2V5U3lzdGVtcyA9IGdldEtleVN5c3RlbXNGb3JDb25maWcoX3RoaXMuY29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGtleUZvcm1hdHMgPSBrZXlTeXN0ZW1zLm1hcChrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdCkuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gISFrO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzLmtleUZvcm1hdFByb21pc2UgPSBfdGhpcy5nZXRLZXlGb3JtYXRQcm9taXNlKGtleUZvcm1hdHMpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmtleUZvcm1hdFByb21pc2UudGhlbihmdW5jdGlvbiAoa2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgICAgICAgdmFyIGtleVN5c3RlbSA9IGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKGtleVN5c3RlbUZvcm1hdCk7XG4gICAgICAgICAgaWYgKGluaXREYXRhVHlwZSAhPT0gJ3NpbmYnIHx8IGtleVN5c3RlbSAhPT0gS2V5U3lzdGVtcy5GQUlSUExBWSkge1xuICAgICAgICAgICAgX3RoaXMubG9nKFwiSWdub3JpbmcgXFxcIlwiICsgZXZlbnQudHlwZSArIFwiXFxcIiBldmVudCB3aXRoIGluaXQgZGF0YSB0eXBlOiBcXFwiXCIgKyBpbml0RGF0YVR5cGUgKyBcIlxcXCIgZm9yIHNlbGVjdGVkIGtleS1zeXN0ZW0gXCIgKyBrZXlTeXN0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1hdGNoIHNpbmYga2V5SWQgdG8gcGxheWxpc3Qgc2tkOi8va2V5SWQ9XG4gICAgICAgICAgdmFyIGtleUlkO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IGJpbjJzdHIobmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEpKTtcbiAgICAgICAgICAgIHZhciBzaW5mID0gYmFzZTY0RGVjb2RlKEpTT04ucGFyc2UoanNvbikuc2luZik7XG4gICAgICAgICAgICB2YXIgdGVuYyA9IHBhcnNlU2luZihzaW5mKTtcbiAgICAgICAgICAgIGlmICghdGVuYykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInc2NobScgYm94IG1pc3Npbmcgb3Igbm90IGNiY3MvY2VuYyB3aXRoIHNjaGkgPiB0ZW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5SWQgPSBuZXcgVWludDhBcnJheSh0ZW5jLnN1YmFycmF5KDgsIDI0KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLndhcm4obG9nTWVzc2FnZSArIFwiIEZhaWxlZCB0byBwYXJzZSBzaW5mOiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGtleUlkSGV4ID0gYXJyYXlUb0hleChrZXlJZCk7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IF90aGlzLFxuICAgICAgICAgICAga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0gX3RoaXMyLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSxcbiAgICAgICAgICAgIG1lZGlhS2V5U2Vzc2lvbnMgPSBfdGhpczIubWVkaWFLZXlTZXNzaW9ucztcbiAgICAgICAgICB2YXIga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkSGV4XTtcbiAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICAgICAgLy8gTWF0Y2ggcGxheWxpc3Qga2V5XG4gICAgICAgICAgICAgIHZhciBrZXlDb250ZXh0ID0gbWVkaWFLZXlTZXNzaW9uc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGRlY3J5cHRkYXRhID0ga2V5Q29udGV4dC5kZWNyeXB0ZGF0YTtcbiAgICAgICAgICAgICAgaWYgKCFkZWNyeXB0ZGF0YS5rZXlJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBvbGRLZXlJZEhleCA9IGFycmF5VG9IZXgoZGVjcnlwdGRhdGEua2V5SWQpO1xuICAgICAgICAgICAgICBpZiAoYXJyYXlWYWx1ZXNNYXRjaChrZXlJZCwgZGVjcnlwdGRhdGEua2V5SWQpIHx8IGRlY3J5cHRkYXRhLnVyaS5yZXBsYWNlKC8tL2csICcnKS5pbmRleE9mKGtleUlkSGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vbb2xkS2V5SWRIZXhdO1xuICAgICAgICAgICAgICAgIGlmICgha2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlY3J5cHRkYXRhLnBzc2gpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxOyAvLyBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW29sZEtleUlkSGV4XTtcbiAgICAgICAgICAgICAgICBkZWNyeXB0ZGF0YS5wc3NoID0gbmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEpO1xuICAgICAgICAgICAgICAgIGRlY3J5cHRkYXRhLmtleUlkID0ga2V5SWQ7XG4gICAgICAgICAgICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkSGV4XSA9IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlDb250ZXh0LCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCAnZW5jcnlwdGVkLWV2ZW50LWtleS1tYXRjaCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7IC8vIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmV0O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFLZXlTZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX3JldCA9IF9sb29wKCk7XG4gICAgICAgICAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoX3JldCA9PT0gMSkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVFcnJvcihuZXcgRXJyb3IoXCJLZXkgSUQgXCIgKyBrZXlJZEhleCArIFwiIG5vdCBlbmNvdW50ZXJlZCBpbiBwbGF5bGlzdC4gS2V5LXN5c3RlbSBzZXNzaW9ucyBcIiArIG1lZGlhS2V5U2Vzc2lvbnMubGVuZ3RoICsgXCIuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIF90aGlzLm9uV2FpdGluZ0ZvcktleSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpcy5sb2coXCJcXFwiXCIgKyBldmVudC50eXBlICsgXCJcXFwiIGV2ZW50XCIpO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmhscyA9IGhscztcbiAgICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICBfdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHNMb29zZShFTUVDb250cm9sbGVyLCBfTG9nZ2VyKTtcbiAgICB2YXIgX3Byb3RvID0gRU1FQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5vbkRlc3Ryb3lpbmcoKTtcbiAgICAgIHRoaXMub25NZWRpYURldGFjaGVkKCk7XG4gICAgICAvLyBSZW1vdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBiZSBoZWxkIGluIGNvbmZpZyBvcHRpb25zIG9yIGNhbGxiYWNrc1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgY29uZmlnLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMgPSBudWxsO1xuICAgICAgY29uZmlnLmxpY2Vuc2VYaHJTZXR1cCA9IGNvbmZpZy5saWNlbnNlUmVzcG9uc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbmZpZy5kcm1TeXN0ZW1zID0gY29uZmlnLmRybVN5c3RlbU9wdGlvbnMgPSB7fTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gdGhpcy5jb25maWcgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQgPSB0aGlzLm9uV2FpdGluZ0ZvcktleSA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub24oRXZlbnRzLkRFU1RST1lJTkcsIHRoaXMub25EZXN0cm95aW5nLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICAgIHRoaXMuaGxzLm9mZihFdmVudHMuREVTVFJPWUlORywgdGhpcy5vbkRlc3Ryb3lpbmcsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldExpY2Vuc2VTZXJ2ZXJVcmwgPSBmdW5jdGlvbiBnZXRMaWNlbnNlU2VydmVyVXJsKGtleVN5c3RlbSkge1xuICAgICAgdmFyIF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBkcm1TeXN0ZW1zID0gX3RoaXMkY29uZmlnLmRybVN5c3RlbXMsXG4gICAgICAgIHdpZGV2aW5lTGljZW5zZVVybCA9IF90aGlzJGNvbmZpZy53aWRldmluZUxpY2Vuc2VVcmw7XG4gICAgICB2YXIga2V5U3lzdGVtQ29uZmlndXJhdGlvbiA9IGRybVN5c3RlbXMgPT0gbnVsbCA/IHZvaWQgMCA6IGRybVN5c3RlbXNba2V5U3lzdGVtXTtcbiAgICAgIGlmIChrZXlTeXN0ZW1Db25maWd1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBrZXlTeXN0ZW1Db25maWd1cmF0aW9uLmxpY2Vuc2VVcmw7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICBpZiAoa2V5U3lzdGVtID09PSBLZXlTeXN0ZW1zLldJREVWSU5FICYmIHdpZGV2aW5lTGljZW5zZVVybCkge1xuICAgICAgICByZXR1cm4gd2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldExpY2Vuc2VTZXJ2ZXJVcmxPclRocm93ID0gZnVuY3Rpb24gZ2V0TGljZW5zZVNlcnZlclVybE9yVGhyb3coa2V5U3lzdGVtKSB7XG4gICAgICB2YXIgdXJsID0gdGhpcy5nZXRMaWNlbnNlU2VydmVyVXJsKGtleVN5c3RlbSk7XG4gICAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gbGljZW5zZSBzZXJ2ZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGtleS1zeXN0ZW0gXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRTZXJ2ZXJDZXJ0aWZpY2F0ZVVybCA9IGZ1bmN0aW9uIGdldFNlcnZlckNlcnRpZmljYXRlVXJsKGtleVN5c3RlbSkge1xuICAgICAgdmFyIGRybVN5c3RlbXMgPSB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zO1xuICAgICAgdmFyIGtleVN5c3RlbUNvbmZpZ3VyYXRpb24gPSBkcm1TeXN0ZW1zID09IG51bGwgPyB2b2lkIDAgOiBkcm1TeXN0ZW1zW2tleVN5c3RlbV07XG4gICAgICBpZiAoa2V5U3lzdGVtQ29uZmlndXJhdGlvbikge1xuICAgICAgICByZXR1cm4ga2V5U3lzdGVtQ29uZmlndXJhdGlvbi5zZXJ2ZXJDZXJ0aWZpY2F0ZVVybDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nKFwiTm8gU2VydmVyIENlcnRpZmljYXRlIGluIGNvbmZpZy5kcm1TeXN0ZW1zW1xcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIl1cIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uIGF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgdmFyIHVuaXF1ZUNvZGVjID0gZnVuY3Rpb24gdW5pcXVlQ29kZWModmFsdWUsIGksIGEpIHtcbiAgICAgICAgcmV0dXJuICEhdmFsdWUgJiYgYS5pbmRleE9mKHZhbHVlKSA9PT0gaTtcbiAgICAgIH07XG4gICAgICB2YXIgYXVkaW9Db2RlY3MgPSBsZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICByZXR1cm4gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIH0pLmZpbHRlcih1bmlxdWVDb2RlYyk7XG4gICAgICB2YXIgdmlkZW9Db2RlY3MgPSBsZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICByZXR1cm4gbGV2ZWwudmlkZW9Db2RlYztcbiAgICAgIH0pLmZpbHRlcih1bmlxdWVDb2RlYyk7XG4gICAgICBpZiAoYXVkaW9Db2RlY3MubGVuZ3RoICsgdmlkZW9Db2RlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZpZGVvQ29kZWNzLnB1c2goJ2F2YzEuNDJlMDFlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgX2F0dGVtcHQgPSBmdW5jdGlvbiBhdHRlbXB0KGtleVN5c3RlbXMpIHtcbiAgICAgICAgICB2YXIga2V5U3lzdGVtID0ga2V5U3lzdGVtcy5zaGlmdCgpO1xuICAgICAgICAgIF90aGlzMy5nZXRNZWRpYUtleXNQcm9taXNlKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKS50aGVuKGZ1bmN0aW9uIChtZWRpYUtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAga2V5U3lzdGVtOiBrZXlTeXN0ZW0sXG4gICAgICAgICAgICAgIG1lZGlhS2V5czogbWVkaWFLZXlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChrZXlTeXN0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICBfYXR0ZW1wdChrZXlTeXN0ZW1zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFTUVLZXlFcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgICAgfSwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfYXR0ZW1wdChrZXlTeXN0ZW1zVG9BdHRlbXB0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyQxKGtleVN5c3RlbSwgc3VwcG9ydGVkQ29uZmlndXJhdGlvbnMpIHtcbiAgICAgIHZhciByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jID0gdGhpcy5jb25maWcucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYztcbiAgICAgIGlmICghKHR5cGVvZiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB2YXIgZXJyTWVzc2FnZSA9IFwiQ29uZmlndXJlZCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaXMgbm90IGEgZnVuY3Rpb24gXCIgKyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jO1xuICAgICAgICBpZiAocmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID09PSBudWxsICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgICBlcnJNZXNzYWdlID0gXCJuYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGlzIG5vdCBhdmFpbGFibGUgb3ZlciBpbnNlY3VyZSBwcm90b2NvbCBcIiArIGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZXJyTWVzc2FnZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMoa2V5U3lzdGVtLCBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TWVkaWFLZXlzUHJvbWlzZSA9IGZ1bmN0aW9uIGdldE1lZGlhS2V5c1Byb21pc2Uoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgICAgIHZhciBfa2V5U3lzdGVtQWNjZXNzUHJvbWksXG4gICAgICAgIF90aGlzNCA9IHRoaXM7XG4gICAgICAvLyBUaGlzIGNhbiB0aHJvdywgYnV0IGlzIGNhdWdodCBpbiBldmVudCBoYW5kbGVyIGNhbGxwYXRoXG4gICAgICB2YXIgbWVkaWFLZXlTeXN0ZW1Db25maWdzID0gZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgdGhpcy5jb25maWcuZHJtU3lzdGVtT3B0aW9ucyB8fCB7fSk7XG4gICAgICB2YXIga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPSB0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzW2tleVN5c3RlbV07XG4gICAgICB2YXIga2V5U3lzdGVtQWNjZXNzID0gKF9rZXlTeXN0ZW1BY2Nlc3NQcm9taSA9IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2tleVN5c3RlbUFjY2Vzc1Byb21pLmtleVN5c3RlbUFjY2VzcztcbiAgICAgIGlmICgha2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgICAgIHRoaXMubG9nKFwiUmVxdWVzdGluZyBlbmNyeXB0ZWQgbWVkaWEgXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiIGtleS1zeXN0ZW0gYWNjZXNzIHdpdGggY29uZmlnOiBcIiArIHN0cmluZ2lmeShtZWRpYUtleVN5c3RlbUNvbmZpZ3MpKTtcbiAgICAgICAga2V5U3lzdGVtQWNjZXNzID0gdGhpcy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MpO1xuICAgICAgICB2YXIga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNOZXcgPSBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNba2V5U3lzdGVtXSA9IHtcbiAgICAgICAgICBrZXlTeXN0ZW1BY2Nlc3M6IGtleVN5c3RlbUFjY2Vzc1xuICAgICAgICB9O1xuICAgICAgICBrZXlTeXN0ZW1BY2Nlc3MuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgX3RoaXM0LmxvZyhcIkZhaWxlZCB0byBvYnRhaW4gYWNjZXNzIHRvIGtleS1zeXN0ZW0gXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiOiBcIiArIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBrZXlTeXN0ZW1BY2Nlc3MudGhlbihmdW5jdGlvbiAobWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgICAgICBfdGhpczQubG9nKFwiQWNjZXNzIGZvciBrZXktc3lzdGVtIFxcXCJcIiArIG1lZGlhS2V5U3lzdGVtQWNjZXNzLmtleVN5c3RlbSArIFwiXFxcIiBvYnRhaW5lZFwiKTtcbiAgICAgICAgICB2YXIgY2VydGlmaWNhdGVSZXF1ZXN0ID0gX3RoaXM0LmZldGNoU2VydmVyQ2VydGlmaWNhdGUoa2V5U3lzdGVtKTtcbiAgICAgICAgICBfdGhpczQubG9nKFwiQ3JlYXRlIG1lZGlhLWtleXMgZm9yIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgICAgICB2YXIgbWVkaWFLZXlzID0ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNOZXcubWVkaWFLZXlzID0gbWVkaWFLZXlTeXN0ZW1BY2Nlc3MuY3JlYXRlTWVkaWFLZXlzKCkudGhlbihmdW5jdGlvbiAobWVkaWFLZXlzKSB7XG4gICAgICAgICAgICBfdGhpczQubG9nKFwiTWVkaWEta2V5cyBjcmVhdGVkIGZvciBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIik7XG4gICAgICAgICAgICBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlc05ldy5oYXNNZWRpYUtleXMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNlcnRpZmljYXRlUmVxdWVzdC50aGVuKGZ1bmN0aW9uIChjZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICBpZiAoY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0LnNldE1lZGlhS2V5c1NlcnZlckNlcnRpZmljYXRlKG1lZGlhS2V5cywga2V5U3lzdGVtLCBjZXJ0aWZpY2F0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhS2V5cztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1lZGlhS2V5cy5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzNC5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgbWVkaWEta2V5cyBmb3IgXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwifTogXCIgKyBlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG1lZGlhS2V5cztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5U3lzdGVtQWNjZXNzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoX3JlZikge1xuICAgICAgdmFyIGRlY3J5cHRkYXRhID0gX3JlZi5kZWNyeXB0ZGF0YSxcbiAgICAgICAga2V5U3lzdGVtID0gX3JlZi5rZXlTeXN0ZW0sXG4gICAgICAgIG1lZGlhS2V5cyA9IF9yZWYubWVkaWFLZXlzO1xuICAgICAgdGhpcy5sb2coXCJDcmVhdGluZyBrZXktc3lzdGVtIHNlc3Npb24gXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiIGtleUlkOiBcIiArIGFycmF5VG9IZXgoZGVjcnlwdGRhdGEua2V5SWQgfHwgW10pICsgXCIga2V5VXJpOiBcIiArIGRlY3J5cHRkYXRhLnVyaSk7XG4gICAgICB2YXIgbWVkaWFLZXlzU2Vzc2lvbiA9IG1lZGlhS2V5cy5jcmVhdGVTZXNzaW9uKCk7XG4gICAgICB2YXIgbWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IHtcbiAgICAgICAgZGVjcnlwdGRhdGE6IGRlY3J5cHRkYXRhLFxuICAgICAgICBrZXlTeXN0ZW06IGtleVN5c3RlbSxcbiAgICAgICAgbWVkaWFLZXlzOiBtZWRpYUtleXMsXG4gICAgICAgIG1lZGlhS2V5c1Nlc3Npb246IG1lZGlhS2V5c1Nlc3Npb24sXG4gICAgICAgIGtleVN0YXR1czogJ3N0YXR1cy1wZW5kaW5nJ1xuICAgICAgfTtcbiAgICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucy5wdXNoKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgICAgcmV0dXJuIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVuZXdLZXlTZXNzaW9uID0gZnVuY3Rpb24gcmVuZXdLZXlTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGE7XG4gICAgICBpZiAoZGVjcnlwdGRhdGEucHNzaCkge1xuICAgICAgICB2YXIga2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQobWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICAgIHZhciBrZXlJZCA9IGdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKTtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICdjZW5jJztcbiAgICAgICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdID0gdGhpcy5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlTZXNzaW9uQ29udGV4dCwgc2NoZW1lLCBkZWNyeXB0ZGF0YS5wc3NoLmJ1ZmZlciwgJ2V4cGlyZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2FybihcIkNvdWxkIG5vdCByZW5ldyBleHBpcmVkIHNlc3Npb24uIE1pc3NpbmcgcHNzaCBpbml0RGF0YS5cIik7XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICB0aGlzLnJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlS2V5U2Vzc2lvbiA9IGZ1bmN0aW9uIHVwZGF0ZUtleVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCwgZGF0YSkge1xuICAgICAgdmFyIGtleVNlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgICB0aGlzLmxvZyhcIlVwZGF0aW5nIGtleS1zZXNzaW9uIFxcXCJcIiArIGtleVNlc3Npb24uc2Vzc2lvbklkICsgXCJcXFwiIGZvciBrZXlJZCBcIiArIGFycmF5VG9IZXgobWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YS5rZXlJZCB8fCBbXSkgKyBcIlxcbiAgICAgIH0gKGRhdGEgbGVuZ3RoOiBcIiArIGRhdGEuYnl0ZUxlbmd0aCArIFwiKVwiKTtcbiAgICAgIHJldHVybiBrZXlTZXNzaW9uLnVwZGF0ZShkYXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRTZWxlY3RlZEtleVN5c3RlbUZvcm1hdHMgPSBmdW5jdGlvbiBnZXRTZWxlY3RlZEtleVN5c3RlbUZvcm1hdHMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzKS5tYXAoZnVuY3Rpb24gKGtleVN5c3RlbSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtleVN5c3RlbToga2V5U3lzdGVtLFxuICAgICAgICAgIGhhc01lZGlhS2V5czogX3RoaXM1LmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzW2tleVN5c3RlbV0uaGFzTWVkaWFLZXlzXG4gICAgICAgIH07XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBoYXNNZWRpYUtleXMgPSBfcmVmMi5oYXNNZWRpYUtleXM7XG4gICAgICAgIHJldHVybiAhIWhhc01lZGlhS2V5cztcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIGtleVN5c3RlbSA9IF9yZWYzLmtleVN5c3RlbTtcbiAgICAgICAgcmV0dXJuIGtleVN5c3RlbURvbWFpblRvS2V5U3lzdGVtRm9ybWF0KGtleVN5c3RlbSk7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGtleVN5c3RlbSkge1xuICAgICAgICByZXR1cm4gISFrZXlTeXN0ZW07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRLZXlTeXN0ZW1BY2Nlc3MgPSBmdW5jdGlvbiBnZXRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5nZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKGtleVN5c3RlbXNUb0F0dGVtcHQpLnRoZW4oZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgIHZhciBrZXlTeXN0ZW0gPSBfcmVmNC5rZXlTeXN0ZW0sXG4gICAgICAgICAgbWVkaWFLZXlzID0gX3JlZjQubWVkaWFLZXlzO1xuICAgICAgICByZXR1cm4gX3RoaXM2LmF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc2VsZWN0S2V5U3lzdGVtID0gZnVuY3Rpb24gc2VsZWN0S2V5U3lzdGVtKGtleVN5c3RlbXNUb0F0dGVtcHQpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXM3LmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2Uoa2V5U3lzdGVtc1RvQXR0ZW1wdCkudGhlbihmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgICB2YXIga2V5U3lzdGVtID0gX3JlZjUua2V5U3lzdGVtO1xuICAgICAgICAgIHZhciBrZXlTeXN0ZW1Gb3JtYXQgPSBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pO1xuICAgICAgICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgICAgICAgIHJlc29sdmUoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGZvcm1hdCBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnNlbGVjdEtleVN5c3RlbUZvcm1hdCA9IGZ1bmN0aW9uIHNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKSB7XG4gICAgICB2YXIga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKGZyYWcubGV2ZWxrZXlzIHx8IHt9KTtcbiAgICAgIGlmICghdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICAgIHRoaXMubG9nKFwiU2VsZWN0aW5nIGtleS1zeXN0ZW0gZnJvbSBmcmFnbWVudCAoc246IFwiICsgZnJhZy5zbiArIFwiIFwiICsgZnJhZy50eXBlICsgXCI6IFwiICsgZnJhZy5sZXZlbCArIFwiKSBrZXkgZm9ybWF0cyBcIiArIGtleUZvcm1hdHMuam9pbignLCAnKSk7XG4gICAgICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IHRoaXMuZ2V0S2V5Rm9ybWF0UHJvbWlzZShrZXlGb3JtYXRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmtleUZvcm1hdFByb21pc2U7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0S2V5Rm9ybWF0UHJvbWlzZSA9IGZ1bmN0aW9uIGdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cykge1xuICAgICAgdmFyIGtleVN5c3RlbXNJbkNvbmZpZyA9IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgICAgdmFyIGtleVN5c3RlbXNUb0F0dGVtcHQgPSBrZXlGb3JtYXRzLm1hcChrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbikuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISF2YWx1ZSAmJiBrZXlTeXN0ZW1zSW5Db25maWcuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RLZXlTeXN0ZW0oa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0S2V5U3RhdHVzID0gZnVuY3Rpb24gZ2V0S2V5U3RhdHVzKGRlY3J5cHRkYXRhKSB7XG4gICAgICB2YXIgbWVkaWFLZXlTZXNzaW9ucyA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFLZXlTZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RhdHVzID0gX2dldEtleVN0YXR1cyhkZWNyeXB0ZGF0YSwgbWVkaWFLZXlTZXNzaW9uc1tpXSk7XG4gICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRLZXkgPSBmdW5jdGlvbiBsb2FkS2V5KGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgdmFyIGRlY3J5cHRkYXRhID0gZGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhO1xuICAgICAgdmFyIGtleUlkID0gZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpO1xuICAgICAgdmFyIGJhZFN0YXR1cyA9IHRoaXMuYmFubmVkS2V5SWRzW2tleUlkXTtcbiAgICAgIGlmIChiYWRTdGF0dXMgfHwgdGhpcy5nZXRLZXlTdGF0dXMoZGVjcnlwdGRhdGEpID09PSAnaW50ZXJuYWwtZXJyb3InKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGdldEtleVN0YXR1c0Vycm9yKGJhZFN0YXR1cyB8fCAnaW50ZXJuYWwtZXJyb3InLCBkZWNyeXB0ZGF0YSk7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIGRhdGEuZnJhZyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICB2YXIga2V5RGV0YWlscyA9IFwiKGtleUlkOiBcIiArIGtleUlkICsgXCIgZm9ybWF0OiBcXFwiXCIgKyBkZWNyeXB0ZGF0YS5rZXlGb3JtYXQgKyBcIlxcXCIgbWV0aG9kOiBcIiArIGRlY3J5cHRkYXRhLm1ldGhvZCArIFwiIHVyaTogXCIgKyBkZWNyeXB0ZGF0YS51cmkgKyBcIilcIjtcbiAgICAgIHRoaXMubG9nKFwiU3RhcnRpbmcgc2Vzc2lvbiBmb3Iga2V5IFwiICsga2V5RGV0YWlscyk7XG4gICAgICB2YXIga2V5Q29udGV4dFByb21pc2UgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF07XG4gICAgICBpZiAoIWtleUNvbnRleHRQcm9taXNlKSB7XG4gICAgICAgIHZhciBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSB0aGlzLmdldEtleVN5c3RlbUZvcktleVByb21pc2UoZGVjcnlwdGRhdGEpLnRoZW4oZnVuY3Rpb24gKF9yZWY2KSB7XG4gICAgICAgICAgdmFyIGtleVN5c3RlbSA9IF9yZWY2LmtleVN5c3RlbSxcbiAgICAgICAgICAgIG1lZGlhS2V5cyA9IF9yZWY2Lm1lZGlhS2V5cztcbiAgICAgICAgICBfdGhpczgudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIF90aGlzOC5sb2coXCJIYW5kbGUgZW5jcnlwdGVkIG1lZGlhIHNuOiBcIiArIGRhdGEuZnJhZy5zbiArIFwiIFwiICsgZGF0YS5mcmFnLnR5cGUgKyBcIjogXCIgKyBkYXRhLmZyYWcubGV2ZWwgKyBcIiB1c2luZyBrZXkgXCIgKyBrZXlEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXM4LmF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM4LnRocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczguY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCh7XG4gICAgICAgICAgICAgIGtleVN5c3RlbToga2V5U3lzdGVtLFxuICAgICAgICAgICAgICBtZWRpYUtleXM6IG1lZGlhS2V5cyxcbiAgICAgICAgICAgICAgZGVjcnlwdGRhdGE6IGRlY3J5cHRkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoa2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgc2NoZW1lID0gJ2NlbmMnO1xuICAgICAgICAgIHZhciBpbml0RGF0YSA9IGRlY3J5cHRkYXRhLnBzc2ggPyBkZWNyeXB0ZGF0YS5wc3NoLmJ1ZmZlciA6IG51bGw7XG4gICAgICAgICAgcmV0dXJuIF90aGlzOC5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlTZXNzaW9uQ29udGV4dCwgc2NoZW1lLCBpbml0RGF0YSwgJ3BsYXlsaXN0LWtleScpO1xuICAgICAgICB9KTtcbiAgICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBfdGhpczguaGFuZGxlRXJyb3IoZXJyb3IsIGRhdGEuZnJhZyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF0gPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2U7XG4gICAgICAgIHJldHVybiBrZXlTZXNzaW9uQ29udGV4dFByb21pc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlLWVtaXQgZXJyb3IgZm9yIHBsYXlsaXN0IGtleSBsb2FkaW5nXG4gICAgICBrZXlDb250ZXh0UHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRU1FS2V5RXJyb3IpIHtcbiAgICAgICAgICB2YXIgZXJyb3JEYXRhID0gX29iamVjdFNwcmVhZDIoe30sIGVycm9yLmRhdGEpO1xuICAgICAgICAgIGlmIChfdGhpczguZ2V0S2V5U3RhdHVzKGRlY3J5cHRkYXRhKSA9PT0gJ2ludGVybmFsLWVycm9yJykge1xuICAgICAgICAgICAgZXJyb3JEYXRhLmRlY3J5cHRkYXRhID0gZGVjcnlwdGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjbG9uZWRFcnJvciA9IG5ldyBFTUVLZXlFcnJvcihlcnJvckRhdGEsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIF90aGlzOC5oYW5kbGVFcnJvcihjbG9uZWRFcnJvciwgZGF0YS5mcmFnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ga2V5Q29udGV4dFByb21pc2U7XG4gICAgfTtcbiAgICBfcHJvdG8udGhyb3dJZkRlc3Ryb3llZCA9IGZ1bmN0aW9uIHRocm93SWZEZXN0cm95ZWQobWVzc2FnZSkge1xuICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCBmcmFnKSB7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVNRUtleUVycm9yKSB7XG4gICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgZXJyb3IuZGF0YS5mcmFnID0gZnJhZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGV2ZWxLZXkgPSBlcnJvci5kYXRhLmRlY3J5cHRkYXRhO1xuICAgICAgICB0aGlzLmVycm9yKFwiXCIgKyBlcnJvci5tZXNzYWdlICsgKGxldmVsS2V5ID8gXCIgKFwiICsgYXJyYXlUb0hleChsZXZlbEtleS5rZXlJZCB8fCBbXSkgKyBcIilcIiA6ICcnKSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvci5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0tFWVMsXG4gICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldEtleVN5c3RlbUZvcktleVByb21pc2UgPSBmdW5jdGlvbiBnZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKGRlY3J5cHRkYXRhKSB7XG4gICAgICB2YXIga2V5SWQgPSBnZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgICB2YXIgbWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXTtcbiAgICAgIGlmICghbWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgICAgICB2YXIga2V5U3lzdGVtID0ga2V5U3lzdGVtRm9ybWF0VG9LZXlTeXN0ZW1Eb21haW4oZGVjcnlwdGRhdGEua2V5Rm9ybWF0KTtcbiAgICAgICAgdmFyIGtleVN5c3RlbXNUb0F0dGVtcHQgPSBrZXlTeXN0ZW0gPyBba2V5U3lzdGVtXSA6IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbXNUb0F0dGVtcHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZSA9IGZ1bmN0aW9uIGdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2Uoa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgICAgaWYgKCFrZXlTeXN0ZW1zVG9BdHRlbXB0Lmxlbmd0aCkge1xuICAgICAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0ID0gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5U3lzdGVtc1RvQXR0ZW1wdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQ09ORklHVVJFRF9MSUNFTlNFLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0sIFwiTWlzc2luZyBrZXktc3lzdGVtIGxpY2Vuc2UgY29uZmlndXJhdGlvbiBvcHRpb25zIFwiICsgc3RyaW5naWZ5KHtcbiAgICAgICAgICBkcm1TeXN0ZW1zOiB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gICAgfTtcbiAgICBfcHJvdG8uYXR0ZW1wdFNldE1lZGlhS2V5cyA9IGZ1bmN0aW9uIGF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgdGhpcy5tZWRpYVJlc29sdmVkID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMubWVkaWFLZXlzID09PSBtZWRpYUtleXMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHF1ZXVlID0gdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5zbGljZSgpO1xuICAgICAgdGhpcy5sb2coXCJTZXR0aW5nIG1lZGlhLWtleXMgZm9yIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgIC8vIE9ubHkgb25lIHNldE1lZGlhS2V5cygpIGNhbiBydW4gYXQgb25lIHRpbWUsIGFuZCBtdWx0aXBsZSBzZXRNZWRpYUtleXMoKSBvcGVyYXRpb25zXG4gICAgICAvLyBjYW4gYmUgcXVldWVkIGZvciBleGVjdXRpb24gZm9yIG11bHRpcGxlIGtleSBzZXNzaW9ucy5cbiAgICAgIHZhciBzZXRNZWRpYUtleXNQcm9taXNlID0gUHJvbWlzZS5hbGwocXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzOS5tZWRpYSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpczkubWVkaWFSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXM5Lm1lZGlhUmVzb2x2ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGlmICghX3RoaXM5Lm1lZGlhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBzZXQgbWVkaWFLZXlzIHdpdGhvdXQgbWVkaWEgZWxlbWVudCBhdHRhY2hlZCcpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdGhpczkubWVkaWFLZXlzID0gbWVkaWFLZXlzO1xuICAgICAgICAgICAgICBfdGhpczkubWVkaWEuc2V0TWVkaWFLZXlzKG1lZGlhS2V5cykudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM5Lm1lZGlhLnNldE1lZGlhS2V5cyhtZWRpYUtleXMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1lZGlhS2V5cyA9IG1lZGlhS2V5cztcbiAgICAgIHRoaXMuc2V0TWVkaWFLZXlzUXVldWUucHVzaChzZXRNZWRpYUtleXNQcm9taXNlKTtcbiAgICAgIHJldHVybiBzZXRNZWRpYUtleXNQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczkubG9nKFwiTWVkaWEta2V5cyBzZXQgZm9yIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgICAgcXVldWUucHVzaChzZXRNZWRpYUtleXNQcm9taXNlKTtcbiAgICAgICAgX3RoaXM5LnNldE1lZGlhS2V5c1F1ZXVlID0gX3RoaXM5LnNldE1lZGlhS2V5c1F1ZXVlLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBxdWV1ZS5pbmRleE9mKHApID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbiA9IGZ1bmN0aW9uIGdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGNvbnRleHQsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsIHJlYXNvbikge1xuICAgICAgdmFyIF90aGlzJGNvbmZpZyRkcm1TeXN0ZSxcbiAgICAgICAgX3RoaXMwID0gdGhpcztcbiAgICAgIHZhciBnZW5lcmF0ZVJlcXVlc3RGaWx0ZXIgPSAoX3RoaXMkY29uZmlnJGRybVN5c3RlID0gdGhpcy5jb25maWcuZHJtU3lzdGVtcykgPT0gbnVsbCB8fCAoX3RoaXMkY29uZmlnJGRybVN5c3RlID0gX3RoaXMkY29uZmlnJGRybVN5c3RlW2NvbnRleHQua2V5U3lzdGVtXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvbmZpZyRkcm1TeXN0ZS5nZW5lcmF0ZVJlcXVlc3Q7XG4gICAgICBpZiAoZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG1hcHBlZEluaXREYXRhID0gZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyLmNhbGwodGhpcy5obHMsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsIGNvbnRleHQpO1xuICAgICAgICAgIGlmICghbWFwcGVkSW5pdERhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmcm9tIGNvbmZpZ3VyZWQgZ2VuZXJhdGVSZXF1ZXN0IGZpbHRlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0RGF0YVR5cGUgPSBtYXBwZWRJbml0RGF0YS5pbml0RGF0YVR5cGU7XG4gICAgICAgICAgaW5pdERhdGEgPSBtYXBwZWRJbml0RGF0YS5pbml0RGF0YSA/IG1hcHBlZEluaXREYXRhLmluaXREYXRhIDogbnVsbDtcbiAgICAgICAgICBjb250ZXh0LmRlY3J5cHRkYXRhLnBzc2ggPSBpbml0RGF0YSA/IG5ldyBVaW50OEFycmF5KGluaXREYXRhKSA6IG51bGw7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIGlmICh0aGlzLmhscyAmJiB0aGlzLmhscy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluaXREYXRhID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMubG9nKFwiU2tpcHBpbmcga2V5LXNlc3Npb24gcmVxdWVzdCBmb3IgXFxcIlwiICsgcmVhc29uICsgXCJcXFwiIChubyBpbml0RGF0YSlcIik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udGV4dCk7XG4gICAgICB9XG4gICAgICB2YXIga2V5SWQgPSBnZXRLZXlJZFN0cmluZyhjb250ZXh0LmRlY3J5cHRkYXRhKTtcbiAgICAgIHZhciBrZXlVcmkgPSBjb250ZXh0LmRlY3J5cHRkYXRhLnVyaTtcbiAgICAgIHRoaXMubG9nKFwiR2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcXFwiXCIgKyByZWFzb24gKyBcIlxcXCIga2V5SWQ6IFwiICsga2V5SWQgKyBcIiBVUkk6IFwiICsga2V5VXJpICsgXCIgKGluaXQgZGF0YSB0eXBlOiBcIiArIGluaXREYXRhVHlwZSArIFwiIGxlbmd0aDogXCIgKyBpbml0RGF0YS5ieXRlTGVuZ3RoICsgXCIpXCIpO1xuICAgICAgdmFyIGxpY2Vuc2VTdGF0dXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICB2YXIgb25tZXNzYWdlID0gY29udGV4dC5fb25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXlTZXNzaW9uID0gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uO1xuICAgICAgICBpZiAoIWtleVNlc3Npb24pIHtcbiAgICAgICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZVR5cGUgPSBldmVudC5tZXNzYWdlVHlwZSxcbiAgICAgICAgICBtZXNzYWdlID0gZXZlbnQubWVzc2FnZTtcbiAgICAgICAgX3RoaXMwLmxvZyhcIlxcXCJcIiArIG1lc3NhZ2VUeXBlICsgXCJcXFwiIG1lc3NhZ2UgZXZlbnQgZm9yIHNlc3Npb24gXFxcIlwiICsga2V5U2Vzc2lvbi5zZXNzaW9uSWQgKyBcIlxcXCIgbWVzc2FnZSBzaXplOiBcIiArIG1lc3NhZ2UuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGlmIChtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVxdWVzdCcgfHwgbWVzc2FnZVR5cGUgPT09ICdsaWNlbnNlLXJlbmV3YWwnKSB7XG4gICAgICAgICAgX3RoaXMwLnJlbmV3TGljZW5zZShjb250ZXh0LCBtZXNzYWdlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChsaWNlbnNlU3RhdHVzLmV2ZW50TmFtZXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzMC5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZVR5cGUgPT09ICdsaWNlbnNlLXJlbGVhc2UnKSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQua2V5U3lzdGVtID09PSBLZXlTeXN0ZW1zLkZBSVJQTEFZKSB7XG4gICAgICAgICAgICBfdGhpczAudXBkYXRlS2V5U2Vzc2lvbihjb250ZXh0LCBzdHJUb1V0ZjhhcnJheSgnYWNrbm93bGVkZ2VkJykpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMwLnJlbW92ZVNlc3Npb24oY29udGV4dCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMC5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMwLndhcm4oXCJ1bmhhbmRsZWQgbWVkaWEga2V5IG1lc3NhZ2UgdHlwZSBcXFwiXCIgKyBtZXNzYWdlVHlwZSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBoYW5kbGVLZXlTdGF0dXMgPSBmdW5jdGlvbiBoYW5kbGVLZXlTdGF0dXMoa2V5U3RhdHVzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQua2V5U3RhdHVzID0ga2V5U3RhdHVzO1xuICAgICAgICB2YXIga2V5RXJyb3I7XG4gICAgICAgIGlmIChrZXlTdGF0dXMuc3RhcnRzV2l0aCgndXNhYmxlJykpIHtcbiAgICAgICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ3Jlc29sdmVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnaW50ZXJuYWwtZXJyb3InIHx8IGtleVN0YXR1cyA9PT0gJ291dHB1dC1yZXN0cmljdGVkJyB8fCBrZXlTdGF0dXMgPT09ICdvdXRwdXQtZG93bnNjYWxlZCcpIHtcbiAgICAgICAgICBrZXlFcnJvciA9IGdldEtleVN0YXR1c0Vycm9yKGtleVN0YXR1cywgY29udGV4dC5kZWNyeXB0ZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnZXhwaXJlZCcpIHtcbiAgICAgICAgICBrZXlFcnJvciA9IG5ldyBFcnJvcihcImtleSBleHBpcmVkIChrZXlJZDogXCIgKyBrZXlJZCArIFwiKVwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdyZWxlYXNlZCcpIHtcbiAgICAgICAgICBrZXlFcnJvciA9IG5ldyBFcnJvcihcImtleSByZWxlYXNlZFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdzdGF0dXMtcGVuZGluZycpIDsgZWxzZSB7XG4gICAgICAgICAgX3RoaXMwLndhcm4oXCJ1bmhhbmRsZWQga2V5IHN0YXR1cyBjaGFuZ2UgXFxcIlwiICsga2V5U3RhdHVzICsgXCJcXFwiIChrZXlJZDogXCIgKyBrZXlJZCArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5RXJyb3IpIHtcbiAgICAgICAgICBpZiAobGljZW5zZVN0YXR1cy5ldmVudE5hbWVzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaWNlbnNlU3RhdHVzLmVtaXQoJ2Vycm9yJywga2V5RXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczAuaGFuZGxlRXJyb3Ioa2V5RXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBvbmtleXN0YXR1c2VzY2hhbmdlID0gY29udGV4dC5fb25rZXlzdGF0dXNlc2NoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5U2Vzc2lvbiA9IGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICAgICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleVN0YXR1c2VzID0gX3RoaXMwLmdldEtleVN0YXR1c2VzKGNvbnRleHQpO1xuICAgICAgICB2YXIga2V5SWRzID0gT2JqZWN0LmtleXMoa2V5U3RhdHVzZXMpO1xuXG4gICAgICAgIC8vIGV4aXQgaWYgYWxsIGtleXMgYXJlIHN0YXR1cy1wZW5kaW5nXG4gICAgICAgIGlmICgha2V5SWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgcmV0dXJuIGtleVN0YXR1c2VzW2lkXSAhPT0gJ3N0YXR1cy1wZW5kaW5nJztcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW5ldyB3aGVuIGEga2V5IHN0YXR1cyBmb3IgYSBsZXZlbEtleSBjb21lcyBiYWNrIGV4cGlyZWRcbiAgICAgICAgaWYgKGtleVN0YXR1c2VzW2tleUlkXSA9PT0gJ2V4cGlyZWQnKSB7XG4gICAgICAgICAgLy8gcmVuZXcgd2hlbiBhIGtleSBzdGF0dXMgY29tZXMgYmFjayBleHBpcmVkXG4gICAgICAgICAgX3RoaXMwLmxvZyhcIkV4cGlyZWQga2V5IFwiICsgc3RyaW5naWZ5KGtleVN0YXR1c2VzKSArIFwiIGluIGtleS1zZXNzaW9uIFxcXCJcIiArIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgX3RoaXMwLnJlbmV3S2V5U2Vzc2lvbihjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleVN0YXR1cyA9IGtleVN0YXR1c2VzW2tleUlkXTtcbiAgICAgICAgaWYgKGtleVN0YXR1cykge1xuICAgICAgICAgIC8vIGhhbmRsZSBzdGF0dXMgb2YgY3VycmVudCBrZXlcbiAgICAgICAgICBoYW5kbGVLZXlTdGF0dXMoa2V5U3RhdHVzLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQka2V5U3RhdHVzVGltO1xuICAgICAgICAgIC8vIFRpbWVvdXQga2V5LXN0YXR1c1xuICAgICAgICAgIHZhciB0aW1lb3V0ID0gMTAwMDtcbiAgICAgICAgICBjb250ZXh0LmtleVN0YXR1c1RpbWVvdXRzIHx8IChjb250ZXh0LmtleVN0YXR1c1RpbWVvdXRzID0ge30pO1xuICAgICAgICAgIChfY29udGV4dCRrZXlTdGF0dXNUaW0gPSBjb250ZXh0LmtleVN0YXR1c1RpbWVvdXRzKVtrZXlJZF0gfHwgKF9jb250ZXh0JGtleVN0YXR1c1RpbVtrZXlJZF0gPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24gfHwgIV90aGlzMC5tZWRpYUtleXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5kIGtleSBzdGF0dXMgaW4gYW5vdGhlciBzZXNzaW9uIGlmIG1pc3NpbmcgKFBsYXlSZWFkeSAjNzUxOSBubyBrZXktc3RhdHVzIFwic2luZ2xlLWtleVwiIHNldHVwIHdpdGggc2hhcmVkIGtleSlcbiAgICAgICAgICAgIHZhciBzZXNzaW9uS2V5U3RhdHVzID0gX3RoaXMwLmdldEtleVN0YXR1cyhjb250ZXh0LmRlY3J5cHRkYXRhKTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uS2V5U3RhdHVzICYmIHNlc3Npb25LZXlTdGF0dXMgIT09ICdzdGF0dXMtcGVuZGluZycpIHtcbiAgICAgICAgICAgICAgX3RoaXMwLmxvZyhcIk5vIHN0YXR1cyBmb3Iga2V5SWQgXCIgKyBrZXlJZCArIFwiIGluIGtleS1zZXNzaW9uIFxcXCJcIiArIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWQgKyBcIlxcXCIuIFVzaW5nIHNlc3Npb24ga2V5LXN0YXR1cyBcIiArIHNlc3Npb25LZXlTdGF0dXMgKyBcIiBmcm9tIG90aGVyIHNlc3Npb24uXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlS2V5U3RhdHVzKHNlc3Npb25LZXlTdGF0dXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaW1lb3V0IGtleSB3aXRoIGludGVybmFsLWVycm9yXG4gICAgICAgICAgICBfdGhpczAubG9nKFwia2V5IHN0YXR1cyBmb3IgXCIgKyBrZXlJZCArIFwiIGluIGtleS1zZXNzaW9uIFxcXCJcIiArIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWQgKyBcIlxcXCIgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZW91dCArIFwibXNcIik7XG4gICAgICAgICAgICBrZXlTdGF0dXMgPSAnaW50ZXJuYWwtZXJyb3InO1xuICAgICAgICAgICAgaGFuZGxlS2V5U3RhdHVzKGtleVN0YXR1cywgY29udGV4dCk7XG4gICAgICAgICAgfSwgdGltZW91dCkpO1xuICAgICAgICAgIF90aGlzMC5sb2coXCJObyBzdGF0dXMgZm9yIGtleUlkIFwiICsga2V5SWQgKyBcIiAoXCIgKyBzdHJpbmdpZnkoa2V5U3RhdHVzZXMpICsgXCIpLlwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoY29udGV4dC5tZWRpYUtleXNTZXNzaW9uLCAnbWVzc2FnZScsIG9ubWVzc2FnZSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbiwgJ2tleXN0YXR1c2VzY2hhbmdlJywgb25rZXlzdGF0dXNlc2NoYW5nZSk7XG4gICAgICB2YXIga2V5VXNhYmxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGljZW5zZVN0YXR1cy5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICBsaWNlbnNlU3RhdHVzLm9uKCdyZXNvbHZlZCcsIHJlc29sdmUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uLmdlbmVyYXRlUmVxdWVzdChpbml0RGF0YVR5cGUsIGluaXREYXRhKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMwLmxvZyhcIlJlcXVlc3QgZ2VuZXJhdGVkIGZvciBrZXktc2Vzc2lvbiBcXFwiXCIgKyBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24uc2Vzc2lvbklkICsgXCJcXFwiIGtleUlkOiBcIiArIGtleUlkICsgXCIgVVJJOiBcIiArIGtleVVyaSk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgZGVjcnlwdGRhdGE6IGNvbnRleHQuZGVjcnlwdGRhdGEsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgIH0sIFwiRXJyb3IgZ2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0OiBcIiArIGVycm9yKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ga2V5VXNhYmxlUHJvbWlzZTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBsaWNlbnNlU3RhdHVzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gX3RoaXMwLnJlbW92ZVNlc3Npb24oY29udGV4dCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxpY2Vuc2VTdGF0dXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0S2V5U3RhdHVzZXMgPSBmdW5jdGlvbiBnZXRLZXlTdGF0dXNlcyhtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMxID0gdGhpcztcbiAgICAgIHZhciBrZXlTdGF0dXNlcyA9IHt9O1xuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uLmtleVN0YXR1c2VzLmZvckVhY2goZnVuY3Rpb24gKHN0YXR1cywga2V5SWQpIHtcbiAgICAgICAgLy8ga2V5U3RhdHVzZXMuZm9yRWFjaCBpcyBub3Qgc3RhbmRhcmQgQVBJIHNvIHRoZSBjYWxsYmFjayB2YWx1ZSBsb29rcyB3ZWlyZCBvbiB4Ym94b25lXG4gICAgICAgIC8vIHhib3hvbmUgY2FsbGJhY2soa2V5SWQsIHN0YXR1cykgc28gd2UgbmVlZCB0byBleGNoYW5nZSB0aGVtXG4gICAgICAgIGlmICh0eXBlb2Yga2V5SWQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzdGF0dXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSBrZXlJZDtcbiAgICAgICAgICBrZXlJZCA9IHN0YXR1cztcbiAgICAgICAgICBzdGF0dXMgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlJZEFycmF5ID0gJ2J1ZmZlcicgaW4ga2V5SWQgPyBuZXcgVWludDhBcnJheShrZXlJZC5idWZmZXIsIGtleUlkLmJ5dGVPZmZzZXQsIGtleUlkLmJ5dGVMZW5ndGgpIDogbmV3IFVpbnQ4QXJyYXkoa2V5SWQpO1xuICAgICAgICBpZiAobWVkaWFLZXlTZXNzaW9uQ29udGV4dC5rZXlTeXN0ZW0gPT09IEtleVN5c3RlbXMuUExBWVJFQURZICYmIGtleUlkQXJyYXkubGVuZ3RoID09PSAxNikge1xuICAgICAgICAgIC8vIE9uIHNvbWUgZGV2aWNlcywgdGhlIGtleSBJRCBoYXMgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCBmb3IgZW5kaWFubmVzcy5cbiAgICAgICAgICAvLyBJbiBzdWNoIGNhc2VzLCB0aGlzIGtleSBJRCBpcyB0aGUgb25lIHdlIG5lZWQgdG8gY2FjaGUuXG4gICAgICAgICAgdmFyIG9yaWdpbktleUlkV2l0aFN0YXR1c0NoYW5nZSA9IGFycmF5VG9IZXgoa2V5SWRBcnJheSk7XG4gICAgICAgICAgLy8gQ2FjaGUgdGhlIG9yaWdpbmFsIGtleSBJRHMgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkgYWNyb3NzIGFsbCBjYXNlcy5cbiAgICAgICAgICBrZXlTdGF0dXNlc1tvcmlnaW5LZXlJZFdpdGhTdGF0dXNDaGFuZ2VdID0gc3RhdHVzO1xuICAgICAgICAgIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWRBcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleUlkV2l0aFN0YXR1c0NoYW5nZSA9IGFycmF5VG9IZXgoa2V5SWRBcnJheSk7XG4gICAgICAgIC8vIEFkZCB0byBiYW5uZWQga2V5cyB0byBwcmV2ZW50IHBsYXlsaXN0IHVzYWdlIGFuZCBsaWNlbnNlIHJlcXVlc3RzXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdpbnRlcm5hbC1lcnJvcicpIHtcbiAgICAgICAgICBfdGhpczEuYmFubmVkS2V5SWRzW2tleUlkV2l0aFN0YXR1c0NoYW5nZV0gPSBzdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMxLmxvZyhcImtleSBzdGF0dXMgY2hhbmdlIFxcXCJcIiArIHN0YXR1cyArIFwiXFxcIiBmb3Iga2V5U3RhdHVzZXMga2V5SWQ6IFwiICsga2V5SWRXaXRoU3RhdHVzQ2hhbmdlICsgXCIga2V5LXNlc3Npb24gXFxcIlwiICsgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uLnNlc3Npb25JZCArIFwiXFxcIlwiKTtcbiAgICAgICAga2V5U3RhdHVzZXNba2V5SWRXaXRoU3RhdHVzQ2hhbmdlXSA9IHN0YXR1cztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleVN0YXR1c2VzO1xuICAgIH07XG4gICAgX3Byb3RvLmZldGNoU2VydmVyQ2VydGlmaWNhdGUgPSBmdW5jdGlvbiBmZXRjaFNlcnZlckNlcnRpZmljYXRlKGtleVN5c3RlbSkge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgdmFyIExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgICB2YXIgY2VydExvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICAgIHZhciB1cmwgPSB0aGlzLmdldFNlcnZlckNlcnRpZmljYXRlVXJsKGtleVN5c3RlbSk7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcIkZldGNoaW5nIHNlcnZlciBjZXJ0aWZpY2F0ZSBmb3IgXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXCIpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICAgIHVybDogdXJsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBsb2FkUG9saWN5ID0gY29uZmlnLmNlcnRMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgICAgbG9hZFBvbGljeTogbG9hZFBvbGljeSxcbiAgICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHZhciBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IocmVzcG9uc2UsIGNvbnRleCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfSwgcmVzcG9uc2UpXG4gICAgICAgICAgICB9LCBcIlxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIiBjZXJ0aWZpY2F0ZSByZXF1ZXN0IGZhaWxlZCAoXCIgKyB1cmwgKyBcIikuIFN0YXR1czogXCIgKyByZXNwb25zZS5jb2RlICsgXCIgKFwiICsgcmVzcG9uc2UudGV4dCArIFwiKVwiKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblRpbWVvdXQ6IGZ1bmN0aW9uIG9uVGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICB1cmw6IGxvYWRlckNvbnRleHQudXJsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBcIlxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIiBjZXJ0aWZpY2F0ZSByZXF1ZXN0IHRpbWVkIG91dCAoXCIgKyB1cmwgKyBcIilcIikpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25BYm9ydDogZnVuY3Rpb24gb25BYm9ydChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2Fib3J0ZWQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjZXJ0TG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0TWVkaWFLZXlzU2VydmVyQ2VydGlmaWNhdGUgPSBmdW5jdGlvbiBzZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZShtZWRpYUtleXMsIGtleVN5c3RlbSwgY2VydCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbWVkaWFLZXlzLnNldFNlcnZlckNlcnRpZmljYXRlKGNlcnQpLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICBfdGhpczEwLmxvZyhcInNldFNlcnZlckNlcnRpZmljYXRlIFwiICsgKHN1Y2Nlc3MgPyAnc3VjY2VzcycgOiAnbm90IHN1cHBvcnRlZCBieSBDRE0nKSArIFwiIChcIiArIGNlcnQuYnl0ZUxlbmd0aCArIFwiKSBvbiBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIik7XG4gICAgICAgICAgcmVzb2x2ZShtZWRpYUtleXMpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVELFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICB9LCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVuZXdMaWNlbnNlID0gZnVuY3Rpb24gcmVuZXdMaWNlbnNlKGNvbnRleHQsIGtleU1lc3NhZ2UpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RMaWNlbnNlKGNvbnRleHQsIG5ldyBVaW50OEFycmF5KGtleU1lc3NhZ2UpKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBfdGhpczExLnVwZGF0ZUtleVNlc3Npb24oY29udGV4dCwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TRVNTSU9OX1VQREFURV9GQUlMRUQsXG4gICAgICAgICAgICBkZWNyeXB0ZGF0YTogY29udGV4dC5kZWNyeXB0ZGF0YSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVucGFja1BsYXlSZWFkeUtleU1lc3NhZ2UgPSBmdW5jdGlvbiB1bnBhY2tQbGF5UmVhZHlLZXlNZXNzYWdlKHhociwgbGljZW5zZUNoYWxsZW5nZSkge1xuICAgICAgLy8gT24gRWRnZSwgdGhlIHJhdyBsaWNlbnNlIG1lc3NhZ2UgaXMgVVRGLTE2LWVuY29kZWQgWE1MLiAgV2UgbmVlZFxuICAgICAgLy8gdG8gdW5wYWNrIHRoZSBDaGFsbGVuZ2UgZWxlbWVudCAoYmFzZTY0LWVuY29kZWQgc3RyaW5nIGNvbnRhaW5pbmcgdGhlXG4gICAgICAvLyBhY3R1YWwgbGljZW5zZSByZXF1ZXN0KSBhbmQgYW55IEh0dHBIZWFkZXIgZWxlbWVudHMgKHNlbnQgYXMgcmVxdWVzdFxuICAgICAgLy8gaGVhZGVycykuXG4gICAgICAvLyBGb3IgUGxheVJlYWR5IENETXMsIHdlIG5lZWQgdG8gZGlnIHRoZSBDaGFsbGVuZ2Ugb3V0IG9mIHRoZSBYTUwuXG4gICAgICB2YXIgeG1sU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkobGljZW5zZUNoYWxsZW5nZS5idWZmZXIpKTtcbiAgICAgIGlmICgheG1sU3RyaW5nLmluY2x1ZGVzKCdQbGF5UmVhZHlLZXlNZXNzYWdlJykpIHtcbiAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB3cmFwcGVkIG1lc3NhZ2UgYXMgb24gRWRnZS4gIFNvbWVcbiAgICAgICAgLy8gY2xpZW50cyBkbyBub3QgbmVlZCB0aGlzIHVud3JhcHBpbmcsIHNvIHdlIHdpbGwgYXNzdW1lIHRoaXMgaXMgb25lIG9mXG4gICAgICAgIC8vIHRoZW0uICBOb3RlIHRoYXQgXCJ4bWxcIiBhdCB0aGlzIHBvaW50IHByb2JhYmx5IGxvb2tzIGxpa2UgcmFuZG9tXG4gICAgICAgIC8vIGdhcmJhZ2UsIHNpbmNlIHdlIGludGVycHJldGVkIFVURi04IGFzIFVURi0xNi5cbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3htbDsgY2hhcnNldD11dGYtOCcpO1xuICAgICAgICByZXR1cm4gbGljZW5zZUNoYWxsZW5nZTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlNZXNzYWdlWG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcsICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICAgIC8vIFNldCByZXF1ZXN0IGhlYWRlcnMuXG4gICAgICB2YXIgaGVhZGVycyA9IGtleU1lc3NhZ2VYbWwucXVlcnlTZWxlY3RvckFsbCgnSHR0cEhlYWRlcicpO1xuICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgaGVhZGVyO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaGVhZGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IsIF9oZWFkZXIkcXVlcnlTZWxlY3RvcjI7XG4gICAgICAgICAgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICB2YXIgbmFtZSA9IChfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IgPSBoZWFkZXIucXVlcnlTZWxlY3RvcignbmFtZScpKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRlciRxdWVyeVNlbGVjdG9yLnRleHRDb250ZW50O1xuICAgICAgICAgIHZhciB2YWx1ZSA9IChfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyID0gaGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJ3ZhbHVlJykpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyLnRleHRDb250ZW50O1xuICAgICAgICAgIGlmIChuYW1lICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hhbGxlbmdlRWxlbWVudCA9IGtleU1lc3NhZ2VYbWwucXVlcnlTZWxlY3RvcignQ2hhbGxlbmdlJyk7XG4gICAgICB2YXIgY2hhbGxlbmdlVGV4dCA9IGNoYWxsZW5nZUVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNoYWxsZW5nZUVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICBpZiAoIWNoYWxsZW5nZVRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgPENoYWxsZW5nZT4gaW4ga2V5IG1lc3NhZ2VcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyVG9VdGY4YXJyYXkoYXRvYihjaGFsbGVuZ2VUZXh0KSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0dXBMaWNlbnNlWEhSID0gZnVuY3Rpb24gc2V0dXBMaWNlbnNlWEhSKHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcbiAgICAgIHZhciBsaWNlbnNlWGhyU2V0dXAgPSB0aGlzLmNvbmZpZy5saWNlbnNlWGhyU2V0dXA7XG4gICAgICBpZiAoIWxpY2Vuc2VYaHJTZXR1cCkge1xuICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIHhocjogeGhyLFxuICAgICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2U6IGxpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgha2V5c0xpc3RJdGVtLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgcmVtb3ZlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaWNlbnNlWGhyU2V0dXAuY2FsbChfdGhpczEyLmhscywgeGhyLCB1cmwsIGtleXNMaXN0SXRlbSwgbGljZW5zZUNoYWxsZW5nZSk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0uZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgICAvLyBLZXkgc2Vzc2lvbiByZW1vdmVkLiBDYW5jZWwgbGljZW5zZSByZXF1ZXN0LlxuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxldCdzIHRyeSB0byBvcGVuIGJlZm9yZSBydW5uaW5nIHNldHVwXG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGxpY2Vuc2VYaHJTZXR1cC5jYWxsKF90aGlzMTIuaGxzLCB4aHIsIHVybCwga2V5c0xpc3RJdGVtLCBsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGxpY2Vuc2VYaHJTZXR1cFJlc3VsdCkge1xuICAgICAgICAvLyBpZiBsaWNlbnNlWGhyU2V0dXAgZGlkIG5vdCB5ZXQgY2FsbCBvcGVuLCBsZXQncyBkbyBpdCBub3dcbiAgICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmluYWxMaWNlbnNlQ2hhbGxlbmdlID0gbGljZW5zZVhoclNldHVwUmVzdWx0ID8gbGljZW5zZVhoclNldHVwUmVzdWx0IDogbGljZW5zZUNoYWxsZW5nZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4aHI6IHhocixcbiAgICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlOiBmaW5hbExpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcXVlc3RMaWNlbnNlID0gZnVuY3Rpb24gcmVxdWVzdExpY2Vuc2Uoa2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICAgIHZhciBfdGhpczEzID0gdGhpcztcbiAgICAgIHZhciBrZXlMb2FkUG9saWN5ID0gdGhpcy5jb25maWcua2V5TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHVybCA9IF90aGlzMTMuZ2V0TGljZW5zZVNlcnZlclVybE9yVGhyb3coa2V5U2Vzc2lvbkNvbnRleHQua2V5U3lzdGVtKTtcbiAgICAgICAgX3RoaXMxMy5sb2coXCJTZW5kaW5nIGxpY2Vuc2UgcmVxdWVzdCB0byBVUkw6IFwiICsgdXJsKTtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIV90aGlzMTMuaGxzIHx8ICFrZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgIF90aGlzMTMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgIF90aGlzMTMubG9nKFwiTGljZW5zZSByZWNlaXZlZCBcIiArIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhKSk7XG4gICAgICAgICAgICAgIHZhciBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjayA9IF90aGlzMTMuY29uZmlnLmxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrO1xuICAgICAgICAgICAgICBpZiAobGljZW5zZVJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZGF0YSA9IGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrLmNhbGwoX3RoaXMxMy5obHMsIHhociwgdXJsLCBrZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMTMuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJldHJ5Q29uZmlnID0ga2V5TG9hZFBvbGljeS5lcnJvclJldHJ5O1xuICAgICAgICAgICAgICB2YXIgbWF4TnVtUmV0cnkgPSByZXRyeUNvbmZpZyA/IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5IDogMDtcbiAgICAgICAgICAgICAgX3RoaXMxMy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQrKztcbiAgICAgICAgICAgICAgaWYgKF90aGlzMTMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID4gbWF4TnVtUmV0cnkgfHwgeGhyLnN0YXR1cyA+PSA0MDAgJiYgeGhyLnN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgICAgIGRlY3J5cHRkYXRhOiBrZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YSxcbiAgICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IHhocixcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHhoci5zdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgXCJMaWNlbnNlIFJlcXVlc3QgWEhSIGZhaWxlZCAoXCIgKyB1cmwgKyBcIikuIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzICsgXCIgKFwiICsgeGhyLnN0YXR1c1RleHQgKyBcIilcIikpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhdHRlbXB0c0xlZnQgPSBtYXhOdW1SZXRyeSAtIF90aGlzMTMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ICsgMTtcbiAgICAgICAgICAgICAgICBfdGhpczEzLndhcm4oXCJSZXRyeWluZyBsaWNlbnNlIHJlcXVlc3QsIFwiICsgYXR0ZW1wdHNMZWZ0ICsgXCIgYXR0ZW1wdHMgbGVmdFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpczEzLnJlcXVlc3RMaWNlbnNlKGtleVNlc3Npb25Db250ZXh0LCBsaWNlbnNlQ2hhbGxlbmdlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyICYmIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICAgIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyID0geGhyO1xuICAgICAgICBfdGhpczEzLnNldHVwTGljZW5zZVhIUih4aHIsIHVybCwga2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpLnRoZW4oZnVuY3Rpb24gKF9yZWY3KSB7XG4gICAgICAgICAgdmFyIHhociA9IF9yZWY3LnhocixcbiAgICAgICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2UgPSBfcmVmNy5saWNlbnNlQ2hhbGxlbmdlO1xuICAgICAgICAgIGlmIChrZXlTZXNzaW9uQ29udGV4dC5rZXlTeXN0ZW0gPT0gS2V5U3lzdGVtcy5QTEFZUkVBRFkpIHtcbiAgICAgICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2UgPSBfdGhpczEzLnVucGFja1BsYXlSZWFkeUtleU1lc3NhZ2UoeGhyLCBsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeGhyLnNlbmQobGljZW5zZUNoYWxsZW5nZSk7XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vbkRlc3Ryb3lpbmcgPSBmdW5jdGlvbiBvbkRlc3Ryb3lpbmcoKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1lZGlhID0gZGF0YS5tZWRpYTtcblxuICAgICAgLy8ga2VlcCByZWZlcmVuY2Ugb2YgbWVkaWFcbiAgICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdlbmNyeXB0ZWQnLCB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3dhaXRpbmdmb3JrZXknLCB0aGlzLm9uV2FpdGluZ0ZvcktleSk7XG4gICAgICB2YXIgbWVkaWFSZXNvbHZlZCA9IHRoaXMubWVkaWFSZXNvbHZlZDtcbiAgICAgIGlmIChtZWRpYVJlc29sdmVkKSB7XG4gICAgICAgIG1lZGlhUmVzb2x2ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVkaWFLZXlzID0gbWVkaWEubWVkaWFLZXlzO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFEZXRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ2VuY3J5cHRlZCcsIHRoaXMub25NZWRpYUVuY3J5cHRlZCk7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICd3YWl0aW5nZm9ya2V5JywgdGhpcy5vbldhaXRpbmdGb3JLZXkpO1xuICAgICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZWRpYUtleXMgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl9jbGVhciA9IGZ1bmN0aW9uIF9jbGVhcigpIHtcbiAgICAgIHZhciBfdGhpczE0ID0gdGhpcyxcbiAgICAgICAgX21lZGlhJHNldE1lZGlhS2V5cztcbiAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgIHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0ge307XG4gICAgICB0aGlzLmJhbm5lZEtleUlkcyA9IHt9O1xuICAgICAgdmFyIG1lZGlhUmVzb2x2ZWQgPSB0aGlzLm1lZGlhUmVzb2x2ZWQ7XG4gICAgICBpZiAobWVkaWFSZXNvbHZlZCkge1xuICAgICAgICBtZWRpYVJlc29sdmVkKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubWVkaWFLZXlzICYmICF0aGlzLm1lZGlhS2V5U2Vzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICB2YXIgbWVkaWFLZXlzTGlzdCA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucy5zbGljZSgpO1xuICAgICAgdGhpcy5tZWRpYUtleVNlc3Npb25zID0gW107XG4gICAgICB0aGlzLm1lZGlhS2V5cyA9IG51bGw7XG4gICAgICBMZXZlbEtleS5jbGVhcktleVVyaVRvS2V5SWRNYXAoKTtcblxuICAgICAgLy8gQ2xvc2UgYWxsIHNlc3Npb25zIGFuZCByZW1vdmUgbWVkaWEga2V5cyBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgICAgdmFyIGtleVNlc3Npb25Db3VudCA9IG1lZGlhS2V5c0xpc3QubGVuZ3RoO1xuICAgICAgRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA9IFByb21pc2UuYWxsKG1lZGlhS2V5c0xpc3QubWFwKGZ1bmN0aW9uIChtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfdGhpczE0LnJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICB9KS5jb25jYXQoKG1lZGlhID09IG51bGwgfHwgKF9tZWRpYSRzZXRNZWRpYUtleXMgPSBtZWRpYS5zZXRNZWRpYUtleXMobnVsbCkpID09IG51bGwgPyB2b2lkIDAgOiBfbWVkaWEkc2V0TWVkaWFLZXlzLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBfdGhpczE0LmxvZyhcIkNvdWxkIG5vdCBjbGVhciBtZWRpYSBrZXlzOiBcIiArIGVycm9yKTtcbiAgICAgICAgaWYgKCFfdGhpczE0LmhscykgcmV0dXJuO1xuICAgICAgICBfdGhpczE0Lmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fREVTVFJPWV9NRURJQV9LRVlTX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiQ291bGQgbm90IGNsZWFyIG1lZGlhIGtleXM6IFwiICsgZXJyb3IpXG4gICAgICAgIH0pO1xuICAgICAgfSkpIHx8IFByb21pc2UucmVzb2x2ZSgpKSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIF90aGlzMTQubG9nKFwiQ291bGQgbm90IGNsb3NlIHNlc3Npb25zIGFuZCBjbGVhciBtZWRpYSBrZXlzOiBcIiArIGVycm9yKTtcbiAgICAgICAgaWYgKCFfdGhpczE0LmhscykgcmV0dXJuO1xuICAgICAgICBfdGhpczE0Lmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fREVTVFJPWV9DTE9TRV9TRVNTSU9OX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiQ291bGQgbm90IGNsb3NlIHNlc3Npb25zIGFuZCBjbGVhciBtZWRpYSBrZXlzOiBcIiArIGVycm9yKVxuICAgICAgICB9KTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoa2V5U2Vzc2lvbkNvdW50KSB7XG4gICAgICAgICAgX3RoaXMxNC5sb2coJ2ZpbmlzaGVkIGNsb3Npbmcga2V5IHNlc3Npb25zIGFuZCBjbGVhcmluZyBtZWRpYSBrZXlzJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICB0aGlzLl9jbGVhcigpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBfcmVmOCkge1xuICAgICAgdmFyIHNlc3Npb25LZXlzID0gX3JlZjguc2Vzc2lvbktleXM7XG4gICAgICBpZiAoIXNlc3Npb25LZXlzIHx8ICF0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICAgIHZhciBrZXlGb3JtYXRzID0gc2Vzc2lvbktleXMucmVkdWNlKGZ1bmN0aW9uIChmb3JtYXRzLCBzZXNzaW9uS2V5KSB7XG4gICAgICAgICAgaWYgKGZvcm1hdHMuaW5kZXhPZihzZXNzaW9uS2V5LmtleUZvcm1hdCkgPT09IC0xKSB7XG4gICAgICAgICAgICBmb3JtYXRzLnB1c2goc2Vzc2lvbktleS5rZXlGb3JtYXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICB0aGlzLmxvZyhcIlNlbGVjdGluZyBrZXktc3lzdGVtIGZyb20gc2Vzc2lvbi1rZXlzIFwiICsga2V5Rm9ybWF0cy5qb2luKCcsICcpKTtcbiAgICAgICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gdGhpcy5nZXRLZXlGb3JtYXRQcm9taXNlKGtleUZvcm1hdHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZVNlc3Npb24gPSBmdW5jdGlvbiByZW1vdmVTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczE1ID0gdGhpcztcbiAgICAgIHZhciBtZWRpYUtleXNTZXNzaW9uID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uLFxuICAgICAgICBsaWNlbnNlWGhyID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyLFxuICAgICAgICBkZWNyeXB0ZGF0YSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGE7XG4gICAgICBpZiAobWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICB0aGlzLmxvZyhcIlJlbW92ZSBsaWNlbnNlcyBhbmQga2V5cyBhbmQgY2xvc2Ugc2Vzc2lvbiBcXFwiXCIgKyBtZWRpYUtleXNTZXNzaW9uLnNlc3Npb25JZCArIFwiXFxcIiBrZXlJZDogXCIgKyBhcnJheVRvSGV4KChkZWNyeXB0ZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGVjcnlwdGRhdGEua2V5SWQpIHx8IFtdKSk7XG4gICAgICAgIGlmIChtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbm1lc3NhZ2UpIHtcbiAgICAgICAgICBtZWRpYUtleXNTZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbm1lc3NhZ2UpO1xuICAgICAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25rZXlzdGF0dXNlc2NoYW5nZSkge1xuICAgICAgICAgIG1lZGlhS2V5c1Nlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5c3RhdHVzZXNjaGFuZ2UnLCBtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbmtleXN0YXR1c2VzY2hhbmdlKTtcbiAgICAgICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbmtleXN0YXR1c2VzY2hhbmdlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaWNlbnNlWGhyICYmIGxpY2Vuc2VYaHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICAgIGxpY2Vuc2VYaHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMuaW5kZXhPZihtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5U3RhdHVzVGltZW91dHMgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmtleVN0YXR1c1RpbWVvdXRzO1xuICAgICAgICBpZiAoa2V5U3RhdHVzVGltZW91dHMpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhrZXlTdGF0dXNUaW1lb3V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNsZWFyVGltZW91dChrZXlTdGF0dXNUaW1lb3V0c1trZXlJZF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcm1TeXN0ZW1PcHRpb25zID0gdGhpcy5jb25maWcuZHJtU3lzdGVtT3B0aW9ucztcbiAgICAgICAgdmFyIHJlbW92ZVByb21pc2UgPSBpc1BlcnNpc3RlbnRTZXNzaW9uVHlwZShkcm1TeXN0ZW1PcHRpb25zKSA/IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJNZWRpYUtleVNlc3Npb24ucmVtb3ZlKCkgdGltZW91dFwiKSk7XG4gICAgICAgICAgfSwgODAwMCk7XG4gICAgICAgICAgbWVkaWFLZXlzU2Vzc2lvbi5yZW1vdmUoKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0pIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiByZW1vdmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIF90aGlzMTUubG9nKFwiQ291bGQgbm90IHJlbW92ZSBzZXNzaW9uOiBcIiArIGVycm9yKTtcbiAgICAgICAgICBpZiAoIV90aGlzMTUuaGxzKSByZXR1cm47XG4gICAgICAgICAgX3RoaXMxNS5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9ERVNUUk9ZX1JFTU9WRV9TRVNTSU9OX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZW1vdmUgc2Vzc2lvbjogXCIgKyBlcnJvcilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG1lZGlhS2V5c1Nlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgX3RoaXMxNS5sb2coXCJDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbjogXCIgKyBlcnJvcik7XG4gICAgICAgICAgaWYgKCFfdGhpczE1LmhscykgcmV0dXJuO1xuICAgICAgICAgIF90aGlzMTUuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fREVTVFJPWV9DTE9TRV9TRVNTSU9OX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjbG9zZSBzZXNzaW9uOiBcIiArIGVycm9yKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBFTUVDb250cm9sbGVyO1xuICB9KExvZ2dlcik7XG4gIEVNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2UgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIGdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKSB7XG4gICAgaWYgKCFkZWNyeXB0ZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVhZCBrZXlJZCBvZiB1bmRlZmluZWQgZGVjcnlwdGRhdGEnKTtcbiAgICB9XG4gICAgaWYgKGRlY3J5cHRkYXRhLmtleUlkID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleUlkIGlzIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5VG9IZXgoZGVjcnlwdGRhdGEua2V5SWQpO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRLZXlTdGF0dXMoZGVjcnlwdGRhdGEsIGtleUNvbnRleHQpIHtcbiAgICBpZiAoZGVjcnlwdGRhdGEua2V5SWQgJiYga2V5Q29udGV4dC5tZWRpYUtleXNTZXNzaW9uLmtleVN0YXR1c2VzLmhhcyhkZWNyeXB0ZGF0YS5rZXlJZCkpIHtcbiAgICAgIHJldHVybiBrZXlDb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24ua2V5U3RhdHVzZXMuZ2V0KGRlY3J5cHRkYXRhLmtleUlkKTtcbiAgICB9XG4gICAgaWYgKGRlY3J5cHRkYXRhLm1hdGNoZXMoa2V5Q29udGV4dC5kZWNyeXB0ZGF0YSkpIHtcbiAgICAgIHJldHVybiBrZXlDb250ZXh0LmtleVN0YXR1cztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgRU1FS2V5RXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICAgIGZ1bmN0aW9uIEVNRUtleUVycm9yKGRhdGEsIG1lc3NhZ2UpIHtcbiAgICAgIHZhciBfdGhpczE2O1xuICAgICAgX3RoaXMxNiA9IF9FcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICBfdGhpczE2LmRhdGEgPSB2b2lkIDA7XG4gICAgICBkYXRhLmVycm9yIHx8IChkYXRhLmVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICAgIF90aGlzMTYuZGF0YSA9IGRhdGE7XG4gICAgICBkYXRhLmVyciA9IGRhdGEuZXJyb3I7XG4gICAgICByZXR1cm4gX3RoaXMxNjtcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoRU1FS2V5RXJyb3IsIF9FcnJvcik7XG4gICAgcmV0dXJuIEVNRUtleUVycm9yO1xuICB9KC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG4gIGZ1bmN0aW9uIGdldEtleVN0YXR1c0Vycm9yKGtleVN0YXR1cywgZGVjcnlwdGRhdGEpIHtcbiAgICB2YXIgb3V0cHV0UmVzdHJpY3RlZCA9IGtleVN0YXR1cyA9PT0gJ291dHB1dC1yZXN0cmljdGVkJztcbiAgICB2YXIgZGV0YWlscyA9IG91dHB1dFJlc3RyaWN0ZWQgPyBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQgOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1I7XG4gICAgcmV0dXJuIG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZGVjcnlwdGRhdGE6IGRlY3J5cHRkYXRhXG4gICAgfSwgb3V0cHV0UmVzdHJpY3RlZCA/ICdIRENQIGxldmVsIG91dHB1dCByZXN0cmljdGVkJyA6IFwia2V5IHN0YXR1cyBjaGFuZ2VkIHRvIFxcXCJcIiArIGtleVN0YXR1cyArIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHZhciBGUFNDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGUFNDb250cm9sbGVyKGhscykge1xuICAgICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMudGltZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdFRpbWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gMDtcbiAgICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSAwO1xuICAgICAgLy8gc3RyZWFtIGNvbnRyb2xsZXIgbXVzdCBiZSBwcm92aWRlZCBhcyBhIGRlcGVuZGVuY3khXG4gICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEZQU0NvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRTdHJlYW1Db250cm9sbGVyID0gZnVuY3Rpb24gc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBzdHJlYW1Db250cm9sbGVyO1xuICAgIH07XG4gICAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgaWYgKGNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xuICAgICAgICB2YXIgbWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2Ygc2VsZi5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhICYmIHR5cGVvZiBtZWRpYS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrRlBTID0gZnVuY3Rpb24gY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgICAgICB2YXIgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcztcbiAgICAgICAgICB2YXIgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcztcbiAgICAgICAgICB2YXIgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2Q7XG4gICAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUCwge1xuICAgICAgICAgICAgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLFxuICAgICAgICAgICAgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLFxuICAgICAgICAgICAgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgICAvLyBobHMubG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IGhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQgKiBjdXJyZW50RGVjb2RlZCkge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudExldmVsID0gaGxzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgaGxzLmxvZ2dlci53YXJuKCdkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogJyArIGN1cnJlbnRMZXZlbCk7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPiAwICYmIChobHMuYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgfHwgaGxzLmF1dG9MZXZlbENhcHBpbmcgPj0gY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsOiBjdXJyZW50TGV2ZWwsXG4gICAgICAgICAgICAgICAgICBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gZHJvcHBlZEZyYW1lcztcbiAgICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tGUFNJbnRlcnZhbCA9IGZ1bmN0aW9uIGNoZWNrRlBTSW50ZXJ2YWwoKSB7XG4gICAgICB2YXIgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgICB2YXIgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSFRNTFZpZGVvRWxlbWVudCBkb2Vzbid0IGluY2x1ZGUgdGhlIHdlYmtpdCB0eXBlc1xuICAgICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGUFNDb250cm9sbGVyO1xuICB9KCk7XG5cbiAgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaFxuICBmdW5jdGlvbiBoYXNoKHRleHQpIHtcbiAgICB2YXIgaGFzaCA9IDUzODE7XG4gICAgdmFyIGkgPSB0ZXh0Lmxlbmd0aDtcbiAgICB3aGlsZSAoaSkge1xuICAgICAgaGFzaCA9IGhhc2ggKiAzMyBeIHRleHQuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICByZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG4gIH1cblxuICB2YXIgQUxJR05FRF9FTkRfVEhSRVNIT0xEX1NFQ09ORFMgPSAwLjAyNTtcbiAgdmFyIFRpbWVsaW5lT2NjdXBhbmN5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChUaW1lbGluZU9jY3VwYW5jeSkge1xuICAgIFRpbWVsaW5lT2NjdXBhbmN5W1RpbWVsaW5lT2NjdXBhbmN5W1wiUG9pbnRcIl0gPSAwXSA9IFwiUG9pbnRcIjtcbiAgICBUaW1lbGluZU9jY3VwYW5jeVtUaW1lbGluZU9jY3VwYW5jeVtcIlJhbmdlXCJdID0gMV0gPSBcIlJhbmdlXCI7XG4gICAgcmV0dXJuIFRpbWVsaW5lT2NjdXBhbmN5O1xuICB9KHt9KTtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVBc3NldElkZW50aWZpZXIoaW50ZXJzdGl0aWFsLCB1cmksIGFzc2V0TGlzdEluZGV4KSB7XG4gICAgcmV0dXJuIGludGVyc3RpdGlhbC5pZGVudGlmaWVyICsgXCItXCIgKyAoYXNzZXRMaXN0SW5kZXggKyAxKSArIFwiLVwiICsgaGFzaCh1cmkpO1xuICB9XG4gIHZhciBJbnRlcnN0aXRpYWxFdmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJzdGl0aWFsRXZlbnQoZGF0ZVJhbmdlLCBiYXNlKSB7XG4gICAgICB0aGlzLmJhc2UgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lbGluZVN0YXJ0ID0gbnVsbDtcbiAgICAgIHRoaXMuYXBwZW5kSW5QbGFjZURpc2FibGVkID0gdm9pZCAwO1xuICAgICAgdGhpcy5hcHBlbmRJblBsYWNlU3RhcnRlZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlID0gdm9pZCAwO1xuICAgICAgdGhpcy5oYXNQbGF5ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VtdWxhdGl2ZUR1cmF0aW9uID0gMDtcbiAgICAgIHRoaXMucmVzdW1lT2Zmc2V0ID0gTmFOO1xuICAgICAgdGhpcy5wbGF5b3V0TGltaXQgPSBOYU47XG4gICAgICB0aGlzLnJlc3RyaWN0aW9ucyA9IHtcbiAgICAgICAgc2tpcDogZmFsc2UsXG4gICAgICAgIGp1bXA6IGZhbHNlXG4gICAgICB9O1xuICAgICAgdGhpcy5zbmFwT3B0aW9ucyA9IHtcbiAgICAgICAgb3V0OiBmYWxzZSxcbiAgICAgICAgaW46IGZhbHNlXG4gICAgICB9O1xuICAgICAgdGhpcy5hc3NldExpc3QgPSBbXTtcbiAgICAgIHRoaXMuYXNzZXRMaXN0TG9hZGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5hc3NldExpc3RSZXNwb25zZSA9IG51bGw7XG4gICAgICB0aGlzLnJlc3VtZUFuY2hvciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZXJyb3IgPSB2b2lkIDA7XG4gICAgICB0aGlzLnJlc2V0T25SZXN1bWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgdGhpcy5kYXRlUmFuZ2UgPSBkYXRlUmFuZ2U7XG4gICAgICB0aGlzLnNldERhdGVSYW5nZShkYXRlUmFuZ2UpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gSW50ZXJzdGl0aWFsRXZlbnQucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXREYXRlUmFuZ2UgPSBmdW5jdGlvbiBzZXREYXRlUmFuZ2UoZGF0ZVJhbmdlKSB7XG4gICAgICB0aGlzLmRhdGVSYW5nZSA9IGRhdGVSYW5nZTtcbiAgICAgIHRoaXMucmVzdW1lT2Zmc2V0ID0gZGF0ZVJhbmdlLmF0dHIub3B0aW9uYWxGbG9hdCgnWC1SRVNVTUUtT0ZGU0VUJywgdGhpcy5yZXN1bWVPZmZzZXQpO1xuICAgICAgdGhpcy5wbGF5b3V0TGltaXQgPSBkYXRlUmFuZ2UuYXR0ci5vcHRpb25hbEZsb2F0KCdYLVBMQVlPVVQtTElNSVQnLCB0aGlzLnBsYXlvdXRMaW1pdCk7XG4gICAgICB0aGlzLnJlc3RyaWN0aW9ucyA9IGRhdGVSYW5nZS5hdHRyLmVudW1lcmF0ZWRTdHJpbmdMaXN0KCdYLVJFU1RSSUNUJywgdGhpcy5yZXN0cmljdGlvbnMpO1xuICAgICAgdGhpcy5zbmFwT3B0aW9ucyA9IGRhdGVSYW5nZS5hdHRyLmVudW1lcmF0ZWRTdHJpbmdMaXN0KCdYLVNOQVAnLCB0aGlzLnNuYXBPcHRpb25zKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdmFyIF90aGlzJGFzc2V0TGlzdExvYWRlcjtcbiAgICAgIHRoaXMuYXBwZW5kSW5QbGFjZVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIChfdGhpcyRhc3NldExpc3RMb2FkZXIgPSB0aGlzLmFzc2V0TGlzdExvYWRlcikgPT0gbnVsbCB8fCBfdGhpcyRhc3NldExpc3RMb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5hc3NldExpc3RMb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoIXRoaXMuc3VwcGxlbWVudHNQcmltYXJ5KSB7XG4gICAgICAgIHRoaXMuYXNzZXRMaXN0UmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmFzc2V0TGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBgZXJyb3I/YCBpcyByZXNldCB3aGVuIHNlZWtpbmcgYmFjayBvdmVyIGludGVyc3RpdGlhbCBgc3RhcnRPZmZzZXRgXG4gICAgICAvLyAgdXNpbmcgYHNjaGVkdWxlLnJlc2V0RXJyb3JzSW5SYW5nZShzdGFydCwgZW5kKWAuXG4gICAgfTtcbiAgICBfcHJvdG8uaXNBc3NldFBhc3RQbGF5b3V0TGltaXQgPSBmdW5jdGlvbiBpc0Fzc2V0UGFzdFBsYXlvdXRMaW1pdChhc3NldEluZGV4KSB7XG4gICAgICB2YXIgX3RoaXMkYXNzZXRMaXN0JGFzc2V0O1xuICAgICAgaWYgKGFzc2V0SW5kZXggPiAwICYmIGFzc2V0SW5kZXggPj0gdGhpcy5hc3NldExpc3QubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHBsYXlvdXRMaW1pdCA9IHRoaXMucGxheW91dExpbWl0O1xuICAgICAgaWYgKGFzc2V0SW5kZXggPD0gMCB8fCBpc05hTihwbGF5b3V0TGltaXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGF5b3V0TGltaXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgYXNzZXRPZmZzZXQgPSAoKF90aGlzJGFzc2V0TGlzdCRhc3NldCA9IHRoaXMuYXNzZXRMaXN0W2Fzc2V0SW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYXNzZXRMaXN0JGFzc2V0LnN0YXJ0T2Zmc2V0KSB8fCAwO1xuICAgICAgcmV0dXJuIGFzc2V0T2Zmc2V0ID4gcGxheW91dExpbWl0O1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmRBc3NldEluZGV4ID0gZnVuY3Rpb24gZmluZEFzc2V0SW5kZXgoYXNzZXQpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuYXNzZXRMaXN0LmluZGV4T2YoYXNzZXQpO1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gZXZlbnRUb1N0cmluZyh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoSW50ZXJzdGl0aWFsRXZlbnQsIFt7XG4gICAgICBrZXk6IFwiaWRlbnRpZmllclwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZS5pZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhcnREYXRlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVJhbmdlLnN0YXJ0RGF0ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhcnRUaW1lXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgLy8gUHJpbWFyeSBtZWRpYSB0aW1lbGluZSBzdGFydCB0aW1lXG4gICAgICAgIHZhciBzdGFydFRpbWUgPSB0aGlzLmRhdGVSYW5nZS5zdGFydFRpbWU7XG4gICAgICAgIGlmICh0aGlzLnNuYXBPcHRpb25zLm91dCkge1xuICAgICAgICAgIHZhciBmcmFnID0gdGhpcy5kYXRlUmFuZ2UudGFnQW5jaG9yO1xuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U25hcFRvRnJhZ21lbnRUaW1lKHN0YXJ0VGltZSwgZnJhZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydFRpbWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInN0YXJ0T2Zmc2V0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VlLnByZSA/IDAgOiB0aGlzLnN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhcnRJc0FsaWduZWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IDAgfHwgdGhpcy5zbmFwT3B0aW9ucy5vdXQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhZyA9IHRoaXMuZGF0ZVJhbmdlLnRhZ0FuY2hvcjtcbiAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gdGhpcy5kYXRlUmFuZ2Uuc3RhcnRUaW1lO1xuICAgICAgICAgIHZhciBzbmFwcGVkU3RhcnQgPSBnZXRTbmFwVG9GcmFnbWVudFRpbWUoc3RhcnRUaW1lLCBmcmFnKTtcbiAgICAgICAgICByZXR1cm4gc3RhcnRUaW1lIC0gc25hcHBlZFN0YXJ0IDwgMC4xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVzdW1wdGlvbk9mZnNldFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciByZXN1bWVPZmZzZXQgPSB0aGlzLnJlc3VtZU9mZnNldDtcbiAgICAgICAgdmFyIG9mZnNldCA9IGlzRmluaXRlTnVtYmVyKHJlc3VtZU9mZnNldCkgPyByZXN1bWVPZmZzZXQgOiB0aGlzLmR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcy5jdW11bGF0aXZlRHVyYXRpb24gKyBvZmZzZXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc3VtZVRpbWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAvLyBQcmltYXJ5IG1lZGlhIHRpbWVsaW5lIHJlc3VtcHRpb24gdGltZVxuICAgICAgICB2YXIgcmVzdW1lVGltZSA9IHRoaXMuc3RhcnRPZmZzZXQgKyB0aGlzLnJlc3VtcHRpb25PZmZzZXQ7XG4gICAgICAgIGlmICh0aGlzLnNuYXBPcHRpb25zLmluKSB7XG4gICAgICAgICAgdmFyIGZyYWcgPSB0aGlzLnJlc3VtZUFuY2hvcjtcbiAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgcmV0dXJuIGdldFNuYXBUb0ZyYWdtZW50VGltZShyZXN1bWVUaW1lLCBmcmFnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VtZVRpbWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFwcGVuZEluUGxhY2VcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRJblBsYWNlU3RhcnRlZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZEluUGxhY2VEaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY3VlLm9uY2UgJiYgIXRoaXMuY3VlLnByZSAmJlxuICAgICAgICAvLyBwcmVyb2xsIHN0YXJ0cyBhdCBzdGFydFBvc2l0aW9uIGJlZm9yZSBzdGFydFBvc2l0aW9uIGlzIGtub3duIChsaXZlKVxuICAgICAgICB0aGlzLnN0YXJ0SXNBbGlnbmVkICYmIChpc05hTih0aGlzLnBsYXlvdXRMaW1pdCkgJiYgaXNOYU4odGhpcy5yZXN1bWVPZmZzZXQpIHx8IHRoaXMucmVzdW1lT2Zmc2V0ICYmIHRoaXMuZHVyYXRpb24gJiYgTWF0aC5hYnModGhpcy5yZXN1bWVPZmZzZXQgLSB0aGlzLmR1cmF0aW9uKSA8IEFMSUdORURfRU5EX1RIUkVTSE9MRF9TRUNPTkRTKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRJblBsYWNlU3RhcnRlZCkge1xuICAgICAgICAgIHRoaXMucmVzZXRPblJlc3VtZSA9ICF2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRJblBsYWNlRGlzYWJsZWQgPSAhdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dGVuZGVkIHRpbWVsaW5lIHN0YXJ0IHRpbWVcbiAgICB9LCB7XG4gICAgICBrZXk6IFwidGltZWxpbmVTdGFydFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lbGluZVN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3RpbWVsaW5lU3RhcnQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgcGxheW91dExpbWl0ID0gdGhpcy5wbGF5b3V0TGltaXQ7XG4gICAgICAgIHZhciBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuX2R1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGVSYW5nZS5kdXJhdGlvbikge1xuICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5kYXRlUmFuZ2UuZHVyYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmRhdGVSYW5nZS5wbGFubmVkRHVyYXRpb24gfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKHBsYXlvdXRMaW1pdCkgJiYgcGxheW91dExpbWl0IDwgZHVyYXRpb24pIHtcbiAgICAgICAgICBkdXJhdGlvbiA9IHBsYXlvdXRMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHVyYXRpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3VlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVJhbmdlLmN1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidGltZWxpbmVPY2N1cGFuY3lcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5kYXRlUmFuZ2UuYXR0clsnWC1USU1FTElORS1PQ0NVUElFUyddID09PSAnUkFOR0UnKSB7XG4gICAgICAgICAgcmV0dXJuIFRpbWVsaW5lT2NjdXBhbmN5LlJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUaW1lbGluZU9jY3VwYW5jeS5Qb2ludDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3VwcGxlbWVudHNQcmltYXJ5XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVJhbmdlLmF0dHJbJ1gtVElNRUxJTkUtU1RZTEUnXSA9PT0gJ1BSSU1BUlknO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb250ZW50TWF5VmFyeVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVSYW5nZS5hdHRyWydYLUNPTlRFTlQtTUFZLVZBUlknXSAhPT0gJ05PJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXNzZXRVcmxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuYXR0clsnWC1BU1NFVC1VUkknXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXNzZXRMaXN0VXJsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVJhbmdlLmF0dHJbJ1gtQVNTRVQtTElTVCddO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJiYXNlVXJsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZS51cmw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFzc2V0TGlzdExvYWRlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0TGlzdC5sZW5ndGggPiAwIHx8IHRoaXMuYXNzZXRMaXN0UmVzcG9uc2UgIT09IG51bGw7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGdldFNuYXBUb0ZyYWdtZW50VGltZSh0aW1lLCBmcmFnKSB7XG4gICAgcmV0dXJuIHRpbWUgLSBmcmFnLnN0YXJ0IDwgZnJhZy5kdXJhdGlvbiAvIDIgJiYgIShNYXRoLmFicyh0aW1lIC0gKGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uKSkgPCBBTElHTkVEX0VORF9USFJFU0hPTERfU0VDT05EUykgPyBmcmFnLnN0YXJ0IDogZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW50ZXJzdGl0aWFsVXJsKHVyaSwgc2Vzc2lvbklkLCBiYXNlVXJsKSB7XG4gICAgdmFyIHVybCA9IG5ldyBzZWxmLlVSTCh1cmksIGJhc2VVcmwpO1xuICAgIGlmICh1cmwucHJvdG9jb2wgIT09ICdkYXRhOicpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3ByaW1hcnlfaWQnLCBzZXNzaW9uSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGZ1bmN0aW9uIGdldE5leHRBc3NldEluZGV4KGludGVyc3RpdGlhbCwgYXNzZXRMaXN0SW5kZXgpIHtcbiAgICB3aGlsZSAoKF9pbnRlcnN0aXRpYWwkYXNzZXRMaSA9IGludGVyc3RpdGlhbC5hc3NldExpc3RbKythc3NldExpc3RJbmRleF0pICE9IG51bGwgJiYgX2ludGVyc3RpdGlhbCRhc3NldExpLmVycm9yKSB7XG4gICAgICB2YXIgX2ludGVyc3RpdGlhbCRhc3NldExpO1xuICAgIH0gLyogbm8tb3AgKi9cbiAgICByZXR1cm4gYXNzZXRMaXN0SW5kZXg7XG4gIH1cbiAgZnVuY3Rpb24gZXZlbnRUb1N0cmluZyhpbnRlcnN0aXRpYWwpIHtcbiAgICByZXR1cm4gXCJbXFxcIlwiICsgaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIgKyBcIlxcXCIgXCIgKyAoaW50ZXJzdGl0aWFsLmN1ZS5wcmUgPyAnPHByZT4nIDogaW50ZXJzdGl0aWFsLmN1ZS5wb3N0ID8gJzxwb3N0PicgOiAnJykgKyBpbnRlcnN0aXRpYWwudGltZWxpbmVTdGFydC50b0ZpeGVkKDIpICsgXCItXCIgKyBpbnRlcnN0aXRpYWwucmVzdW1lVGltZS50b0ZpeGVkKDIpICsgXCJdXCI7XG4gIH1cbiAgZnVuY3Rpb24gZXZlbnRBc3NldFRvU3RyaW5nKGFzc2V0KSB7XG4gICAgdmFyIHN0YXJ0ID0gYXNzZXQudGltZWxpbmVTdGFydDtcbiAgICB2YXIgZHVyYXRpb24gPSBhc3NldC5kdXJhdGlvbiB8fCAwO1xuICAgIHJldHVybiBcIltcXFwiXCIgKyBhc3NldC5pZGVudGlmaWVyICsgXCJcXFwiIFwiICsgc3RhcnQudG9GaXhlZCgyKSArIFwiLVwiICsgKHN0YXJ0ICsgZHVyYXRpb24pLnRvRml4ZWQoMikgKyBcIl1cIjtcbiAgfVxuXG4gIHZhciBIbHNBc3NldFBsYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGxzQXNzZXRQbGF5ZXIoSGxzUGxheWVyQ2xhc3MsIHVzZXJDb25maWcsIGludGVyc3RpdGlhbCwgYXNzZXRJdGVtKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmludGVyc3RpdGlhbCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYXNzZXRJdGVtID0gdm9pZCAwO1xuICAgICAgdGhpcy50cmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5oYXNEZXRhaWxzID0gZmFsc2U7XG4gICAgICB0aGlzLm1lZGlhQXR0YWNoZWQgPSBudWxsO1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9idWZmZXJlZEVvc1RpbWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNoZWNrUGxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLnJlYWNoZWRQbGF5b3V0KF90aGlzLmN1cnJlbnRUaW1lKSAmJiBfdGhpcy5obHMpIHtcbiAgICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihFdmVudHMuUExBWU9VVF9MSU1JVF9SRUFDSEVELCB7fSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHMgPSBuZXcgSGxzUGxheWVyQ2xhc3ModXNlckNvbmZpZyk7XG4gICAgICB0aGlzLmludGVyc3RpdGlhbCA9IGludGVyc3RpdGlhbDtcbiAgICAgIHRoaXMuYXNzZXRJdGVtID0gYXNzZXRJdGVtO1xuICAgICAgdmFyIGRldGFpbHNMb2FkZWQgPSBmdW5jdGlvbiBkZXRhaWxzTG9hZGVkKCkge1xuICAgICAgICBfdGhpcy5oYXNEZXRhaWxzID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBobHMub25jZShFdmVudHMuTEVWRUxfTE9BREVELCBkZXRhaWxzTG9hZGVkKTtcbiAgICAgIGhscy5vbmNlKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIGRldGFpbHNMb2FkZWQpO1xuICAgICAgaGxzLm9uY2UoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgZGV0YWlsc0xvYWRlZCk7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgZnVuY3Rpb24gKG5hbWUsIF9yZWYpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gX3JlZi5tZWRpYTtcbiAgICAgICAgX3RoaXMucmVtb3ZlTWVkaWFMaXN0ZW5lcnMoKTtcbiAgICAgICAgX3RoaXMubWVkaWFBdHRhY2hlZCA9IG1lZGlhO1xuICAgICAgICB2YXIgZXZlbnQgPSBfdGhpcy5pbnRlcnN0aXRpYWw7XG4gICAgICAgIGlmIChldmVudC5wbGF5b3V0TGltaXQpIHtcbiAgICAgICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgX3RoaXMuY2hlY2tQbGF5b3V0KTtcbiAgICAgICAgICBpZiAoX3RoaXMuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkRW5kID0gX3RoaXMuYnVmZmVyZWRFbmQ7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5yZWFjaGVkUGxheW91dChidWZmZXJlZEVuZCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYnVmZmVyZWRFb3NUaW1lID0gYnVmZmVyZWRFbmQ7XG4gICAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUkVEX1RPX0VORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEhsc0Fzc2V0UGxheWVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ubG9hZFNvdXJjZSA9IGZ1bmN0aW9uIGxvYWRTb3VyY2UoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoIWhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWhscy51cmwpIHtcbiAgICAgICAgdmFyIHVyaSA9IHRoaXMuYXNzZXRJdGVtLnVyaTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmkgPSBnZXRJbnRlcnN0aXRpYWxVcmwodXJpLCBobHMuY29uZmlnLnByaW1hcnlTZXNzaW9uSWQgfHwgJycpLmhyZWY7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGVycm9yIHBhcnNpbmcgQVNTRVRfVVJJIG9yIGFkZGluZyBfSExTX3ByaW1hcnlfaWQgdG8gaXQuIFRoZVxuICAgICAgICAgIC8vIGlzc3VlIHNob3VsZCBzdXJmYWNlIGFzIGFuIElOVEVSU1RJVElBTF9BU1NFVF9FUlJPUiBsb2FkaW5nIHRoZSBhc3NldC5cbiAgICAgICAgfVxuICAgICAgICBobHMubG9hZFNvdXJjZSh1cmkpO1xuICAgICAgfSBlbHNlIGlmIChobHMubGV2ZWxzLmxlbmd0aCAmJiAhaGxzLnN0YXJ0ZWQpIHtcbiAgICAgICAgaGxzLnN0YXJ0TG9hZCgtMSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYnVmZmVyZWRJblBsYWNlVG9FbmQgPSBmdW5jdGlvbiBidWZmZXJlZEluUGxhY2VUb0VuZChtZWRpYSkge1xuICAgICAgdmFyIF90aGlzJGhscztcbiAgICAgIGlmICghdGhpcy5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgoX3RoaXMkaGxzID0gdGhpcy5obHMpICE9IG51bGwgJiYgX3RoaXMkaGxzLmJ1ZmZlcmVkVG9FbmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBkdXJhdGlvbiA9IE1hdGgubWluKHRoaXMuX2J1ZmZlcmVkRW9zVGltZSB8fCBJbmZpbml0eSwgdGhpcy5kdXJhdGlvbik7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgICAgdmFyIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgc3RhcnQsIDApO1xuICAgICAgdmFyIGJ1ZmZlcmVkRW5kID0gdGhpcy5nZXRBc3NldFRpbWUoYnVmZmVySW5mby5lbmQpO1xuICAgICAgcmV0dXJuIGJ1ZmZlcmVkRW5kID49IGR1cmF0aW9uIC0gMC4wMjtcbiAgICB9O1xuICAgIF9wcm90by5yZWFjaGVkUGxheW91dCA9IGZ1bmN0aW9uIHJlYWNoZWRQbGF5b3V0KHRpbWUpIHtcbiAgICAgIHZhciBpbnRlcnN0aXRpYWwgPSB0aGlzLmludGVyc3RpdGlhbDtcbiAgICAgIHZhciBwbGF5b3V0TGltaXQgPSBpbnRlcnN0aXRpYWwucGxheW91dExpbWl0O1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZmZzZXQgKyB0aW1lID49IHBsYXlvdXRMaW1pdDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRBc3NldFRpbWUgPSBmdW5jdGlvbiBnZXRBc3NldFRpbWUodGltZSkge1xuICAgICAgdmFyIHRpbWVsaW5lT2Zmc2V0ID0gdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoMCwgdGltZSAtIHRpbWVsaW5lT2Zmc2V0KSwgZHVyYXRpb24pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZU1lZGlhTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlTWVkaWFMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQXR0YWNoZWQ7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5idWZmZXJTbmFwU2hvdCgpO1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy5jaGVja1BsYXlvdXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmJ1ZmZlclNuYXBTaG90ID0gZnVuY3Rpb24gYnVmZmVyU25hcFNob3QoKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUF0dGFjaGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyRobHMyO1xuICAgICAgICBpZiAoKF90aGlzJGhsczIgPSB0aGlzLmhscykgIT0gbnVsbCAmJiBfdGhpcyRobHMyLmJ1ZmZlcmVkVG9FbmQpIHtcbiAgICAgICAgICB0aGlzLl9idWZmZXJlZEVvc1RpbWUgPSB0aGlzLmJ1ZmZlcmVkRW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKCk7XG4gICAgICBpZiAodGhpcy5obHMpIHtcbiAgICAgICAgdGhpcy5obHMuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy50cmFja3MgPSB0aGlzLm1lZGlhQXR0YWNoZWQgPSB0aGlzLmNoZWNrUGxheW91dCA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uYXR0YWNoTWVkaWEgPSBmdW5jdGlvbiBhdHRhY2hNZWRpYShkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMkaGxzMztcbiAgICAgIHRoaXMubG9hZFNvdXJjZSgpO1xuICAgICAgKF90aGlzJGhsczMgPSB0aGlzLmhscykgPT0gbnVsbCB8fCBfdGhpcyRobHMzLmF0dGFjaE1lZGlhKGRhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLmRldGFjaE1lZGlhID0gZnVuY3Rpb24gZGV0YWNoTWVkaWEoKSB7XG4gICAgICB2YXIgX3RoaXMkaGxzNDtcbiAgICAgIHRoaXMucmVtb3ZlTWVkaWFMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMubWVkaWFBdHRhY2hlZCA9IG51bGw7XG4gICAgICAoX3RoaXMkaGxzNCA9IHRoaXMuaGxzKSA9PSBudWxsIHx8IF90aGlzJGhsczQuZGV0YWNoTWVkaWEoKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXN1bWVCdWZmZXJpbmcgPSBmdW5jdGlvbiByZXN1bWVCdWZmZXJpbmcoKSB7XG4gICAgICB2YXIgX3RoaXMkaGxzNTtcbiAgICAgIChfdGhpcyRobHM1ID0gdGhpcy5obHMpID09IG51bGwgfHwgX3RoaXMkaGxzNS5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgICB9O1xuICAgIF9wcm90by5wYXVzZUJ1ZmZlcmluZyA9IGZ1bmN0aW9uIHBhdXNlQnVmZmVyaW5nKCkge1xuICAgICAgdmFyIF90aGlzJGhsczY7XG4gICAgICAoX3RoaXMkaGxzNiA9IHRoaXMuaGxzKSA9PSBudWxsIHx8IF90aGlzJGhsczYucGF1c2VCdWZmZXJpbmcoKTtcbiAgICB9O1xuICAgIF9wcm90by50cmFuc2Zlck1lZGlhID0gZnVuY3Rpb24gdHJhbnNmZXJNZWRpYSgpIHtcbiAgICAgIHZhciBfdGhpcyRobHM3O1xuICAgICAgdGhpcy5idWZmZXJTbmFwU2hvdCgpO1xuICAgICAgcmV0dXJuICgoX3RoaXMkaGxzNyA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzNy50cmFuc2Zlck1lZGlhKCkpIHx8IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXREZXRhaWxzID0gZnVuY3Rpb24gcmVzZXREZXRhaWxzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKGhscyAmJiB0aGlzLmhhc0RldGFpbHMpIHtcbiAgICAgICAgaGxzLnN0b3BMb2FkKCk7XG4gICAgICAgIHZhciBkZWxldGVEZXRhaWxzID0gZnVuY3Rpb24gZGVsZXRlRGV0YWlscyhvYmopIHtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlIG9iai5kZXRhaWxzO1xuICAgICAgICB9O1xuICAgICAgICBobHMubGV2ZWxzLmZvckVhY2goZGVsZXRlRGV0YWlscyk7XG4gICAgICAgIGhscy5hbGxBdWRpb1RyYWNrcy5mb3JFYWNoKGRlbGV0ZURldGFpbHMpO1xuICAgICAgICBobHMuYWxsU3VidGl0bGVUcmFja3MuZm9yRWFjaChkZWxldGVEZXRhaWxzKTtcbiAgICAgICAgdGhpcy5oYXNEZXRhaWxzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub24gPSBmdW5jdGlvbiBvbihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpcyRobHM4O1xuICAgICAgKF90aGlzJGhsczggPSB0aGlzLmhscykgPT0gbnVsbCB8fCBfdGhpcyRobHM4Lm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBfcHJvdG8ub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMkaGxzOTtcbiAgICAgIChfdGhpcyRobHM5ID0gdGhpcy5obHMpID09IG51bGwgfHwgX3RoaXMkaGxzOS5vbmNlKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzJGhsczA7XG4gICAgICAoX3RoaXMkaGxzMCA9IHRoaXMuaGxzKSA9PSBudWxsIHx8IF90aGlzJGhsczAub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBfdGhpcyRobHMxO1xuICAgICAgcmV0dXJuIFwiSGxzQXNzZXRQbGF5ZXI6IFwiICsgZXZlbnRBc3NldFRvU3RyaW5nKHRoaXMuYXNzZXRJdGVtKSArIFwiIFwiICsgKChfdGhpcyRobHMxID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMxLnNlc3Npb25JZCkgKyBcIiBcIiArICh0aGlzLmFwcGVuZEluUGxhY2UgPyAnYXBwZW5kLWluLXBsYWNlJyA6ICcnKTtcbiAgICB9O1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoSGxzQXNzZXRQbGF5ZXIsIFt7XG4gICAgICBrZXk6IFwiYXBwZW5kSW5QbGFjZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXN0cm95ZWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkaGxzMTA7XG4gICAgICAgIHJldHVybiAhKChfdGhpcyRobHMxMCA9IHRoaXMuaGxzKSAhPSBudWxsICYmIF90aGlzJGhsczEwLnVzZXJDb25maWcpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhc3NldElkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXRJdGVtLmlkZW50aWZpZXI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImludGVyc3RpdGlhbElkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXRJdGVtLnBhcmVudElkZW50aWZpZXI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1lZGlhXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJGhsczExO1xuICAgICAgICByZXR1cm4gKChfdGhpcyRobHMxMSA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzMTEubWVkaWEpIHx8IG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImJ1ZmZlcmVkRW5kXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSB8fCB0aGlzLm1lZGlhQXR0YWNoZWQ7XG4gICAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgICBpZiAodGhpcy5fYnVmZmVyZWRFb3NUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyZWRFb3NUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSwgMC4wMDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBc3NldFRpbWUoYnVmZmVySW5mby5lbmQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjdXJyZW50VGltZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgfHwgdGhpcy5tZWRpYUF0dGFjaGVkO1xuICAgICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXNzZXRUaW1lKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmFzc2V0SXRlbS5kdXJhdGlvbjtcbiAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwbGF5b3V0TGltaXQgPSB0aGlzLmludGVyc3RpdGlhbC5wbGF5b3V0TGltaXQ7XG4gICAgICAgIGlmIChwbGF5b3V0TGltaXQpIHtcbiAgICAgICAgICB2YXIgYXNzZXRQbGF5b3V0ID0gcGxheW91dExpbWl0IC0gdGhpcy5zdGFydE9mZnNldDtcbiAgICAgICAgICBpZiAoYXNzZXRQbGF5b3V0ID4gMCAmJiBhc3NldFBsYXlvdXQgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2V0UGxheW91dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1haW5pbmdcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGR1cmF0aW9uIC0gdGhpcy5jdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInN0YXJ0T2Zmc2V0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXRJdGVtLnN0YXJ0T2Zmc2V0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0aW1lbGluZU9mZnNldFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRobHMxMjtcbiAgICAgICAgcmV0dXJuICgoX3RoaXMkaGxzMTIgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczEyLmNvbmZpZy50aW1lbGluZU9mZnNldCkgfHwgMDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgdGltZWxpbmVPZmZzZXQgPSB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgICAgICBpZiAodmFsdWUgIT09IHRpbWVsaW5lT2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIGRpZmYgPSB2YWx1ZSAtIHRpbWVsaW5lT2Zmc2V0O1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+IDEgLyA5MDAwMCAmJiB0aGlzLmhscykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRGV0YWlscykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRpbWVsaW5lT2Zmc2V0IGFmdGVyIHBsYXlsaXN0cyBhcmUgbG9hZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5obHMuY29uZmlnLnRpbWVsaW5lT2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG5cbiAgdmFyIEFCVVRUSU5HX1RIUkVTSE9MRF9TRUNPTkRTID0gMC4wMzM7XG4gIHZhciBJbnRlcnN0aXRpYWxzU2NoZWR1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Mb2dnZXIpIHtcbiAgICBmdW5jdGlvbiBJbnRlcnN0aXRpYWxzU2NoZWR1bGUob25TY2hlZHVsZVVwZGF0ZSwgbG9nZ2VyKSB7XG4gICAgICB2YXIgX3RoaXM7XG4gICAgICBfdGhpcyA9IF9Mb2dnZXIuY2FsbCh0aGlzLCAnaW50ZXJzdGl0aWFscy1zY2hlZCcsIGxvZ2dlcikgfHwgdGhpcztcbiAgICAgIF90aGlzLm9uU2NoZWR1bGVVcGRhdGUgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5ldmVudE1hcCA9IHt9O1xuICAgICAgX3RoaXMuZXZlbnRzID0gbnVsbDtcbiAgICAgIF90aGlzLml0ZW1zID0gbnVsbDtcbiAgICAgIF90aGlzLmR1cmF0aW9ucyA9IHtcbiAgICAgICAgcHJpbWFyeTogMCxcbiAgICAgICAgcGxheW91dDogMCxcbiAgICAgICAgaW50ZWdyYXRlZDogMFxuICAgICAgfTtcbiAgICAgIF90aGlzLm9uU2NoZWR1bGVVcGRhdGUgPSBvblNjaGVkdWxlVXBkYXRlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHNMb29zZShJbnRlcnN0aXRpYWxzU2NoZWR1bGUsIF9Mb2dnZXIpO1xuICAgIHZhciBfcHJvdG8gPSBJbnRlcnN0aXRpYWxzU2NoZWR1bGUucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuZXZlbnRNYXAgPSB7fTtcbiAgICAgIHRoaXMuc2V0RHVyYXRpb25zKDAsIDAsIDApO1xuICAgICAgaWYgKHRoaXMuZXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGludGVyc3RpdGlhbCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcnN0aXRpYWwucmVzZXQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuaXRlbXMgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0RXJyb3JzSW5SYW5nZSA9IGZ1bmN0aW9uIHJlc2V0RXJyb3JzSW5SYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICBpZiAodGhpcy5ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIGludGVyc3RpdGlhbCkge1xuICAgICAgICAgIGlmIChzdGFydCA8PSBpbnRlcnN0aXRpYWwuc3RhcnRPZmZzZXQgJiYgZW5kID4gaW50ZXJzdGl0aWFsLnN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJzdGl0aWFsLmVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEV2ZW50ID0gZnVuY3Rpb24gZ2V0RXZlbnQoaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIGlkZW50aWZpZXIgPyB0aGlzLmV2ZW50TWFwW2lkZW50aWZpZXJdIHx8IG51bGwgOiBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmhhc0V2ZW50ID0gZnVuY3Rpb24gaGFzRXZlbnQoaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIGlkZW50aWZpZXIgaW4gdGhpcy5ldmVudE1hcDtcbiAgICB9O1xuICAgIF9wcm90by5maW5kSXRlbUluZGV4ID0gZnVuY3Rpb24gZmluZEl0ZW1JbmRleChpdGVtLCB0aW1lKSB7XG4gICAgICBpZiAoaXRlbS5ldmVudCkge1xuICAgICAgICAvLyBGaW5kIEV2ZW50IEl0ZW1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEV2ZW50SW5kZXgoaXRlbS5ldmVudC5pZGVudGlmaWVyKTtcbiAgICAgIH1cbiAgICAgIC8vIEZpbmQgUHJpbWFyeSBJdGVtXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGlmIChpdGVtLm5leHRFdmVudCkge1xuICAgICAgICBpbmRleCA9IHRoaXMuZmluZEV2ZW50SW5kZXgoaXRlbS5uZXh0RXZlbnQuaWRlbnRpZmllcikgLSAxO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnByZXZpb3VzRXZlbnQpIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLmZpbmRFdmVudEluZGV4KGl0ZW0ucHJldmlvdXNFdmVudC5pZGVudGlmaWVyKSArIDE7XG4gICAgICB9XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgIGlmICghaXRlbXNbaW5kZXhdKSB7XG4gICAgICAgICAgaWYgKHRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZSA9IGl0ZW0uc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4QXRUaW1lKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgcmV0dXJuIGluZGV4IG9mIGEgUHJpbWFyeSBJdGVtXG4gICAgICAgIHdoaWxlIChpbmRleCA+PSAwICYmIChfaXRlbXMkaW5kZXggPSBpdGVtc1tpbmRleF0pICE9IG51bGwgJiYgX2l0ZW1zJGluZGV4LmV2ZW50KSB7XG4gICAgICAgICAgdmFyIF9pdGVtcyRpbmRleDtcbiAgICAgICAgICAvLyBJZiBpbmRleCBmb3VuZCBpcyBhbiBpbnRlcnN0aXRpYWwgaXQgaXMgbm90IGEgdmFsaWQgcmVzdWx0IGFzIGl0IHNob3VsZCBoYXZlIGJlZW4gbWF0Y2hlZCB1cCB0b3BcbiAgICAgICAgICAvLyBkZWNyZW1lbnQgdW50aWwgcmVzdWx0IGlzIG5lZ2F0aXZlIChub3QgZm91bmQpIG9yIGEgcHJpbWFyeSBzZWdtZW50XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmRJdGVtSW5kZXhBdFRpbWUgPSBmdW5jdGlvbiBmaW5kSXRlbUluZGV4QXRUaW1lKHRpbWVsaW5lUG9zLCB0aW1lbGluZVR5cGUpIHtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0aW1lUmFuZ2UgPSBpdGVtc1tpXTtcbiAgICAgICAgICBpZiAodGltZWxpbmVUeXBlICYmIHRpbWVsaW5lVHlwZSAhPT0gJ3ByaW1hcnknKSB7XG4gICAgICAgICAgICB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VbdGltZWxpbmVUeXBlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRpbWVsaW5lUG9zID09PSB0aW1lUmFuZ2Uuc3RhcnQgfHwgdGltZWxpbmVQb3MgPiB0aW1lUmFuZ2Uuc3RhcnQgJiYgdGltZWxpbmVQb3MgPCB0aW1lUmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIF9wcm90by5maW5kSnVtcFJlc3RyaWN0ZWRJbmRleCA9IGZ1bmN0aW9uIGZpbmRKdW1wUmVzdHJpY3RlZEluZGV4KHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICBpZiAoIWl0ZW1zW2ldKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGV2ZW50ID0gaXRlbXNbaV0uZXZlbnQ7XG4gICAgICAgICAgaWYgKGV2ZW50ICE9IG51bGwgJiYgZXZlbnQucmVzdHJpY3Rpb25zLmp1bXAgJiYgIWV2ZW50LmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmRFdmVudEluZGV4ID0gZnVuY3Rpb24gZmluZEV2ZW50SW5kZXgoaWRlbnRpZmllcikge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgIGlmIChpdGVtcykge1xuICAgICAgICBmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgdmFyIF9pdGVtcyRpJGV2ZW50O1xuICAgICAgICAgIGlmICgoKF9pdGVtcyRpJGV2ZW50ID0gaXRlbXNbaV0uZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfaXRlbXMkaSRldmVudC5pZGVudGlmaWVyKSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBfcHJvdG8uZmluZEFzc2V0SW5kZXggPSBmdW5jdGlvbiBmaW5kQXNzZXRJbmRleChldmVudCwgdGltZWxpbmVQb3MpIHtcbiAgICAgIHZhciBhc3NldExpc3QgPSBldmVudC5hc3NldExpc3Q7XG4gICAgICB2YXIgbGVuZ3RoID0gYXNzZXRMaXN0Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgYXNzZXQgPSBhc3NldExpc3RbaV07XG4gICAgICAgICAgaWYgKCFhc3NldC5lcnJvcikge1xuICAgICAgICAgICAgdmFyIHRpbWVsaW5lU3RhcnQgPSBhc3NldC50aW1lbGluZVN0YXJ0O1xuICAgICAgICAgICAgaWYgKHRpbWVsaW5lUG9zID09PSB0aW1lbGluZVN0YXJ0IHx8IHRpbWVsaW5lUG9zID4gdGltZWxpbmVTdGFydCAmJiAodGltZWxpbmVQb3MgPCB0aW1lbGluZVN0YXJ0ICsgKGFzc2V0LmR1cmF0aW9uIHx8IDApIHx8IGkgPT09IGxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBfcHJvdG8ucGFyc2VJbnRlcnN0aXRpYWxEYXRlUmFuZ2VzID0gZnVuY3Rpb24gcGFyc2VJbnRlcnN0aXRpYWxEYXRlUmFuZ2VzKG1lZGlhU2VsZWN0aW9uLCBlbmFibGVBcHBlbmRJblBsYWNlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBkZXRhaWxzID0gbWVkaWFTZWxlY3Rpb24ubWFpbi5kZXRhaWxzO1xuICAgICAgdmFyIGRhdGVSYW5nZXMgPSBkZXRhaWxzLmRhdGVSYW5nZXM7XG4gICAgICB2YXIgcHJldmlvdXNJbnRlcnN0aXRpYWxFdmVudHMgPSB0aGlzLmV2ZW50cztcbiAgICAgIHZhciBpbnRlcnN0aXRpYWxFdmVudHMgPSB0aGlzLnBhcnNlRGF0ZVJhbmdlcyhkYXRlUmFuZ2VzLCB7XG4gICAgICAgIHVybDogZGV0YWlscy51cmxcbiAgICAgIH0sIGVuYWJsZUFwcGVuZEluUGxhY2UpO1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZXMpO1xuICAgICAgdmFyIHJlbW92ZWRJbnRlcnN0aXRpYWxzID0gcHJldmlvdXNJbnRlcnN0aXRpYWxFdmVudHMgPyBwcmV2aW91c0ludGVyc3RpdGlhbEV2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiAhaWRzLmluY2x1ZGVzKGV2ZW50LmlkZW50aWZpZXIpO1xuICAgICAgfSkgOiBbXTtcbiAgICAgIGlmIChpbnRlcnN0aXRpYWxFdmVudHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHByZS1yb2xscywgcG9zdC1yb2xscywgYW5kIGV2ZW50cyB3aXRoIHRoZSBzYW1lIHN0YXJ0IHRpbWUgYXJlIHBsYXllZCBpbiBwbGF5bGlzdCB0YWcgb3JkZXJcbiAgICAgICAgLy8gYWxsIG90aGVyIGV2ZW50cyBhcmUgb3JkZXJlZCBieSBzdGFydCB0aW1lXG4gICAgICAgIGludGVyc3RpdGlhbEV2ZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgdmFyIGFQcmUgPSBhLmN1ZS5wcmU7XG4gICAgICAgICAgdmFyIGFQb3N0ID0gYS5jdWUucG9zdDtcbiAgICAgICAgICB2YXIgYlByZSA9IGIuY3VlLnByZTtcbiAgICAgICAgICB2YXIgYlBvc3QgPSBiLmN1ZS5wb3N0O1xuICAgICAgICAgIGlmIChhUHJlICYmICFiUHJlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiUHJlICYmICFhUHJlKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFQb3N0ICYmICFiUG9zdCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiUG9zdCAmJiAhYVBvc3QpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFhUHJlICYmICFiUHJlICYmICFhUG9zdCAmJiAhYlBvc3QpIHtcbiAgICAgICAgICAgIHZhciBzdGFydEEgPSBhLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIHZhciBzdGFydEIgPSBiLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIGlmIChzdGFydEEgIT09IHN0YXJ0Qikge1xuICAgICAgICAgICAgICByZXR1cm4gc3RhcnRBIC0gc3RhcnRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYS5kYXRlUmFuZ2UudGFnT3JkZXIgLSBiLmRhdGVSYW5nZS50YWdPcmRlcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmV2ZW50cyA9IGludGVyc3RpdGlhbEV2ZW50cztcblxuICAgICAgLy8gQ2xlYXIgcmVtb3ZlZCBEYXRlUmFuZ2VzIGZyb20gYnVmZmVyZWQgbGlzdCAoa2lsbHMgcGxheWJhY2sgb2YgYWN0aXZlIEludGVyc3RpdGlhbHMpXG4gICAgICByZW1vdmVkSW50ZXJzdGl0aWFscy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgX3RoaXMyLnJlbW92ZUV2ZW50KGludGVyc3RpdGlhbCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlU2NoZWR1bGUobWVkaWFTZWxlY3Rpb24sIHJlbW92ZWRJbnRlcnN0aXRpYWxzKTtcbiAgICB9O1xuICAgIF9wcm90by51cGRhdGVTY2hlZHVsZSA9IGZ1bmN0aW9uIHVwZGF0ZVNjaGVkdWxlKG1lZGlhU2VsZWN0aW9uLCByZW1vdmVkSW50ZXJzdGl0aWFscywgZm9yY2VVcGRhdGUpIHtcbiAgICAgIGlmIChyZW1vdmVkSW50ZXJzdGl0aWFscyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJlbW92ZWRJbnRlcnN0aXRpYWxzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoZm9yY2VVcGRhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBmb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IFtdO1xuICAgICAgaWYgKGV2ZW50cy5sZW5ndGggfHwgcmVtb3ZlZEludGVyc3RpdGlhbHMubGVuZ3RoIHx8IHRoaXMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YXIgY3VycmVudEl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgICAgdmFyIHVwZGF0ZWRJdGVtcyA9IHRoaXMucGFyc2VTY2hlZHVsZShldmVudHMsIG1lZGlhU2VsZWN0aW9uKTtcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBmb3JjZVVwZGF0ZSB8fCByZW1vdmVkSW50ZXJzdGl0aWFscy5sZW5ndGggfHwgKGN1cnJlbnRJdGVtcyA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudEl0ZW1zLmxlbmd0aCkgIT09IHVwZGF0ZWRJdGVtcy5sZW5ndGggfHwgdXBkYXRlZEl0ZW1zLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoaXRlbS5wbGF5b3V0LnN0YXJ0IC0gY3VycmVudEl0ZW1zW2ldLnBsYXlvdXQuc3RhcnQpID4gMC4wMDUgfHwgTWF0aC5hYnMoaXRlbS5wbGF5b3V0LmVuZCAtIGN1cnJlbnRJdGVtc1tpXS5wbGF5b3V0LmVuZCkgPiAwLjAwNTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgdGhpcy5pdGVtcyA9IHVwZGF0ZWRJdGVtcztcbiAgICAgICAgICAvLyBjYWxsIGludGVyc3RpdGlhbHMtY29udHJvbGxlciBvblNjaGVkdWxlVXBkYXRlZCgpXG4gICAgICAgICAgdGhpcy5vblNjaGVkdWxlVXBkYXRlKHJlbW92ZWRJbnRlcnN0aXRpYWxzLCBjdXJyZW50SXRlbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucGFyc2VEYXRlUmFuZ2VzID0gZnVuY3Rpb24gcGFyc2VEYXRlUmFuZ2VzKGRhdGVSYW5nZXMsIGJhc2VEYXRhLCBlbmFibGVBcHBlbmRJblBsYWNlKSB7XG4gICAgICB2YXIgaW50ZXJzdGl0aWFsRXZlbnRzID0gW107XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBkYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgICAgaWYgKGRhdGVSYW5nZS5pc0ludGVyc3RpdGlhbCkge1xuICAgICAgICAgIHZhciBpbnRlcnN0aXRpYWwgPSB0aGlzLmV2ZW50TWFwW2lkXTtcbiAgICAgICAgICBpZiAoaW50ZXJzdGl0aWFsKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgSW50ZXJzdGl0aWFsRXZlbnQgYWxyZWFkeSBwYXJzZWQgYW5kIG1hcHBlZFxuICAgICAgICAgICAgLy8gVGhpcyByZXRhaW5zIGFscmVhZHkgbG9hZGVkIGR1cmF0aW9uIGFuZCBsb2FkZWQgYXNzZXQgbGlzdCBpbmZvXG4gICAgICAgICAgICBpbnRlcnN0aXRpYWwuc2V0RGF0ZVJhbmdlKGRhdGVSYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVyc3RpdGlhbCA9IG5ldyBJbnRlcnN0aXRpYWxFdmVudChkYXRlUmFuZ2UsIGJhc2VEYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYXBbaWRdID0gaW50ZXJzdGl0aWFsO1xuICAgICAgICAgICAgaWYgKGVuYWJsZUFwcGVuZEluUGxhY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlID0gZW5hYmxlQXBwZW5kSW5QbGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW50ZXJzdGl0aWFsRXZlbnRzLnB1c2goaW50ZXJzdGl0aWFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGludGVyc3RpdGlhbEV2ZW50cztcbiAgICB9O1xuICAgIF9wcm90by5wYXJzZVNjaGVkdWxlID0gZnVuY3Rpb24gcGFyc2VTY2hlZHVsZShpbnRlcnN0aXRpYWxFdmVudHMsIG1lZGlhU2VsZWN0aW9uKSB7XG4gICAgICB2YXIgc2NoZWR1bGUgPSBbXTtcbiAgICAgIHZhciBkZXRhaWxzID0gbWVkaWFTZWxlY3Rpb24ubWFpbi5kZXRhaWxzO1xuICAgICAgdmFyIHByaW1hcnlEdXJhdGlvbiA9IGRldGFpbHMubGl2ZSA/IEluZmluaXR5IDogZGV0YWlscy5lZGdlO1xuICAgICAgdmFyIHBsYXlvdXREdXJhdGlvbiA9IDA7XG5cbiAgICAgIC8vIEZpbHRlciBldmVudHMgdGhhdCBoYXZlIGVycm9yZWQgZnJvbSB0aGUgc2NoZWR1bGUgKFByaW1hcnkgZmFsbGJhY2spXG4gICAgICBpbnRlcnN0aXRpYWxFdmVudHMgPSBpbnRlcnN0aXRpYWxFdmVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gIWV2ZW50LmVycm9yICYmICEoZXZlbnQuY3VlLm9uY2UgJiYgZXZlbnQuaGFzUGxheWVkKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGludGVyc3RpdGlhbEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVXBkYXRlIFNjaGVkdWxlXG4gICAgICAgIHRoaXMucmVzb2x2ZU9mZnNldHMoaW50ZXJzdGl0aWFsRXZlbnRzLCBtZWRpYVNlbGVjdGlvbik7XG5cbiAgICAgICAgLy8gUG9wdWxhdGUgU2NoZWR1bGUgd2l0aCBJbnRlcnN0aXRpYWwgRXZlbnQgYW5kIFByaW1hcnkgU2VnbWVudCBJdGVtc1xuICAgICAgICB2YXIgcHJpbWFyeVBvc2l0aW9uID0gMDtcbiAgICAgICAgdmFyIGludGVncmF0ZWRUaW1lID0gMDtcbiAgICAgICAgaW50ZXJzdGl0aWFsRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGludGVyc3RpdGlhbCwgaSkge1xuICAgICAgICAgIHZhciBwcmVyb2xsID0gaW50ZXJzdGl0aWFsLmN1ZS5wcmU7XG4gICAgICAgICAgdmFyIHBvc3Ryb2xsID0gaW50ZXJzdGl0aWFsLmN1ZS5wb3N0O1xuICAgICAgICAgIHZhciBwcmV2aW91c0V2ZW50ID0gaW50ZXJzdGl0aWFsRXZlbnRzW2kgLSAxXSB8fCBudWxsO1xuICAgICAgICAgIHZhciBhcHBlbmRJblBsYWNlID0gaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2U7XG4gICAgICAgICAgdmFyIGV2ZW50U3RhcnQgPSBwb3N0cm9sbCA/IHByaW1hcnlEdXJhdGlvbiA6IGludGVyc3RpdGlhbC5zdGFydE9mZnNldDtcbiAgICAgICAgICB2YXIgaW50ZXJzdGl0aWFsRHVyYXRpb24gPSBpbnRlcnN0aXRpYWwuZHVyYXRpb247XG4gICAgICAgICAgdmFyIHRpbWVsaW5lRHVyYXRpb24gPSBpbnRlcnN0aXRpYWwudGltZWxpbmVPY2N1cGFuY3kgPT09IFRpbWVsaW5lT2NjdXBhbmN5LlJhbmdlID8gaW50ZXJzdGl0aWFsRHVyYXRpb24gOiAwO1xuICAgICAgICAgIHZhciByZXN1bXB0aW9uT2Zmc2V0ID0gaW50ZXJzdGl0aWFsLnJlc3VtcHRpb25PZmZzZXQ7XG4gICAgICAgICAgdmFyIGluU2FtZVN0YXJ0VGltZVNlcXVlbmNlID0gKHByZXZpb3VzRXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzRXZlbnQuc3RhcnRUaW1lKSA9PT0gZXZlbnRTdGFydDtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBldmVudFN0YXJ0ICsgaW50ZXJzdGl0aWFsLmN1bXVsYXRpdmVEdXJhdGlvbjtcbiAgICAgICAgICB2YXIgZW5kID0gYXBwZW5kSW5QbGFjZSA/IHN0YXJ0ICsgaW50ZXJzdGl0aWFsRHVyYXRpb24gOiBldmVudFN0YXJ0ICsgcmVzdW1wdGlvbk9mZnNldDtcbiAgICAgICAgICBpZiAocHJlcm9sbCB8fCAhcG9zdHJvbGwgJiYgZXZlbnRTdGFydCA8PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVyb2xsIG9yIGluLXByb2dyZXNzIG1pZHJvbGxcbiAgICAgICAgICAgIHZhciBpbnRlZ3JhdGVkU3RhcnQgPSBpbnRlZ3JhdGVkVGltZTtcbiAgICAgICAgICAgIGludGVncmF0ZWRUaW1lICs9IHRpbWVsaW5lRHVyYXRpb247XG4gICAgICAgICAgICBpbnRlcnN0aXRpYWwudGltZWxpbmVTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgdmFyIHBsYXlvdXRTdGFydCA9IHBsYXlvdXREdXJhdGlvbjtcbiAgICAgICAgICAgIHBsYXlvdXREdXJhdGlvbiArPSBpbnRlcnN0aXRpYWxEdXJhdGlvbjtcbiAgICAgICAgICAgIHNjaGVkdWxlLnB1c2goe1xuICAgICAgICAgICAgICBldmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICBwbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHBsYXlvdXRTdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IHBsYXlvdXREdXJhdGlvblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGludGVncmF0ZWRTdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGludGVncmF0ZWRUaW1lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRTdGFydCA8PSBwcmltYXJ5RHVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICghaW5TYW1lU3RhcnRUaW1lU2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgdmFyIHNlZ21lbnREdXJhdGlvbiA9IGV2ZW50U3RhcnQgLSBwcmltYXJ5UG9zaXRpb247XG4gICAgICAgICAgICAgIC8vIERvIG5vdCBzY2hlZHVsZSBhIHByaW1hcnkgc2VnbWVudCBpZiBpbnRlcnN0aXRpYWxzIGFyZSBhYnV0dGluZyBieSBsZXNzIHRoYW4gQUJVVFRJTkdfVEhSRVNIT0xEX1NFQ09ORFNcbiAgICAgICAgICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA+IEFCVVRUSU5HX1RIUkVTSE9MRF9TRUNPTkRTKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeSBzZWdtZW50XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVsaW5lU3RhcnQgPSBwcmltYXJ5UG9zaXRpb247XG4gICAgICAgICAgICAgICAgdmFyIF9pbnRlZ3JhdGVkU3RhcnQgPSBpbnRlZ3JhdGVkVGltZTtcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdGVkVGltZSArPSBzZWdtZW50RHVyYXRpb247XG4gICAgICAgICAgICAgICAgdmFyIF9wbGF5b3V0U3RhcnQgPSBwbGF5b3V0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgcGxheW91dER1cmF0aW9uICs9IHNlZ21lbnREdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWFyeVNlZ21lbnQgPSB7XG4gICAgICAgICAgICAgICAgICBwcmV2aW91c0V2ZW50OiBpbnRlcnN0aXRpYWxFdmVudHNbaSAtIDFdIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICBuZXh0RXZlbnQ6IGludGVyc3RpdGlhbCxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aW1lbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgZW5kOiB0aW1lbGluZVN0YXJ0ICsgc2VnbWVudER1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgcGxheW91dDoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogX3BsYXlvdXRTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwbGF5b3V0RHVyYXRpb25cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBfaW50ZWdyYXRlZFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGludGVncmF0ZWRUaW1lXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZS5wdXNoKHByaW1hcnlTZWdtZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWdtZW50RHVyYXRpb24gPiAwICYmIHByZXZpb3VzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgcHJldmlvdXMgZXZlbnQgYHJlc3VtZVRpbWVgIChiYXNlZCBvbiBkdXJhdGlvbiBvciByZXN1bWVPZmZzZXQpIHNvIHRoYXQgaXQgZW5kcyBhbGlnbmVkIHdpdGggdGhpcyBvbmVcbiAgICAgICAgICAgICAgICBwcmV2aW91c0V2ZW50LmN1bXVsYXRpdmVEdXJhdGlvbiArPSBzZWdtZW50RHVyYXRpb247XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVbc2NoZWR1bGUubGVuZ3RoIC0gMV0uZW5kID0gZXZlbnRTdGFydDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWlkcm9sbCAvIHBvc3Ryb2xsXG4gICAgICAgICAgICBpZiAocG9zdHJvbGwpIHtcbiAgICAgICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcnN0aXRpYWwudGltZWxpbmVTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgdmFyIF9pbnRlZ3JhdGVkU3RhcnQyID0gaW50ZWdyYXRlZFRpbWU7XG4gICAgICAgICAgICBpbnRlZ3JhdGVkVGltZSArPSB0aW1lbGluZUR1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIF9wbGF5b3V0U3RhcnQyID0gcGxheW91dER1cmF0aW9uO1xuICAgICAgICAgICAgcGxheW91dER1cmF0aW9uICs9IGludGVyc3RpdGlhbER1cmF0aW9uO1xuICAgICAgICAgICAgc2NoZWR1bGUucHVzaCh7XG4gICAgICAgICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgIHBsYXlvdXQ6IHtcbiAgICAgICAgICAgICAgICBzdGFydDogX3BsYXlvdXRTdGFydDIsXG4gICAgICAgICAgICAgICAgZW5kOiBwbGF5b3V0RHVyYXRpb25cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaW50ZWdyYXRlZDoge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBfaW50ZWdyYXRlZFN0YXJ0MixcbiAgICAgICAgICAgICAgICBlbmQ6IGludGVncmF0ZWRUaW1lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbnRlcnN0aXRpYWwgc3RhcnRzIGFmdGVyIGVuZCBvZiBwcmltYXJ5IFZPRCAtIG5vdCBpbmNsdWRlZCBpbiBzY2hlZHVsZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdW1lVGltZSA9IGludGVyc3RpdGlhbC5yZXN1bWVUaW1lO1xuICAgICAgICAgIGlmIChwb3N0cm9sbCB8fCByZXN1bWVUaW1lID4gcHJpbWFyeUR1cmF0aW9uKSB7XG4gICAgICAgICAgICBwcmltYXJ5UG9zaXRpb24gPSBwcmltYXJ5RHVyYXRpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByaW1hcnlQb3NpdGlvbiA9IHJlc3VtZVRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByaW1hcnlQb3NpdGlvbiA8IHByaW1hcnlEdXJhdGlvbikge1xuICAgICAgICAgIHZhciBfc2NoZWR1bGU7XG4gICAgICAgICAgLy8gbGFzdCBwcmltYXJ5IHNlZ21lbnRcbiAgICAgICAgICB2YXIgdGltZWxpbmVTdGFydCA9IHByaW1hcnlQb3NpdGlvbjtcbiAgICAgICAgICB2YXIgaW50ZWdyYXRlZFN0YXJ0ID0gaW50ZWdyYXRlZFRpbWU7XG4gICAgICAgICAgdmFyIHNlZ21lbnREdXJhdGlvbiA9IHByaW1hcnlEdXJhdGlvbiAtIHByaW1hcnlQb3NpdGlvbjtcbiAgICAgICAgICBpbnRlZ3JhdGVkVGltZSArPSBzZWdtZW50RHVyYXRpb247XG4gICAgICAgICAgdmFyIHBsYXlvdXRTdGFydCA9IHBsYXlvdXREdXJhdGlvbjtcbiAgICAgICAgICBwbGF5b3V0RHVyYXRpb24gKz0gc2VnbWVudER1cmF0aW9uO1xuICAgICAgICAgIHNjaGVkdWxlLnB1c2goe1xuICAgICAgICAgICAgcHJldmlvdXNFdmVudDogKChfc2NoZWR1bGUgPSBzY2hlZHVsZVtzY2hlZHVsZS5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zY2hlZHVsZS5ldmVudCkgfHwgbnVsbCxcbiAgICAgICAgICAgIG5leHRFdmVudDogbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0OiBwcmltYXJ5UG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IHRpbWVsaW5lU3RhcnQgKyBzZWdtZW50RHVyYXRpb24sXG4gICAgICAgICAgICBwbGF5b3V0OiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBwbGF5b3V0U3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogcGxheW91dER1cmF0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZWdyYXRlZDoge1xuICAgICAgICAgICAgICBzdGFydDogaW50ZWdyYXRlZFN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGludGVncmF0ZWRUaW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXREdXJhdGlvbnMocHJpbWFyeUR1cmF0aW9uLCBwbGF5b3V0RHVyYXRpb24sIGludGVncmF0ZWRUaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGludGVyc3RpYWxzIC0gc2NoZWR1bGUgaXMgb25lIHByaW1hcnkgc2VnbWVudFxuICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICBzY2hlZHVsZS5wdXNoKHtcbiAgICAgICAgICBwcmV2aW91c0V2ZW50OiBudWxsLFxuICAgICAgICAgIG5leHRFdmVudDogbnVsbCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBwcmltYXJ5RHVyYXRpb24sXG4gICAgICAgICAgcGxheW91dDoge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwcmltYXJ5RHVyYXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIGludGVncmF0ZWQ6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJpbWFyeUR1cmF0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXREdXJhdGlvbnMocHJpbWFyeUR1cmF0aW9uLCBwcmltYXJ5RHVyYXRpb24sIHByaW1hcnlEdXJhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZWR1bGU7XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0RHVyYXRpb25zID0gZnVuY3Rpb24gc2V0RHVyYXRpb25zKHByaW1hcnksIHBsYXlvdXQsIGludGVncmF0ZWQpIHtcbiAgICAgIHRoaXMuZHVyYXRpb25zID0ge1xuICAgICAgICBwcmltYXJ5OiBwcmltYXJ5LFxuICAgICAgICBwbGF5b3V0OiBwbGF5b3V0LFxuICAgICAgICBpbnRlZ3JhdGVkOiBpbnRlZ3JhdGVkXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnJlc29sdmVPZmZzZXRzID0gZnVuY3Rpb24gcmVzb2x2ZU9mZnNldHMoaW50ZXJzdGl0aWFsRXZlbnRzLCBtZWRpYVNlbGVjdGlvbikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgZGV0YWlscyA9IG1lZGlhU2VsZWN0aW9uLm1haW4uZGV0YWlscztcbiAgICAgIHZhciBwcmltYXJ5RHVyYXRpb24gPSBkZXRhaWxzLmxpdmUgPyBJbmZpbml0eSA6IGRldGFpbHMuZWRnZTtcblxuICAgICAgLy8gRmlyc3QgcmVzb2x2ZSBjdW11bGF0aXZlIHJlc3VtcHRpb24gb2Zmc2V0cyBmb3IgSW50ZXJzdGl0aWFscyB0aGF0IHN0YXJ0IGF0IHRoZSBzYW1lIERhdGVUaW1lXG4gICAgICB2YXIgY3VtdWxhdGl2ZUR1cmF0aW9uID0gMDtcbiAgICAgIHZhciBsYXN0U2NoZWR1bGVkU3RhcnQgPSAtMTtcbiAgICAgIGludGVyc3RpdGlhbEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnN0aXRpYWwsIGkpIHtcbiAgICAgICAgdmFyIHByZXJvbGwgPSBpbnRlcnN0aXRpYWwuY3VlLnByZTtcbiAgICAgICAgdmFyIHBvc3Ryb2xsID0gaW50ZXJzdGl0aWFsLmN1ZS5wb3N0O1xuICAgICAgICB2YXIgZXZlbnRTdGFydCA9IHByZXJvbGwgPyAwIDogcG9zdHJvbGwgPyBwcmltYXJ5RHVyYXRpb24gOiBpbnRlcnN0aXRpYWwuc3RhcnRUaW1lO1xuICAgICAgICBfdGhpczMudXBkYXRlQXNzZXREdXJhdGlvbnMoaW50ZXJzdGl0aWFsKTtcblxuICAgICAgICAvLyBYLVJFU1VNRS1PRkZTRVQgdmFsdWVzIG9mIGludGVyc3RpdGlhbHMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWUgYXJlIGN1bXVsYXRpdmVcbiAgICAgICAgdmFyIGluU2FtZVN0YXJ0VGltZVNlcXVlbmNlID0gbGFzdFNjaGVkdWxlZFN0YXJ0ID09PSBldmVudFN0YXJ0O1xuICAgICAgICBpZiAoaW5TYW1lU3RhcnRUaW1lU2VxdWVuY2UpIHtcbiAgICAgICAgICBpbnRlcnN0aXRpYWwuY3VtdWxhdGl2ZUR1cmF0aW9uID0gY3VtdWxhdGl2ZUR1cmF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1bXVsYXRpdmVEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFN0YXJ0ID0gZXZlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBvc3Ryb2xsICYmIGludGVyc3RpdGlhbC5zbmFwT3B0aW9ucy5pbikge1xuICAgICAgICAgIC8vIEZJWE1FOiBJbmNsdWRlIGF1ZGlvIHBsYXlsaXN0IGluIHNuYXBwaW5nXG4gICAgICAgICAgaW50ZXJzdGl0aWFsLnJlc3VtZUFuY2hvciA9IGZpbmRGcmFnbWVudEJ5UFRTKG51bGwsIGRldGFpbHMuZnJhZ21lbnRzLCBpbnRlcnN0aXRpYWwuc3RhcnRPZmZzZXQgKyBpbnRlcnN0aXRpYWwucmVzdW1wdGlvbk9mZnNldCwgMCwgMCkgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHByaW1hcnkgZnJhZ21lbnRzIGFsaWduIHdpdGggcmVzdW1wdGlvbiBvZmZzZXQgYW5kIGRpc2FibGUgYXBwZW5kSW5QbGFjZSBpZiB0aGV5IGRvIG5vdFxuICAgICAgICBpZiAoaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UgJiYgIWludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlU3RhcnRlZCkge1xuICAgICAgICAgIHZhciBhbGlnbmVkU2VnbWVudFN0YXJ0ID0gX3RoaXMzLnByaW1hcnlDYW5SZXN1bWVJblBsYWNlQXQoaW50ZXJzdGl0aWFsLCBtZWRpYVNlbGVjdGlvbik7XG4gICAgICAgICAgaWYgKCFhbGlnbmVkU2VnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlICYmIGkgKyAxIDwgaW50ZXJzdGl0aWFsRXZlbnRzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGFidXR0aW5nIEludGVyc3RpdGlhbHMgbXVzdCB1c2UgdGhlIHNhbWUgTWVkaWFTb3VyY2Ugc3RyYXRlZ3ksIHRoaXMgYXBwbGllcyB0byBhbGwgd2hldGhlciBvciBub3QgdGhleSBhcmUgYmFjayB0byBiYWNrOlxuICAgICAgICAgIHZhciB0aW1lQmV0d2VlbiA9IGludGVyc3RpdGlhbEV2ZW50c1tpICsgMV0uc3RhcnRUaW1lIC0gaW50ZXJzdGl0aWFsRXZlbnRzW2ldLnJlc3VtZVRpbWU7XG4gICAgICAgICAgaWYgKHRpbWVCZXR3ZWVuIDwgQUJVVFRJTkdfVEhSRVNIT0xEX1NFQ09ORFMpIHtcbiAgICAgICAgICAgIGludGVyc3RpdGlhbEV2ZW50c1tpICsgMV0uYXBwZW5kSW5QbGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGludGVyc3RpdGlhbEV2ZW50c1tpICsgMV0uYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgICAgICBfdGhpczMud2FybihcIkNvdWxkIG5vdCBjaGFuZ2UgYXBwZW5kIHN0cmF0ZWd5IGZvciBhYnV0dGluZyBldmVudCBcIiArIGludGVyc3RpdGlhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBjdW11bGF0aXZlRHVyYXRpb24gZm9yIG5leHQgYWJ1dHRpbmcgaW50ZXJzdGl0aWFsIHdpdGggdGhlIHNhbWUgc3RhcnQgZGF0ZVxuICAgICAgICB2YXIgcmVzdW1lT2Zmc2V0ID0gaXNGaW5pdGVOdW1iZXIoaW50ZXJzdGl0aWFsLnJlc3VtZU9mZnNldCkgPyBpbnRlcnN0aXRpYWwucmVzdW1lT2Zmc2V0IDogaW50ZXJzdGl0aWFsLmR1cmF0aW9uO1xuICAgICAgICBjdW11bGF0aXZlRHVyYXRpb24gKz0gcmVzdW1lT2Zmc2V0O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJpbWFyeUNhblJlc3VtZUluUGxhY2VBdCA9IGZ1bmN0aW9uIHByaW1hcnlDYW5SZXN1bWVJblBsYWNlQXQoaW50ZXJzdGl0aWFsLCBtZWRpYVNlbGVjdGlvbikge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgcmVzdW1lVGltZSA9IGludGVyc3RpdGlhbC5yZXN1bWVUaW1lO1xuICAgICAgdmFyIHJlc3VtZXNJblBsYWNlQXQgPSBpbnRlcnN0aXRpYWwuc3RhcnRUaW1lICsgaW50ZXJzdGl0aWFsLnJlc3VtcHRpb25PZmZzZXQ7XG4gICAgICBpZiAoTWF0aC5hYnMocmVzdW1lVGltZSAtIHJlc3VtZXNJblBsYWNlQXQpID4gQUxJR05FRF9FTkRfVEhSRVNIT0xEX1NFQ09ORFMpIHtcbiAgICAgICAgdGhpcy5sb2coXCJcXFwiXCIgKyBpbnRlcnN0aXRpYWwuaWRlbnRpZmllciArIFwiXFxcIiByZXN1bXB0aW9uIFwiICsgcmVzdW1lVGltZSArIFwiIG5vdCBhbGlnbmVkIHdpdGggZXN0aW1hdGVkIHRpbWVsaW5lIGVuZCBcIiArIHJlc3VtZXNJblBsYWNlQXQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGxheWxpc3RzID0gT2JqZWN0LmtleXMobWVkaWFTZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuICFwbGF5bGlzdHMuc29tZShmdW5jdGlvbiAocGxheWxpc3RUeXBlKSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gbWVkaWFTZWxlY3Rpb25bcGxheWxpc3RUeXBlXS5kZXRhaWxzO1xuICAgICAgICB2YXIgcGxheWxpc3RFbmQgPSBkZXRhaWxzLmVkZ2U7XG4gICAgICAgIGlmIChyZXN1bWVUaW1lID49IHBsYXlsaXN0RW5kKSB7XG4gICAgICAgICAgLy8gTGl2ZSBwbGF5YmFjayAtIHJlc3VtcHRpb24gc2VnbWVudHMgYXJlIG5vdCB5ZXQgYXZhaWxhYmxlXG4gICAgICAgICAgX3RoaXM0LmxvZyhcIlxcXCJcIiArIGludGVyc3RpdGlhbC5pZGVudGlmaWVyICsgXCJcXFwiIHJlc3VtcHRpb24gXCIgKyByZXN1bWVUaW1lICsgXCIgcGFzdCBcIiArIHBsYXlsaXN0VHlwZSArIFwiIHBsYXlsaXN0IGVuZCBcIiArIHBsYXlsaXN0RW5kKTtcbiAgICAgICAgICAvLyBBc3N1bWUgYWxpZ25tZW50IGlzIHBvc3NpYmxlIChvciByZXNldCBjYW4gdGFrZSBwbGFjZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0RnJhZ21lbnQgPSBmaW5kRnJhZ21lbnRCeVBUUyhudWxsLCBkZXRhaWxzLmZyYWdtZW50cywgcmVzdW1lVGltZSk7XG4gICAgICAgIGlmICghc3RhcnRGcmFnbWVudCkge1xuICAgICAgICAgIF90aGlzNC5sb2coXCJcXFwiXCIgKyBpbnRlcnN0aXRpYWwuaWRlbnRpZmllciArIFwiXFxcIiByZXN1bXB0aW9uIFwiICsgcmVzdW1lVGltZSArIFwiIGRvZXMgbm90IGFsaWduIHdpdGggYW55IGZyYWdtZW50cyBpbiBcIiArIHBsYXlsaXN0VHlwZSArIFwiIHBsYXlsaXN0IChcIiArIGRldGFpbHMuZnJhZ1N0YXJ0ICsgXCItXCIgKyBkZXRhaWxzLmZyYWdtZW50RW5kICsgXCIpXCIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxvd2FuY2UgPSBwbGF5bGlzdFR5cGUgPT09ICdhdWRpbycgPyAwLjE3NSA6IDA7XG4gICAgICAgIHZhciBhbGlnbmVkV2l0aFNlZ21lbnQgPSBNYXRoLmFicyhzdGFydEZyYWdtZW50LnN0YXJ0IC0gcmVzdW1lVGltZSkgPCBBTElHTkVEX0VORF9USFJFU0hPTERfU0VDT05EUyArIGFsbG93YW5jZSB8fCBNYXRoLmFicyhzdGFydEZyYWdtZW50LmVuZCAtIHJlc3VtZVRpbWUpIDwgQUxJR05FRF9FTkRfVEhSRVNIT0xEX1NFQ09ORFMgKyBhbGxvd2FuY2U7XG4gICAgICAgIGlmICghYWxpZ25lZFdpdGhTZWdtZW50KSB7XG4gICAgICAgICAgX3RoaXM0LmxvZyhcIlxcXCJcIiArIGludGVyc3RpdGlhbC5pZGVudGlmaWVyICsgXCJcXFwiIHJlc3VtcHRpb24gXCIgKyByZXN1bWVUaW1lICsgXCIgbm90IGFsaWduZWQgd2l0aCBcIiArIHBsYXlsaXN0VHlwZSArIFwiIGZyYWdtZW50IGJvdW5kcyAoXCIgKyBzdGFydEZyYWdtZW50LnN0YXJ0ICsgXCItXCIgKyBzdGFydEZyYWdtZW50LmVuZCArIFwiIHNuOiBcIiArIHN0YXJ0RnJhZ21lbnQuc24gKyBcIiBjYzogXCIgKyBzdGFydEZyYWdtZW50LmNjICsgXCIpXCIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVwZGF0ZUFzc2V0RHVyYXRpb25zID0gZnVuY3Rpb24gdXBkYXRlQXNzZXREdXJhdGlvbnMoaW50ZXJzdGl0aWFsKSB7XG4gICAgICBpZiAoIWludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGV2ZW50U3RhcnQgPSBpbnRlcnN0aXRpYWwudGltZWxpbmVTdGFydDtcbiAgICAgIHZhciBzdW1EdXJhdGlvbiA9IDA7XG4gICAgICB2YXIgaGFzVW5rbm93bkR1cmF0aW9uID0gZmFsc2U7XG4gICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVyc3RpdGlhbC5hc3NldExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFzc2V0ID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdFtpXTtcbiAgICAgICAgdmFyIHRpbWVsaW5lU3RhcnQgPSBldmVudFN0YXJ0ICsgc3VtRHVyYXRpb247XG4gICAgICAgIGFzc2V0LnN0YXJ0T2Zmc2V0ID0gc3VtRHVyYXRpb247XG4gICAgICAgIGFzc2V0LnRpbWVsaW5lU3RhcnQgPSB0aW1lbGluZVN0YXJ0O1xuICAgICAgICBoYXNVbmtub3duRHVyYXRpb24gfHwgKGhhc1Vua25vd25EdXJhdGlvbiA9IGFzc2V0LmR1cmF0aW9uID09PSBudWxsKTtcbiAgICAgICAgaGFzRXJyb3JzIHx8IChoYXNFcnJvcnMgPSAhIWFzc2V0LmVycm9yKTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gYXNzZXQuZXJyb3IgPyAwIDogYXNzZXQuZHVyYXRpb24gfHwgMDtcbiAgICAgICAgc3VtRHVyYXRpb24gKz0gZHVyYXRpb247XG4gICAgICB9XG4gICAgICAvLyBVc2UgdGhlIHN1bSBvZiBrbm93biBkdXJhdGlvbnMgd2hlbiBpdCBpcyBncmVhdGVyIHRoYW4gdGhlIHN0YXRlZCBkdXJhdGlvblxuICAgICAgaWYgKGhhc1Vua25vd25EdXJhdGlvbiAmJiAhaGFzRXJyb3JzKSB7XG4gICAgICAgIGludGVyc3RpdGlhbC5kdXJhdGlvbiA9IE1hdGgubWF4KHN1bUR1cmF0aW9uLCBpbnRlcnN0aXRpYWwuZHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJzdGl0aWFsLmR1cmF0aW9uID0gc3VtRHVyYXRpb247XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChpbnRlcnN0aXRpYWwpIHtcbiAgICAgIGludGVyc3RpdGlhbC5yZXNldCgpO1xuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRNYXBbaW50ZXJzdGl0aWFsLmlkZW50aWZpZXJdO1xuICAgIH07XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJbnRlcnN0aXRpYWxzU2NoZWR1bGUsIFt7XG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICByZXR1cm4gaXRlbXMgPyBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS5lbmQgOiAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsZW5ndGhcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcyA/IHRoaXMuaXRlbXMubGVuZ3RoIDogMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXNzZXRJZEF0RW5kXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJGl0ZW1zO1xuICAgICAgICB2YXIgaW50ZXJzdGl0aWFsQXRFbmQgPSAoX3RoaXMkaXRlbXMgPSB0aGlzLml0ZW1zKSA9PSBudWxsIHx8IChfdGhpcyRpdGVtcyA9IF90aGlzJGl0ZW1zW3RoaXMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRpdGVtcy5ldmVudDtcbiAgICAgICAgaWYgKGludGVyc3RpdGlhbEF0RW5kKSB7XG4gICAgICAgICAgdmFyIGFzc2V0TGlzdCA9IGludGVyc3RpdGlhbEF0RW5kLmFzc2V0TGlzdDtcbiAgICAgICAgICB2YXIgYXNzZXRBdEVuZCA9IGFzc2V0TGlzdFthc3NldExpc3QubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGFzc2V0QXRFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3NldEF0RW5kLmlkZW50aWZpZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShMb2dnZXIpO1xuICBmdW5jdGlvbiBzZWdtZW50VG9TdHJpbmcoc2VnbWVudCkge1xuICAgIHJldHVybiBcIltcIiArIChzZWdtZW50LmV2ZW50ID8gJ1wiJyArIHNlZ21lbnQuZXZlbnQuaWRlbnRpZmllciArICdcIicgOiAncHJpbWFyeScpICsgXCI6IFwiICsgc2VnbWVudC5zdGFydC50b0ZpeGVkKDIpICsgXCItXCIgKyBzZWdtZW50LmVuZC50b0ZpeGVkKDIpICsgXCJdXCI7XG4gIH1cblxuICB2YXIgQXNzZXRMaXN0TG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3NldExpc3RMb2FkZXIoaGxzKSB7XG4gICAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQXNzZXRMaXN0TG9hZGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmhscyA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEFzc2V0TGlzdCA9IGZ1bmN0aW9uIGxvYWRBc3NldExpc3QoaW50ZXJzdGl0aWFsLCBobHNTdGFydE9mZnNldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBhc3NldExpc3RVcmwgPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0VXJsO1xuICAgICAgdmFyIHVybDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVybCA9IGdldEludGVyc3RpdGlhbFVybChhc3NldExpc3RVcmwsIHRoaXMuaGxzLnNlc3Npb25JZCwgaW50ZXJzdGl0aWFsLmJhc2VVcmwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdmFyIGVycm9yRGF0YSA9IHRoaXMuYXNzaWduQXNzZXRMaXN0RXJyb3IoaW50ZXJzdGl0aWFsLCBFcnJvckRldGFpbHMuQVNTRVRfTElTVF9MT0FEX0VSUk9SLCBlcnJvciwgYXNzZXRMaXN0VXJsKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yRGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChobHNTdGFydE9mZnNldCAmJiB1cmwucHJvdG9jb2wgIT09ICdkYXRhOicpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfc3RhcnRfb2Zmc2V0JywgJycgKyBobHNTdGFydE9mZnNldCk7XG4gICAgICB9XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgdmFyIExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgICB2YXIgbG9hZGVyID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICB1cmw6IHVybC5ocmVmXG4gICAgICB9O1xuICAgICAgdmFyIGxvYWRQb2xpY3kgPSBjb25maWcuaW50ZXJzdGl0aWFsQXNzZXRMaXN0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgbG9hZFBvbGljeTogbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMFxuICAgICAgfTtcbiAgICAgIHZhciBjYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICB2YXIgYXNzZXRMaXN0UmVzcG9uc2UgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgIHZhciBhc3NldHMgPSBhc3NldExpc3RSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogYXNzZXRMaXN0UmVzcG9uc2UuQVNTRVRTO1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhc3NldHMpKSB7XG4gICAgICAgICAgICB2YXIgX2Vycm9yRGF0YSA9IF90aGlzLmFzc2lnbkFzc2V0TGlzdEVycm9yKGludGVyc3RpdGlhbCwgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfUEFSU0lOR19FUlJPUiwgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlcnN0aXRpYWwgYXNzZXQgbGlzdFwiKSwgY29udGV4dC51cmwsIHN0YXRzLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIF9lcnJvckRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0UmVzcG9uc2UgPSBhc3NldExpc3RSZXNwb25zZTtcbiAgICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVNTRVRfTElTVF9MT0FERUQsIHtcbiAgICAgICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgICAgICBhc3NldExpc3RSZXNwb25zZTogYXNzZXRMaXN0UmVzcG9uc2UsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnJvciwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSB7XG4gICAgICAgICAgdmFyIGVycm9yRGF0YSA9IF90aGlzLmFzc2lnbkFzc2V0TGlzdEVycm9yKGludGVyc3RpdGlhbCwgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfTE9BRF9FUlJPUiwgbmV3IEVycm9yKFwiRXJyb3IgbG9hZGluZyBYLUFTU0VULUxJU1Q6IEhUVFAgc3RhdHVzIFwiICsgZXJyb3IuY29kZSArIFwiIFwiICsgZXJyb3IudGV4dCArIFwiIChcIiArIGNvbnRleHQudXJsICsgXCIpXCIpLCBjb250ZXh0LnVybCwgc3RhdHMsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yRGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogZnVuY3Rpb24gb25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIHZhciBlcnJvckRhdGEgPSBfdGhpcy5hc3NpZ25Bc3NldExpc3RFcnJvcihpbnRlcnN0aXRpYWwsIEVycm9yRGV0YWlscy5BU1NFVF9MSVNUX0xPQURfVElNRU9VVCwgbmV3IEVycm9yKFwiVGltZW91dCBsb2FkaW5nIFgtQVNTRVQtTElTVCAoXCIgKyBjb250ZXh0LnVybCArIFwiKVwiKSwgY29udGV4dC51cmwsIHN0YXRzLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgICAgX3RoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBjYWxsYmFja3MpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVNTRVRfTElTVF9MT0FESU5HLCB7XG4gICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9O1xuICAgIF9wcm90by5hc3NpZ25Bc3NldExpc3RFcnJvciA9IGZ1bmN0aW9uIGFzc2lnbkFzc2V0TGlzdEVycm9yKGludGVyc3RpdGlhbCwgZGV0YWlscywgZXJyb3IsIHVybCwgc3RhdHMsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICBpbnRlcnN0aXRpYWwuZXJyb3IgPSBlcnJvcjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBpbnRlcnN0aXRpYWw6IGludGVyc3RpdGlhbCxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQXNzZXRMaXN0TG9hZGVyO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gcGxheVdpdGhDYXRjaChtZWRpYSkge1xuICAgIHZhciBfbWVkaWEkcGxheTtcbiAgICBtZWRpYSA9PSBudWxsIHx8IChfbWVkaWEkcGxheSA9IG1lZGlhLnBsYXkoKSkgPT0gbnVsbCB8fCBfbWVkaWEkcGxheS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBuby1vcCAqL1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRpbWVsaW5lTWVzc2FnZShsYWJlbCwgdGltZSkge1xuICAgIHJldHVybiBcIltcIiArIGxhYmVsICsgXCJdIEFkdmFuY2luZyB0aW1lbGluZSBwb3NpdGlvbiB0byBcIiArIHRpbWU7XG4gIH1cbiAgdmFyIEludGVyc3RpdGlhbHNDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9nZ2VyKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIoaGxzLCBIbHNQbGF5ZXJDbGFzcykge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfTG9nZ2VyLmNhbGwodGhpcywgJ2ludGVyc3RpdGlhbHMnLCBobHMubG9nZ2VyKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuSGxzUGxheWVyQ2xhc3MgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5hc3NldExpc3RMb2FkZXIgPSB2b2lkIDA7XG4gICAgICAvLyBMYXN0IHVwZGF0ZWQgTGV2ZWxEZXRhaWxzXG4gICAgICBfdGhpcy5tZWRpYVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICBfdGhpcy5hbHRTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgLy8gTWVkaWEgYW5kIE1lZGlhU291cmNlL1NvdXJjZUJ1ZmZlcnNcbiAgICAgIF90aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIF90aGlzLmRldGFjaGVkRGF0YSA9IG51bGw7XG4gICAgICBfdGhpcy5yZXF1aXJlZFRyYWNrcyA9IG51bGw7XG4gICAgICAvLyBQdWJsaWMgSW50ZXJmYWNlIGZvciBJbnRlcnN0aXRpYWwgcGxheWJhY2sgc3RhdGUgYW5kIGNvbnRyb2xcbiAgICAgIF90aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgICAgLy8gSW50ZXJzdGl0aWFsIEFzc2V0IFBsYXllcnNcbiAgICAgIF90aGlzLnBsYXllclF1ZXVlID0gW107XG4gICAgICAvLyBUaW1lbGluZSBwb3NpdGlvbiB0cmFja2luZ1xuICAgICAgX3RoaXMuYnVmZmVyZWRQb3MgPSAtMTtcbiAgICAgIF90aGlzLnRpbWVsaW5lUG9zID0gLTE7XG4gICAgICAvLyBTY2hlZHVsZVxuICAgICAgX3RoaXMuc2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgICAvLyBTY2hlZHVsZSBwbGF5YmFjayBhbmQgYnVmZmVyaW5nIHN0YXRlXG4gICAgICBfdGhpcy5wbGF5aW5nSXRlbSA9IG51bGw7XG4gICAgICBfdGhpcy5idWZmZXJpbmdJdGVtID0gbnVsbDtcbiAgICAgIF90aGlzLndhaXRpbmdJdGVtID0gbnVsbDtcbiAgICAgIF90aGlzLmVuZGVkSXRlbSA9IG51bGw7XG4gICAgICBfdGhpcy5wbGF5aW5nQXNzZXQgPSBudWxsO1xuICAgICAgX3RoaXMuZW5kZWRBc3NldCA9IG51bGw7XG4gICAgICBfdGhpcy5idWZmZXJpbmdBc3NldCA9IG51bGw7XG4gICAgICBfdGhpcy5zaG91bGRQbGF5ID0gZmFsc2U7XG4gICAgICBfdGhpcy5vblBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnNob3VsZFBsYXkgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIF90aGlzLm9uUGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnNob3VsZFBsYXkgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5vblNlZWtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IF90aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IHVuZGVmaW5lZCB8fCBfdGhpcy5wbGF5YmFja0Rpc2FibGVkIHx8ICFfdGhpcy5zY2hlZHVsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmZiA9IGN1cnJlbnRUaW1lIC0gX3RoaXMudGltZWxpbmVQb3M7XG4gICAgICAgIHZhciByb3VuZGluZ0Vycm9yID0gTWF0aC5hYnMoZGlmZikgPCAxIC8gNzA1NjAwMDAwOyAvLyBvbmUgZmxpY2tcbiAgICAgICAgaWYgKHJvdW5kaW5nRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhY2t3YXJkU2VlayA9IGRpZmYgPD0gLTAuMDE7XG4gICAgICAgIF90aGlzLnRpbWVsaW5lUG9zID0gY3VycmVudFRpbWU7XG4gICAgICAgIF90aGlzLmJ1ZmZlcmVkUG9zID0gY3VycmVudFRpbWU7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgc2Vla2luZyBvdXQgb2YgYW4gaXRlbVxuICAgICAgICB2YXIgcGxheWluZ0l0ZW0gPSBfdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgICAgaWYgKCFwbGF5aW5nSXRlbSkge1xuICAgICAgICAgIF90aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYWNrd2FyZFNlZWspIHtcbiAgICAgICAgICB2YXIgcmVzZXRDb3VudCA9IF90aGlzLnNjaGVkdWxlLnJlc2V0RXJyb3JzSW5SYW5nZShjdXJyZW50VGltZSwgY3VycmVudFRpbWUgLSBkaWZmKTtcbiAgICAgICAgICBpZiAocmVzZXRDb3VudCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlU2NoZWR1bGUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgICAgIGlmIChiYWNrd2FyZFNlZWsgJiYgY3VycmVudFRpbWUgPCBwbGF5aW5nSXRlbS5zdGFydCB8fCBjdXJyZW50VGltZSA+PSBwbGF5aW5nSXRlbS5lbmQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgdmFyIHBsYXlpbmdJbmRleCA9IF90aGlzLmZpbmRJdGVtSW5kZXgocGxheWluZ0l0ZW0pO1xuICAgICAgICAgIHZhciBzY2hlZHVsZUluZGV4ID0gX3RoaXMuc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZShjdXJyZW50VGltZSk7XG4gICAgICAgICAgaWYgKHNjaGVkdWxlSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBzY2hlZHVsZUluZGV4ID0gcGxheWluZ0luZGV4ICsgKGJhY2t3YXJkU2VlayA/IC0xIDogMSk7XG4gICAgICAgICAgICBfdGhpcy5sb2coXCJzZWVrZWQgXCIgKyAoYmFja3dhcmRTZWVrID8gJ2JhY2sgJyA6ICcnKSArIFwidG8gcG9zaXRpb24gbm90IGNvdmVyZWQgYnkgc2NoZWR1bGUgXCIgKyBjdXJyZW50VGltZSArIFwiIChyZXNvbHZpbmcgZnJvbSBcIiArIHBsYXlpbmdJbmRleCArIFwiIHRvIFwiICsgc2NoZWR1bGVJbmRleCArIFwiKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfdGhpcy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkgJiYgKF90aGlzJG1lZGlhID0gX3RoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEucGF1c2VkKSB7XG4gICAgICAgICAgICBfdGhpcy5zaG91bGRQbGF5ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmFja3dhcmRTZWVrKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhbiBJbnRlcnN0aXRpYWwgYmV0d2VlbiB0aGUgY3VycmVudCBpdGVtIGFuZCB0YXJnZXQgaXRlbSBoYXMgYW4gWC1SRVNUUklDVCBKVU1QIHJlc3RyaWN0aW9uXG4gICAgICAgICAgICBpZiAoc2NoZWR1bGVJbmRleCA+IHBsYXlpbmdJbmRleCkge1xuICAgICAgICAgICAgICB2YXIganVtcEluZGV4ID0gX3RoaXMuc2NoZWR1bGUuZmluZEp1bXBSZXN0cmljdGVkSW5kZXgocGxheWluZ0luZGV4ICsgMSwgc2NoZWR1bGVJbmRleCk7XG4gICAgICAgICAgICAgIGlmIChqdW1wSW5kZXggPiBwbGF5aW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKGp1bXBJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oc2NoZWR1bGVJbmRleCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHNlZWtpbmcgb3V0IG9mIGFuIGFzc2V0IChhc3N1bWVzIHNhbWUgaXRlbSBmb2xsb3dpbmcgYWJvdmUgY2hlY2spXG4gICAgICAgIHZhciBwbGF5aW5nQXNzZXQgPSBfdGhpcy5wbGF5aW5nQXNzZXQ7XG4gICAgICAgIGlmICghcGxheWluZ0Fzc2V0KSB7XG4gICAgICAgICAgLy8gcmVzdGFydCBJbnRlcnN0aXRpYWwgYXQgZW5kXG4gICAgICAgICAgaWYgKF90aGlzLnBsYXlpbmdMYXN0SXRlbSAmJiBfdGhpcy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkpIHtcbiAgICAgICAgICAgIHZhciByZXN0YXJ0QXNzZXQgPSBwbGF5aW5nSXRlbS5ldmVudC5hc3NldExpc3RbMF07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKHJlc3RhcnRBc3NldCkge1xuICAgICAgICAgICAgICBfdGhpcy5lbmRlZEl0ZW0gPSBfdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgICAgICAgICAgX3RoaXMucGxheWluZ0l0ZW0gPSBudWxsO1xuICAgICAgICAgICAgICBfdGhpcy5zZXRTY2hlZHVsZVRvQXNzZXRBdFRpbWUoY3VycmVudFRpbWUsIHJlc3RhcnRBc3NldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBwbGF5aW5nQXNzZXQudGltZWxpbmVTdGFydDtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gcGxheWluZ0Fzc2V0LmR1cmF0aW9uIHx8IDA7XG4gICAgICAgIGlmIChiYWNrd2FyZFNlZWsgJiYgY3VycmVudFRpbWUgPCBzdGFydCB8fCBjdXJyZW50VGltZSA+PSBzdGFydCArIGR1cmF0aW9uKSB7XG4gICAgICAgICAgdmFyIF9wbGF5aW5nSXRlbSRldmVudDtcbiAgICAgICAgICBpZiAoKF9wbGF5aW5nSXRlbSRldmVudCA9IHBsYXlpbmdJdGVtLmV2ZW50KSAhPSBudWxsICYmIF9wbGF5aW5nSXRlbSRldmVudC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gU291cmNlQnVmZmVyKHMpIHRvIHByaW1hcnkgcGxheWVyIGFuZCBmbHVzaFxuICAgICAgICAgICAgX3RoaXMuY2xlYXJBc3NldFBsYXllcnMocGxheWluZ0l0ZW0uZXZlbnQsIHBsYXlpbmdJdGVtKTtcbiAgICAgICAgICAgIF90aGlzLmZsdXNoRnJvbnRCdWZmZXIoY3VycmVudFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5zZXRTY2hlZHVsZVRvQXNzZXRBdFRpbWUoY3VycmVudFRpbWUsIHBsYXlpbmdBc3NldCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy5vblRpbWV1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IF90aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IHVuZGVmaW5lZCB8fCBfdGhpcy5wbGF5YmFja0Rpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBhbGxvdyB0aW1ldXBkYXRlIHRvIGFkdmFuY2UgcHJpbWFyeSBwb3NpdGlvbiwgc2Vla2luZyBpcyB1c2VkIGZvciBqdW1waW5nIGJhY2tcbiAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyBwcmltYXJ5UG9zIGZyb20gYmVpbmcgcmVzZXQgdG8gMCBhZnRlciByZS1hdHRhY2hcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lID4gX3RoaXMudGltZWxpbmVQb3MpIHtcbiAgICAgICAgICBfdGhpcy50aW1lbGluZVBvcyA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+IF90aGlzLmJ1ZmZlcmVkUG9zKSB7XG4gICAgICAgICAgICBfdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBwbGF5YmFjayBoYXMgZW50ZXJlZCB0aGUgbmV4dCBpdGVtXG4gICAgICAgIHZhciBwbGF5aW5nSXRlbSA9IF90aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgICBpZiAoIXBsYXlpbmdJdGVtIHx8IF90aGlzLnBsYXlpbmdMYXN0SXRlbSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFRpbWUgPj0gcGxheWluZ0l0ZW0uZW5kKSB7XG4gICAgICAgICAgX3RoaXMudGltZWxpbmVQb3MgPSBwbGF5aW5nSXRlbS5lbmQ7XG4gICAgICAgICAgdmFyIHBsYXlpbmdJbmRleCA9IF90aGlzLmZpbmRJdGVtSW5kZXgocGxheWluZ0l0ZW0pO1xuICAgICAgICAgIF90aGlzLnNldFNjaGVkdWxlUG9zaXRpb24ocGxheWluZ0luZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgcGxheWJhY2sgaGFzIGVudGVyZWQgdGhlIG5leHQgYXNzZXRcbiAgICAgICAgdmFyIHBsYXlpbmdBc3NldCA9IF90aGlzLnBsYXlpbmdBc3NldDtcbiAgICAgICAgaWYgKCFwbGF5aW5nQXNzZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZCA9IHBsYXlpbmdBc3NldC50aW1lbGluZVN0YXJ0ICsgKHBsYXlpbmdBc3NldC5kdXJhdGlvbiB8fCAwKTtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lID49IGVuZCkge1xuICAgICAgICAgIF90aGlzLnNldFNjaGVkdWxlVG9Bc3NldEF0VGltZShjdXJyZW50VGltZSwgcGxheWluZ0Fzc2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8vIFNjaGVkdWxlIHVwZGF0ZSBjYWxsYmFja1xuICAgICAgX3RoaXMub25TY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChyZW1vdmVkSW50ZXJzdGl0aWFscywgcHJldmlvdXNJdGVtcykge1xuICAgICAgICB2YXIgc2NoZWR1bGUgPSBfdGhpcy5zY2hlZHVsZTtcbiAgICAgICAgaWYgKCFzY2hlZHVsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGxheWluZ0l0ZW0gPSBfdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgICAgdmFyIGludGVyc3RpdGlhbEV2ZW50cyA9IHNjaGVkdWxlLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgdmFyIHNjaGVkdWxlSXRlbXMgPSBzY2hlZHVsZS5pdGVtcyB8fCBbXTtcbiAgICAgICAgdmFyIGR1cmF0aW9ucyA9IHNjaGVkdWxlLmR1cmF0aW9ucztcbiAgICAgICAgdmFyIHJlbW92ZWRJZHMgPSByZW1vdmVkSW50ZXJzdGl0aWFscy5tYXAoZnVuY3Rpb24gKGludGVyc3RpdGlhbCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcnN0aXRpYWwuaWRlbnRpZmllcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbnRlcnN0aXRpYWxzVXBkYXRlZCA9ICEhKGludGVyc3RpdGlhbEV2ZW50cy5sZW5ndGggfHwgcmVtb3ZlZElkcy5sZW5ndGgpO1xuICAgICAgICBpZiAoaW50ZXJzdGl0aWFsc1VwZGF0ZWQgfHwgcHJldmlvdXNJdGVtcykge1xuICAgICAgICAgIF90aGlzLmxvZyhcIklOVEVSU1RJVElBTFNfVVBEQVRFRCAoXCIgKyBpbnRlcnN0aXRpYWxFdmVudHMubGVuZ3RoICsgXCIpOiBcIiArIGludGVyc3RpdGlhbEV2ZW50cyArIFwiXFxuU2NoZWR1bGU6IFwiICsgc2NoZWR1bGVJdGVtcy5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnRUb1N0cmluZyhzZWcpO1xuICAgICAgICAgIH0pICsgXCIgcG9zOiBcIiArIF90aGlzLnRpbWVsaW5lUG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICBfdGhpcy5sb2coXCJSZW1vdmVkIGV2ZW50cyBcIiArIHJlbW92ZWRJZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHNjaGVkdWxlIGl0ZW0gcmVmZXJlbmNlc1xuICAgICAgICAvLyBEbyBub3QgcmVwbGFjZSBJbnRlcnN0aXRpYWwgcGxheWluZ0l0ZW0gd2l0aG91dCBhIG1hdGNoIC0gdXNlZCBmb3IgSU5URVJTVElUSUFMX0FTU0VUX0VOREVEIGFuZCBJTlRFUlNUSVRJQUxfRU5ERURcbiAgICAgICAgdmFyIHVwZGF0ZWRQbGF5aW5nSXRlbSA9IG51bGw7XG4gICAgICAgIHZhciB1cGRhdGVkQnVmZmVyaW5nSXRlbSA9IG51bGw7XG4gICAgICAgIGlmIChwbGF5aW5nSXRlbSkge1xuICAgICAgICAgIHVwZGF0ZWRQbGF5aW5nSXRlbSA9IF90aGlzLnVwZGF0ZUl0ZW0ocGxheWluZ0l0ZW0sIF90aGlzLnRpbWVsaW5lUG9zKTtcbiAgICAgICAgICBpZiAoX3RoaXMuaXRlbXNNYXRjaChwbGF5aW5nSXRlbSwgdXBkYXRlZFBsYXlpbmdJdGVtKSkge1xuICAgICAgICAgICAgX3RoaXMucGxheWluZ0l0ZW0gPSB1cGRhdGVkUGxheWluZ0l0ZW07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLndhaXRpbmdJdGVtID0gX3RoaXMuZW5kZWRJdGVtID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgd2FpdGluZ0l0ZW0gaWYgaXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBzY2hlZHVsZVxuICAgICAgICBfdGhpcy53YWl0aW5nSXRlbSA9IF90aGlzLnVwZGF0ZUl0ZW0oX3RoaXMud2FpdGluZ0l0ZW0pO1xuICAgICAgICBfdGhpcy5lbmRlZEl0ZW0gPSBfdGhpcy51cGRhdGVJdGVtKF90aGlzLmVuZGVkSXRlbSk7XG4gICAgICAgIC8vIERvIG5vdCByZXBsYWNlIEludGVyc3RpdGlhbCBidWZmZXJpbmdJdGVtIHdpdGhvdXQgYSBtYXRjaCAtIHVzZWQgZm9yIHRyYW5zZmVyaW5nIG1lZGlhIGVsZW1lbnQgb3Igc291cmNlXG4gICAgICAgIHZhciBidWZmZXJpbmdJdGVtID0gX3RoaXMuYnVmZmVyaW5nSXRlbTtcbiAgICAgICAgaWYgKGJ1ZmZlcmluZ0l0ZW0pIHtcbiAgICAgICAgICB1cGRhdGVkQnVmZmVyaW5nSXRlbSA9IF90aGlzLnVwZGF0ZUl0ZW0oYnVmZmVyaW5nSXRlbSwgX3RoaXMuYnVmZmVyZWRQb3MpO1xuICAgICAgICAgIGlmIChfdGhpcy5pdGVtc01hdGNoKGJ1ZmZlcmluZ0l0ZW0sIHVwZGF0ZWRCdWZmZXJpbmdJdGVtKSkge1xuICAgICAgICAgICAgX3RoaXMuYnVmZmVyaW5nSXRlbSA9IHVwZGF0ZWRCdWZmZXJpbmdJdGVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyaW5nSXRlbS5ldmVudCkge1xuICAgICAgICAgICAgLy8gSW50ZXJzdGl0aWFsIHJlbW92ZWQgZnJvbSBzY2hlZHVsZSAoTGl2ZSAtPiBWT0Qgb3Igb3RoZXIgc2NlbmFyaW8gd2hlcmUgU3RhcnQgRGF0ZSBpcyBvdXRzaWRlIHRoZSByYW5nZSBvZiBWT0QgUGxheWxpc3QpXG4gICAgICAgICAgICBfdGhpcy5idWZmZXJpbmdJdGVtID0gX3RoaXMucGxheWluZ0l0ZW07XG4gICAgICAgICAgICBfdGhpcy5jbGVhckludGVyc3RpdGlhbChidWZmZXJpbmdJdGVtLmV2ZW50LCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlZEludGVyc3RpdGlhbHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJzdGl0aWFsKSB7XG4gICAgICAgICAgaW50ZXJzdGl0aWFsLmFzc2V0TGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChhc3NldCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJBc3NldFBsYXllcihhc3NldC5pZGVudGlmaWVyLCBudWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLnBsYXllclF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgIGlmIChwbGF5ZXIuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgIHZhciB0aW1lbGluZVN0YXJ0ID0gcGxheWVyLmFzc2V0SXRlbS50aW1lbGluZVN0YXJ0O1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBwbGF5ZXIudGltZWxpbmVPZmZzZXQgLSB0aW1lbGluZVN0YXJ0O1xuICAgICAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIudGltZWxpbmVPZmZzZXQgPSB0aW1lbGluZVN0YXJ0O1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gQUxJR05FRF9FTkRfVEhSRVNIT0xEX1NFQ09ORFMpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLndhcm4oZSArIFwiIChcXFwiXCIgKyBwbGF5ZXIuYXNzZXRJZCArIFwiXFxcIiBcIiArIHBsYXllci50aW1lbGluZU9mZnNldCArIFwiLT5cIiArIHRpbWVsaW5lU3RhcnQgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludGVyc3RpdGlhbHNVcGRhdGVkIHx8IHByZXZpb3VzSXRlbXMpIHtcbiAgICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMU19VUERBVEVELCB7XG4gICAgICAgICAgICBldmVudHM6IGludGVyc3RpdGlhbEV2ZW50cy5zbGljZSgwKSxcbiAgICAgICAgICAgIHNjaGVkdWxlOiBzY2hlZHVsZUl0ZW1zLnNsaWNlKDApLFxuICAgICAgICAgICAgZHVyYXRpb25zOiBkdXJhdGlvbnMsXG4gICAgICAgICAgICByZW1vdmVkSWRzOiByZW1vdmVkSWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKF90aGlzLmlzSW50ZXJzdGl0aWFsKHBsYXlpbmdJdGVtKSAmJiByZW1vdmVkSWRzLmluY2x1ZGVzKHBsYXlpbmdJdGVtLmV2ZW50LmlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICBfdGhpcy53YXJuKFwiSW50ZXJzdGl0aWFsIFxcXCJcIiArIHBsYXlpbmdJdGVtLmV2ZW50LmlkZW50aWZpZXIgKyBcIlxcXCIgcmVtb3ZlZCB3aGlsZSBwbGF5aW5nXCIpO1xuICAgICAgICAgICAgX3RoaXMucHJpbWFyeUZhbGxiYWNrKHBsYXlpbmdJdGVtLmV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBsYXlpbmdJdGVtKSB7XG4gICAgICAgICAgICBfdGhpcy50cmltSW5QbGFjZSh1cGRhdGVkUGxheWluZ0l0ZW0sIHBsYXlpbmdJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ1ZmZlcmluZ0l0ZW0gJiYgdXBkYXRlZEJ1ZmZlcmluZ0l0ZW0gIT09IHVwZGF0ZWRQbGF5aW5nSXRlbSkge1xuICAgICAgICAgICAgX3RoaXMudHJpbUluUGxhY2UodXBkYXRlZEJ1ZmZlcmluZ0l0ZW0sIGJ1ZmZlcmluZ0l0ZW0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENoZWNrIGlmIGJ1ZmZlcmVkIHRvIG5ldyBJbnRlcnN0aXRpYWwgZXZlbnQgYm91bmRhcnlcbiAgICAgICAgICAvLyAoTGl2ZSB1cGRhdGUgcHVibGlzaGVzIEludGVyc3RpdGlhbCB3aXRoIG5ldyBzZWdtZW50KVxuICAgICAgICAgIF90aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy5obHMgPSBobHM7XG4gICAgICBfdGhpcy5IbHNQbGF5ZXJDbGFzcyA9IEhsc1BsYXllckNsYXNzO1xuICAgICAgX3RoaXMuYXNzZXRMaXN0TG9hZGVyID0gbmV3IEFzc2V0TGlzdExvYWRlcihobHMpO1xuICAgICAgX3RoaXMuc2NoZWR1bGUgPSBuZXcgSW50ZXJzdGl0aWFsc1NjaGVkdWxlKF90aGlzLm9uU2NoZWR1bGVVcGRhdGUsIGhscy5sb2dnZXIpO1xuICAgICAgX3RoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoSW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIsIF9Mb2dnZXIpO1xuICAgIHZhciBfcHJvdG8gPSBJbnRlcnN0aXRpYWxzQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgaWYgKGhscykge1xuICAgICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgICAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrVXBkYXRlZCwgdGhpcyk7XG4gICAgICAgIGhscy5vbihFdmVudHMuRVZFTlRfQ1VFX0VOVEVSLCB0aGlzLm9uSW50ZXJzdGl0aWFsQ3VlRW50ZXIsIHRoaXMpO1xuICAgICAgICBobHMub24oRXZlbnRzLkFTU0VUX0xJU1RfTE9BREVELCB0aGlzLm9uQXNzZXRMaXN0TG9hZGVkLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJFRF9UT19FTkQsIHRoaXMub25CdWZmZXJlZFRvRW5kLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9FTkRFRCwgdGhpcy5vbk1lZGlhRW5kZWQsIHRoaXMpO1xuICAgICAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgICAgICBobHMub24oRXZlbnRzLkRFU1RST1lJTkcsIHRoaXMub25EZXN0cm95aW5nLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICBpZiAoaGxzKSB7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHRoaXMub25TdWJ0aXRsZVRyYWNrU3dpdGNoLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tVcGRhdGVkLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuRVZFTlRfQ1VFX0VOVEVSLCB0aGlzLm9uSW50ZXJzdGl0aWFsQ3VlRW50ZXIsIHRoaXMpO1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5BU1NFVF9MSVNUX0xPQURFRCwgdGhpcy5vbkFzc2V0TGlzdExvYWRlZCwgdGhpcyk7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUkVEX1RPX0VORCwgdGhpcy5vbkJ1ZmZlcmVkVG9FbmQsIHRoaXMpO1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9FTkRFRCwgdGhpcy5vbk1lZGlhRW5kZWQsIHRoaXMpO1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuREVTVFJPWUlORywgdGhpcy5vbkRlc3Ryb3lpbmcsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZCgpIHtcbiAgICAgIC8vIFRPRE86IHN0YXJ0TG9hZCAtIGNoZWNrIGZvciB3YWl0aW5nSXRlbSBhbmQgcmV0cnkgYnkgcmVzZXR0aW5nIHNjaGVkdWxlXG4gICAgICB0aGlzLnJlc3VtZUJ1ZmZlcmluZygpO1xuICAgIH07XG4gICAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICAvLyBUT0RPOiBzdG9wTG9hZCAtIHN0b3AgYWxsIHNjaGV1bGUuZXZlbnRzW10uYXNzZXRMaXN0TG9hZGVyPy5hYm9ydCgpIHRoZW4gZGVsZXRlIHRoZSBsb2FkZXJzXG4gICAgICB0aGlzLnBhdXNlQnVmZmVyaW5nKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzdW1lQnVmZmVyaW5nID0gZnVuY3Rpb24gcmVzdW1lQnVmZmVyaW5nKCkge1xuICAgICAgdmFyIF90aGlzJGdldEJ1ZmZlcmluZ1BsYTtcbiAgICAgIChfdGhpcyRnZXRCdWZmZXJpbmdQbGEgPSB0aGlzLmdldEJ1ZmZlcmluZ1BsYXllcigpKSA9PSBudWxsIHx8IF90aGlzJGdldEJ1ZmZlcmluZ1BsYS5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgICB9O1xuICAgIF9wcm90by5wYXVzZUJ1ZmZlcmluZyA9IGZ1bmN0aW9uIHBhdXNlQnVmZmVyaW5nKCkge1xuICAgICAgdmFyIF90aGlzJGdldEJ1ZmZlcmluZ1BsYTI7XG4gICAgICAoX3RoaXMkZ2V0QnVmZmVyaW5nUGxhMiA9IHRoaXMuZ2V0QnVmZmVyaW5nUGxheWVyKCkpID09IG51bGwgfHwgX3RoaXMkZ2V0QnVmZmVyaW5nUGxhMi5wYXVzZUJ1ZmZlcmluZygpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgaWYgKHRoaXMuYXNzZXRMaXN0TG9hZGVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXRMaXN0TG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1wdHlQbGF5ZXJRdWV1ZSgpO1xuICAgICAgdGhpcy5jbGVhclNjaGVkdWxlU3RhdGUoKTtcbiAgICAgIGlmICh0aGlzLnNjaGVkdWxlKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMuZGV0YWNoZWREYXRhID0gdGhpcy5tZWRpYVNlbGVjdGlvbiA9IHRoaXMucmVxdWlyZWRUcmFja3MgPSB0aGlzLmFsdFNlbGVjdGlvbiA9IHRoaXMuc2NoZWR1bGUgPSB0aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5obHMgPSB0aGlzLkhsc1BsYXllckNsYXNzID0gdGhpcy5sb2cgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5hc3NldExpc3RMb2FkZXIgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5vblBsYXkgPSB0aGlzLm9uUGF1c2UgPSB0aGlzLm9uU2Vla2luZyA9IHRoaXMub25UaW1ldXBkYXRlID0gbnVsbDtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ub25EZXN0cm95aW5nID0gZnVuY3Rpb24gb25EZXN0cm95aW5nKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5wcmltYXJ5TWVkaWEgfHwgdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKG1lZGlhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVNZWRpYUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZU1lZGlhTGlzdGVuZXJzKG1lZGlhKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAncGxheScsIHRoaXMub25QbGF5KTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICdwYXVzZScsIHRoaXMub25QYXVzZSk7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhLCAnc2Vla2luZycsIHRoaXMub25TZWVraW5nKTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobWVkaWEsICd0aW1ldXBkYXRlJywgdGhpcy5vblRpbWV1cGRhdGUpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdzZWVraW5nJywgdGhpcy5vblNlZWtpbmcpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3RpbWV1cGRhdGUnLCB0aGlzLm9uVGltZXVwZGF0ZSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAncGxheScsIHRoaXMub25QbGF5KTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdwYXVzZScsIHRoaXMub25QYXVzZSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgcGxheWluZ0l0ZW0gPSB0aGlzLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgdmFyIGRldGFjaGVkTWVkaWEgPSB0aGlzLmRldGFjaGVkRGF0YTtcbiAgICAgIHRoaXMuZGV0YWNoZWREYXRhID0gbnVsbDtcbiAgICAgIGlmIChwbGF5aW5nSXRlbSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNoZWNrU3RhcnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRldGFjaGVkTWVkaWEpIHtcbiAgICAgICAgLy8gUmVzdW1lIHNjaGVkdWxlIGFmdGVyIGRldGFjaGVkIGV4dGVybmFsbHlcbiAgICAgICAgdGhpcy5jbGVhclNjaGVkdWxlU3RhdGUoKTtcbiAgICAgICAgdmFyIHBsYXlpbmdJbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChwbGF5aW5nSXRlbSk7XG4gICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihwbGF5aW5nSW5kZXgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNsZWFyU2NoZWR1bGVTdGF0ZSA9IGZ1bmN0aW9uIGNsZWFyU2NoZWR1bGVTdGF0ZSgpIHtcbiAgICAgIHRoaXMubG9nKFwiY2xlYXIgc2NoZWR1bGUgc3RhdGVcIik7XG4gICAgICB0aGlzLnBsYXlpbmdJdGVtID0gdGhpcy5idWZmZXJpbmdJdGVtID0gdGhpcy53YWl0aW5nSXRlbSA9IHRoaXMuZW5kZWRJdGVtID0gdGhpcy5wbGF5aW5nQXNzZXQgPSB0aGlzLmVuZGVkQXNzZXQgPSB0aGlzLmJ1ZmZlcmluZ0Fzc2V0ID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIHRyYW5zZmVycmluZ01lZGlhID0gISFkYXRhLnRyYW5zZmVyTWVkaWE7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTWVkaWFMaXN0ZW5lcnMobWVkaWEpO1xuICAgICAgfVxuICAgICAgLy8gSWYgZGV0YWNoTWVkaWEgaXMgY2FsbGVkIHdoaWxlIGluIGFuIEludGVyc3RpdGlhbCwgZGV0YWNoIHRoZSBhc3NldCBwbGF5ZXIgYXMgd2VsbCBhbmQgcmVzZXQgdGhlIHNjaGVkdWxlIHBvc2l0aW9uXG4gICAgICBpZiAodGhpcy5kZXRhY2hlZERhdGEpIHtcbiAgICAgICAgdmFyIHBsYXllciA9IHRoaXMuZ2V0QnVmZmVyaW5nUGxheWVyKCk7XG4gICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcIlJlbW92aW5nIHNjaGVkdWxlIHN0YXRlIGZvciBkZXRhY2hlZERhdGEgYW5kIFwiICsgcGxheWVyKTtcbiAgICAgICAgICB0aGlzLnBsYXlpbmdBc3NldCA9IHRoaXMuZW5kZWRBc3NldCA9IHRoaXMuYnVmZmVyaW5nQXNzZXQgPSB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLndhaXRpbmdJdGVtID0gdGhpcy5kZXRhY2hlZERhdGEgPSBudWxsO1xuICAgICAgICAgIHBsYXllci5kZXRhY2hNZWRpYSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdWxkUGxheSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmlzSW50ZXJzdGl0aWFsID0gZnVuY3Rpb24gaXNJbnRlcnN0aXRpYWwoaXRlbSkge1xuICAgICAgcmV0dXJuICEhKGl0ZW0gIT0gbnVsbCAmJiBpdGVtLmV2ZW50KTtcbiAgICB9O1xuICAgIF9wcm90by5yZXRyZWl2ZU1lZGlhU291cmNlID0gZnVuY3Rpb24gcmV0cmVpdmVNZWRpYVNvdXJjZShhc3NldElkLCB0b1NlZ21lbnQpIHtcbiAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0SWQpO1xuICAgICAgaWYgKHBsYXllcikge1xuICAgICAgICB0aGlzLnRyYW5zZmVyTWVkaWFGcm9tUGxheWVyKHBsYXllciwgdG9TZWdtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50cmFuc2Zlck1lZGlhRnJvbVBsYXllciA9IGZ1bmN0aW9uIHRyYW5zZmVyTWVkaWFGcm9tUGxheWVyKHBsYXllciwgdG9TZWdtZW50KSB7XG4gICAgICB2YXIgYXBwZW5kSW5QbGFjZSA9IHBsYXllci5pbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZTtcbiAgICAgIHZhciBwbGF5ZXJNZWRpYSA9IHBsYXllci5tZWRpYTtcbiAgICAgIGlmIChhcHBlbmRJblBsYWNlICYmIHBsYXllck1lZGlhID09PSB0aGlzLnByaW1hcnlNZWRpYSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcmluZ0Fzc2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCF0b1NlZ21lbnQgfHwgdGhpcy5pc0ludGVyc3RpdGlhbCh0b1NlZ21lbnQpICYmICF0b1NlZ21lbnQuZXZlbnQuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIC8vIE1lZGlhU291cmNlIGNhbm5vdCBiZSB0cmFuc2ZlcmVkIGJhY2sgdG8gYW4gSW50ZXJzdGl0aWFsIHRoYXQgcmVxdWlyZXMgYSBzb3VyY2UgcmVzZXRcbiAgICAgICAgICAvLyBuby1vcCB3aGVuIHRvU2VnbWVudCBpcyB1bmRlZmluZWRcbiAgICAgICAgICBpZiAodG9TZWdtZW50ICYmIHBsYXllck1lZGlhKSB7XG4gICAgICAgICAgICB0aGlzLmRldGFjaGVkRGF0YSA9IHtcbiAgICAgICAgICAgICAgbWVkaWE6IHBsYXllck1lZGlhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0YWNoTWVkaWFTb3VyY2VEYXRhID0gcGxheWVyLnRyYW5zZmVyTWVkaWEoKTtcbiAgICAgICAgdGhpcy5sb2coXCJ0cmFuc2ZlciBNZWRpYVNvdXJjZSBmcm9tIFwiICsgcGxheWVyICsgXCIgXCIgKyBzdHJpbmdpZnkoYXR0YWNoTWVkaWFTb3VyY2VEYXRhKSk7XG4gICAgICAgIHRoaXMuZGV0YWNoZWREYXRhID0gYXR0YWNoTWVkaWFTb3VyY2VEYXRhO1xuICAgICAgfSBlbHNlIGlmICh0b1NlZ21lbnQgJiYgcGxheWVyTWVkaWEpIHtcbiAgICAgICAgdGhpcy5zaG91bGRQbGF5IHx8ICh0aGlzLnNob3VsZFBsYXkgPSAhcGxheWVyTWVkaWEucGF1c2VkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50cmFuc2Zlck1lZGlhVG8gPSBmdW5jdGlvbiB0cmFuc2Zlck1lZGlhVG8ocGxheWVyLCBtZWRpYSkge1xuICAgICAgdmFyIF90aGlzJGRldGFjaGVkRGF0YSxcbiAgICAgICAgX3RoaXMyID0gdGhpcyxcbiAgICAgICAgX2F0dGFjaE1lZGlhU291cmNlRGF0O1xuICAgICAgaWYgKHBsYXllci5tZWRpYSA9PT0gbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGF0dGFjaE1lZGlhU291cmNlRGF0YSA9IG51bGw7XG4gICAgICB2YXIgcHJpbWFyeVBsYXllciA9IHRoaXMuaGxzO1xuICAgICAgdmFyIGlzQXNzZXRQbGF5ZXIgPSBwbGF5ZXIgIT09IHByaW1hcnlQbGF5ZXI7XG4gICAgICB2YXIgYXBwZW5kSW5QbGFjZSA9IGlzQXNzZXRQbGF5ZXIgJiYgcGxheWVyLmludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlO1xuICAgICAgdmFyIGRldGFjaGVkTWVkaWFTb3VyY2UgPSAoX3RoaXMkZGV0YWNoZWREYXRhID0gdGhpcy5kZXRhY2hlZERhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRkZXRhY2hlZERhdGEubWVkaWFTb3VyY2U7XG4gICAgICB2YXIgbG9nRnJvbVNvdXJjZTtcbiAgICAgIGlmIChwcmltYXJ5UGxheWVyLm1lZGlhKSB7XG4gICAgICAgIGlmIChhcHBlbmRJblBsYWNlKSB7XG4gICAgICAgICAgYXR0YWNoTWVkaWFTb3VyY2VEYXRhID0gcHJpbWFyeVBsYXllci50cmFuc2Zlck1lZGlhKCk7XG4gICAgICAgICAgdGhpcy5kZXRhY2hlZERhdGEgPSBhdHRhY2hNZWRpYVNvdXJjZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbG9nRnJvbVNvdXJjZSA9IFwiUHJpbWFyeVwiO1xuICAgICAgfSBlbHNlIGlmIChkZXRhY2hlZE1lZGlhU291cmNlKSB7XG4gICAgICAgIHZhciBidWZmZXJpbmdQbGF5ZXIgPSB0aGlzLmdldEJ1ZmZlcmluZ1BsYXllcigpO1xuICAgICAgICBpZiAoYnVmZmVyaW5nUGxheWVyKSB7XG4gICAgICAgICAgYXR0YWNoTWVkaWFTb3VyY2VEYXRhID0gYnVmZmVyaW5nUGxheWVyLnRyYW5zZmVyTWVkaWEoKTtcbiAgICAgICAgICBsb2dGcm9tU291cmNlID0gXCJcIiArIGJ1ZmZlcmluZ1BsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dGcm9tU291cmNlID0gXCJkZXRhY2hlZCBNZWRpYVNvdXJjZVwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dGcm9tU291cmNlID0gXCJkZXRhY2hlZCBtZWRpYVwiO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRhY2hNZWRpYVNvdXJjZURhdGEpIHtcbiAgICAgICAgaWYgKGRldGFjaGVkTWVkaWFTb3VyY2UpIHtcbiAgICAgICAgICBhdHRhY2hNZWRpYVNvdXJjZURhdGEgPSB0aGlzLmRldGFjaGVkRGF0YTtcbiAgICAgICAgICB0aGlzLmxvZyhcInVzaW5nIGRldGFjaGVkRGF0YTogTWVkaWFTb3VyY2UgXCIgKyBzdHJpbmdpZnkoYXR0YWNoTWVkaWFTb3VyY2VEYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZGV0YWNoZWREYXRhIHx8IHByaW1hcnlQbGF5ZXIubWVkaWEgPT09IG1lZGlhKSB7XG4gICAgICAgICAgLy8gS2VlcCBpbnRlcnN0aXRpYWwgbWVkaWEgdHJhbnNpdGlvbiBjb25zaXN0ZW50XG4gICAgICAgICAgdmFyIHBsYXllclF1ZXVlID0gdGhpcy5wbGF5ZXJRdWV1ZTtcbiAgICAgICAgICBpZiAocGxheWVyUXVldWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcGxheWVyUXVldWUuZm9yRWFjaChmdW5jdGlvbiAocXVldWVkUGxheWVyKSB7XG4gICAgICAgICAgICAgIGlmIChpc0Fzc2V0UGxheWVyICYmIHF1ZXVlZFBsYXllci5pbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSAhPT0gYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnN0aXRpYWwgPSBxdWV1ZWRQbGF5ZXIuaW50ZXJzdGl0aWFsO1xuICAgICAgICAgICAgICAgIF90aGlzMi5jbGVhckludGVyc3RpdGlhbChxdWV1ZWRQbGF5ZXIuaW50ZXJzdGl0aWFsLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSA9IGZhbHNlOyAvLyBzZXR0ZXIgbWF5IGJlIGEgbm8tb3A7XG4gICAgICAgICAgICAgICAgLy8gYGFwcGVuZEluUGxhY2VgIGdldHRlciBtYXkgc3RpbGwgcmV0dXJuIGB0cnVlYCBhZnRlciBpbnN0ZXJzdGl0aWFsIHN0cmVhbWluZyBoYXMgYmVndW4gaW4gdGhhdCBtb2RlLlxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMyLndhcm4oXCJDb3VsZCBub3QgY2hhbmdlIGFwcGVuZCBzdHJhdGVneSBmb3IgcXVldWVkIGFzc2V0cyBcIiArIGludGVyc3RpdGlhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5obHMuZGV0YWNoTWVkaWEoKTtcbiAgICAgICAgICB0aGlzLmRldGFjaGVkRGF0YSA9IHtcbiAgICAgICAgICAgIG1lZGlhOiBtZWRpYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0cmFuc2ZlcnJpbmcgPSBhdHRhY2hNZWRpYVNvdXJjZURhdGEgJiYgJ21lZGlhU291cmNlJyBpbiBhdHRhY2hNZWRpYVNvdXJjZURhdGEgJiYgKChfYXR0YWNoTWVkaWFTb3VyY2VEYXQgPSBhdHRhY2hNZWRpYVNvdXJjZURhdGEubWVkaWFTb3VyY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYXR0YWNoTWVkaWFTb3VyY2VEYXQucmVhZHlTdGF0ZSkgIT09ICdjbG9zZWQnO1xuICAgICAgdmFyIGRhdGFUb0F0dGFjaCA9IHRyYW5zZmVycmluZyAmJiBhdHRhY2hNZWRpYVNvdXJjZURhdGEgPyBhdHRhY2hNZWRpYVNvdXJjZURhdGEgOiBtZWRpYTtcbiAgICAgIHRoaXMubG9nKCh0cmFuc2ZlcnJpbmcgPyAndHJhbnNmZXJpbmcgTWVkaWFTb3VyY2UnIDogJ2F0dGFjaGluZyBtZWRpYScpICsgXCIgdG8gXCIgKyAoaXNBc3NldFBsYXllciA/IHBsYXllciA6ICdQcmltYXJ5JykgKyBcIiBmcm9tIFwiICsgbG9nRnJvbVNvdXJjZSArIFwiIChtZWRpYS5jdXJyZW50VGltZTogXCIgKyBtZWRpYS5jdXJyZW50VGltZSArIFwiKVwiKTtcbiAgICAgIHZhciBzY2hlZHVsZSA9IHRoaXMuc2NoZWR1bGU7XG4gICAgICBpZiAoZGF0YVRvQXR0YWNoID09PSBhdHRhY2hNZWRpYVNvdXJjZURhdGEgJiYgc2NoZWR1bGUpIHtcbiAgICAgICAgdmFyIGlzQXNzZXRBdEVuZE9mU2NoZWR1bGUgPSBpc0Fzc2V0UGxheWVyICYmIHBsYXllci5hc3NldElkID09PSBzY2hlZHVsZS5hc3NldElkQXRFbmQ7XG4gICAgICAgIC8vIFByZXZlbnQgYXNzZXQgcGxheWVycyBmcm9tIG1hcmtpbmcgRW9TIG9uIHRyYW5zZmVycmVkIE1lZGlhU291cmNlXG4gICAgICAgIGRhdGFUb0F0dGFjaC5vdmVycmlkZXMgPSB7XG4gICAgICAgICAgZHVyYXRpb246IHNjaGVkdWxlLmR1cmF0aW9uLFxuICAgICAgICAgIGVuZE9mU3RyZWFtOiAhaXNBc3NldFBsYXllciB8fCBpc0Fzc2V0QXRFbmRPZlNjaGVkdWxlLFxuICAgICAgICAgIGN1ZVJlbW92YWw6ICFpc0Fzc2V0UGxheWVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBwbGF5ZXIuYXR0YWNoTWVkaWEoZGF0YVRvQXR0YWNoKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkludGVyc3RpdGlhbEN1ZUVudGVyID0gZnVuY3Rpb24gb25JbnRlcnN0aXRpYWxDdWVFbnRlcigpIHtcbiAgICAgIHRoaXMub25UaW1ldXBkYXRlKCk7XG4gICAgfTtcbiAgICAvLyBTY2hlZHVsaW5nIG1ldGhvZHNcbiAgICBfcHJvdG8uY2hlY2tTdGFydCA9IGZ1bmN0aW9uIGNoZWNrU3RhcnQoKSB7XG4gICAgICB2YXIgc2NoZWR1bGUgPSB0aGlzLnNjaGVkdWxlO1xuICAgICAgdmFyIGludGVyc3RpdGlhbEV2ZW50cyA9IHNjaGVkdWxlID09IG51bGwgPyB2b2lkIDAgOiBzY2hlZHVsZS5ldmVudHM7XG4gICAgICBpZiAoIWludGVyc3RpdGlhbEV2ZW50cyB8fCB0aGlzLnBsYXliYWNrRGlzYWJsZWQgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgYnVmZmVyZWQgdG8gcHJlLXJvbGxcbiAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkUG9zID09PSAtMSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkUG9zID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIFN0YXJ0IHN0ZXBwaW5nIHRocm91Z2ggc2NoZWR1bGUgd2hlbiBwbGF5YmFjayBiZWdpbnMgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZCB3ZSBoYXZlIGEgcHJlLXJvbGxcbiAgICAgIHZhciB0aW1lbGluZVBvcyA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgICB2YXIgZWZmZWN0aXZlUGxheWluZ0l0ZW0gPSB0aGlzLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgaWYgKHRpbWVsaW5lUG9zID09PSAtMSkge1xuICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuaGxzLnN0YXJ0UG9zaXRpb247XG4gICAgICAgIHRoaXMubG9nKHRpbWVsaW5lTWVzc2FnZSgnY2hlY2tTdGFydCcsIHN0YXJ0UG9zaXRpb24pKTtcbiAgICAgICAgdGhpcy50aW1lbGluZVBvcyA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIGlmIChpbnRlcnN0aXRpYWxFdmVudHMubGVuZ3RoICYmIGludGVyc3RpdGlhbEV2ZW50c1swXS5jdWUucHJlKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsRXZlbnRzWzBdLmlkZW50aWZpZXIpO1xuICAgICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihpbmRleCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwIHx8ICF0aGlzLnByaW1hcnlMaXZlKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy50aW1lbGluZVBvcyA9IHN0YXJ0UG9zaXRpb24gPiAwID8gc3RhcnRQb3NpdGlvbiA6IDA7XG4gICAgICAgICAgdmFyIF9pbmRleCA9IHNjaGVkdWxlLmZpbmRJdGVtSW5kZXhBdFRpbWUoc3RhcnQpO1xuICAgICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihfaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVmZmVjdGl2ZVBsYXlpbmdJdGVtICYmICF0aGlzLnBsYXlpbmdJdGVtKSB7XG4gICAgICAgIHZhciBfaW5kZXgyID0gc2NoZWR1bGUuZmluZEl0ZW1JbmRleChlZmZlY3RpdmVQbGF5aW5nSXRlbSk7XG4gICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihfaW5kZXgyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5hZHZhbmNlQXNzZXRCdWZmZXJpbmcgPSBmdW5jdGlvbiBhZHZhbmNlQXNzZXRCdWZmZXJpbmcoaXRlbSwgYXNzZXRJdGVtKSB7XG4gICAgICB2YXIgaW50ZXJzdGl0aWFsID0gaXRlbS5ldmVudDtcbiAgICAgIHZhciBhc3NldExpc3RJbmRleCA9IGludGVyc3RpdGlhbC5maW5kQXNzZXRJbmRleChhc3NldEl0ZW0pO1xuICAgICAgdmFyIG5leHRBc3NldEluZGV4ID0gZ2V0TmV4dEFzc2V0SW5kZXgoaW50ZXJzdGl0aWFsLCBhc3NldExpc3RJbmRleCk7XG4gICAgICBpZiAoIWludGVyc3RpdGlhbC5pc0Fzc2V0UGFzdFBsYXlvdXRMaW1pdChuZXh0QXNzZXRJbmRleCkpIHtcbiAgICAgICAgdGhpcy5idWZmZXJlZFRvRXZlbnQoaXRlbSwgbmV4dEFzc2V0SW5kZXgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNjaGVkdWxlKSB7XG4gICAgICAgIHZhciBfdGhpcyRzY2hlZHVsZSRpdGVtcztcbiAgICAgICAgdmFyIG5leHRJdGVtID0gKF90aGlzJHNjaGVkdWxlJGl0ZW1zID0gdGhpcy5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHNjaGVkdWxlJGl0ZW1zW3RoaXMuZmluZEl0ZW1JbmRleChpdGVtKSArIDFdO1xuICAgICAgICBpZiAobmV4dEl0ZW0pIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKG5leHRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQgPSBmdW5jdGlvbiBhZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgaW5kZXgsIGFzc2V0TGlzdEluZGV4KSB7XG4gICAgICB2YXIgbmV4dEFzc2V0SW5kZXggPSBnZXROZXh0QXNzZXRJbmRleChpbnRlcnN0aXRpYWwsIGFzc2V0TGlzdEluZGV4KTtcbiAgICAgIGlmICghaW50ZXJzdGl0aWFsLmlzQXNzZXRQYXN0UGxheW91dExpbWl0KG5leHRBc3NldEluZGV4KSkge1xuICAgICAgICAvLyBBZHZhbmNlIHRvIG5leHQgYXNzZXQgbGlzdCBpdGVtXG4gICAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIHZhciBhc3NldEl0ZW0gPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W25leHRBc3NldEluZGV4XTtcbiAgICAgICAgICBpZiAoYXNzZXRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2VJblBsYWNlKGFzc2V0SXRlbS50aW1lbGluZVN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKGluZGV4LCBuZXh0QXNzZXRJbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2NoZWR1bGUpIHtcbiAgICAgICAgLy8gQWR2YW5jZSB0byBuZXh0IHNjaGVkdWxlIHNlZ21lbnRcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwcm9ncmFtXG4gICAgICAgIHZhciBzY2hlZHVsZUl0ZW1zID0gdGhpcy5zY2hlZHVsZS5pdGVtcztcbiAgICAgICAgaWYgKHNjaGVkdWxlSXRlbXMpIHtcbiAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgIHZhciBzY2hlZHVsZUxlbmd0aCA9IHNjaGVkdWxlSXRlbXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChuZXh0SW5kZXggPj0gc2NoZWR1bGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbigtMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bXB0aW9uVGltZSA9IGludGVyc3RpdGlhbC5yZXN1bWVUaW1lO1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVsaW5lUG9zIDwgcmVzdW1wdGlvblRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKHRpbWVsaW5lTWVzc2FnZSgnYWR2YW5jZUFmdGVyQXNzZXRFbmRlZCcsIHJlc3VtcHRpb25UaW1lKSk7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lUG9zID0gcmVzdW1wdGlvblRpbWU7XG4gICAgICAgICAgICBpZiAoaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlSW5QbGFjZShyZXN1bXB0aW9uVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrQnVmZmVyKHRoaXMuYnVmZmVyZWRQb3MgPCByZXN1bXB0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihuZXh0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0U2NoZWR1bGVUb0Fzc2V0QXRUaW1lID0gZnVuY3Rpb24gc2V0U2NoZWR1bGVUb0Fzc2V0QXRUaW1lKHRpbWUsIHBsYXlpbmdBc3NldCkge1xuICAgICAgdmFyIHNjaGVkdWxlID0gdGhpcy5zY2hlZHVsZTtcbiAgICAgIGlmICghc2NoZWR1bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudElkZW50aWZpZXIgPSBwbGF5aW5nQXNzZXQucGFyZW50SWRlbnRpZmllcjtcbiAgICAgIHZhciBpbnRlcnN0aXRpYWwgPSBzY2hlZHVsZS5nZXRFdmVudChwYXJlbnRJZGVudGlmaWVyKTtcbiAgICAgIGlmIChpbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgdmFyIGl0ZW1JbmRleCA9IHNjaGVkdWxlLmZpbmRFdmVudEluZGV4KHBhcmVudElkZW50aWZpZXIpO1xuICAgICAgICB2YXIgYXNzZXRMaXN0SW5kZXggPSBzY2hlZHVsZS5maW5kQXNzZXRJbmRleChpbnRlcnN0aXRpYWwsIHRpbWUpO1xuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQoaW50ZXJzdGl0aWFsLCBpdGVtSW5kZXgsIGFzc2V0TGlzdEluZGV4IC0gMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0U2NoZWR1bGVQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldFNjaGVkdWxlUG9zaXRpb24oaW5kZXgsIGFzc2V0TGlzdEluZGV4KSB7XG4gICAgICB2YXIgX3RoaXMkc2NoZWR1bGU7XG4gICAgICB2YXIgc2NoZWR1bGVJdGVtcyA9IChfdGhpcyRzY2hlZHVsZSA9IHRoaXMuc2NoZWR1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzY2hlZHVsZS5pdGVtcztcbiAgICAgIGlmICghc2NoZWR1bGVJdGVtcyB8fCB0aGlzLnBsYXliYWNrRGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNjaGVkdWxlZEl0ZW0gPSBpbmRleCA+PSAwID8gc2NoZWR1bGVJdGVtc1tpbmRleF0gOiBudWxsO1xuICAgICAgdGhpcy5sb2coXCJzZXRTY2hlZHVsZVBvc2l0aW9uIFwiICsgaW5kZXggKyBcIiwgXCIgKyBhc3NldExpc3RJbmRleCArIFwiIChcIiArIChzY2hlZHVsZWRJdGVtID8gc2VnbWVudFRvU3RyaW5nKHNjaGVkdWxlZEl0ZW0pIDogc2NoZWR1bGVkSXRlbSkgKyBcIikgcG9zOiBcIiArIHRoaXMudGltZWxpbmVQb3MpO1xuICAgICAgLy8gQ2xlYW51cCBjdXJyZW50IGl0ZW0gLyBhc3NldFxuICAgICAgdmFyIGN1cnJlbnRJdGVtID0gdGhpcy53YWl0aW5nSXRlbSB8fCB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgdmFyIHBsYXlpbmdMYXN0SXRlbSA9IHRoaXMucGxheWluZ0xhc3RJdGVtO1xuICAgICAgaWYgKHRoaXMuaXNJbnRlcnN0aXRpYWwoY3VycmVudEl0ZW0pKSB7XG4gICAgICAgIHZhciBpbnRlcnN0aXRpYWwgPSBjdXJyZW50SXRlbS5ldmVudDtcbiAgICAgICAgdmFyIHBsYXlpbmdBc3NldCA9IHRoaXMucGxheWluZ0Fzc2V0O1xuICAgICAgICB2YXIgYXNzZXRJZCA9IHBsYXlpbmdBc3NldCA9PSBudWxsID8gdm9pZCAwIDogcGxheWluZ0Fzc2V0LmlkZW50aWZpZXI7XG4gICAgICAgIHZhciBwbGF5ZXIgPSBhc3NldElkID8gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldElkKSA6IG51bGw7XG4gICAgICAgIGlmIChwbGF5ZXIgJiYgYXNzZXRJZCAmJiAoIXRoaXMuZXZlbnRJdGVtc01hdGNoKGN1cnJlbnRJdGVtLCBzY2hlZHVsZWRJdGVtKSB8fCBhc3NldExpc3RJbmRleCAhPT0gdW5kZWZpbmVkICYmIGFzc2V0SWQgIT09IGludGVyc3RpdGlhbC5hc3NldExpc3RbYXNzZXRMaXN0SW5kZXhdLmlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgdmFyIF90aGlzJGRldGFjaGVkRGF0YTI7XG4gICAgICAgICAgdmFyIHBsYXlpbmdBc3NldExpc3RJbmRleCA9IGludGVyc3RpdGlhbC5maW5kQXNzZXRJbmRleChwbGF5aW5nQXNzZXQpO1xuICAgICAgICAgIHRoaXMubG9nKFwiSU5URVJTVElUSUFMX0FTU0VUX0VOREVEIFwiICsgKHBsYXlpbmdBc3NldExpc3RJbmRleCArIDEpICsgXCIvXCIgKyBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0Lmxlbmd0aCArIFwiIFwiICsgZXZlbnRBc3NldFRvU3RyaW5nKHBsYXlpbmdBc3NldCkpO1xuICAgICAgICAgIHRoaXMuZW5kZWRBc3NldCA9IHBsYXlpbmdBc3NldDtcbiAgICAgICAgICB0aGlzLnBsYXlpbmdBc3NldCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMX0FTU0VUX0VOREVELCB7XG4gICAgICAgICAgICBhc3NldDogcGxheWluZ0Fzc2V0LFxuICAgICAgICAgICAgYXNzZXRMaXN0SW5kZXg6IHBsYXlpbmdBc3NldExpc3RJbmRleCxcbiAgICAgICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgICAgICBzY2hlZHVsZTogc2NoZWR1bGVJdGVtcy5zbGljZSgwKSxcbiAgICAgICAgICAgIHNjaGVkdWxlSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgcGxheWVyOiBwbGF5ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY3VycmVudEl0ZW0gIT09IHRoaXMucGxheWluZ0l0ZW0pIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGNoYW5nZSBvY2N1cmVkIG9uIElOVEVSU1RJVElBTF9BU1NFVF9FTkRFRFxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNNYXRjaChjdXJyZW50SXRlbSwgdGhpcy5wbGF5aW5nSXRlbSkgJiZcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICAhdGhpcy5wbGF5aW5nQXNzZXQgLy8gSU5URVJTVElUSUFMX0FTU0VUX0VOREVEIHNpZGUtZWZmZWN0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgdGhpcy5maW5kSXRlbUluZGV4KHRoaXMucGxheWluZ0l0ZW0pLCBwbGF5aW5nQXNzZXRMaXN0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmF2aWdhdGlvbiBvY2N1cmVkIG9uIElOVEVSU1RJVElBTF9BU1NFVF9FTkRFRFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJldHJlaXZlTWVkaWFTb3VyY2UoYXNzZXRJZCwgc2NoZWR1bGVkSXRlbSk7XG4gICAgICAgICAgaWYgKHBsYXllci5tZWRpYSAmJiAhKChfdGhpcyRkZXRhY2hlZERhdGEyID0gdGhpcy5kZXRhY2hlZERhdGEpICE9IG51bGwgJiYgX3RoaXMkZGV0YWNoZWREYXRhMi5tZWRpYVNvdXJjZSkpIHtcbiAgICAgICAgICAgIHBsYXllci5kZXRhY2hNZWRpYSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRJdGVtc01hdGNoKGN1cnJlbnRJdGVtLCBzY2hlZHVsZWRJdGVtKSkge1xuICAgICAgICAgIHRoaXMuZW5kZWRJdGVtID0gY3VycmVudEl0ZW07XG4gICAgICAgICAgdGhpcy5wbGF5aW5nSXRlbSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5sb2coXCJJTlRFUlNUSVRJQUxfRU5ERUQgXCIgKyBpbnRlcnN0aXRpYWwgKyBcIiBcIiArIHNlZ21lbnRUb1N0cmluZyhjdXJyZW50SXRlbSkpO1xuICAgICAgICAgIGludGVyc3RpdGlhbC5oYXNQbGF5ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLklOVEVSU1RJVElBTF9FTkRFRCwge1xuICAgICAgICAgICAgZXZlbnQ6IGludGVyc3RpdGlhbCxcbiAgICAgICAgICAgIHNjaGVkdWxlOiBzY2hlZHVsZUl0ZW1zLnNsaWNlKDApLFxuICAgICAgICAgICAgc2NoZWR1bGVJbmRleDogaW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBFeGl0aW5nIGFuIEludGVyc3RpdGlhbFxuICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwuY3VlLm9uY2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRzY2hlZHVsZTI7XG4gICAgICAgICAgICAvLyBSZW1vdmUgaW50ZXJzdGl0aWFsIHdpdGggQ1VFIGF0dHJpYnV0ZSB2YWx1ZSBvZiBPTkNFIGFmdGVyIGl0IGhhcyBwbGF5ZWRcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2NoZWR1bGUoKTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVkU2NoZWR1bGVJdGVtcyA9IChfdGhpcyRzY2hlZHVsZTIgPSB0aGlzLnNjaGVkdWxlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc2NoZWR1bGUyLml0ZW1zO1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlZEl0ZW0gJiYgdXBkYXRlZFNjaGVkdWxlSXRlbXMpIHtcbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRJbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChzY2hlZHVsZWRJdGVtKTtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU2NoZWR1bGUodXBkYXRlZEluZGV4LCB1cGRhdGVkU2NoZWR1bGVJdGVtcywgYXNzZXRMaXN0SW5kZXgsIGN1cnJlbnRJdGVtLCBwbGF5aW5nTGFzdEl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hZHZhbmNlU2NoZWR1bGUoaW5kZXgsIHNjaGVkdWxlSXRlbXMsIGFzc2V0TGlzdEluZGV4LCBjdXJyZW50SXRlbSwgcGxheWluZ0xhc3RJdGVtKTtcbiAgICB9O1xuICAgIF9wcm90by5hZHZhbmNlU2NoZWR1bGUgPSBmdW5jdGlvbiBhZHZhbmNlU2NoZWR1bGUoaW5kZXgsIHNjaGVkdWxlSXRlbXMsIGFzc2V0TGlzdEluZGV4LCBjdXJyZW50SXRlbSwgcGxheWVkTGFzdEl0ZW0pIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIHNjaGVkdWxlID0gdGhpcy5zY2hlZHVsZTtcbiAgICAgIGlmICghc2NoZWR1bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNjaGVkdWxlZEl0ZW0gPSBzY2hlZHVsZUl0ZW1zW2luZGV4XSB8fCBudWxsO1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5wcmltYXJ5TWVkaWE7XG4gICAgICAvLyBDbGVhbnVwIG91dCBvZiByYW5nZSBJbnRlcnN0aXRpYWxzXG4gICAgICB2YXIgcGxheWVyUXVldWUgPSB0aGlzLnBsYXllclF1ZXVlO1xuICAgICAgaWYgKHBsYXllclF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBwbGF5ZXJRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICB2YXIgaW50ZXJzdGl0aWFsID0gcGxheWVyLmludGVyc3RpdGlhbDtcbiAgICAgICAgICB2YXIgcXVldWVkSW5kZXggPSBzY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWwuaWRlbnRpZmllcik7XG4gICAgICAgICAgaWYgKHF1ZXVlZEluZGV4IDwgaW5kZXggfHwgcXVldWVkSW5kZXggPiBpbmRleCArIDEpIHtcbiAgICAgICAgICAgIF90aGlzMy5jbGVhckludGVyc3RpdGlhbChpbnRlcnN0aXRpYWwsIHNjaGVkdWxlZEl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBTZXR1cCBzY2hlZHVsZWQgaXRlbVxuICAgICAgaWYgKHRoaXMuaXNJbnRlcnN0aXRpYWwoc2NoZWR1bGVkSXRlbSkpIHtcbiAgICAgICAgdGhpcy50aW1lbGluZVBvcyA9IE1hdGgubWluKE1hdGgubWF4KHRoaXMudGltZWxpbmVQb3MsIHNjaGVkdWxlZEl0ZW0uc3RhcnQpLCBzY2hlZHVsZWRJdGVtLmVuZCk7XG4gICAgICAgIC8vIEhhbmRsZSBJbnRlcnN0aXRpYWxcbiAgICAgICAgdmFyIGludGVyc3RpdGlhbCA9IHNjaGVkdWxlZEl0ZW0uZXZlbnQ7XG4gICAgICAgIC8vIGZpbmQgYXNzZXQgaW5kZXhcbiAgICAgICAgaWYgKGFzc2V0TGlzdEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhc3NldExpc3RJbmRleCA9IHNjaGVkdWxlLmZpbmRBc3NldEluZGV4KGludGVyc3RpdGlhbCwgdGhpcy50aW1lbGluZVBvcyk7XG4gICAgICAgICAgdmFyIGFzc2V0SW5kZXhDYW5kaWRhdGUgPSBnZXROZXh0QXNzZXRJbmRleChpbnRlcnN0aXRpYWwsIGFzc2V0TGlzdEluZGV4IC0gMSk7XG4gICAgICAgICAgaWYgKGludGVyc3RpdGlhbC5pc0Fzc2V0UGFzdFBsYXlvdXRMaW1pdChhc3NldEluZGV4Q2FuZGlkYXRlKSB8fCBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSAmJiB0aGlzLnRpbWVsaW5lUG9zID09PSBzY2hlZHVsZWRJdGVtLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgaW5kZXgsIGFzc2V0TGlzdEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXRMaXN0SW5kZXggPSBhc3NldEluZGV4Q2FuZGlkYXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBJbnRlcnN0aXRpYWwgaXMgZW5xdWV1ZWRcbiAgICAgICAgdmFyIHdhaXRpbmdJdGVtID0gdGhpcy53YWl0aW5nSXRlbTtcbiAgICAgICAgaWYgKCF0aGlzLmFzc2V0c0J1ZmZlcmVkKHNjaGVkdWxlZEl0ZW0sIG1lZGlhKSkge1xuICAgICAgICAgIHRoaXMuc2V0QnVmZmVyaW5nSXRlbShzY2hlZHVsZWRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGxheWVyID0gdGhpcy5wcmVsb2FkQXNzZXRzKGludGVyc3RpdGlhbCwgYXNzZXRMaXN0SW5kZXgpO1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRJdGVtc01hdGNoKHNjaGVkdWxlZEl0ZW0sIHdhaXRpbmdJdGVtIHx8IGN1cnJlbnRJdGVtKSkge1xuICAgICAgICAgIHRoaXMud2FpdGluZ0l0ZW0gPSBzY2hlZHVsZWRJdGVtO1xuICAgICAgICAgIHRoaXMubG9nKFwiSU5URVJTVElUSUFMX1NUQVJURUQgXCIgKyBzZWdtZW50VG9TdHJpbmcoc2NoZWR1bGVkSXRlbSkgKyBcIiBcIiArIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSA/ICdhcHBlbmQgaW4gcGxhY2UnIDogJycpKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5JTlRFUlNUSVRJQUxfU1RBUlRFRCwge1xuICAgICAgICAgICAgZXZlbnQ6IGludGVyc3RpdGlhbCxcbiAgICAgICAgICAgIHNjaGVkdWxlOiBzY2hlZHVsZUl0ZW1zLnNsaWNlKDApLFxuICAgICAgICAgICAgc2NoZWR1bGVJbmRleDogaW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZWQpIHtcbiAgICAgICAgICAvLyBXYWl0aW5nIGF0IGVuZCBvZiBwcmltYXJ5IGNvbnRlbnQgc2VnbWVudFxuICAgICAgICAgIC8vIEV4cGVjdCBzZXRTY2hlZHVsZVBvc2l0aW9uIHRvIGJlIGNhbGxlZCBhZ2FpbiBvbmNlIEFTU0VULUxJU1QgaXMgbG9hZGVkXG4gICAgICAgICAgdGhpcy5sb2coXCJXYWl0aW5nIGZvciBBU1NFVC1MSVNUIHRvIGNvbXBsZXRlIGxvYWRpbmcgXCIgKyBpbnRlcnN0aXRpYWwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlcikge1xuICAgICAgICAgIGludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICAgIGludGVyc3RpdGlhbC5hc3NldExpc3RMb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZWRpYSkge1xuICAgICAgICAgIHRoaXMubG9nKFwiV2FpdGluZyBmb3IgYXR0YWNoTWVkaWEgdG8gc3RhcnQgSW50ZXJzdGl0aWFsIFwiICsgaW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHNjaGVkdWxlIGFuZCBhc3NldCBsaXN0IHBvc2l0aW9uIG5vdyB0aGF0IGl0IGNhbiBzdGFydFxuICAgICAgICB0aGlzLndhaXRpbmdJdGVtID0gdGhpcy5lbmRlZEl0ZW0gPSBudWxsO1xuICAgICAgICB0aGlzLnBsYXlpbmdJdGVtID0gc2NoZWR1bGVkSXRlbTtcblxuICAgICAgICAvLyBJZiBhc3NldC1saXN0IGlzIGVtcHR5IG9yIG1pc3NpbmcgYXNzZXQgaW5kZXgsIGFkdmFuY2UgdG8gbmV4dCBpdGVtXG4gICAgICAgIHZhciBhc3NldEl0ZW0gPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2Fzc2V0TGlzdEluZGV4XTtcbiAgICAgICAgaWYgKCFhc3NldEl0ZW0pIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQoaW50ZXJzdGl0aWFsLCBpbmRleCwgYXNzZXRMaXN0SW5kZXggfHwgMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgSW50ZXJzdGl0aWFsIFBsYXliYWNrXG4gICAgICAgIGlmICghcGxheWVyKSB7XG4gICAgICAgICAgcGxheWVyID0gdGhpcy5nZXRBc3NldFBsYXllcihhc3NldEl0ZW0uaWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYXllciA9PT0gbnVsbCB8fCBwbGF5ZXIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdmFyIGFzc2V0TGlzdExlbmd0aCA9IGludGVyc3RpdGlhbC5hc3NldExpc3QubGVuZ3RoO1xuICAgICAgICAgIHRoaXMud2FybihcImFzc2V0IFwiICsgKGFzc2V0TGlzdEluZGV4ICsgMSkgKyBcIi9cIiArIGFzc2V0TGlzdExlbmd0aCArIFwiIHBsYXllciBkZXN0cm95ZWQgXCIgKyBpbnRlcnN0aXRpYWwpO1xuICAgICAgICAgIHBsYXllciA9IHRoaXMuY3JlYXRlQXNzZXRQbGF5ZXIoaW50ZXJzdGl0aWFsLCBhc3NldEl0ZW0sIGFzc2V0TGlzdEluZGV4KTtcbiAgICAgICAgICBwbGF5ZXIubG9hZFNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ldmVudEl0ZW1zTWF0Y2goc2NoZWR1bGVkSXRlbSwgdGhpcy5idWZmZXJpbmdJdGVtKSkge1xuICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSAmJiB0aGlzLmlzQXNzZXRCdWZmZXJlZChhc3NldEl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRBc3NldFBsYXllcihwbGF5ZXIsIGFzc2V0TGlzdEluZGV4LCBzY2hlZHVsZUl0ZW1zLCBpbmRleCwgbWVkaWEpO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRQbGF5KSB7XG4gICAgICAgICAgcGxheVdpdGhDYXRjaChwbGF5ZXIubWVkaWEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNjaGVkdWxlZEl0ZW0pIHtcbiAgICAgICAgdGhpcy5yZXN1bWVQcmltYXJ5KHNjaGVkdWxlZEl0ZW0sIGluZGV4LCBjdXJyZW50SXRlbSk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFBsYXkpIHtcbiAgICAgICAgICBwbGF5V2l0aENhdGNoKHRoaXMuaGxzLm1lZGlhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwbGF5ZWRMYXN0SXRlbSAmJiB0aGlzLmlzSW50ZXJzdGl0aWFsKGN1cnJlbnRJdGVtKSkge1xuICAgICAgICAvLyBNYWludGFpbiBwbGF5aW5nSXRlbSBzdGF0ZSBhdCBlbmQgb2Ygc2NoZWR1bGUgKHNldFNjaGVkdWxlUG9zaXRpb24oLTEpIGNhbGxlZCB0byBlbmQgcHJvZ3JhbSlcbiAgICAgICAgLy8gdGhpcyBhbGxvd3Mgb25TZWVraW5nIGhhbmRsZXIgdG8gdXBkYXRlIHNjaGVkdWxlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuZW5kZWRJdGVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbGF5aW5nSXRlbSA9IGN1cnJlbnRJdGVtO1xuICAgICAgICBpZiAoIWN1cnJlbnRJdGVtLmV2ZW50LmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAvLyBNZWRpYSBtdXN0IGJlIHJlLWF0dGFjaGVkIHRvIHJlc3VtZSBwcmltYXJ5IHNjaGVkdWxlIGlmIG5vdCBzaGFyaW5nIHNvdXJjZVxuICAgICAgICAgIHRoaXMuYXR0YWNoUHJpbWFyeShzY2hlZHVsZS5kdXJhdGlvbnMucHJpbWFyeSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZXN1bWVQcmltYXJ5ID0gZnVuY3Rpb24gcmVzdW1lUHJpbWFyeShzY2hlZHVsZWRJdGVtLCBpbmRleCwgZnJvbUl0ZW0pIHtcbiAgICAgIHZhciBfdGhpcyRkZXRhY2hlZERhdGEzLCBfdGhpcyRzY2hlZHVsZTM7XG4gICAgICB0aGlzLnBsYXlpbmdJdGVtID0gc2NoZWR1bGVkSXRlbTtcbiAgICAgIHRoaXMucGxheWluZ0Fzc2V0ID0gdGhpcy5lbmRlZEFzc2V0ID0gbnVsbDtcbiAgICAgIHRoaXMud2FpdGluZ0l0ZW0gPSB0aGlzLmVuZGVkSXRlbSA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKHNjaGVkdWxlZEl0ZW0pO1xuICAgICAgdGhpcy5sb2coXCJyZXN1bWluZyBcIiArIHNlZ21lbnRUb1N0cmluZyhzY2hlZHVsZWRJdGVtKSk7XG4gICAgICBpZiAoISgoX3RoaXMkZGV0YWNoZWREYXRhMyA9IHRoaXMuZGV0YWNoZWREYXRhKSAhPSBudWxsICYmIF90aGlzJGRldGFjaGVkRGF0YTMubWVkaWFTb3VyY2UpKSB7XG4gICAgICAgIHZhciB0aW1lbGluZVBvcyA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgICAgIGlmICh0aW1lbGluZVBvcyA8IHNjaGVkdWxlZEl0ZW0uc3RhcnQgfHwgdGltZWxpbmVQb3MgPj0gc2NoZWR1bGVkSXRlbS5lbmQpIHtcbiAgICAgICAgICB0aW1lbGluZVBvcyA9IHRoaXMuZ2V0UHJpbWFyeVJlc3VtcHRpb24oc2NoZWR1bGVkSXRlbSwgaW5kZXgpO1xuICAgICAgICAgIHRoaXMubG9nKHRpbWVsaW5lTWVzc2FnZSgncmVzdW1lUHJpbWFyeScsIHRpbWVsaW5lUG9zKSk7XG4gICAgICAgICAgdGhpcy50aW1lbGluZVBvcyA9IHRpbWVsaW5lUG9zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0YWNoUHJpbWFyeSh0aW1lbGluZVBvcywgc2NoZWR1bGVkSXRlbSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZyb21JdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzY2hlZHVsZUl0ZW1zID0gKF90aGlzJHNjaGVkdWxlMyA9IHRoaXMuc2NoZWR1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzY2hlZHVsZTMuaXRlbXM7XG4gICAgICBpZiAoIXNjaGVkdWxlSXRlbXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2coXCJJTlRFUlNUSVRJQUxTX1BSSU1BUllfUkVTVU1FRCBcIiArIHNlZ21lbnRUb1N0cmluZyhzY2hlZHVsZWRJdGVtKSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5JTlRFUlNUSVRJQUxTX1BSSU1BUllfUkVTVU1FRCwge1xuICAgICAgICBzY2hlZHVsZTogc2NoZWR1bGVJdGVtcy5zbGljZSgwKSxcbiAgICAgICAgc2NoZWR1bGVJbmRleDogaW5kZXhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFByaW1hcnlSZXN1bXB0aW9uID0gZnVuY3Rpb24gZ2V0UHJpbWFyeVJlc3VtcHRpb24oc2NoZWR1bGVkSXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBpdGVtU3RhcnQgPSBzY2hlZHVsZWRJdGVtLnN0YXJ0O1xuICAgICAgaWYgKHRoaXMucHJpbWFyeUxpdmUpIHtcbiAgICAgICAgdmFyIGRldGFpbHMgPSB0aGlzLnByaW1hcnlEZXRhaWxzO1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5obHMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChkZXRhaWxzICYmIChpdGVtU3RhcnQgPCBkZXRhaWxzLmZyYWdtZW50U3RhcnQgfHwgaXRlbVN0YXJ0ID4gZGV0YWlscy5lZGdlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbVN0YXJ0O1xuICAgIH07XG4gICAgX3Byb3RvLmlzQXNzZXRCdWZmZXJlZCA9IGZ1bmN0aW9uIGlzQXNzZXRCdWZmZXJlZChhc3NldCkge1xuICAgICAgdmFyIHBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXQuaWRlbnRpZmllcik7XG4gICAgICBpZiAocGxheWVyICE9IG51bGwgJiYgcGxheWVyLmhscykge1xuICAgICAgICByZXR1cm4gcGxheWVyLmhscy5idWZmZXJlZFRvRW5kO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLnByaW1hcnlNZWRpYSwgdGhpcy50aW1lbGluZVBvcywgMCk7XG4gICAgICByZXR1cm4gYnVmZmVySW5mby5lbmQgKyAxID49IGFzc2V0LnRpbWVsaW5lU3RhcnQgKyAoYXNzZXQuZHVyYXRpb24gfHwgMCk7XG4gICAgfTtcbiAgICBfcHJvdG8uYXR0YWNoUHJpbWFyeSA9IGZ1bmN0aW9uIGF0dGFjaFByaW1hcnkodGltZWxpbmVQb3MsIGl0ZW0sIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICB0aGlzLnNldEJ1ZmZlcmluZ0l0ZW0oaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJpbmdBc3NldCA9IG51bGw7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKGhscy5tZWRpYSkge1xuICAgICAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyYW5zZmVyTWVkaWFUbyhobHMsIG1lZGlhKTtcbiAgICAgICAgaWYgKHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKSB7XG4gICAgICAgICAgdGhpcy5zdGFydExvYWRpbmdQcmltYXJ5QXQodGltZWxpbmVQb3MsIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgICAgICAvLyBTZXQgcHJpbWFyeSBwb3NpdGlvbiB0byByZXN1bWUgdGltZVxuICAgICAgICB0aGlzLmxvZyh0aW1lbGluZU1lc3NhZ2UoJ2F0dGFjaFByaW1hcnknLCB0aW1lbGluZVBvcykpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lUG9zID0gdGltZWxpbmVQb3M7XG4gICAgICAgIHRoaXMuc3RhcnRMb2FkaW5nUHJpbWFyeUF0KHRpbWVsaW5lUG9zLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRMb2FkaW5nUHJpbWFyeUF0ID0gZnVuY3Rpb24gc3RhcnRMb2FkaW5nUHJpbWFyeUF0KHRpbWVsaW5lUG9zLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgICAgdmFyIF9obHMkbWFpbkZvcndhcmRCdWZmZTtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmICghaGxzLmxvYWRpbmdFbmFibGVkIHx8ICFobHMubWVkaWEgfHwgTWF0aC5hYnMoKCgoX2hscyRtYWluRm9yd2FyZEJ1ZmZlID0gaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9obHMkbWFpbkZvcndhcmRCdWZmZS5zdGFydCkgfHwgaGxzLm1lZGlhLmN1cnJlbnRUaW1lKSAtIHRpbWVsaW5lUG9zKSA+IDAuNSkge1xuICAgICAgICBobHMuc3RhcnRMb2FkKHRpbWVsaW5lUG9zLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKCFobHMuYnVmZmVyaW5nRW5hYmxlZCkge1xuICAgICAgICBobHMucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSExTLmpzIGV2ZW50IGNhbGxiYWNrc1xuICAgIDtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIHZhciBfdGhpcyRzY2hlZHVsZTQ7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICAoX3RoaXMkc2NoZWR1bGU0ID0gdGhpcy5zY2hlZHVsZSkgPT0gbnVsbCB8fCBfdGhpcyRzY2hlZHVsZTQucmVzZXQoKTtcbiAgICAgIHRoaXMuZW1wdHlQbGF5ZXJRdWV1ZSgpO1xuICAgICAgdGhpcy5jbGVhclNjaGVkdWxlU3RhdGUoKTtcbiAgICAgIHRoaXMuc2hvdWxkUGxheSA9IGZhbHNlO1xuICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IHRoaXMudGltZWxpbmVQb3MgPSAtMTtcbiAgICAgIHRoaXMubWVkaWFTZWxlY3Rpb24gPSB0aGlzLmFsdFNlbGVjdGlvbiA9IHRoaXMubWFuYWdlciA9IHRoaXMucmVxdWlyZWRUcmFja3MgPSBudWxsO1xuICAgICAgLy8gQlVGRkVSX0NPREVDUyBsaXN0ZW5lciBhZGRlZCBoZXJlIGZvciBidWZmZXItY29udHJvbGxlciB0byBoYW5kbGUgaXQgZmlyc3Qgd2hlcmUgaXQgYWRkcyB0cmFja3NcbiAgICAgIHRoaXMuaGxzLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgICB0aGlzLmhscy5vbihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbFVwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEubGV2ZWwgPT09IC0xIHx8ICF0aGlzLnNjaGVkdWxlKSB7XG4gICAgICAgIC8vIGxldmVsIHdhcyByZW1vdmVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtYWluID0gdGhpcy5obHMubGV2ZWxzW2RhdGEubGV2ZWxdO1xuICAgICAgaWYgKCFtYWluLmRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5tZWRpYVNlbGVjdGlvbiB8fCB0aGlzLmFsdFNlbGVjdGlvbiksIHt9LCB7XG4gICAgICAgIG1haW46IG1haW5cbiAgICAgIH0pO1xuICAgICAgdGhpcy5tZWRpYVNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICB0aGlzLnNjaGVkdWxlLnBhcnNlSW50ZXJzdGl0aWFsRGF0ZVJhbmdlcyhjdXJyZW50U2VsZWN0aW9uLCB0aGlzLmhscy5jb25maWcuaW50ZXJzdGl0aWFsQXBwZW5kSW5QbGFjZSk7XG4gICAgICBpZiAoIXRoaXMuZWZmZWN0aXZlUGxheWluZ0l0ZW0gJiYgdGhpcy5zY2hlZHVsZS5pdGVtcykge1xuICAgICAgICB0aGlzLmNoZWNrU3RhcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkF1ZGlvVHJhY2tVcGRhdGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGF1ZGlvID0gdGhpcy5obHMuYXVkaW9UcmFja3NbZGF0YS5pZF07XG4gICAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSB0aGlzLm1lZGlhU2VsZWN0aW9uO1xuICAgICAgaWYgKCFwcmV2aW91c1NlbGVjdGlvbikge1xuICAgICAgICB0aGlzLmFsdFNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLmFsdFNlbGVjdGlvbiksIHt9LCB7XG4gICAgICAgICAgYXVkaW86IGF1ZGlvXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcmV2aW91c1NlbGVjdGlvbiksIHt9LCB7XG4gICAgICAgIGF1ZGlvOiBhdWRpb1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1lZGlhU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcbiAgICB9O1xuICAgIF9wcm90by5vblN1YnRpdGxlVHJhY2tVcGRhdGVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIHN1YnRpdGxlcyA9IHRoaXMuaGxzLnN1YnRpdGxlVHJhY2tzW2RhdGEuaWRdO1xuICAgICAgdmFyIHByZXZpb3VzU2VsZWN0aW9uID0gdGhpcy5tZWRpYVNlbGVjdGlvbjtcbiAgICAgIGlmICghcHJldmlvdXNTZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5hbHRTZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5hbHRTZWxlY3Rpb24pLCB7fSwge1xuICAgICAgICAgIHN1YnRpdGxlczogc3VidGl0bGVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcmV2aW91c1NlbGVjdGlvbiksIHt9LCB7XG4gICAgICAgIHN1YnRpdGxlczogc3VidGl0bGVzXG4gICAgICB9KTtcbiAgICAgIHRoaXMubWVkaWFTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgIH07XG4gICAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGluZyA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGF1ZGlvT3B0aW9uID0gZ2V0QmFzaWNTZWxlY3Rpb25PcHRpb24oZGF0YSk7XG4gICAgICB0aGlzLnBsYXllclF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGhscyA9IF9yZWYuaGxzO1xuICAgICAgICByZXR1cm4gaGxzICYmIChobHMuc2V0QXVkaW9PcHRpb24oZGF0YSkgfHwgaGxzLnNldEF1ZGlvT3B0aW9uKGF1ZGlvT3B0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vblN1YnRpdGxlVHJhY2tTd2l0Y2ggPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBzdWJ0aXRsZU9wdGlvbiA9IGdldEJhc2ljU2VsZWN0aW9uT3B0aW9uKGRhdGEpO1xuICAgICAgdGhpcy5wbGF5ZXJRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgaGxzID0gX3JlZjIuaGxzO1xuICAgICAgICByZXR1cm4gaGxzICYmIChobHMuc2V0U3VidGl0bGVPcHRpb24oZGF0YSkgfHwgZGF0YS5pZCAhPT0gLTEgJiYgaGxzLnNldFN1YnRpdGxlT3B0aW9uKHN1YnRpdGxlT3B0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckNvZGVjcyA9IGZ1bmN0aW9uIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgcmVxdWlyZWRUcmFja3MgPSBkYXRhLnRyYWNrcztcbiAgICAgIGlmIChyZXF1aXJlZFRyYWNrcykge1xuICAgICAgICB0aGlzLnJlcXVpcmVkVHJhY2tzID0gcmVxdWlyZWRUcmFja3M7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJBcHBlbmRlZCA9IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBwbGF5aW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgICBpZiAocGxheWluZ0l0ZW0gJiYgIXRoaXMuaXRlbXNNYXRjaChwbGF5aW5nSXRlbSwgdGhpcy5idWZmZXJpbmdJdGVtKSAmJiAhdGhpcy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkpIHtcbiAgICAgICAgdmFyIHRpbWVsaW5lUG9zID0gdGhpcy50aW1lbGluZVBvcztcbiAgICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IHRpbWVsaW5lUG9zO1xuICAgICAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJlZFRvRW5kID0gZnVuY3Rpb24gb25CdWZmZXJlZFRvRW5kKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuc2NoZWR1bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQnVmZmVyZWQgdG8gcG9zdC1yb2xsXG4gICAgICB2YXIgaW50ZXJzdGl0aWFsRXZlbnRzID0gdGhpcy5zY2hlZHVsZS5ldmVudHM7XG4gICAgICBpZiAodGhpcy5idWZmZXJlZFBvcyA8IE51bWJlci5NQVhfVkFMVUUgJiYgaW50ZXJzdGl0aWFsRXZlbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJzdGl0aWFsRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGludGVyc3RpdGlhbCA9IGludGVyc3RpdGlhbEV2ZW50c1tpXTtcbiAgICAgICAgICBpZiAoaW50ZXJzdGl0aWFsLmN1ZS5wb3N0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkc2NoZWR1bGUkaXRlbXMyO1xuICAgICAgICAgICAgdmFyIHNjaGVkdWxlSW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbC5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHZhciBpdGVtID0gKF90aGlzJHNjaGVkdWxlJGl0ZW1zMiA9IHRoaXMuc2NoZWR1bGUuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzY2hlZHVsZSRpdGVtczJbc2NoZWR1bGVJbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ludGVyc3RpdGlhbChpdGVtKSAmJiB0aGlzLmV2ZW50SXRlbXNNYXRjaChpdGVtLCB0aGlzLmJ1ZmZlcmluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRUb0l0ZW0oaXRlbSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUVuZGVkID0gZnVuY3Rpb24gb25NZWRpYUVuZGVkKGV2ZW50KSB7XG4gICAgICB2YXIgcGxheWluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgaWYgKCF0aGlzLnBsYXlpbmdMYXN0SXRlbSAmJiBwbGF5aW5nSXRlbSkge1xuICAgICAgICB2YXIgcGxheWluZ0luZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4KHBsYXlpbmdJdGVtKTtcbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKHBsYXlpbmdJbmRleCArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG91bGRQbGF5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlSXRlbSA9IGZ1bmN0aW9uIHVwZGF0ZUl0ZW0ocHJldmlvdXNJdGVtLCB0aW1lKSB7XG4gICAgICB2YXIgX3RoaXMkc2NoZWR1bGU1O1xuICAgICAgLy8gZmluZCBpdGVtIGluIHRoaXMuc2NoZWR1bGUuaXRlbXM7XG4gICAgICB2YXIgaXRlbXMgPSAoX3RoaXMkc2NoZWR1bGU1ID0gdGhpcy5zY2hlZHVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHNjaGVkdWxlNS5pdGVtcztcbiAgICAgIGlmIChwcmV2aW91c0l0ZW0gJiYgaXRlbXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4KHByZXZpb3VzSXRlbSwgdGltZSk7XG4gICAgICAgIHJldHVybiBpdGVtc1tpbmRleF0gfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnRyaW1JblBsYWNlID0gZnVuY3Rpb24gdHJpbUluUGxhY2UodXBkYXRlZEl0ZW0sIGl0ZW1CZWZvcmVVcGRhdGUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaXNJbnRlcnN0aXRpYWwodXBkYXRlZEl0ZW0pICYmIHVwZGF0ZWRJdGVtLmV2ZW50LmFwcGVuZEluUGxhY2UgJiYgaXRlbUJlZm9yZVVwZGF0ZS5lbmQgLSB1cGRhdGVkSXRlbS5lbmQgPiAwLjI1KSB7XG4gICAgICAgIHVwZGF0ZWRJdGVtLmV2ZW50LmFzc2V0TGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChhc3NldCwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAodXBkYXRlZEl0ZW0uZXZlbnQuaXNBc3NldFBhc3RQbGF5b3V0TGltaXQoaW5kZXgpKSB7XG4gICAgICAgICAgICBfdGhpczQuY2xlYXJBc3NldFBsYXllcihhc3NldC5pZGVudGlmaWVyLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZmx1c2hTdGFydCA9IHVwZGF0ZWRJdGVtLmVuZCArIDAuMjU7XG4gICAgICAgIHZhciBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odGhpcy5wcmltYXJ5TWVkaWEsIGZsdXNoU3RhcnQsIDApO1xuICAgICAgICBpZiAoYnVmZmVySW5mby5lbmQgPiBmbHVzaFN0YXJ0IHx8IChidWZmZXJJbmZvLm5leHRTdGFydCB8fCAwKSA+IGZsdXNoU3RhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcInRyaW0gYnVmZmVyZWQgaW50ZXJzdGl0aWFsIFwiICsgc2VnbWVudFRvU3RyaW5nKHVwZGF0ZWRJdGVtKSArIFwiICh3YXMgXCIgKyBzZWdtZW50VG9TdHJpbmcoaXRlbUJlZm9yZVVwZGF0ZSkgKyBcIilcIik7XG4gICAgICAgICAgdmFyIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmF0dGFjaFByaW1hcnkoZmx1c2hTdGFydCwgbnVsbCwgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcihmbHVzaFN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLml0ZW1zTWF0Y2ggPSBmdW5jdGlvbiBpdGVtc01hdGNoKGEsIGIpIHtcbiAgICAgIHJldHVybiAhIWIgJiYgKGEgPT09IGIgfHwgYS5ldmVudCAmJiBiLmV2ZW50ICYmIHRoaXMuZXZlbnRJdGVtc01hdGNoKGEsIGIpIHx8ICFhLmV2ZW50ICYmICFiLmV2ZW50ICYmIHRoaXMuZmluZEl0ZW1JbmRleChhKSA9PT0gdGhpcy5maW5kSXRlbUluZGV4KGIpKTtcbiAgICB9O1xuICAgIF9wcm90by5ldmVudEl0ZW1zTWF0Y2ggPSBmdW5jdGlvbiBldmVudEl0ZW1zTWF0Y2goYSwgYikge1xuICAgICAgdmFyIF9iJGV2ZW50O1xuICAgICAgcmV0dXJuICEhYiAmJiAoYSA9PT0gYiB8fCBhLmV2ZW50LmlkZW50aWZpZXIgPT09ICgoX2IkZXZlbnQgPSBiLmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2IkZXZlbnQuaWRlbnRpZmllcikpO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmRJdGVtSW5kZXggPSBmdW5jdGlvbiBmaW5kSXRlbUluZGV4KGl0ZW0sIHRpbWUpIHtcbiAgICAgIHJldHVybiBpdGVtICYmIHRoaXMuc2NoZWR1bGUgPyB0aGlzLnNjaGVkdWxlLmZpbmRJdGVtSW5kZXgoaXRlbSwgdGltZSkgOiAtMTtcbiAgICB9O1xuICAgIF9wcm90by51cGRhdGVTY2hlZHVsZSA9IGZ1bmN0aW9uIHVwZGF0ZVNjaGVkdWxlKGZvcmNlVXBkYXRlKSB7XG4gICAgICB2YXIgX3RoaXMkc2NoZWR1bGU2O1xuICAgICAgaWYgKGZvcmNlVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgZm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBtZWRpYVNlbGVjdGlvbiA9IHRoaXMubWVkaWFTZWxlY3Rpb247XG4gICAgICBpZiAoIW1lZGlhU2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIChfdGhpcyRzY2hlZHVsZTYgPSB0aGlzLnNjaGVkdWxlKSA9PSBudWxsIHx8IF90aGlzJHNjaGVkdWxlNi51cGRhdGVTY2hlZHVsZShtZWRpYVNlbGVjdGlvbiwgW10sIGZvcmNlVXBkYXRlKTtcbiAgICB9XG5cbiAgICAvLyBTY2hlZHVsZSBidWZmZXIgY29udHJvbFxuICAgIDtcbiAgICBfcHJvdG8uY2hlY2tCdWZmZXIgPSBmdW5jdGlvbiBjaGVja0J1ZmZlcihzdGFydmVkKSB7XG4gICAgICB2YXIgX3RoaXMkc2NoZWR1bGU3O1xuICAgICAgdmFyIGl0ZW1zID0gKF90aGlzJHNjaGVkdWxlNyA9IHRoaXMuc2NoZWR1bGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzY2hlZHVsZTcuaXRlbXM7XG4gICAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEZpbmQgd2hlbiBjb21iaW5lZCBmb3J3YXJkIGJ1ZmZlciBjaGFuZ2UgcmVhY2hlcyBuZXh0IHNjaGVkdWxlIHNlZ21lbnRcbiAgICAgIHZhciBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odGhpcy5wcmltYXJ5TWVkaWEsIHRoaXMudGltZWxpbmVQb3MsIDApO1xuICAgICAgaWYgKHN0YXJ2ZWQpIHtcbiAgICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgICB9XG4gICAgICBzdGFydmVkIHx8IChzdGFydmVkID0gYnVmZmVySW5mby5sZW4gPCAxKTtcbiAgICAgIHRoaXMudXBkYXRlQnVmZmVyZWRQb3MoYnVmZmVySW5mby5lbmQsIGl0ZW1zLCBzdGFydmVkKTtcbiAgICB9O1xuICAgIF9wcm90by51cGRhdGVCdWZmZXJlZFBvcyA9IGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlcmVkUG9zKGJ1ZmZlckVuZCwgaXRlbXMsIGJ1ZmZlcklzRW1wdHkpIHtcbiAgICAgIHZhciBzY2hlZHVsZSA9IHRoaXMuc2NoZWR1bGU7XG4gICAgICB2YXIgYnVmZmVyaW5nSXRlbSA9IHRoaXMuYnVmZmVyaW5nSXRlbTtcbiAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkUG9zID4gYnVmZmVyRW5kIHx8ICFzY2hlZHVsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxICYmIHRoaXMuaXRlbXNNYXRjaChpdGVtc1swXSwgYnVmZmVyaW5nSXRlbSkpIHtcbiAgICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IGJ1ZmZlckVuZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBsYXlpbmdJdGVtID0gdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgIHZhciBwbGF5aW5nSW5kZXggPSB0aGlzLmZpbmRJdGVtSW5kZXgocGxheWluZ0l0ZW0pO1xuICAgICAgdmFyIGJ1ZmZlckVuZEluZGV4ID0gc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZShidWZmZXJFbmQpO1xuICAgICAgaWYgKHRoaXMuYnVmZmVyZWRQb3MgPCBidWZmZXJFbmQpIHtcbiAgICAgICAgdmFyIF9uZXh0SXRlbVRvQnVmZmVyJGV2ZTtcbiAgICAgICAgdmFyIGJ1ZmZlcmluZ0luZGV4ID0gdGhpcy5maW5kSXRlbUluZGV4KGJ1ZmZlcmluZ0l0ZW0pO1xuICAgICAgICB2YXIgbmV4dFRvQnVmZmVySW5kZXggPSBNYXRoLm1pbihidWZmZXJpbmdJbmRleCArIDEsIGl0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbmV4dEl0ZW1Ub0J1ZmZlciA9IGl0ZW1zW25leHRUb0J1ZmZlckluZGV4XTtcbiAgICAgICAgaWYgKGJ1ZmZlckVuZEluZGV4ID09PSAtMSAmJiBidWZmZXJpbmdJdGVtICYmIGJ1ZmZlckVuZCA+PSBidWZmZXJpbmdJdGVtLmVuZCB8fCAoX25leHRJdGVtVG9CdWZmZXIkZXZlID0gbmV4dEl0ZW1Ub0J1ZmZlci5ldmVudCkgIT0gbnVsbCAmJiBfbmV4dEl0ZW1Ub0J1ZmZlciRldmUuYXBwZW5kSW5QbGFjZSAmJiBidWZmZXJFbmQgKyAwLjAxID49IG5leHRJdGVtVG9CdWZmZXIuc3RhcnQpIHtcbiAgICAgICAgICBidWZmZXJFbmRJbmRleCA9IG5leHRUb0J1ZmZlckluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKGJ1ZmZlcmluZ0l0ZW0pKSB7XG4gICAgICAgICAgdmFyIGludGVyc3RpdGlhbCA9IGJ1ZmZlcmluZ0l0ZW0uZXZlbnQ7XG4gICAgICAgICAgaWYgKG5leHRUb0J1ZmZlckluZGV4IC0gcGxheWluZ0luZGV4ID4gMSAmJiBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdCBhZHZhbmNlIGJ1ZmZlcmluZyBpdGVtIHBhc3QgSW50ZXJzdGl0aWFsIHRoYXQgcmVxdWlyZXMgc291cmNlIHJlc2V0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXNzZXRMaXN0Lmxlbmd0aCA9PT0gMCAmJiBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0TG9hZGVyKSB7XG4gICAgICAgICAgICAvLyBkbyBub3QgYWR2YW5jZSBidWZmZXJpbmcgaXRlbSBwYXN0IEludGVyc3RpdGlhbCBsb2FkaW5nIGFzc2V0LWxpc3RcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IGJ1ZmZlckVuZDtcbiAgICAgICAgaWYgKGJ1ZmZlckVuZEluZGV4ID4gYnVmZmVyaW5nSW5kZXggJiYgYnVmZmVyRW5kSW5kZXggPiBwbGF5aW5nSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKG5leHRJdGVtVG9CdWZmZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFsbG93IG1vcmUgdGltZSB0aGFuIGRpc3RhbmNlIGZyb20gZWRnZSBmb3IgYXNzZXRzIHRvIGxvYWRcbiAgICAgICAgICB2YXIgZGV0YWlscyA9IHRoaXMucHJpbWFyeURldGFpbHM7XG4gICAgICAgICAgaWYgKHRoaXMucHJpbWFyeUxpdmUgJiYgZGV0YWlscyAmJiBidWZmZXJFbmQgPiBkZXRhaWxzLmVkZ2UgLSBkZXRhaWxzLnRhcmdldGR1cmF0aW9uICYmIG5leHRJdGVtVG9CdWZmZXIuc3RhcnQgPCBkZXRhaWxzLmVkZ2UgKyB0aGlzLmhscy5jb25maWcuaW50ZXJzdGl0aWFsTGl2ZUxvb2tBaGVhZCAmJiB0aGlzLmlzSW50ZXJzdGl0aWFsKG5leHRJdGVtVG9CdWZmZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnByZWxvYWRBc3NldHMobmV4dEl0ZW1Ub0J1ZmZlci5ldmVudCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlcklzRW1wdHkgJiYgcGxheWluZ0l0ZW0gJiYgIXRoaXMuaXRlbXNNYXRjaChwbGF5aW5nSXRlbSwgYnVmZmVyaW5nSXRlbSkpIHtcbiAgICAgICAgaWYgKGJ1ZmZlckVuZEluZGV4ID09PSBwbGF5aW5nSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKHBsYXlpbmdJdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXJFbmRJbmRleCA9PT0gcGxheWluZ0luZGV4ICsgMSkge1xuICAgICAgICAgIHRoaXMuYnVmZmVyZWRUb0l0ZW0oaXRlbXNbYnVmZmVyRW5kSW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFzc2V0c0J1ZmZlcmVkID0gZnVuY3Rpb24gYXNzZXRzQnVmZmVyZWQoaXRlbSwgbWVkaWEpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdmFyIGFzc2V0TGlzdCA9IGl0ZW0uZXZlbnQuYXNzZXRMaXN0O1xuICAgICAgaWYgKGFzc2V0TGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFpdGVtLmV2ZW50LmFzc2V0TGlzdC5zb21lKGZ1bmN0aW9uIChhc3NldCkge1xuICAgICAgICB2YXIgcGxheWVyID0gX3RoaXM1LmdldEFzc2V0UGxheWVyKGFzc2V0LmlkZW50aWZpZXIpO1xuICAgICAgICByZXR1cm4gIShwbGF5ZXIgIT0gbnVsbCAmJiBwbGF5ZXIuYnVmZmVyZWRJblBsYWNlVG9FbmQobWVkaWEpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnNldEJ1ZmZlcmluZ0l0ZW0gPSBmdW5jdGlvbiBzZXRCdWZmZXJpbmdJdGVtKGl0ZW0pIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgdmFyIGJ1ZmZlcmluZ0xhc3QgPSB0aGlzLmJ1ZmZlcmluZ0l0ZW07XG4gICAgICB2YXIgc2NoZWR1bGUgPSB0aGlzLnNjaGVkdWxlO1xuICAgICAgaWYgKCF0aGlzLml0ZW1zTWF0Y2goaXRlbSwgYnVmZmVyaW5nTGFzdCkgJiYgc2NoZWR1bGUpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gc2NoZWR1bGUuaXRlbXMsXG4gICAgICAgICAgZXZlbnRzID0gc2NoZWR1bGUuZXZlbnRzO1xuICAgICAgICBpZiAoIWl0ZW1zIHx8ICFldmVudHMpIHtcbiAgICAgICAgICByZXR1cm4gYnVmZmVyaW5nTGFzdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNJbnRlcnN0aXRpYWwgPSB0aGlzLmlzSW50ZXJzdGl0aWFsKGl0ZW0pO1xuICAgICAgICB2YXIgYnVmZmVyaW5nUGxheWVyID0gdGhpcy5nZXRCdWZmZXJpbmdQbGF5ZXIoKTtcbiAgICAgICAgdGhpcy5idWZmZXJpbmdJdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IE1hdGgubWF4KGl0ZW0uc3RhcnQsIE1hdGgubWluKGl0ZW0uZW5kLCB0aGlzLnRpbWVsaW5lUG9zKSk7XG4gICAgICAgIHZhciB0aW1lUmVtYWluaW5nID0gYnVmZmVyaW5nUGxheWVyID8gYnVmZmVyaW5nUGxheWVyLnJlbWFpbmluZyA6IGJ1ZmZlcmluZ0xhc3QgPyBidWZmZXJpbmdMYXN0LmVuZCAtIHRoaXMudGltZWxpbmVQb3MgOiAwO1xuICAgICAgICB0aGlzLmxvZyhcIklOVEVSU1RJVElBTFNfQlVGRkVSRURfVE9fQk9VTkRBUlkgXCIgKyBzZWdtZW50VG9TdHJpbmcoaXRlbSkgKyAoYnVmZmVyaW5nTGFzdCA/IFwiIChcIiArIHRpbWVSZW1haW5pbmcudG9GaXhlZCgyKSArIFwiIHJlbWFpbmluZylcIiA6ICcnKSk7XG4gICAgICAgIGlmICghdGhpcy5wbGF5YmFja0Rpc2FibGVkKSB7XG4gICAgICAgICAgaWYgKGlzSW50ZXJzdGl0aWFsKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVySW5kZXggPSBzY2hlZHVsZS5maW5kQXNzZXRJbmRleChpdGVtLmV2ZW50LCB0aGlzLmJ1ZmZlcmVkUG9zKTtcbiAgICAgICAgICAgIC8vIHByaW1hcnkgZnJhZ21lbnQgbG9hZGluZyB3aWxsIGV4aXQgZWFybHkgaW4gYmFzZS1zdHJlYW0tY29udHJvbGxlciB3aGlsZSBgYnVmZmVyaW5nSXRlbWAgaXMgc2V0IHRvIGFuIEludGVyc3RpdGlhbCBibG9ja1xuICAgICAgICAgICAgaXRlbS5ldmVudC5hc3NldExpc3QuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXQsIGkpIHtcbiAgICAgICAgICAgICAgdmFyIHBsYXllciA9IF90aGlzNi5nZXRBc3NldFBsYXllcihhc3NldC5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgaWYgKHBsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBidWZmZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgcGxheWVyLmxvYWRTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGxheWVyLnJlc3VtZUJ1ZmZlcmluZygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5obHMucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLnBsYXllclF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICByZXR1cm4gcGxheWVyLnBhdXNlQnVmZmVyaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMU19CVUZGRVJFRF9UT19CT1VOREFSWSwge1xuICAgICAgICAgIGV2ZW50czogZXZlbnRzLnNsaWNlKDApLFxuICAgICAgICAgIHNjaGVkdWxlOiBpdGVtcy5zbGljZSgwKSxcbiAgICAgICAgICBidWZmZXJpbmdJbmRleDogdGhpcy5maW5kSXRlbUluZGV4KGl0ZW0pLFxuICAgICAgICAgIHBsYXlpbmdJbmRleDogdGhpcy5maW5kSXRlbUluZGV4KHRoaXMucGxheWluZ0l0ZW0pXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJ1ZmZlcmluZ0l0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgdGhpcy5idWZmZXJpbmdJdGVtID0gaXRlbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJpbmdMYXN0O1xuICAgIH07XG4gICAgX3Byb3RvLmJ1ZmZlcmVkVG9JdGVtID0gZnVuY3Rpb24gYnVmZmVyZWRUb0l0ZW0oaXRlbSwgYXNzZXRMaXN0SW5kZXgpIHtcbiAgICAgIGlmIChhc3NldExpc3RJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGFzc2V0TGlzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXJpbmdMYXN0ID0gdGhpcy5zZXRCdWZmZXJpbmdJdGVtKGl0ZW0pO1xuICAgICAgaWYgKHRoaXMucGxheWJhY2tEaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0ludGVyc3RpdGlhbChpdGVtKSkge1xuICAgICAgICAvLyBFbnN1cmUgYXNzZXQgbGlzdCBpcyBsb2FkZWRcbiAgICAgICAgdGhpcy5idWZmZXJlZFRvRXZlbnQoaXRlbSwgYXNzZXRMaXN0SW5kZXgpO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXJpbmdMYXN0ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHByaW1hcnkgcGxheWVyIGlzIGRldGFjaGVkLCBpdCBpcyBhbHNvIHN0b3BwZWQsIHJlc3RhcnQgbG9hZGluZyBhdCBwcmltYXJ5IHBvc2l0aW9uXG4gICAgICAgIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBudWxsO1xuICAgICAgICB2YXIgZGV0YWNoZWREYXRhID0gdGhpcy5kZXRhY2hlZERhdGE7XG4gICAgICAgIGlmIChkZXRhY2hlZERhdGEpIHtcbiAgICAgICAgICBpZiAoZGV0YWNoZWREYXRhLm1lZGlhU291cmNlKSB7XG4gICAgICAgICAgICB2YXIgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hQcmltYXJ5KGl0ZW0uc3RhcnQsIGl0ZW0sIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmVsb2FkUHJpbWFyeShpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbm90IGRldGFjaGVkIHNlZWsgdG8gcmVzdW1wdGlvbiBwb2ludFxuICAgICAgICAgIHRoaXMucHJlbG9hZFByaW1hcnkoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wcmVsb2FkUHJpbWFyeSA9IGZ1bmN0aW9uIHByZWxvYWRQcmltYXJ5KGl0ZW0pIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEl0ZW1JbmRleChpdGVtKTtcbiAgICAgIHZhciB0aW1lbGluZVBvcyA9IHRoaXMuZ2V0UHJpbWFyeVJlc3VtcHRpb24oaXRlbSwgaW5kZXgpO1xuICAgICAgdGhpcy5zdGFydExvYWRpbmdQcmltYXJ5QXQodGltZWxpbmVQb3MpO1xuICAgIH07XG4gICAgX3Byb3RvLmJ1ZmZlcmVkVG9FdmVudCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkVG9FdmVudChpdGVtLCBhc3NldExpc3RJbmRleCkge1xuICAgICAgdmFyIGludGVyc3RpdGlhbCA9IGl0ZW0uZXZlbnQ7XG4gICAgICB2YXIgbmV2ZXJMb2FkZWQgPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0Lmxlbmd0aCA9PT0gMCAmJiAhaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlcjtcbiAgICAgIHZhciBwbGF5T25jZSA9IGludGVyc3RpdGlhbC5jdWUub25jZTtcbiAgICAgIGlmIChuZXZlckxvYWRlZCB8fCAhcGxheU9uY2UpIHtcbiAgICAgICAgLy8gQnVmZmVyZWQgdG8gSW50ZXJzdGl0aWFsIGJvdW5kYXJ5XG4gICAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLnByZWxvYWRBc3NldHMoaW50ZXJzdGl0aWFsLCBhc3NldExpc3RJbmRleCk7XG4gICAgICAgIGlmIChwbGF5ZXIgIT0gbnVsbCAmJiBwbGF5ZXIuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyQXNzZXRQbGF5ZXIocGxheWVyLCBtZWRpYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlbG9hZEFzc2V0cyA9IGZ1bmN0aW9uIHByZWxvYWRBc3NldHMoaW50ZXJzdGl0aWFsLCBhc3NldExpc3RJbmRleCkge1xuICAgICAgdmFyIHVyaSA9IGludGVyc3RpdGlhbC5hc3NldFVybDtcbiAgICAgIHZhciBhc3NldExpc3RMZW5ndGggPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0Lmxlbmd0aDtcbiAgICAgIHZhciBuZXZlckxvYWRlZCA9IGFzc2V0TGlzdExlbmd0aCA9PT0gMCAmJiAhaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlcjtcbiAgICAgIHZhciBwbGF5T25jZSA9IGludGVyc3RpdGlhbC5jdWUub25jZTtcbiAgICAgIGlmIChuZXZlckxvYWRlZCkge1xuICAgICAgICB2YXIgdGltZWxpbmVTdGFydCA9IGludGVyc3RpdGlhbC50aW1lbGluZVN0YXJ0O1xuICAgICAgICBpZiAoaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICB2YXIgX3BsYXlpbmdJdGVtJG5leHRFdmVuO1xuICAgICAgICAgIHZhciBwbGF5aW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgICAgICAgaWYgKCF0aGlzLmlzSW50ZXJzdGl0aWFsKHBsYXlpbmdJdGVtKSAmJiAocGxheWluZ0l0ZW0gPT0gbnVsbCB8fCAoX3BsYXlpbmdJdGVtJG5leHRFdmVuID0gcGxheWluZ0l0ZW0ubmV4dEV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3BsYXlpbmdJdGVtJG5leHRFdmVuLmlkZW50aWZpZXIpID09PSBpbnRlcnN0aXRpYWwuaWRlbnRpZmllcikge1xuICAgICAgICAgICAgdGhpcy5mbHVzaEZyb250QnVmZmVyKHRpbWVsaW5lU3RhcnQgKyAwLjI1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhsc1N0YXJ0T2Zmc2V0O1xuICAgICAgICB2YXIgbGl2ZVN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICBpZiAoIXRoaXMucGxheWluZ0l0ZW0gJiYgdGhpcy5wcmltYXJ5TGl2ZSkge1xuICAgICAgICAgIGxpdmVTdGFydFBvc2l0aW9uID0gdGhpcy5obHMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICBpZiAobGl2ZVN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICBsaXZlU3RhcnRQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpdmVTdGFydFBvc2l0aW9uICYmICEoaW50ZXJzdGl0aWFsLmN1ZS5wcmUgfHwgaW50ZXJzdGl0aWFsLmN1ZS5wb3N0KSkge1xuICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IGxpdmVTdGFydFBvc2l0aW9uIC0gdGltZWxpbmVTdGFydDtcbiAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBobHNTdGFydE9mZnNldCA9IE1hdGgucm91bmQoc3RhcnRPZmZzZXQgKiAxMDAwKSAvIDEwMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKFwiTG9hZCBpbnRlcnN0aXRpYWwgYXNzZXQgXCIgKyAoYXNzZXRMaXN0SW5kZXggKyAxKSArIFwiL1wiICsgKHVyaSA/IDEgOiBhc3NldExpc3RMZW5ndGgpICsgXCIgXCIgKyBpbnRlcnN0aXRpYWwgKyAoaGxzU3RhcnRPZmZzZXQgPyBcIiBsaXZlLXN0YXJ0OiBcIiArIGxpdmVTdGFydFBvc2l0aW9uICsgXCIgc3RhcnQtb2Zmc2V0OiBcIiArIGhsc1N0YXJ0T2Zmc2V0IDogJycpKTtcbiAgICAgICAgaWYgKHVyaSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFzc2V0KGludGVyc3RpdGlhbCwgMCwgMCwgdGltZWxpbmVTdGFydCwgaW50ZXJzdGl0aWFsLmR1cmF0aW9uLCB1cmkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NldExpc3RMb2FkZXIgPSB0aGlzLmFzc2V0TGlzdExvYWRlci5sb2FkQXNzZXRMaXN0KGludGVyc3RpdGlhbCwgaGxzU3RhcnRPZmZzZXQpO1xuICAgICAgICBpZiAoYXNzZXRMaXN0TG9hZGVyKSB7XG4gICAgICAgICAgaW50ZXJzdGl0aWFsLmFzc2V0TGlzdExvYWRlciA9IGFzc2V0TGlzdExvYWRlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghcGxheU9uY2UgJiYgYXNzZXRMaXN0TGVuZ3RoKSB7XG4gICAgICAgIC8vIFJlLWJ1ZmZlcmVkIHRvIEludGVyc3RpdGlhbCBib3VuZGFyeSwgcmUtY3JlYXRlIGFzc2V0IHBsYXllcihzKVxuICAgICAgICBmb3IgKHZhciBpID0gYXNzZXRMaXN0SW5kZXg7IGkgPCBhc3NldExpc3RMZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfYXNzZXQgPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2ldO1xuICAgICAgICAgIHZhciBwbGF5ZXJJbmRleCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXJRdWV1ZUluZGV4KF9hc3NldC5pZGVudGlmaWVyKTtcbiAgICAgICAgICBpZiAoKHBsYXllckluZGV4ID09PSAtMSB8fCB0aGlzLnBsYXllclF1ZXVlW3BsYXllckluZGV4XS5kZXN0cm95ZWQpICYmICFfYXNzZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQXNzZXRQbGF5ZXIoaW50ZXJzdGl0aWFsLCBfYXNzZXQsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXNzZXQgPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2Fzc2V0TGlzdEluZGV4XTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgaWYgKGFzc2V0KSB7XG4gICAgICAgICAgdmFyIHBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXQuaWRlbnRpZmllcik7XG4gICAgICAgICAgaWYgKHBsYXllcikge1xuICAgICAgICAgICAgcGxheWVyLmxvYWRTb3VyY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2hGcm9udEJ1ZmZlciA9IGZ1bmN0aW9uIGZsdXNoRnJvbnRCdWZmZXIoc3RhcnRPZmZzZXQpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgLy8gRm9yY2UgcXVldWVkIGZsdXNoaW5nIG9mIGFsbCBidWZmZXJzXG4gICAgICB2YXIgcmVxdWlyZWRUcmFja3MgPSB0aGlzLnJlcXVpcmVkVHJhY2tzO1xuICAgICAgaWYgKCFyZXF1aXJlZFRyYWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcIlJlbW92aW5nIGZyb250IGJ1ZmZlciBzdGFydGluZyBhdCBcIiArIHN0YXJ0T2Zmc2V0KTtcbiAgICAgIHZhciBzb3VyY2VCdWZmZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlcXVpcmVkVHJhY2tzKTtcbiAgICAgIHNvdXJjZUJ1ZmZlck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgX3RoaXM3Lmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBJbmZpbml0eSxcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSW50ZXJzdGl0aWFsIEFzc2V0IFBsYXllciBjb250cm9sXG4gICAgO1xuICAgIF9wcm90by5nZXRBc3NldFBsYXllclF1ZXVlSW5kZXggPSBmdW5jdGlvbiBnZXRBc3NldFBsYXllclF1ZXVlSW5kZXgoYXNzZXRJZCkge1xuICAgICAgdmFyIHBsYXllclF1ZXVlID0gdGhpcy5wbGF5ZXJRdWV1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxheWVyUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFzc2V0SWQgPT09IHBsYXllclF1ZXVlW2ldLmFzc2V0SWQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEFzc2V0UGxheWVyID0gZnVuY3Rpb24gZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRBc3NldFBsYXllclF1ZXVlSW5kZXgoYXNzZXRJZCk7XG4gICAgICByZXR1cm4gdGhpcy5wbGF5ZXJRdWV1ZVtpbmRleF0gfHwgbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRCdWZmZXJpbmdQbGF5ZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXJpbmdQbGF5ZXIoKSB7XG4gICAgICB2YXIgcGxheWVyUXVldWUgPSB0aGlzLnBsYXllclF1ZXVlLFxuICAgICAgICBwcmltYXJ5TWVkaWEgPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICAgIGlmIChwcmltYXJ5TWVkaWEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGF5ZXJRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwbGF5ZXJRdWV1ZVtpXS5tZWRpYSA9PT0gcHJpbWFyeU1lZGlhKSB7XG4gICAgICAgICAgICByZXR1cm4gcGxheWVyUXVldWVbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVBc3NldCA9IGZ1bmN0aW9uIGNyZWF0ZUFzc2V0KGludGVyc3RpdGlhbCwgYXNzZXRMaXN0SW5kZXgsIHN0YXJ0T2Zmc2V0LCB0aW1lbGluZVN0YXJ0LCBkdXJhdGlvbiwgdXJpKSB7XG4gICAgICB2YXIgYXNzZXRJdGVtID0ge1xuICAgICAgICBwYXJlbnRJZGVudGlmaWVyOiBpbnRlcnN0aXRpYWwuaWRlbnRpZmllcixcbiAgICAgICAgaWRlbnRpZmllcjogZ2VuZXJhdGVBc3NldElkZW50aWZpZXIoaW50ZXJzdGl0aWFsLCB1cmksIGFzc2V0TGlzdEluZGV4KSxcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsXG4gICAgICAgIHRpbWVsaW5lU3RhcnQ6IHRpbWVsaW5lU3RhcnQsXG4gICAgICAgIHVyaTogdXJpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQXNzZXRQbGF5ZXIoaW50ZXJzdGl0aWFsLCBhc3NldEl0ZW0sIGFzc2V0TGlzdEluZGV4KTtcbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVBc3NldFBsYXllciA9IGZ1bmN0aW9uIGNyZWF0ZUFzc2V0UGxheWVyKGludGVyc3RpdGlhbCwgYXNzZXRJdGVtLCBhc3NldExpc3RJbmRleCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgICB2YXIgcHJpbWFyeSA9IHRoaXMuaGxzO1xuICAgICAgdmFyIHVzZXJDb25maWcgPSBwcmltYXJ5LnVzZXJDb25maWc7XG4gICAgICB2YXIgdmlkZW9QcmVmZXJlbmNlID0gdXNlckNvbmZpZy52aWRlb1ByZWZlcmVuY2U7XG4gICAgICB2YXIgY3VycmVudExldmVsID0gcHJpbWFyeS5sb2FkTGV2ZWxPYmogfHwgcHJpbWFyeS5sZXZlbHNbcHJpbWFyeS5jdXJyZW50TGV2ZWxdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgIGlmICh2aWRlb1ByZWZlcmVuY2UgfHwgY3VycmVudExldmVsKSB7XG4gICAgICAgIHZpZGVvUHJlZmVyZW5jZSA9IF9leHRlbmRzKHt9LCB2aWRlb1ByZWZlcmVuY2UpO1xuICAgICAgICBpZiAoY3VycmVudExldmVsLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgICB2aWRlb1ByZWZlcmVuY2UudmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwudmlkZW9SYW5nZSkge1xuICAgICAgICAgIHZpZGVvUHJlZmVyZW5jZS5hbGxvd2VkVmlkZW9SYW5nZXMgPSBbY3VycmVudExldmVsLnZpZGVvUmFuZ2VdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2VsZWN0ZWRBdWRpbyA9IHByaW1hcnkuYXVkaW9UcmFja3NbcHJpbWFyeS5hdWRpb1RyYWNrXTtcbiAgICAgIHZhciBzZWxlY3RlZFN1YnRpdGxlID0gcHJpbWFyeS5zdWJ0aXRsZVRyYWNrc1twcmltYXJ5LnN1YnRpdGxlVHJhY2tdO1xuICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgaWYgKHRoaXMucHJpbWFyeUxpdmUgfHwgaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgdmFyIHRpbWVQYXN0U3RhcnQgPSB0aGlzLnRpbWVsaW5lUG9zIC0gYXNzZXRJdGVtLnRpbWVsaW5lU3RhcnQ7XG4gICAgICAgIGlmICh0aW1lUGFzdFN0YXJ0ID4gMSkge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGFzc2V0SXRlbS5kdXJhdGlvbjtcbiAgICAgICAgICBpZiAoZHVyYXRpb24gJiYgdGltZVBhc3RTdGFydCA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gdGltZVBhc3RTdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBhc3NldElkID0gYXNzZXRJdGVtLmlkZW50aWZpZXI7XG4gICAgICB2YXIgcGxheWVyQ29uZmlnID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHVzZXJDb25maWcpLCB7fSwge1xuICAgICAgICBtYXhNYXhCdWZmZXJMZW5ndGg6IE1hdGgubWluKDE4MCwgcHJpbWFyeS5jb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKSxcbiAgICAgICAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgICAgICAgc3RhcnRGcmFnUHJlZmV0Y2g6IHRydWUsXG4gICAgICAgIHByaW1hcnlTZXNzaW9uSWQ6IHByaW1hcnkuc2Vzc2lvbklkLFxuICAgICAgICBhc3NldFBsYXllcklkOiBhc3NldElkLFxuICAgICAgICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiBwcmltYXJ5LmJhbmR3aWR0aEVzdGltYXRlLFxuICAgICAgICBpbnRlcnN0aXRpYWxzQ29udHJvbGxlcjogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydFBvc2l0aW9uOiBzdGFydFBvc2l0aW9uLFxuICAgICAgICBsaXZlRHVyYXRpb25JbmZpbml0eTogZmFsc2UsXG4gICAgICAgIHRlc3RCYW5kd2lkdGg6IGZhbHNlLFxuICAgICAgICB2aWRlb1ByZWZlcmVuY2U6IHZpZGVvUHJlZmVyZW5jZSxcbiAgICAgICAgYXVkaW9QcmVmZXJlbmNlOiBzZWxlY3RlZEF1ZGlvIHx8IHVzZXJDb25maWcuYXVkaW9QcmVmZXJlbmNlLFxuICAgICAgICBzdWJ0aXRsZVByZWZlcmVuY2U6IHNlbGVjdGVkU3VidGl0bGUgfHwgdXNlckNvbmZpZy5zdWJ0aXRsZVByZWZlcmVuY2VcbiAgICAgIH0pO1xuICAgICAgLy8gVE9ETzogbGltaXQgbWF4TWF4QnVmZmVyTGVuZ3RoIGluIGFzc2V0IHBsYXllcnMgdG8gcHJldmVudCBRRUVcbiAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZVN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoYXNzZXRJdGVtLnRpbWVsaW5lU3RhcnQpIHtcbiAgICAgICAgICBwbGF5ZXJDb25maWcudGltZWxpbmVPZmZzZXQgPSBhc3NldEl0ZW0udGltZWxpbmVTdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNtY2QgPSBwbGF5ZXJDb25maWcuY21jZDtcbiAgICAgIGlmIChjbWNkICE9IG51bGwgJiYgY21jZC5zZXNzaW9uSWQgJiYgY21jZC5jb250ZW50SWQpIHtcbiAgICAgICAgcGxheWVyQ29uZmlnLmNtY2QgPSBfZXh0ZW5kcyh7fSwgY21jZCwge1xuICAgICAgICAgIGNvbnRlbnRJZDogaGFzaChhc3NldEl0ZW0udXJpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmdldEFzc2V0UGxheWVyKGFzc2V0SWQpKSB7XG4gICAgICAgIHRoaXMud2FybihcIkR1cGxpY2F0ZSBkYXRlIHJhbmdlIGlkZW50aWZpZXIgXCIgKyBpbnRlcnN0aXRpYWwgKyBcIiBhbmQgYXNzZXQgXCIgKyBhc3NldElkKTtcbiAgICAgIH1cbiAgICAgIHZhciBwbGF5ZXIgPSBuZXcgSGxzQXNzZXRQbGF5ZXIodGhpcy5IbHNQbGF5ZXJDbGFzcywgcGxheWVyQ29uZmlnLCBpbnRlcnN0aXRpYWwsIGFzc2V0SXRlbSk7XG4gICAgICB0aGlzLnBsYXllclF1ZXVlLnB1c2gocGxheWVyKTtcbiAgICAgIGludGVyc3RpdGlhbC5hc3NldExpc3RbYXNzZXRMaXN0SW5kZXhdID0gYXNzZXRJdGVtO1xuICAgICAgLy8gTGlzdGVuIGZvciBMZXZlbERldGFpbHMgYW5kIFBUUyBjaGFuZ2UgdG8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICB2YXIgaW5pdGlhbER1cmF0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciB1cGRhdGVBc3NldFBsYXllckRldGFpbHMgPSBmdW5jdGlvbiB1cGRhdGVBc3NldFBsYXllckRldGFpbHMoZGV0YWlscykge1xuICAgICAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgdmFyIF90aGlzOCRzY2hlZHVsZTtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJJbnRlcnN0aXRpYWxzIE1VU1QgYmUgVk9EIGFzc2V0cyBcIiArIGludGVyc3RpdGlhbCk7XG4gICAgICAgICAgdmFyIGVycm9yRGF0YSA9IHtcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUlNUSVRJQUxfQVNTRVRfSVRFTV9FUlJPUixcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHNjaGVkdWxlSW5kZXggPSAoKF90aGlzOCRzY2hlZHVsZSA9IF90aGlzOC5zY2hlZHVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzOCRzY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWwuaWRlbnRpZmllcikpIHx8IC0xO1xuICAgICAgICAgIF90aGlzOC5oYW5kbGVBc3NldEl0ZW1FcnJvcihlcnJvckRhdGEsIGludGVyc3RpdGlhbCwgc2NoZWR1bGVJbmRleCwgYXNzZXRMaXN0SW5kZXgsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGltZSBhdCBlbmQgb2YgbGFzdCBmcmFnbWVudFxuICAgICAgICB2YXIgZHVyYXRpb24gPSBkZXRhaWxzLmVkZ2UgLSBkZXRhaWxzLmZyYWdtZW50U3RhcnQ7XG4gICAgICAgIHZhciBjdXJyZW50QXNzZXREdXJhdGlvbiA9IGFzc2V0SXRlbS5kdXJhdGlvbjtcbiAgICAgICAgaWYgKGluaXRpYWxEdXJhdGlvbiB8fCBjdXJyZW50QXNzZXREdXJhdGlvbiA9PT0gbnVsbCB8fCBkdXJhdGlvbiA+IGN1cnJlbnRBc3NldER1cmF0aW9uKSB7XG4gICAgICAgICAgaW5pdGlhbER1cmF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXM4LmxvZyhcIkludGVyc3RpdGlhbCBhc3NldCBcXFwiXCIgKyBhc3NldElkICsgXCJcXFwiIGR1cmF0aW9uIGNoYW5nZSBcIiArIGN1cnJlbnRBc3NldER1cmF0aW9uICsgXCIgPiBcIiArIGR1cmF0aW9uKTtcbiAgICAgICAgICBhc3NldEl0ZW0uZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAvLyBVcGRhdGUgc2NoZWR1bGUgd2l0aCBuZXcgZXZlbnQgYW5kIGFzc2V0IGR1cmF0aW9uXG4gICAgICAgICAgX3RoaXM4LnVwZGF0ZVNjaGVkdWxlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwbGF5ZXIub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIGZ1bmN0aW9uIChldmVudCwgX3JlZjMpIHtcbiAgICAgICAgdmFyIGRldGFpbHMgPSBfcmVmMy5kZXRhaWxzO1xuICAgICAgICByZXR1cm4gdXBkYXRlQXNzZXRQbGF5ZXJEZXRhaWxzKGRldGFpbHMpO1xuICAgICAgfSk7XG4gICAgICBwbGF5ZXIub24oRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCBmdW5jdGlvbiAoZXZlbnQsIF9yZWY0KSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gX3JlZjQuZGV0YWlscztcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFzc2V0UGxheWVyRGV0YWlscyhkZXRhaWxzKTtcbiAgICAgIH0pO1xuICAgICAgcGxheWVyLm9uKEV2ZW50cy5FVkVOVF9DVUVfRU5URVIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOC5vbkludGVyc3RpdGlhbEN1ZUVudGVyKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBfb25CdWZmZXJDb2RlY3MgPSBmdW5jdGlvbiBvbkJ1ZmZlckNvZGVjcyhldmVudCwgZGF0YSkge1xuICAgICAgICB2YXIgaW5RdWV1UGxheWVyID0gX3RoaXM4LmdldEFzc2V0UGxheWVyKGFzc2V0SWQpO1xuICAgICAgICBpZiAoaW5RdWV1UGxheWVyICYmIGRhdGEudHJhY2tzKSB7XG4gICAgICAgICAgaW5RdWV1UGxheWVyLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgX29uQnVmZmVyQ29kZWNzKTtcbiAgICAgICAgICBpblF1ZXVQbGF5ZXIudHJhY2tzID0gZGF0YS50cmFja3M7XG4gICAgICAgICAgdmFyIG1lZGlhID0gX3RoaXM4LnByaW1hcnlNZWRpYTtcbiAgICAgICAgICBpZiAoX3RoaXM4LmJ1ZmZlcmluZ0Fzc2V0ID09PSBpblF1ZXVQbGF5ZXIuYXNzZXRJdGVtICYmIG1lZGlhICYmICFpblF1ZXVQbGF5ZXIubWVkaWEpIHtcbiAgICAgICAgICAgIF90aGlzOC5idWZmZXJBc3NldFBsYXllcihpblF1ZXVQbGF5ZXIsIG1lZGlhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwbGF5ZXIub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIF9vbkJ1ZmZlckNvZGVjcyk7XG4gICAgICB2YXIgYnVmZmVyZWRUb0VuZCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkVG9FbmQoKSB7XG4gICAgICAgIHZhciBfdGhpczgkc2NoZWR1bGUkaXRlbXM7XG4gICAgICAgIHZhciBpblF1ZXVQbGF5ZXIgPSBfdGhpczguZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCk7XG4gICAgICAgIF90aGlzOC5sb2coXCJidWZmZXJlZCB0byBlbmQgb2YgYXNzZXQgXCIgKyBpblF1ZXVQbGF5ZXIpO1xuICAgICAgICBpZiAoIWluUXVldVBsYXllciB8fCAhX3RoaXM4LnNjaGVkdWxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZWxvYWQgYXQgZW5kIG9mIGFzc2V0XG4gICAgICAgIHZhciBzY2hlZHVsZUluZGV4ID0gX3RoaXM4LnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbC5pZGVudGlmaWVyKTtcbiAgICAgICAgdmFyIGl0ZW0gPSAoX3RoaXM4JHNjaGVkdWxlJGl0ZW1zID0gX3RoaXM4LnNjaGVkdWxlLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXM4JHNjaGVkdWxlJGl0ZW1zW3NjaGVkdWxlSW5kZXhdO1xuICAgICAgICBpZiAoX3RoaXM4LmlzSW50ZXJzdGl0aWFsKGl0ZW0pKSB7XG4gICAgICAgICAgX3RoaXM4LmFkdmFuY2VBc3NldEJ1ZmZlcmluZyhpdGVtLCBhc3NldEl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGxheWVyLm9uKEV2ZW50cy5CVUZGRVJFRF9UT19FTkQsIGJ1ZmZlcmVkVG9FbmQpO1xuICAgICAgdmFyIGVuZGVkV2l0aEFzc2V0SW5kZXggPSBmdW5jdGlvbiBlbmRlZFdpdGhBc3NldEluZGV4KGFzc2V0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5RdWV1UGxheWVyID0gX3RoaXM4LmdldEFzc2V0UGxheWVyKGFzc2V0SWQpO1xuICAgICAgICAgIGlmICghaW5RdWV1UGxheWVyIHx8ICFfdGhpczguc2NoZWR1bGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXM4LnNob3VsZFBsYXkgPSB0cnVlO1xuICAgICAgICAgIHZhciBzY2hlZHVsZUluZGV4ID0gX3RoaXM4LnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbC5pZGVudGlmaWVyKTtcbiAgICAgICAgICBfdGhpczguYWR2YW5jZUFmdGVyQXNzZXRFbmRlZChpbnRlcnN0aXRpYWwsIHNjaGVkdWxlSW5kZXgsIGFzc2V0SW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHBsYXllci5vbmNlKEV2ZW50cy5NRURJQV9FTkRFRCwgZW5kZWRXaXRoQXNzZXRJbmRleChhc3NldExpc3RJbmRleCkpO1xuICAgICAgcGxheWVyLm9uY2UoRXZlbnRzLlBMQVlPVVRfTElNSVRfUkVBQ0hFRCwgZW5kZWRXaXRoQXNzZXRJbmRleChJbmZpbml0eSkpO1xuICAgICAgcGxheWVyLm9uKEV2ZW50cy5FUlJPUiwgZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICghX3RoaXM4LnNjaGVkdWxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpblF1ZXVQbGF5ZXIgPSBfdGhpczguZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJZCk7XG4gICAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgICAgIGlmIChpblF1ZXVQbGF5ZXIgIT0gbnVsbCAmJiBpblF1ZXVQbGF5ZXIuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgICAgX3RoaXM4LmhhbmRsZUluUGxhY2VTdGFsbChpbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczgub25UaW1ldXBkYXRlKCk7XG4gICAgICAgICAgX3RoaXM4LmNoZWNrQnVmZmVyKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczguaGFuZGxlQXNzZXRJdGVtRXJyb3IoZGF0YSwgaW50ZXJzdGl0aWFsLCBfdGhpczguc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpLCBhc3NldExpc3RJbmRleCwgXCJBc3NldCBwbGF5ZXIgZXJyb3IgXCIgKyBkYXRhLmVycm9yICsgXCIgXCIgKyBpbnRlcnN0aXRpYWwpO1xuICAgICAgfSk7XG4gICAgICBwbGF5ZXIub24oRXZlbnRzLkRFU1RST1lJTkcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluUXVldVBsYXllciA9IF90aGlzOC5nZXRBc3NldFBsYXllcihhc3NldElkKTtcbiAgICAgICAgaWYgKCFpblF1ZXVQbGF5ZXIgfHwgIV90aGlzOC5zY2hlZHVsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJBc3NldCBwbGF5ZXIgZGVzdHJveWVkIHVuZXhwZWN0ZWRseSBcIiArIGFzc2V0SWQpO1xuICAgICAgICB2YXIgZXJyb3JEYXRhID0ge1xuICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSU1RJVElBTF9BU1NFVF9JVEVNX0VSUk9SLFxuICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICB9O1xuICAgICAgICBfdGhpczguaGFuZGxlQXNzZXRJdGVtRXJyb3IoZXJyb3JEYXRhLCBpbnRlcnN0aXRpYWwsIF90aGlzOC5zY2hlZHVsZS5maW5kRXZlbnRJbmRleChpbnRlcnN0aXRpYWwuaWRlbnRpZmllciksIGFzc2V0TGlzdEluZGV4LCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2coXCJJTlRFUlNUSVRJQUxfQVNTRVRfUExBWUVSX0NSRUFURUQgXCIgKyBldmVudEFzc2V0VG9TdHJpbmcoYXNzZXRJdGVtKSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5JTlRFUlNUSVRJQUxfQVNTRVRfUExBWUVSX0NSRUFURUQsIHtcbiAgICAgICAgYXNzZXQ6IGFzc2V0SXRlbSxcbiAgICAgICAgYXNzZXRMaXN0SW5kZXg6IGFzc2V0TGlzdEluZGV4LFxuICAgICAgICBldmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgICBwbGF5ZXI6IHBsYXllclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGxheWVyO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFySW50ZXJzdGl0aWFsID0gZnVuY3Rpb24gY2xlYXJJbnRlcnN0aXRpYWwoaW50ZXJzdGl0aWFsLCB0b1NlZ21lbnQpIHtcbiAgICAgIHRoaXMuY2xlYXJBc3NldFBsYXllcnMoaW50ZXJzdGl0aWFsLCB0b1NlZ21lbnQpO1xuICAgICAgLy8gUmVtb3ZlIGFzc2V0IGxpc3QgYW5kIHJlc29sdmVkIGR1cmF0aW9uXG4gICAgICBpbnRlcnN0aXRpYWwucmVzZXQoKTtcbiAgICB9O1xuICAgIF9wcm90by5jbGVhckFzc2V0UGxheWVycyA9IGZ1bmN0aW9uIGNsZWFyQXNzZXRQbGF5ZXJzKGludGVyc3RpdGlhbCwgdG9TZWdtZW50KSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcbiAgICAgIGludGVyc3RpdGlhbC5hc3NldExpc3QuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXQpIHtcbiAgICAgICAgX3RoaXM5LmNsZWFyQXNzZXRQbGF5ZXIoYXNzZXQuaWRlbnRpZmllciwgdG9TZWdtZW50KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0QXNzZXRQbGF5ZXIgPSBmdW5jdGlvbiByZXNldEFzc2V0UGxheWVyKGFzc2V0SWQpIHtcbiAgICAgIC8vIFJlc2V0IGFzc2V0IHBsYXllciBzbyB0aGF0IGl0J3MgdGltZWxpbmUgY2FuIGJlIGFkanVzdGVkIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBNVlBcbiAgICAgIHZhciBwbGF5ZXJJbmRleCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXJRdWV1ZUluZGV4KGFzc2V0SWQpO1xuICAgICAgaWYgKHBsYXllckluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmxvZyhcInJlc2V0IGFzc2V0IHBsYXllciBcXFwiXCIgKyBhc3NldElkICsgXCJcXFwiIGFmdGVyIGVycm9yXCIpO1xuICAgICAgICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXJRdWV1ZVtwbGF5ZXJJbmRleF07XG4gICAgICAgIHRoaXMudHJhbnNmZXJNZWRpYUZyb21QbGF5ZXIocGxheWVyLCBudWxsKTtcbiAgICAgICAgcGxheWVyLnJlc2V0RGV0YWlscygpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNsZWFyQXNzZXRQbGF5ZXIgPSBmdW5jdGlvbiBjbGVhckFzc2V0UGxheWVyKGFzc2V0SWQsIHRvU2VnbWVudCkge1xuICAgICAgdmFyIHBsYXllckluZGV4ID0gdGhpcy5nZXRBc3NldFBsYXllclF1ZXVlSW5kZXgoYXNzZXRJZCk7XG4gICAgICBpZiAocGxheWVySW5kZXggIT09IC0xKSB7XG4gICAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllclF1ZXVlW3BsYXllckluZGV4XTtcbiAgICAgICAgdGhpcy5sb2coXCJjbGVhciBcIiArIHBsYXllciArIFwiIHRvU2VnbWVudDogXCIgKyAodG9TZWdtZW50ID8gc2VnbWVudFRvU3RyaW5nKHRvU2VnbWVudCkgOiB0b1NlZ21lbnQpKTtcbiAgICAgICAgdGhpcy50cmFuc2Zlck1lZGlhRnJvbVBsYXllcihwbGF5ZXIsIHRvU2VnbWVudCk7XG4gICAgICAgIHRoaXMucGxheWVyUXVldWUuc3BsaWNlKHBsYXllckluZGV4LCAxKTtcbiAgICAgICAgcGxheWVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5lbXB0eVBsYXllclF1ZXVlID0gZnVuY3Rpb24gZW1wdHlQbGF5ZXJRdWV1ZSgpIHtcbiAgICAgIHZhciBwbGF5ZXI7XG4gICAgICB3aGlsZSAocGxheWVyID0gdGhpcy5wbGF5ZXJRdWV1ZS5wb3AoKSkge1xuICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5ZXJRdWV1ZSA9IFtdO1xuICAgIH07XG4gICAgX3Byb3RvLnN0YXJ0QXNzZXRQbGF5ZXIgPSBmdW5jdGlvbiBzdGFydEFzc2V0UGxheWVyKHBsYXllciwgYXNzZXRMaXN0SW5kZXgsIHNjaGVkdWxlSXRlbXMsIHNjaGVkdWxlSW5kZXgsIG1lZGlhKSB7XG4gICAgICB2YXIgaW50ZXJzdGl0aWFsID0gcGxheWVyLmludGVyc3RpdGlhbCxcbiAgICAgICAgYXNzZXRJdGVtID0gcGxheWVyLmFzc2V0SXRlbSxcbiAgICAgICAgYXNzZXRJZCA9IHBsYXllci5hc3NldElkO1xuICAgICAgdmFyIGFzc2V0TGlzdExlbmd0aCA9IGludGVyc3RpdGlhbC5hc3NldExpc3QubGVuZ3RoO1xuICAgICAgdmFyIHBsYXlpbmdBc3NldCA9IHRoaXMucGxheWluZ0Fzc2V0O1xuICAgICAgdGhpcy5lbmRlZEFzc2V0ID0gbnVsbDtcbiAgICAgIHRoaXMucGxheWluZ0Fzc2V0ID0gYXNzZXRJdGVtO1xuICAgICAgaWYgKCFwbGF5aW5nQXNzZXQgfHwgcGxheWluZ0Fzc2V0LmlkZW50aWZpZXIgIT09IGFzc2V0SWQpIHtcbiAgICAgICAgaWYgKHBsYXlpbmdBc3NldCkge1xuICAgICAgICAgIC8vIEV4aXRpbmcgYW5vdGhlciBJbnRlcnN0aXRpYWwgYXNzZXRcbiAgICAgICAgICB0aGlzLmNsZWFyQXNzZXRQbGF5ZXIocGxheWluZ0Fzc2V0LmlkZW50aWZpZXIsIHNjaGVkdWxlSXRlbXNbc2NoZWR1bGVJbmRleF0pO1xuICAgICAgICAgIGRlbGV0ZSBwbGF5aW5nQXNzZXQuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coXCJJTlRFUlNUSVRJQUxfQVNTRVRfU1RBUlRFRCBcIiArIChhc3NldExpc3RJbmRleCArIDEpICsgXCIvXCIgKyBhc3NldExpc3RMZW5ndGggKyBcIiBcIiArIGV2ZW50QXNzZXRUb1N0cmluZyhhc3NldEl0ZW0pKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMX0FTU0VUX1NUQVJURUQsIHtcbiAgICAgICAgICBhc3NldDogYXNzZXRJdGVtLFxuICAgICAgICAgIGFzc2V0TGlzdEluZGV4OiBhc3NldExpc3RJbmRleCxcbiAgICAgICAgICBldmVudDogaW50ZXJzdGl0aWFsLFxuICAgICAgICAgIHNjaGVkdWxlOiBzY2hlZHVsZUl0ZW1zLnNsaWNlKDApLFxuICAgICAgICAgIHNjaGVkdWxlSW5kZXg6IHNjaGVkdWxlSW5kZXgsXG4gICAgICAgICAgcGxheWVyOiBwbGF5ZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRldGFjaCBtZWRpYSBhbmQgYXR0YWNoIHRvIGludGVyc3RpdGlhbCBwbGF5ZXIgaWYgaXQgZG9lcyBub3QgaGF2ZSBhbm90aGVyIGVsZW1lbnQgYXR0YWNoZWRcbiAgICAgIHRoaXMuYnVmZmVyQXNzZXRQbGF5ZXIocGxheWVyLCBtZWRpYSk7XG4gICAgfTtcbiAgICBfcHJvdG8uYnVmZmVyQXNzZXRQbGF5ZXIgPSBmdW5jdGlvbiBidWZmZXJBc3NldFBsYXllcihwbGF5ZXIsIG1lZGlhKSB7XG4gICAgICB2YXIgX3RoaXMkc2NoZWR1bGUkaXRlbXMzLCBfdGhpcyRkZXRhY2hlZERhdGE0O1xuICAgICAgaWYgKCF0aGlzLnNjaGVkdWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbnRlcnN0aXRpYWwgPSBwbGF5ZXIuaW50ZXJzdGl0aWFsLFxuICAgICAgICBhc3NldEl0ZW0gPSBwbGF5ZXIuYXNzZXRJdGVtO1xuICAgICAgdmFyIHNjaGVkdWxlSW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGludGVyc3RpdGlhbC5pZGVudGlmaWVyKTtcbiAgICAgIHZhciBpdGVtID0gKF90aGlzJHNjaGVkdWxlJGl0ZW1zMyA9IHRoaXMuc2NoZWR1bGUuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzY2hlZHVsZSRpdGVtczNbc2NoZWR1bGVJbmRleF07XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGxheWVyLmxvYWRTb3VyY2UoKTtcbiAgICAgIHRoaXMuc2V0QnVmZmVyaW5nSXRlbShpdGVtKTtcbiAgICAgIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBhc3NldEl0ZW07XG4gICAgICB2YXIgYnVmZmVyaW5nUGxheWVyID0gdGhpcy5nZXRCdWZmZXJpbmdQbGF5ZXIoKTtcbiAgICAgIGlmIChidWZmZXJpbmdQbGF5ZXIgPT09IHBsYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXBwZW5kSW5QbGFjZU5leHQgPSBpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZTtcbiAgICAgIGlmIChhcHBlbmRJblBsYWNlTmV4dCAmJiAoYnVmZmVyaW5nUGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJpbmdQbGF5ZXIuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UpID09PSBmYWxzZSkge1xuICAgICAgICAvLyBNZWRpYSBpcyBkZXRhY2hlZCBhbmQgbm90IGF2YWlsYWJsZSB0byBhcHBlbmQgaW4gcGxhY2VcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVRyYWNrcyA9IChidWZmZXJpbmdQbGF5ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGJ1ZmZlcmluZ1BsYXllci50cmFja3MpIHx8ICgoX3RoaXMkZGV0YWNoZWREYXRhNCA9IHRoaXMuZGV0YWNoZWREYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZGV0YWNoZWREYXRhNC50cmFja3MpIHx8IHRoaXMucmVxdWlyZWRUcmFja3M7XG4gICAgICBpZiAoYXBwZW5kSW5QbGFjZU5leHQgJiYgYXNzZXRJdGVtICE9PSB0aGlzLnBsYXlpbmdBc3NldCkge1xuICAgICAgICAvLyBEbyBub3QgYnVmZmVyIGFub3RoZXIgaXRlbSBpZiB0cmFja3MgYXJlIHVua25vd24gb3IgaW5jb21wYXRpYmxlXG4gICAgICAgIGlmICghcGxheWVyLnRyYWNrcykge1xuICAgICAgICAgIHRoaXMubG9nKFwiV2FpdGluZyBmb3IgdHJhY2sgaW5mbyBiZWZvcmUgYnVmZmVyaW5nIFwiICsgcGxheWVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZVRyYWNrcyAmJiAhaXNDb21wYXRpYmxlVHJhY2tDaGFuZ2UoYWN0aXZlVHJhY2tzLCBwbGF5ZXIudHJhY2tzKSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkFzc2V0IFwiICsgZXZlbnRBc3NldFRvU3RyaW5nKGFzc2V0SXRlbSkgKyBcIiBTb3VyY2VCdWZmZXIgdHJhY2tzICgnXCIgKyBPYmplY3Qua2V5cyhwbGF5ZXIudHJhY2tzKSArIFwiJykgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggcHJpbWFyeSBjb250ZW50IHRyYWNrcyAoJ1wiICsgT2JqZWN0LmtleXMoYWN0aXZlVHJhY2tzKSArIFwiJylcIik7XG4gICAgICAgICAgdmFyIGVycm9yRGF0YSA9IHtcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUlNUSVRJQUxfQVNTRVRfSVRFTV9FUlJPUixcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGFzc2V0TGlzdEluZGV4ID0gaW50ZXJzdGl0aWFsLmZpbmRBc3NldEluZGV4KGFzc2V0SXRlbSk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVBc3NldEl0ZW1FcnJvcihlcnJvckRhdGEsIGludGVyc3RpdGlhbCwgc2NoZWR1bGVJbmRleCwgYXNzZXRMaXN0SW5kZXgsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zlck1lZGlhVG8ocGxheWVyLCBtZWRpYSk7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlSW5QbGFjZVN0YWxsID0gZnVuY3Rpb24gaGFuZGxlSW5QbGFjZVN0YWxsKGludGVyc3RpdGlhbCkge1xuICAgICAgdmFyIHNjaGVkdWxlID0gdGhpcy5zY2hlZHVsZTtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhO1xuICAgICAgaWYgKCFzY2hlZHVsZSB8fCAhbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICB2YXIgZm91bmRBc3NldEluZGV4ID0gc2NoZWR1bGUuZmluZEFzc2V0SW5kZXgoaW50ZXJzdGl0aWFsLCBjdXJyZW50VGltZSk7XG4gICAgICB2YXIgc3RhbGxpbmdBc3NldCA9IGludGVyc3RpdGlhbC5hc3NldExpc3RbZm91bmRBc3NldEluZGV4XTtcbiAgICAgIGlmIChzdGFsbGluZ0Fzc2V0KSB7XG4gICAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLmdldEFzc2V0UGxheWVyKHN0YWxsaW5nQXNzZXQuaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICB2YXIgYXNzZXRDdXJyZW50VGltZSA9IHBsYXllci5jdXJyZW50VGltZSB8fCBjdXJyZW50VGltZSAtIHN0YWxsaW5nQXNzZXQudGltZWxpbmVTdGFydDtcbiAgICAgICAgICB2YXIgZGlzdGFuY2VGcm9tRW5kID0gcGxheWVyLmR1cmF0aW9uIC0gYXNzZXRDdXJyZW50VGltZTtcbiAgICAgICAgICB0aGlzLndhcm4oXCJTdGFsbGVkIGF0IFwiICsgYXNzZXRDdXJyZW50VGltZSArIFwiIG9mIFwiICsgKGFzc2V0Q3VycmVudFRpbWUgKyBkaXN0YW5jZUZyb21FbmQpICsgXCIgaW4gXCIgKyBwbGF5ZXIgKyBcIiBcIiArIGludGVyc3RpdGlhbCArIFwiIChtZWRpYS5jdXJyZW50VGltZTogXCIgKyBjdXJyZW50VGltZSArIFwiKVwiKTtcbiAgICAgICAgICBpZiAoYXNzZXRDdXJyZW50VGltZSAmJiAoZGlzdGFuY2VGcm9tRW5kIC8gbWVkaWEucGxheWJhY2tSYXRlIDwgMC41IHx8IHBsYXllci5idWZmZXJlZEluUGxhY2VUb0VuZChtZWRpYSkpICYmIHBsYXllci5obHMpIHtcbiAgICAgICAgICAgIHZhciBzY2hlZHVsZUluZGV4ID0gc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsLmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgc2NoZWR1bGVJbmRleCwgZm91bmRBc3NldEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5hZHZhbmNlSW5QbGFjZSA9IGZ1bmN0aW9uIGFkdmFuY2VJblBsYWNlKHRpbWUpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLmN1cnJlbnRUaW1lIDwgdGltZSkge1xuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlQXNzZXRJdGVtRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVBc3NldEl0ZW1FcnJvcihkYXRhLCBpbnRlcnN0aXRpYWwsIHNjaGVkdWxlSW5kZXgsIGFzc2V0TGlzdEluZGV4LCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXNzZXRJdGVtID0gaW50ZXJzdGl0aWFsLmFzc2V0TGlzdFthc3NldExpc3RJbmRleF0gfHwgbnVsbDtcbiAgICAgIHRoaXMud2FybihcIklOVEVSU1RJVElBTF9BU1NFVF9FUlJPUiBcIiArIChhc3NldEl0ZW0gPyBldmVudEFzc2V0VG9TdHJpbmcoYXNzZXRJdGVtKSA6IGFzc2V0SXRlbSkgKyBcIiBcIiArIGRhdGEuZXJyb3IpO1xuICAgICAgaWYgKCF0aGlzLnNjaGVkdWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhc3NldElkID0gKGFzc2V0SXRlbSA9PSBudWxsID8gdm9pZCAwIDogYXNzZXRJdGVtLmlkZW50aWZpZXIpIHx8ICcnO1xuICAgICAgdmFyIHBsYXllckluZGV4ID0gdGhpcy5nZXRBc3NldFBsYXllclF1ZXVlSW5kZXgoYXNzZXRJZCk7XG4gICAgICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXJRdWV1ZVtwbGF5ZXJJbmRleF0gfHwgbnVsbDtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuc2NoZWR1bGUuaXRlbXM7XG4gICAgICB2YXIgaW50ZXJzdGl0aWFsQXNzZXRFcnJvciA9IF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZXJyb3JBY3Rpb246IGNyZWF0ZURvTm90aGluZ0Vycm9yQWN0aW9uKHRydWUpLFxuICAgICAgICBhc3NldDogYXNzZXRJdGVtLFxuICAgICAgICBhc3NldExpc3RJbmRleDogYXNzZXRMaXN0SW5kZXgsXG4gICAgICAgIGV2ZW50OiBpbnRlcnN0aXRpYWwsXG4gICAgICAgIHNjaGVkdWxlOiBpdGVtcyxcbiAgICAgICAgc2NoZWR1bGVJbmRleDogc2NoZWR1bGVJbmRleCxcbiAgICAgICAgcGxheWVyOiBwbGF5ZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuSU5URVJTVElUSUFMX0FTU0VUX0VSUk9SLCBpbnRlcnN0aXRpYWxBc3NldEVycm9yKTtcbiAgICAgIGlmICghZGF0YS5mYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcGxheWluZ0Fzc2V0ID0gdGhpcy5wbGF5aW5nQXNzZXQ7XG4gICAgICB2YXIgYnVmZmVyaW5nQXNzZXQgPSB0aGlzLmJ1ZmZlcmluZ0Fzc2V0O1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICBpZiAoYXNzZXRJdGVtKSB7XG4gICAgICAgIHRoaXMuY2xlYXJBc3NldFBsYXllcihhc3NldElkLCBudWxsKTtcbiAgICAgICAgYXNzZXRJdGVtLmVycm9yID0gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFsbCBhc3NldHMgaW4gaW50ZXJzdGl0aWFsIGZhaWwsIG1hcmsgdGhlIGludGVyc3RpdGlhbCB3aXRoIGFuIGVycm9yXG4gICAgICBpZiAoIWludGVyc3RpdGlhbC5hc3NldExpc3Quc29tZShmdW5jdGlvbiAoYXNzZXQpIHtcbiAgICAgICAgcmV0dXJuICFhc3NldC5lcnJvcjtcbiAgICAgIH0pKSB7XG4gICAgICAgIGludGVyc3RpdGlhbC5lcnJvciA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzZXQgbGV2ZWwgZGV0YWlscyBhbmQgcmVsb2FkL3BhcnNlIG1lZGlhIHBsYXlsaXN0cyB0byBhbGlnbiB3aXRoIHVwZGF0ZWQgc2NoZWR1bGVcbiAgICAgICAgZm9yICh2YXIgaSA9IGFzc2V0TGlzdEluZGV4OyBpIDwgaW50ZXJzdGl0aWFsLmFzc2V0TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMucmVzZXRBc3NldFBsYXllcihpbnRlcnN0aXRpYWwuYXNzZXRMaXN0W2ldLmlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKHRydWUpO1xuICAgICAgaWYgKGludGVyc3RpdGlhbC5lcnJvcikge1xuICAgICAgICB0aGlzLnByaW1hcnlGYWxsYmFjayhpbnRlcnN0aXRpYWwpO1xuICAgICAgfSBlbHNlIGlmIChwbGF5aW5nQXNzZXQgJiYgcGxheWluZ0Fzc2V0LmlkZW50aWZpZXIgPT09IGFzc2V0SWQpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGludGVyc3RpdGlhbCwgc2NoZWR1bGVJbmRleCwgYXNzZXRMaXN0SW5kZXgpO1xuICAgICAgfSBlbHNlIGlmIChidWZmZXJpbmdBc3NldCAmJiBidWZmZXJpbmdBc3NldC5pZGVudGlmaWVyID09PSBhc3NldElkICYmIHRoaXMuaXNJbnRlcnN0aXRpYWwodGhpcy5idWZmZXJpbmdJdGVtKSkge1xuICAgICAgICB0aGlzLmFkdmFuY2VBc3NldEJ1ZmZlcmluZyh0aGlzLmJ1ZmZlcmluZ0l0ZW0sIGJ1ZmZlcmluZ0Fzc2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wcmltYXJ5RmFsbGJhY2sgPSBmdW5jdGlvbiBwcmltYXJ5RmFsbGJhY2soaW50ZXJzdGl0aWFsKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBQcmltYXJ5IGJ5IG9uIGN1cnJlbnQgb3IgZnV0dXJlIGV2ZW50cyBieSB1cGRhdGluZyBzY2hlZHVsZSB0byBza2lwIGVycm9yZWQgaW50ZXJzdGl0aWFscy9hc3NldHNcbiAgICAgIHZhciBmbHVzaFN0YXJ0ID0gaW50ZXJzdGl0aWFsLnRpbWVsaW5lU3RhcnQ7XG4gICAgICB2YXIgcGxheWluZ0l0ZW0gPSB0aGlzLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgdmFyIHRpbWVsaW5lUG9zID0gdGhpcy50aW1lbGluZVBvcztcbiAgICAgIC8vIFVwZGF0ZSBzY2hlZHVsZSBub3cgdGhhdCBpbnRlcnN0aXRpYWwvYXNzZXRzIGFyZSBmbGFnZ2VkIHdpdGggYGVycm9yYCBmb3IgZmFsbGJhY2tcbiAgICAgIGlmIChwbGF5aW5nSXRlbSkge1xuICAgICAgICB0aGlzLmxvZyhcIkZhbGxiYWNrIHRvIHByaW1hcnkgZnJvbSBldmVudCBcXFwiXCIgKyBpbnRlcnN0aXRpYWwuaWRlbnRpZmllciArIFwiXFxcIiBzdGFydDogXCIgKyBmbHVzaFN0YXJ0ICsgXCIgcG9zOiBcIiArIHRpbWVsaW5lUG9zICsgXCIgcGxheWluZzogXCIgKyBzZWdtZW50VG9TdHJpbmcocGxheWluZ0l0ZW0pICsgXCIgZXJyb3I6IFwiICsgaW50ZXJzdGl0aWFsLmVycm9yKTtcbiAgICAgICAgaWYgKHRpbWVsaW5lUG9zID09PSAtMSkge1xuICAgICAgICAgIHRpbWVsaW5lUG9zID0gdGhpcy5obHMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3UGxheWluZ0l0ZW0gPSB0aGlzLnVwZGF0ZUl0ZW0ocGxheWluZ0l0ZW0sIHRpbWVsaW5lUG9zKTtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXNNYXRjaChwbGF5aW5nSXRlbSwgbmV3UGxheWluZ0l0ZW0pKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckludGVyc3RpdGlhbChpbnRlcnN0aXRpYWwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIHRoaXMuYXR0YWNoUHJpbWFyeShmbHVzaFN0YXJ0LCBudWxsKTtcbiAgICAgICAgICB0aGlzLmZsdXNoRnJvbnRCdWZmZXIoZmx1c2hTdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGltZWxpbmVQb3MgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTdGFydCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2NoZWR1bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNjaGVkdWxlSW5kZXggPSB0aGlzLnNjaGVkdWxlLmZpbmRJdGVtSW5kZXhBdFRpbWUodGltZWxpbmVQb3MpO1xuICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKHNjaGVkdWxlSW5kZXgpO1xuICAgIH1cblxuICAgIC8vIEFzc2V0IExpc3QgbG9hZGluZ1xuICAgIDtcbiAgICBfcHJvdG8ub25Bc3NldExpc3RMb2FkZWQgPSBmdW5jdGlvbiBvbkFzc2V0TGlzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzJHNjaGVkdWxlOCxcbiAgICAgICAgX3RoaXMwID0gdGhpcyxcbiAgICAgICAgX3RoaXMkYnVmZmVyaW5nSXRlbTtcbiAgICAgIHZhciBpbnRlcnN0aXRpYWwgPSBkYXRhLmV2ZW50O1xuICAgICAgdmFyIGludGVyc3RpdGlhbElkID0gaW50ZXJzdGl0aWFsLmlkZW50aWZpZXI7XG4gICAgICB2YXIgYXNzZXRzID0gZGF0YS5hc3NldExpc3RSZXNwb25zZS5BU1NFVFM7XG4gICAgICBpZiAoISgoX3RoaXMkc2NoZWR1bGU4ID0gdGhpcy5zY2hlZHVsZSkgIT0gbnVsbCAmJiBfdGhpcyRzY2hlZHVsZTguaGFzRXZlbnQoaW50ZXJzdGl0aWFsSWQpKSkge1xuICAgICAgICAvLyBJbnRlcnN0aXRpYWwgd2l0aCBpZCB3YXMgcmVtb3ZlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZXZlbnRTdGFydCA9IGludGVyc3RpdGlhbC50aW1lbGluZVN0YXJ0O1xuICAgICAgdmFyIHByZXZpb3VzRHVyYXRpb24gPSBpbnRlcnN0aXRpYWwuZHVyYXRpb247XG4gICAgICB2YXIgc3VtRHVyYXRpb24gPSAwO1xuICAgICAgYXNzZXRzLmZvckVhY2goZnVuY3Rpb24gKGFzc2V0LCBhc3NldExpc3RJbmRleCkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBwYXJzZUZsb2F0KGFzc2V0LkRVUkFUSU9OKTtcbiAgICAgICAgX3RoaXMwLmNyZWF0ZUFzc2V0KGludGVyc3RpdGlhbCwgYXNzZXRMaXN0SW5kZXgsIHN1bUR1cmF0aW9uLCBldmVudFN0YXJ0ICsgc3VtRHVyYXRpb24sIGR1cmF0aW9uLCBhc3NldC5VUkkpO1xuICAgICAgICBzdW1EdXJhdGlvbiArPSBkdXJhdGlvbjtcbiAgICAgIH0pO1xuICAgICAgaW50ZXJzdGl0aWFsLmR1cmF0aW9uID0gc3VtRHVyYXRpb247XG4gICAgICB0aGlzLmxvZyhcIkxvYWRlZCBhc3NldC1saXN0IHdpdGggZHVyYXRpb246IFwiICsgc3VtRHVyYXRpb24gKyBcIiAod2FzOiBcIiArIHByZXZpb3VzRHVyYXRpb24gKyBcIikgXCIgKyBpbnRlcnN0aXRpYWwpO1xuICAgICAgdmFyIHdhaXRpbmdJdGVtID0gdGhpcy53YWl0aW5nSXRlbTtcbiAgICAgIHZhciB3YWl0aW5nRm9ySXRlbSA9ICh3YWl0aW5nSXRlbSA9PSBudWxsID8gdm9pZCAwIDogd2FpdGluZ0l0ZW0uZXZlbnQuaWRlbnRpZmllcikgPT09IGludGVyc3RpdGlhbElkO1xuXG4gICAgICAvLyBVcGRhdGUgc2NoZWR1bGUgbm93IHRoYXQgYXNzZXQuRFVSQVRJT04ocykgYXJlIHBhcnNlZFxuICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZSgpO1xuICAgICAgdmFyIGJ1ZmZlcmluZ0V2ZW50ID0gKF90aGlzJGJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLmJ1ZmZlcmluZ0l0ZW0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRidWZmZXJpbmdJdGVtLmV2ZW50O1xuXG4gICAgICAvLyBJZiBidWZmZXIgcmVhY2hlZCBJbnRlcnN0aXRpYWwsIHN0YXJ0IGJ1ZmZlcmluZyBmaXJzdCBhc3NldFxuICAgICAgaWYgKHdhaXRpbmdGb3JJdGVtKSB7XG4gICAgICAgIHZhciBfdGhpcyRzY2hlZHVsZSRpdGVtczQ7XG4gICAgICAgIC8vIEFkdmFuY2Ugc2NoZWR1bGUgd2hlbiB3YWl0aW5nIGZvciBhc3NldCBsaXN0IGRhdGEgdG8gcGxheVxuICAgICAgICB2YXIgc2NoZWR1bGVJbmRleCA9IHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaW50ZXJzdGl0aWFsSWQpO1xuICAgICAgICB2YXIgaXRlbSA9IChfdGhpcyRzY2hlZHVsZSRpdGVtczQgPSB0aGlzLnNjaGVkdWxlLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkc2NoZWR1bGUkaXRlbXM0W3NjaGVkdWxlSW5kZXhdO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIGlmICghdGhpcy5wbGF5aW5nSXRlbSAmJiB0aGlzLnRpbWVsaW5lUG9zID4gaXRlbS5lbmQpIHtcbiAgICAgICAgICAgIC8vIEFiYW5kb24gaWYgbmV3IGR1cmF0aW9uIGlzIHJlZHVjZWQgZW5vdWdoIHRvIGxhbmQgcGxheWJhY2sgaW4gcHJpbWFyeSBzdGFydFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zY2hlZHVsZS5maW5kSXRlbUluZGV4QXRUaW1lKHRoaXMudGltZWxpbmVQb3MpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBzY2hlZHVsZUluZGV4KSB7XG4gICAgICAgICAgICAgIGludGVyc3RpdGlhbC5lcnJvciA9IG5ldyBFcnJvcihcIkludGVyc3RpdGlhbCBcIiArIChhc3NldHMubGVuZ3RoID8gJ25vIGxvbmdlciB3aXRoaW4gcGxheWJhY2sgcmFuZ2UnIDogJ2Fzc2V0LWxpc3QgaXMgZW1wdHknKSArIFwiIFwiICsgdGhpcy50aW1lbGluZVBvcyArIFwiIFwiICsgaW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgICAgdGhpcy5sb2coaW50ZXJzdGl0aWFsLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnByaW1hcnlGYWxsYmFjayhpbnRlcnN0aXRpYWwpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0QnVmZmVyaW5nSXRlbShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oc2NoZWR1bGVJbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKChidWZmZXJpbmdFdmVudCA9PSBudWxsID8gdm9pZCAwIDogYnVmZmVyaW5nRXZlbnQuaWRlbnRpZmllcikgPT09IGludGVyc3RpdGlhbElkKSB7XG4gICAgICAgIHZhciBhc3NldEl0ZW0gPSBpbnRlcnN0aXRpYWwuYXNzZXRMaXN0WzBdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoYXNzZXRJdGVtKSB7XG4gICAgICAgICAgdmFyIHBsYXllciA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXRJdGVtLmlkZW50aWZpZXIpO1xuICAgICAgICAgIGlmIChidWZmZXJpbmdFdmVudC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAgICAgICAvLyBJZiBidWZmZXJpbmcgKGJ1dCBub3QgcGxheWJhY2spIGhhcyByZWFjaGVkIHRoaXMgaXRlbSB0cmFuc2ZlciBtZWRpYS1zb3VyY2VcbiAgICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhO1xuICAgICAgICAgICAgaWYgKHBsYXllciAmJiBtZWRpYSkge1xuICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckFzc2V0UGxheWVyKHBsYXllciwgbWVkaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICBwbGF5ZXIubG9hZFNvdXJjZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAoIXRoaXMuc2NoZWR1bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVNTRVRfTElTVF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5BU1NFVF9MSVNUX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFTU0VUX0xJU1RfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnN0aXRpYWwgPSBkYXRhLmludGVyc3RpdGlhbDtcbiAgICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZSh0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5RmFsbGJhY2soaW50ZXJzdGl0aWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1I6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0YWxsaW5nSXRlbSA9IHRoaXMuZW5kZWRJdGVtIHx8IHRoaXMud2FpdGluZ0l0ZW0gfHwgdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKHN0YWxsaW5nSXRlbSkgJiYgc3RhbGxpbmdJdGVtLmV2ZW50LmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVJblBsYWNlU3RhbGwoc3RhbGxpbmdJdGVtLmV2ZW50KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2coXCJQcmltYXJ5IHBsYXllciBzdGFsbCBAXCIgKyB0aGlzLnRpbWVsaW5lUG9zICsgXCIgYnVmZmVyZWRQb3M6IFwiICsgdGhpcy5idWZmZXJlZFBvcyk7XG4gICAgICAgICAgICB0aGlzLm9uVGltZXVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0J1ZmZlcih0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoSW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIsIFt7XG4gICAgICBrZXk6IFwiaW50ZXJzdGl0aWFsc01hbmFnZXJcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFuYWdlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSB0aGlzO1xuICAgICAgICB2YXIgZWZmZWN0aXZlQnVmZmVyaW5nSXRlbSA9IGZ1bmN0aW9uIGVmZmVjdGl2ZUJ1ZmZlcmluZ0l0ZW0oKSB7XG4gICAgICAgICAgcmV0dXJuIGMuYnVmZmVyaW5nSXRlbSB8fCBjLndhaXRpbmdJdGVtO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0QXNzZXRQbGF5ZXIgPSBmdW5jdGlvbiBnZXRBc3NldFBsYXllcihhc3NldCkge1xuICAgICAgICAgIHJldHVybiBhc3NldCA/IGMuZ2V0QXNzZXRQbGF5ZXIoYXNzZXQuaWRlbnRpZmllcikgOiBhc3NldDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldE1hcHBlZFRpbWUgPSBmdW5jdGlvbiBnZXRNYXBwZWRUaW1lKGl0ZW0sIHRpbWVsaW5lVHlwZSwgYXNzZXQsIGNvbnRyb2xsZXJGaWVsZCwgYXNzZXRQbGF5ZXJGaWVsZCkge1xuICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IGl0ZW1bdGltZWxpbmVUeXBlXS5zdGFydDtcbiAgICAgICAgICAgIHZhciBpbnRlcnN0aXRpYWwgPSBpdGVtLmV2ZW50O1xuICAgICAgICAgICAgaWYgKGludGVyc3RpdGlhbCkge1xuICAgICAgICAgICAgICBpZiAodGltZWxpbmVUeXBlID09PSAncGxheW91dCcgfHwgaW50ZXJzdGl0aWFsLnRpbWVsaW5lT2NjdXBhbmN5ICE9PSBUaW1lbGluZU9jY3VwYW5jeS5Qb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBhc3NldFBsYXllciA9IGdldEFzc2V0UGxheWVyKGFzc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoKGFzc2V0UGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBhc3NldFBsYXllci5pbnRlcnN0aXRpYWwpID09PSBpbnRlcnN0aXRpYWwpIHtcbiAgICAgICAgICAgICAgICAgIHRpbWUgKz0gYXNzZXRQbGF5ZXIuYXNzZXRJdGVtLnN0YXJ0T2Zmc2V0ICsgYXNzZXRQbGF5ZXJbYXNzZXRQbGF5ZXJGaWVsZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250cm9sbGVyRmllbGQgPT09ICdidWZmZXJlZFBvcycgPyBnZXRCdWZmZXJlZEVuZCgpIDogY1tjb250cm9sbGVyRmllbGRdO1xuICAgICAgICAgICAgICB0aW1lICs9IHZhbHVlIC0gaXRlbS5zdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZpbmRNYXBwZWRUaW1lID0gZnVuY3Rpb24gZmluZE1hcHBlZFRpbWUocHJpbWFyeVRpbWUsIHRpbWVsaW5lVHlwZSkge1xuICAgICAgICAgIHZhciBfYyRzY2hlZHVsZTtcbiAgICAgICAgICBpZiAocHJpbWFyeVRpbWUgIT09IDAgJiYgdGltZWxpbmVUeXBlICE9PSAncHJpbWFyeScgJiYgKF9jJHNjaGVkdWxlID0gYy5zY2hlZHVsZSkgIT0gbnVsbCAmJiBfYyRzY2hlZHVsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBfYyRzY2hlZHVsZSRpdGVtcztcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGMuc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZShwcmltYXJ5VGltZSk7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IChfYyRzY2hlZHVsZSRpdGVtcyA9IGMuc2NoZWR1bGUuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfYyRzY2hlZHVsZSRpdGVtc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IGl0ZW1bdGltZWxpbmVUeXBlXS5zdGFydCAtIGl0ZW0uc3RhcnQ7XG4gICAgICAgICAgICAgIHJldHVybiBwcmltYXJ5VGltZSArIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcmltYXJ5VGltZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldEJ1ZmZlcmVkRW5kID0gZnVuY3Rpb24gZ2V0QnVmZmVyZWRFbmQoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYy5idWZmZXJlZFBvcztcbiAgICAgICAgICBpZiAodmFsdWUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNYXBwZWREdXJhdGlvbigncHJpbWFyeScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodmFsdWUsIDApO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0TWFwcGVkRHVyYXRpb24gPSBmdW5jdGlvbiBnZXRNYXBwZWREdXJhdGlvbih0aW1lbGluZVR5cGUpIHtcbiAgICAgICAgICB2YXIgX2MkcHJpbWFyeURldGFpbHMsIF9jJHNjaGVkdWxlMjtcbiAgICAgICAgICBpZiAoKF9jJHByaW1hcnlEZXRhaWxzID0gYy5wcmltYXJ5RGV0YWlscykgIT0gbnVsbCAmJiBfYyRwcmltYXJ5RGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZW5kIG9mIGxhc3QgZXZlbnQgaXRlbSBvciBwbGF5bGlzdFxuICAgICAgICAgICAgcmV0dXJuIGMucHJpbWFyeURldGFpbHMuZWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICgoX2Mkc2NoZWR1bGUyID0gYy5zY2hlZHVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jJHNjaGVkdWxlMi5kdXJhdGlvbnNbdGltZWxpbmVUeXBlXSkgfHwgMDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNlZWtUbyA9IGZ1bmN0aW9uIHNlZWtUbyh0aW1lLCB0aW1lbGluZVR5cGUpIHtcbiAgICAgICAgICB2YXIgX2l0ZW0kZXZlbnQsIF9jJHNjaGVkdWxlJGl0ZW1zMjtcbiAgICAgICAgICB2YXIgaXRlbSA9IGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiAoX2l0ZW0kZXZlbnQgPSBpdGVtLmV2ZW50KSAhPSBudWxsICYmIF9pdGVtJGV2ZW50LnJlc3RyaWN0aW9ucy5za2lwIHx8ICFjLnNjaGVkdWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGMubG9nKFwic2VlayB0byBcIiArIHRpbWUgKyBcIiBcXFwiXCIgKyB0aW1lbGluZVR5cGUgKyBcIlxcXCJcIik7XG4gICAgICAgICAgdmFyIHBsYXlpbmdJdGVtID0gYy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBjLnNjaGVkdWxlLmZpbmRJdGVtSW5kZXhBdFRpbWUodGltZSwgdGltZWxpbmVUeXBlKTtcbiAgICAgICAgICB2YXIgdGFyZ2V0SXRlbSA9IChfYyRzY2hlZHVsZSRpdGVtczIgPSBjLnNjaGVkdWxlLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX2Mkc2NoZWR1bGUkaXRlbXMyW3RhcmdldEluZGV4XTtcbiAgICAgICAgICB2YXIgYnVmZmVyaW5nUGxheWVyID0gYy5nZXRCdWZmZXJpbmdQbGF5ZXIoKTtcbiAgICAgICAgICB2YXIgYnVmZmVyaW5nSW50ZXJzdGl0aWFsID0gYnVmZmVyaW5nUGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJpbmdQbGF5ZXIuaW50ZXJzdGl0aWFsO1xuICAgICAgICAgIHZhciBhcHBlbmRJblBsYWNlID0gYnVmZmVyaW5nSW50ZXJzdGl0aWFsID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJpbmdJbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZTtcbiAgICAgICAgICB2YXIgc2Vla0luSXRlbSA9IHBsYXlpbmdJdGVtICYmIGMuaXRlbXNNYXRjaChwbGF5aW5nSXRlbSwgdGFyZ2V0SXRlbSk7XG4gICAgICAgICAgaWYgKHBsYXlpbmdJdGVtICYmIChhcHBlbmRJblBsYWNlIHx8IHNlZWtJbkl0ZW0pKSB7XG4gICAgICAgICAgICAvLyBzZWVrIGluIGFzc2V0IHBsYXllciBvciBwcmltYXJ5IG1lZGlhIChhcHBlbmRJblBsYWNlKVxuICAgICAgICAgICAgdmFyIGFzc2V0UGxheWVyID0gZ2V0QXNzZXRQbGF5ZXIoYy5wbGF5aW5nQXNzZXQpO1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gKGFzc2V0UGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBhc3NldFBsYXllci5tZWRpYSkgfHwgYy5wcmltYXJ5TWVkaWE7XG4gICAgICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGltZWxpbmVUeXBlID09PSAncHJpbWFyeScgPyBtZWRpYS5jdXJyZW50VGltZSA6IGdldE1hcHBlZFRpbWUocGxheWluZ0l0ZW0sIHRpbWVsaW5lVHlwZSwgYy5wbGF5aW5nQXNzZXQsICd0aW1lbGluZVBvcycsICdjdXJyZW50VGltZScpO1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHRpbWUgLSBjdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgdmFyIHNlZWtUb1RpbWUgPSAoYXBwZW5kSW5QbGFjZSA/IGN1cnJlbnRUaW1lIDogbWVkaWEuY3VycmVudFRpbWUpICsgZGlmZjtcbiAgICAgICAgICAgICAgaWYgKHNlZWtUb1RpbWUgPj0gMCAmJiAoIWFzc2V0UGxheWVyIHx8IGFwcGVuZEluUGxhY2UgfHwgc2Vla1RvVGltZSA8PSBhc3NldFBsYXllci5kdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHNlZWtUb1RpbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNlZWsgb3V0IG9mIGl0ZW0gb3IgYXNzZXRcbiAgICAgICAgICBpZiAodGFyZ2V0SXRlbSkge1xuICAgICAgICAgICAgdmFyIF9zZWVrVG9UaW1lID0gdGltZTtcbiAgICAgICAgICAgIGlmICh0aW1lbGluZVR5cGUgIT09ICdwcmltYXJ5Jykge1xuICAgICAgICAgICAgICB2YXIgcHJpbWFyeVNlZ21lbnRTdGFydCA9IHRhcmdldEl0ZW1bdGltZWxpbmVUeXBlXS5zdGFydDtcbiAgICAgICAgICAgICAgdmFyIF9kaWZmID0gdGltZSAtIHByaW1hcnlTZWdtZW50U3RhcnQ7XG4gICAgICAgICAgICAgIF9zZWVrVG9UaW1lID0gdGFyZ2V0SXRlbS5zdGFydCArIF9kaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhcmdldElzUHJpbWFyeSA9ICFjLmlzSW50ZXJzdGl0aWFsKHRhcmdldEl0ZW0pO1xuICAgICAgICAgICAgaWYgKCghYy5pc0ludGVyc3RpdGlhbChwbGF5aW5nSXRlbSkgfHwgcGxheWluZ0l0ZW0uZXZlbnQuYXBwZW5kSW5QbGFjZSkgJiYgKHRhcmdldElzUHJpbWFyeSB8fCB0YXJnZXRJdGVtLmV2ZW50LmFwcGVuZEluUGxhY2UpKSB7XG4gICAgICAgICAgICAgIHZhciBfbWVkaWEgPSBjLm1lZGlhIHx8IChhcHBlbmRJblBsYWNlID8gYnVmZmVyaW5nUGxheWVyID09IG51bGwgPyB2b2lkIDAgOiBidWZmZXJpbmdQbGF5ZXIubWVkaWEgOiBudWxsKTtcbiAgICAgICAgICAgICAgaWYgKF9tZWRpYSkge1xuICAgICAgICAgICAgICAgIF9tZWRpYS5jdXJyZW50VGltZSA9IF9zZWVrVG9UaW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsYXlpbmdJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFuIEludGVyc3RpdGlhbCBiZXR3ZWVuIHRoZSBjdXJyZW50IGl0ZW0gYW5kIHRhcmdldCBpdGVtIGhhcyBhbiBYLVJFU1RSSUNUIEpVTVAgcmVzdHJpY3Rpb25cbiAgICAgICAgICAgICAgdmFyIHBsYXlpbmdJbmRleCA9IGMuZmluZEl0ZW1JbmRleChwbGF5aW5nSXRlbSk7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRJbmRleCA+IHBsYXlpbmdJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBqdW1wSW5kZXggPSBjLnNjaGVkdWxlLmZpbmRKdW1wUmVzdHJpY3RlZEluZGV4KHBsYXlpbmdJbmRleCArIDEsIHRhcmdldEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoanVtcEluZGV4ID4gcGxheWluZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICBjLnNldFNjaGVkdWxlUG9zaXRpb24oanVtcEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGFzc2V0SW5kZXggPSAwO1xuICAgICAgICAgICAgICBpZiAodGFyZ2V0SXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgYy50aW1lbGluZVBvcyA9IF9zZWVrVG9UaW1lO1xuICAgICAgICAgICAgICAgIGMuY2hlY2tCdWZmZXIoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYXNzZXRMaXN0ID0gdGFyZ2V0SXRlbS5ldmVudC5hc3NldExpc3Q7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VGltZSA9IHRpbWUgLSAodGFyZ2V0SXRlbVt0aW1lbGluZVR5cGVdIHx8IHRhcmdldEl0ZW0pLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhc3NldExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXNzZXQgPSBhc3NldExpc3RbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoYXNzZXQuZHVyYXRpb24gJiYgZXZlbnRUaW1lID49IGFzc2V0LnN0YXJ0T2Zmc2V0ICYmIGV2ZW50VGltZSA8IGFzc2V0LnN0YXJ0T2Zmc2V0ICsgYXNzZXQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjLnNldFNjaGVkdWxlUG9zaXRpb24odGFyZ2V0SW5kZXgsIGFzc2V0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldEFjdGl2ZUludGVyc3RpdGlhbCA9IGZ1bmN0aW9uIGdldEFjdGl2ZUludGVyc3RpdGlhbCgpIHtcbiAgICAgICAgICB2YXIgcGxheWluZ0l0ZW0gPSBjLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgICAgIGlmIChjLmlzSW50ZXJzdGl0aWFsKHBsYXlpbmdJdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBsYXlpbmdJdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYnVmZmVyaW5nSXRlbSA9IGVmZmVjdGl2ZUJ1ZmZlcmluZ0l0ZW0oKTtcbiAgICAgICAgICBpZiAoYy5pc0ludGVyc3RpdGlhbChidWZmZXJpbmdJdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcmluZ0l0ZW07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaW50ZXJzdGl0aWFsUGxheWVyID0ge1xuICAgICAgICAgIGdldCBidWZmZXJlZEVuZCgpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnN0aXRpYWxJdGVtID0gZWZmZWN0aXZlQnVmZmVyaW5nSXRlbSgpO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlcmluZ0l0ZW0gPSBjLmJ1ZmZlcmluZ0l0ZW07XG4gICAgICAgICAgICBpZiAoYnVmZmVyaW5nSXRlbSAmJiBidWZmZXJpbmdJdGVtID09PSBpbnRlcnN0aXRpYWxJdGVtKSB7XG4gICAgICAgICAgICAgIHZhciBfYyRidWZmZXJpbmdBc3NldDtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldE1hcHBlZFRpbWUoYnVmZmVyaW5nSXRlbSwgJ3BsYXlvdXQnLCBjLmJ1ZmZlcmluZ0Fzc2V0LCAnYnVmZmVyZWRQb3MnLCAnYnVmZmVyZWRFbmQnKSAtIGJ1ZmZlcmluZ0l0ZW0ucGxheW91dC5zdGFydCB8fCAoKF9jJGJ1ZmZlcmluZ0Fzc2V0ID0gYy5idWZmZXJpbmdBc3NldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jJGJ1ZmZlcmluZ0Fzc2V0LnN0YXJ0T2Zmc2V0KSB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJzdGl0aWFsSXRlbSA9IGdldEFjdGl2ZUludGVyc3RpdGlhbCgpO1xuICAgICAgICAgICAgdmFyIHBsYXlpbmdJdGVtID0gYy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICAgICAgICAgIGlmIChwbGF5aW5nSXRlbSAmJiBwbGF5aW5nSXRlbSA9PT0gaW50ZXJzdGl0aWFsSXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0TWFwcGVkVGltZShwbGF5aW5nSXRlbSwgJ3BsYXlvdXQnLCBjLmVmZmVjdGl2ZVBsYXlpbmdBc3NldCwgJ3RpbWVsaW5lUG9zJywgJ2N1cnJlbnRUaW1lJykgLSBwbGF5aW5nSXRlbS5wbGF5b3V0LnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQgY3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgdmFyIGludGVyc3RpdGlhbEl0ZW0gPSBnZXRBY3RpdmVJbnRlcnN0aXRpYWwoKTtcbiAgICAgICAgICAgIHZhciBwbGF5aW5nSXRlbSA9IGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgICAgICBpZiAocGxheWluZ0l0ZW0gJiYgcGxheWluZ0l0ZW0gPT09IGludGVyc3RpdGlhbEl0ZW0pIHtcbiAgICAgICAgICAgICAgc2Vla1RvKHRpbWUgKyBwbGF5aW5nSXRlbS5wbGF5b3V0LnN0YXJ0LCAncGxheW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGludGVyc3RpdGlhbEl0ZW0gPSBnZXRBY3RpdmVJbnRlcnN0aXRpYWwoKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnN0aXRpYWxJdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnRlcnN0aXRpYWxJdGVtLnBsYXlvdXQuZW5kIC0gaW50ZXJzdGl0aWFsSXRlbS5wbGF5b3V0LnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgYXNzZXRQbGF5ZXJzKCkge1xuICAgICAgICAgICAgdmFyIF9nZXRBY3RpdmVJbnRlcnN0aXRpYTtcbiAgICAgICAgICAgIHZhciBhc3NldExpc3QgPSAoX2dldEFjdGl2ZUludGVyc3RpdGlhID0gZ2V0QWN0aXZlSW50ZXJzdGl0aWFsKCkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0QWN0aXZlSW50ZXJzdGl0aWEuZXZlbnQuYXNzZXRMaXN0O1xuICAgICAgICAgICAgaWYgKGFzc2V0TGlzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXNzZXRMaXN0Lm1hcChmdW5jdGlvbiAoYXNzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy5nZXRBc3NldFBsYXllcihhc3NldC5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgcGxheWluZ0luZGV4KCkge1xuICAgICAgICAgICAgdmFyIF9nZXRBY3RpdmVJbnRlcnN0aXRpYTI7XG4gICAgICAgICAgICB2YXIgaW50ZXJzdGl0aWFsID0gKF9nZXRBY3RpdmVJbnRlcnN0aXRpYTIgPSBnZXRBY3RpdmVJbnRlcnN0aXRpYWwoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXRBY3RpdmVJbnRlcnN0aXRpYTIuZXZlbnQ7XG4gICAgICAgICAgICBpZiAoaW50ZXJzdGl0aWFsICYmIGMuZWZmZWN0aXZlUGxheWluZ0Fzc2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnRlcnN0aXRpYWwuZmluZEFzc2V0SW5kZXgoYy5lZmZlY3RpdmVQbGF5aW5nQXNzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHNjaGVkdWxlSXRlbSgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBY3RpdmVJbnRlcnN0aXRpYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIgPSB7XG4gICAgICAgICAgZ2V0IGV2ZW50cygpIHtcbiAgICAgICAgICAgIHZhciBfYyRzY2hlZHVsZTM7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgcmV0dXJuICgoX2Mkc2NoZWR1bGUzID0gYy5zY2hlZHVsZSkgPT0gbnVsbCB8fCAoX2Mkc2NoZWR1bGUzID0gX2Mkc2NoZWR1bGUzLmV2ZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jJHNjaGVkdWxlMy5zbGljZSgwKSkgfHwgW107XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgc2NoZWR1bGUoKSB7XG4gICAgICAgICAgICB2YXIgX2Mkc2NoZWR1bGU0O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgIHJldHVybiAoKF9jJHNjaGVkdWxlNCA9IGMuc2NoZWR1bGUpID09IG51bGwgfHwgKF9jJHNjaGVkdWxlNCA9IF9jJHNjaGVkdWxlNC5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jJHNjaGVkdWxlNC5zbGljZSgwKSkgfHwgW107XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgaW50ZXJzdGl0aWFsUGxheWVyKCkge1xuICAgICAgICAgICAgaWYgKGdldEFjdGl2ZUludGVyc3RpdGlhbCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnRlcnN0aXRpYWxQbGF5ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBwbGF5ZXJRdWV1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBjLnBsYXllclF1ZXVlLnNsaWNlKDApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IGJ1ZmZlcmluZ0Fzc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYnVmZmVyaW5nQXNzZXQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgYnVmZmVyaW5nSXRlbSgpIHtcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RpdmVCdWZmZXJpbmdJdGVtKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgYnVmZmVyaW5nSW5kZXgoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGVmZmVjdGl2ZUJ1ZmZlcmluZ0l0ZW0oKTtcbiAgICAgICAgICAgIHJldHVybiBjLmZpbmRJdGVtSW5kZXgoaXRlbSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgcGxheWluZ0Fzc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuZWZmZWN0aXZlUGxheWluZ0Fzc2V0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0IHBsYXlpbmdJdGVtKCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgcGxheWluZ0luZGV4KCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBjLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGMuZmluZEl0ZW1JbmRleChpdGVtKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByaW1hcnk6IHtcbiAgICAgICAgICAgIGdldCBidWZmZXJlZEVuZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEJ1ZmZlcmVkRW5kKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgICAgICAgICAgICB2YXIgdGltZWxpbmVQb3MgPSBjLnRpbWVsaW5lUG9zO1xuICAgICAgICAgICAgICByZXR1cm4gdGltZWxpbmVQb3MgPiAwID8gdGltZWxpbmVQb3MgOiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBjdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgIHNlZWtUbyh0aW1lLCAncHJpbWFyeScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldE1hcHBlZER1cmF0aW9uKCdwcmltYXJ5Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHNlZWthYmxlU3RhcnQoKSB7XG4gICAgICAgICAgICAgIHZhciBfYyRwcmltYXJ5RGV0YWlsczI7XG4gICAgICAgICAgICAgIHJldHVybiAoKF9jJHByaW1hcnlEZXRhaWxzMiA9IGMucHJpbWFyeURldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYyRwcmltYXJ5RGV0YWlsczIuZnJhZ21lbnRTdGFydCkgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGludGVncmF0ZWQ6IHtcbiAgICAgICAgICAgIGdldCBidWZmZXJlZEVuZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldE1hcHBlZFRpbWUoZWZmZWN0aXZlQnVmZmVyaW5nSXRlbSgpLCAnaW50ZWdyYXRlZCcsIGMuYnVmZmVyaW5nQXNzZXQsICdidWZmZXJlZFBvcycsICdidWZmZXJlZEVuZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldE1hcHBlZFRpbWUoYy5lZmZlY3RpdmVQbGF5aW5nSXRlbSwgJ2ludGVncmF0ZWQnLCBjLmVmZmVjdGl2ZVBsYXlpbmdBc3NldCwgJ3RpbWVsaW5lUG9zJywgJ2N1cnJlbnRUaW1lJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IGN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgICAgICAgc2Vla1RvKHRpbWUsICdpbnRlZ3JhdGVkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0TWFwcGVkRHVyYXRpb24oJ2ludGVncmF0ZWQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgc2Vla2FibGVTdGFydCgpIHtcbiAgICAgICAgICAgICAgdmFyIF9jJHByaW1hcnlEZXRhaWxzMztcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmRNYXBwZWRUaW1lKCgoX2MkcHJpbWFyeURldGFpbHMzID0gYy5wcmltYXJ5RGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jJHByaW1hcnlEZXRhaWxzMy5mcmFnbWVudFN0YXJ0KSB8fCAwLCAnaW50ZWdyYXRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2tpcDogZnVuY3Rpb24gc2tpcCgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYy5lZmZlY3RpdmVQbGF5aW5nSXRlbTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uZXZlbnQ7XG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgIWV2ZW50LnJlc3RyaWN0aW9ucy5za2lwKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IGMuZmluZEl0ZW1JbmRleChpdGVtKTtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50LmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IGl0ZW0ucGxheW91dC5zdGFydCArIGl0ZW0uZXZlbnQuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgc2Vla1RvKHRpbWUgKyAwLjAwMSwgJ3BsYXlvdXQnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQoZXZlbnQsIGluZGV4LCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFNjaGVkdWxlIGdldHRlcnNcbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZWZmZWN0aXZlUGxheWluZ0l0ZW1cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53YWl0aW5nSXRlbSB8fCB0aGlzLnBsYXlpbmdJdGVtIHx8IHRoaXMuZW5kZWRJdGVtO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlZmZlY3RpdmVQbGF5aW5nQXNzZXRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbGF5aW5nQXNzZXQgfHwgdGhpcy5lbmRlZEFzc2V0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwbGF5aW5nTGFzdEl0ZW1cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkc2NoZWR1bGU5O1xuICAgICAgICB2YXIgcGxheWluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgICB2YXIgaXRlbXMgPSAoX3RoaXMkc2NoZWR1bGU5ID0gdGhpcy5zY2hlZHVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHNjaGVkdWxlOS5pdGVtcztcbiAgICAgICAgaWYgKCF0aGlzLnBsYXliYWNrU3RhcnRlZCB8fCAhcGxheWluZ0l0ZW0gfHwgIWl0ZW1zKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRJdGVtSW5kZXgocGxheWluZ0l0ZW0pID09PSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwbGF5YmFja1N0YXJ0ZWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZmZlY3RpdmVQbGF5aW5nSXRlbSAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gTWVkaWEgZ2V0dGVycyBhbmQgZXZlbnQgY2FsbGJhY2tzXG4gICAgfSwge1xuICAgICAga2V5OiBcImN1cnJlbnRUaW1lXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJGJ1ZmZlcmluZ0l0ZW0yLCBfbWVkaWEyO1xuICAgICAgICBpZiAodGhpcy5tZWRpYVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIERvIG5vdCBhZHZhbmNlIGJlZm9yZSBzY2hlZHVsZSBpcyBrbm93blxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIGN1cnJlbnRUaW1lIHdoZW4gZGV0YWNoZWQgZm9yIEludGVyc3RpdGlhbCBwbGF5YmFjayB3aXRoIHNvdXJjZSByZXNldFxuICAgICAgICB2YXIgcXVldWVkRm9yUGxheWJhY2sgPSB0aGlzLndhaXRpbmdJdGVtIHx8IHRoaXMucGxheWluZ0l0ZW07XG4gICAgICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKHF1ZXVlZEZvclBsYXliYWNrKSAmJiAhcXVldWVkRm9yUGxheWJhY2suZXZlbnQuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKCFtZWRpYSAmJiAoX3RoaXMkYnVmZmVyaW5nSXRlbTIgPSB0aGlzLmJ1ZmZlcmluZ0l0ZW0pICE9IG51bGwgJiYgKF90aGlzJGJ1ZmZlcmluZ0l0ZW0yID0gX3RoaXMkYnVmZmVyaW5nSXRlbTIuZXZlbnQpICE9IG51bGwgJiYgX3RoaXMkYnVmZmVyaW5nSXRlbTIuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIC8vIE9ic2VydmUgZGV0YWNoZWQgbWVkaWEgY3VycmVudFRpbWUgd2hlbiBhcHBlbmRpbmcgaW4gcGxhY2VcbiAgICAgICAgICBtZWRpYSA9IHRoaXMucHJpbWFyeU1lZGlhO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IChfbWVkaWEyID0gbWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfbWVkaWEyLmN1cnJlbnRUaW1lO1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IHVuZGVmaW5lZCB8fCAhaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByaW1hcnlNZWRpYVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRkZXRhY2hlZERhdGE1O1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYSB8fCAoKF90aGlzJGRldGFjaGVkRGF0YTUgPSB0aGlzLmRldGFjaGVkRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGRldGFjaGVkRGF0YTUubWVkaWEpIHx8IG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBsYXliYWNrRGlzYWJsZWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5obHMuY29uZmlnLmVuYWJsZUludGVyc3RpdGlhbFBsYXliYWNrID09PSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJpbWFyeURldGFpbHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkbWVkaWFTZWxlY3Rpb247XG4gICAgICAgIHJldHVybiAoX3RoaXMkbWVkaWFTZWxlY3Rpb24gPSB0aGlzLm1lZGlhU2VsZWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTZWxlY3Rpb24ubWFpbi5kZXRhaWxzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcmltYXJ5TGl2ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcmltYXJ5RGV0YWlscztcbiAgICAgICAgcmV0dXJuICEhKChfdGhpcyRwcmltYXJ5RGV0YWlscyA9IHRoaXMucHJpbWFyeURldGFpbHMpICE9IG51bGwgJiYgX3RoaXMkcHJpbWFyeURldGFpbHMubGl2ZSk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KExvZ2dlcik7XG5cbiAgdmFyIFRJQ0tfSU5URVJWQUwkMiA9IDUwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcblxuICB2YXIgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICBmdW5jdGlvbiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfQmFzZVN0cmVhbUNvbnRyb2xsZXIuY2FsbCh0aGlzLCBobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXInLCBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkgfHwgdGhpcztcbiAgICAgIF90aGlzLmN1cnJlbnRUcmFja0lkID0gLTE7XG4gICAgICBfdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgICAgX3RoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgICAgX3RoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIHZhciBfcHJvdG8gPSBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5yZWdpc3Rlckxpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgdGhpcy5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUudW5yZWdpc3Rlckxpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbiwgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pIHtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDIpO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uICsgdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHNraXBTZWVrVG9TdGFydFBvc2l0aW9uID8gLTEgOiBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25NYW5pZmVzdExvYWRpbmcuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcuY2FsbCh0aGlzLCBldmVudCwgZGF0YSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMubWFpbkRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgfTtcbiAgICBfcHJvdG8ub25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHN1Y2Nlc3MgPSBkYXRhLnN1Y2Nlc3M7XG4gICAgICBpZiAoIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIGlmIChpc01lZGlhRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICAgIGlmICghYnVmZmVyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUvdXBkYXRlIGEgYnVmZmVyZWQgYXJyYXkgbWF0Y2hpbmcgdGhlIGludGVyZmFjZSB1c2VkIGJ5IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm9cbiAgICAgIC8vIHNvIHdlIGNhbiByZS11c2UgdGhlIGxvZ2ljIHVzZWQgdG8gZGV0ZWN0IGhvdyBtdWNoIGhhcyBiZWVuIGJ1ZmZlcmVkXG4gICAgICB2YXIgdGltZVJhbmdlO1xuICAgICAgdmFyIGZyYWdTdGFydCA9IGZyYWcuc3RhcnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmcmFnU3RhcnQgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgZnJhZ1N0YXJ0IDw9IGJ1ZmZlcmVkW2ldLmVuZCkge1xuICAgICAgICAgIHRpbWVSYW5nZSA9IGJ1ZmZlcmVkW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZnJhZ0VuZCA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgaWYgKHRpbWVSYW5nZSkge1xuICAgICAgICB0aW1lUmFuZ2UuZW5kID0gZnJhZ0VuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVSYW5nZSA9IHtcbiAgICAgICAgICBzdGFydDogZnJhZ1N0YXJ0LFxuICAgICAgICAgIGVuZDogZnJhZ0VuZFxuICAgICAgICB9O1xuICAgICAgICBidWZmZXJlZC5wdXNoKHRpbWVSYW5nZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZyk7XG4gICAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIG51bGwpO1xuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBzdGFydE9mZnNldCA9IGRhdGEuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldCA9IGRhdGEuZW5kT2Zmc2V0O1xuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgIHZhciBlbmRPZmZzZXRTdWJ0aXRsZXMgPSBlbmRPZmZzZXQgLSAxO1xuICAgICAgICBpZiAoZW5kT2Zmc2V0U3VidGl0bGVzIDw9IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5lbmRPZmZzZXRTdWJ0aXRsZXMgPSBNYXRoLm1heCgwLCBlbmRPZmZzZXRTdWJ0aXRsZXMpO1xuICAgICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7KSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kIDw9IGVuZE9mZnNldFN1YnRpdGxlcykge1xuICAgICAgICAgICAgICBidWZmZXJlZC5zaGlmdCgpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgPCBlbmRPZmZzZXRTdWJ0aXRsZXMpIHtcbiAgICAgICAgICAgICAgYnVmZmVyZWRbaV0uc3RhcnQgPSBlbmRPZmZzZXRTdWJ0aXRsZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRTdWJ0aXRsZXMsIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgcHJvY2VlZCB0byBuZXh0IGZyYWcsIGlmIHdlIHdlcmUgcHJvY2Vzc2luZyBvbmUuXG4gICAgO1xuICAgIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAoKGZyYWcgPT0gbnVsbCA/IHZvaWQgMCA6IGZyYWcudHlwZSkgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCkge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHb3QgYWxsIG5ldyBzdWJ0aXRsZSBsZXZlbHMuXG4gICAgO1xuICAgIF9wcm90by5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrcyA9IF9yZWYuc3VidGl0bGVUcmFja3M7XG4gICAgICBpZiAodGhpcy5sZXZlbHMgJiYgc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRoaXMubGV2ZWxzLCBzdWJ0aXRsZVRyYWNrcykpIHtcbiAgICAgICAgdGhpcy5sZXZlbHMgPSBzdWJ0aXRsZVRyYWNrcy5tYXAoZnVuY3Rpb24gKG1lZGlhUGxheWxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExldmVsKG1lZGlhUGxheWxpc3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgICAgdGhpcy5sZXZlbHMgPSBzdWJ0aXRsZVRyYWNrcy5tYXAoZnVuY3Rpb24gKG1lZGlhUGxheWxpc3QpIHtcbiAgICAgICAgdmFyIGxldmVsID0gbmV3IExldmVsKG1lZGlhUGxheWxpc3QpO1xuICAgICAgICBfdGhpczIudHJhY2tzQnVmZmVyZWRbbGV2ZWwuaWRdID0gW107XG4gICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZSgwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKTtcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLm9uU3VidGl0bGVUcmFja1N3aXRjaCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja1N3aXRjaChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzJGxldmVscztcbiAgICAgIHRoaXMuY3VycmVudFRyYWNrSWQgPSBkYXRhLmlkO1xuICAgICAgaWYgKCEoKF90aGlzJGxldmVscyA9IHRoaXMubGV2ZWxzKSAhPSBudWxsICYmIF90aGlzJGxldmVscy5sZW5ndGgpIHx8IHRoaXMuY3VycmVudFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRyYWNrIGhhcyB0aGUgbmVjZXNzYXJ5IGRldGFpbHMgdG8gbG9hZCBmcmFnbWVudHNcbiAgICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICAgIGlmIChjdXJyZW50VHJhY2sgIT0gbnVsbCAmJiBjdXJyZW50VHJhY2suZGV0YWlscykge1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlclRpbWVSYW5nZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VHJhY2sgJiYgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwkMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXG4gICAgO1xuICAgIF9wcm90by5vblN1YnRpdGxlVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdHJhY2skZGV0YWlscztcbiAgICAgIHZhciBjdXJyZW50VHJhY2tJZCA9IHRoaXMuY3VycmVudFRyYWNrSWQsXG4gICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiU3VidGl0bGUgdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCBcIiArIHRyYWNrSWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdHJhY2sgPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgICBpZiAodHJhY2tJZCA+PSBsZXZlbHMubGVuZ3RoIHx8ICF0cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcIlN1YnRpdGxlIHRyYWNrIFwiICsgdHJhY2tJZCArIFwiIGxvYWRlZCBbXCIgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyBcIixcIiArIG5ld0RldGFpbHMuZW5kU04gKyBcIl1cIiArIChuZXdEZXRhaWxzLmxhc3RQYXJ0U24gPyBcIltwYXJ0LVwiICsgbmV3RGV0YWlscy5sYXN0UGFydFNuICsgXCItXCIgKyBuZXdEZXRhaWxzLmxhc3RQYXJ0SW5kZXggKyBcIl1cIiA6ICcnKSArIFwiLGR1cmF0aW9uOlwiICsgbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyVGltZVJhbmdlcztcbiAgICAgIHZhciBzbGlkaW5nID0gMDtcbiAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF90cmFjayRkZXRhaWxzID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscy5saXZlKSB7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYWluRGV0YWlscyA9IHRoaXMubWFpbkRldGFpbHM7XG4gICAgICAgIGlmICghbWFpbkRldGFpbHMpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50ID0gbWFpbkRldGFpbHMuZnJhZ21lbnRzWzBdO1xuICAgICAgICBpZiAoIXRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgICBpZiAobmV3RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgbWFpbkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgICBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVChuZXdEZXRhaWxzLCBtYWluRGV0YWlscyk7XG4gICAgICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudFN0YXJ0O1xuICAgICAgICAgIH0gZWxzZSBpZiAobWFpblNsaWRpbmdTdGFydEZyYWdtZW50KSB7XG4gICAgICAgICAgICAvLyBsaW5lIHVwIGxpdmUgcGxheWxpc3Qgd2l0aCBtYWluIHNvIHRoYXQgZnJhZ21lbnRzIGluIHJhbmdlIGFyZSBsb2FkZWRcbiAgICAgICAgICAgIHNsaWRpbmcgPSBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQuc3RhcnQ7XG4gICAgICAgICAgICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIHRyYWNrLmRldGFpbHMsIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzKTtcbiAgICAgICAgICBpZiAoc2xpZGluZyA9PT0gMCAmJiBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAgIC8vIHJlYWxpZ24gd2l0aCBtYWluIHdoZW4gdGhlcmUgaXMgbm8gb3ZlcmxhcCB3aXRoIGxhc3QgcmVmcmVzaFxuICAgICAgICAgICAgc2xpZGluZyA9IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudC5zdGFydDtcbiAgICAgICAgICAgIGFkZFNsaWRpbmcobmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgd2UgYXJlIGFsaWduZWQgd2l0aCB0aGUgbWFpbiBwbGF5bGlzdFxuICAgICAgICBpZiAobWFpbkRldGFpbHMgJiYgIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG1haW5EZXRhaWxzLCBzbGlkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHRyYWNrO1xuICAgICAgaWYgKHRyYWNrSWQgIT09IGN1cnJlbnRUcmFja0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1VQREFURUQsIHtcbiAgICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgICAgaWQ6IHRyYWNrSWQsXG4gICAgICAgIGdyb3VwSWQ6IGRhdGEuZ3JvdXBJZFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIHRoaXMudGljaygpO1xuXG4gICAgICAvLyBJZiBwbGF5bGlzdCBpcyBtaXNhbGlnbmVkIGJlY2F1c2Ugb2YgYmFkIFBEVCBvciBkcmlmdCwgZGVsZXRlIGRldGFpbHMgdG8gcmVzeW5jIHdpdGggbWFpbiBvbiByZWxvYWRcbiAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgJiYgIXRoaXMuZnJhZ0N1cnJlbnQgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICAgIHZhciBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhudWxsLCBuZXdEZXRhaWxzLmZyYWdtZW50cywgdGhpcy5tZWRpYS5jdXJyZW50VGltZSwgMCk7XG4gICAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgICAgdGhpcy53YXJuKCdTdWJ0aXRsZSBwbGF5bGlzdCBub3QgYWxpZ25lZCB3aXRoIHBsYXliYWNrJyk7XG4gICAgICAgICAgdHJhY2suZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgZnJhZyA9IGZyYWdMb2FkZWREYXRhLmZyYWcsXG4gICAgICAgIHBheWxvYWQgPSBmcmFnTG9hZGVkRGF0YS5wYXlsb2FkO1xuICAgICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGlzRnVsbFNlZ21lbnRFbmNyeXB0aW9uKGRlY3J5cHREYXRhLm1ldGhvZCkpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAvLyBkZWNyeXB0IHRoZSBzdWJ0aXRsZXNcbiAgICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyLCBnZXRBZXNNb2RlRnJvbUZ1bGxTZWdtZW50TWV0aG9kKGRlY3J5cHREYXRhLm1ldGhvZCkpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICBmcmFnOiBmcmFnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgdmFyIGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19ERUNSWVBURUQsIHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgICAgdHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIHRkZWNyeXB0OiBlbmRUaW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBfdGhpczMud2FybihlcnIubmFtZSArIFwiOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICBfdGhpczMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICAgIHZhciBjdXJyZW50VHJhY2tJZCA9IHRoaXMuY3VycmVudFRyYWNrSWQsXG4gICAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICAgIHZhciB0cmFjayA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW2N1cnJlbnRUcmFja0lkXTtcbiAgICAgICAgaWYgKCF0cmFjayB8fCAhbGV2ZWxzLmxlbmd0aCB8fCAhdHJhY2suZGV0YWlscykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53YWl0Rm9yTGl2ZSh0cmFjaykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgICB2YXIgYnVmZmVyZWRJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyh0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdIHx8IFtdLCBjdXJyZW50VGltZSwgY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgICB2YXIgdGFyZ2V0QnVmZmVyVGltZSA9IGJ1ZmZlcmVkSW5mby5lbmQsXG4gICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyZWRJbmZvLmxlbjtcbiAgICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XG4gICAgICAgIHZhciBtYXhCdWZMZW4gPSB0aGlzLmhscy5tYXhCdWZmZXJMZW5ndGggKyB0cmFja0RldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcbiAgICAgICAgaWYgKGJ1ZmZlckxlbiA+IG1heEJ1Zkxlbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgICAgdmFyIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgZW5kID0gdHJhY2tEZXRhaWxzLmVkZ2U7XG4gICAgICAgIHZhciBmb3VuZEZyYWcgPSBudWxsO1xuICAgICAgICB2YXIgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lIDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICAgIHZhciBsb29rdXBUb2xlcmFuY2UgPSB0YXJnZXRCdWZmZXJUaW1lID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgTWF0aC5tYXgoZnJhZ21lbnRzWzBdLnN0YXJ0LCB0YXJnZXRCdWZmZXJUaW1lKSwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICAgICAgICBpZiAoIWZvdW5kRnJhZyAmJiBmcmFnUHJldmlvdXMgJiYgZnJhZ1ByZXZpb3VzLnN0YXJ0IDwgZnJhZ21lbnRzWzBdLnN0YXJ0KSB7XG4gICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRGcmFnID0gdGhpcy5maWx0ZXJSZXBsYWNlZFByaW1hcnkoZm91bmRGcmFnLCB0cmFjay5kZXRhaWxzKTtcbiAgICAgICAgaWYgKCFmb3VuZEZyYWcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9hZCBlYXJsaWVyIGZyYWdtZW50IGluIHNhbWUgZGlzY29udGludWl0eSB0byBtYWtlIHVwIGZvciBtaXNhbGlnbmVkIHBsYXlsaXN0cyBhbmQgY3VlcyB0aGF0IGV4dGVuZCBiZXlvbmQgZW5kIG9mIHNlZ21lbnRcbiAgICAgICAgdmFyIGN1clNOSWR4ID0gZm91bmRGcmFnLnNuIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U047XG4gICAgICAgIHZhciBwcmV2RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCAtIDFdO1xuICAgICAgICBpZiAocHJldkZyYWcgJiYgcHJldkZyYWcuY2MgPT09IGZvdW5kRnJhZy5jYyAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShwcmV2RnJhZykgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IHByZXZGcmFnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmb3VuZEZyYWcpID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQpIHtcbiAgICAgICAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgICAgICAgIHZhciBmcmFnVG9Mb2FkID0gdGhpcy5tYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZvdW5kRnJhZyk7XG4gICAgICAgICAgaWYgKGZyYWdUb0xvYWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEZyYWdtZW50KGZyYWdUb0xvYWQsIHRyYWNrLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIGlmICghaXNNZWRpYUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmxvYWRGcmFnbWVudC5jYWxsKHRoaXMsIGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcIm1lZGlhQnVmZmVyVGltZVJhbmdlc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyYWJsZUluc3RhbmNlKHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF0gfHwgW10pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShCYXNlU3RyZWFtQ29udHJvbGxlcik7XG4gIHZhciBCdWZmZXJhYmxlSW5zdGFuY2UgPSBmdW5jdGlvbiBCdWZmZXJhYmxlSW5zdGFuY2UodGltZXJhbmdlcykge1xuICAgIHRoaXMuYnVmZmVyZWQgPSB2b2lkIDA7XG4gICAgdmFyIGdldFJhbmdlID0gZnVuY3Rpb24gZ2V0UmFuZ2UobmFtZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgaW5kZXggPSBpbmRleCA+Pj4gMDtcbiAgICAgIGlmIChpbmRleCA+IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkZhaWxlZCB0byBleGVjdXRlICdcIiArIG5hbWUgKyBcIicgb24gJ1RpbWVSYW5nZXMnOiBUaGUgaW5kZXggcHJvdmlkZWQgKFwiICsgaW5kZXggKyBcIikgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGJvdW5kIChcIiArIGxlbmd0aCArIFwiKVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1lcmFuZ2VzW2luZGV4XVtuYW1lXTtcbiAgICB9O1xuICAgIHRoaXMuYnVmZmVyZWQgPSB7XG4gICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJhbmdlcy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJhbmdlKCdlbmQnLCBpbmRleCwgdGltZXJhbmdlcy5sZW5ndGgpO1xuICAgICAgfSxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChpbmRleCkge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZ2UoJ3N0YXJ0JywgaW5kZXgsIHRpbWVyYW5nZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50KHRyYWNrLCB2aWRlb0VsKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIHRyeSB7XG4gICAgICBldmVudCA9IG5ldyBFdmVudCgnYWRkdHJhY2snKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGZvciBJRTExXG4gICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZlbnQuaW5pdEV2ZW50KCdhZGR0cmFjaycsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gICAgdmlkZW9FbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBhZGRDdWVUb1RyYWNrKHRyYWNrLCBjdWUpIHtcbiAgICAvLyBTb21ldGltZXMgdGhlcmUgYXJlIGN1ZSBvdmVybGFwcyBvbiBzZWdtZW50ZWQgdnR0cyBzbyB0aGUgc2FtZVxuICAgIC8vIGN1ZSBjYW4gYXBwZWFyIG1vcmUgdGhhbiBvbmNlIGluIGRpZmZlcmVudCB2dHQgZmlsZXMuXG4gICAgLy8gVGhpcyBhdm9pZCBzaG93aW5nIGR1cGxpY2F0ZWQgY3VlcyB3aXRoIHNhbWUgdGltZWNvZGUgYW5kIHRleHQuXG4gICAgdmFyIG1vZGUgPSB0cmFjay5tb2RlO1xuICAgIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gICAgfVxuICAgIGlmICh0cmFjay5jdWVzICYmICF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgIGlmICghdHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRDdWUgaXMgZmFpbGVkIGZvcjogXCIgKyBjdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiW3RleHR0cmFjay11dGlsc106IFwiICsgZXJyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdGV4dFRyYWNrQ3VlID0gbmV3IHNlbGYuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgICAgICAgdGV4dFRyYWNrQ3VlLmlkID0gY3VlLmlkO1xuICAgICAgICAgIHRyYWNrLmFkZEN1ZSh0ZXh0VHJhY2tDdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiW3RleHR0cmFjay11dGlsc106IExlZ2FjeSBUZXh0VHJhY2tDdWUgZmFsbGJhY2sgZmFpbGVkOiBcIiArIGVycjIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaywgZW50ZXJIYW5kbGVyKSB7XG4gICAgLy8gV2hlbiB0cmFjay5tb2RlIGlzIGRpc2FibGVkLCB0cmFjay5jdWVzIHdpbGwgYmUgbnVsbC5cbiAgICAvLyBUbyBndWFyYW50ZWUgdGhlIHJlbW92YWwgb2YgY3Vlcywgd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAgIC8vIGNoYW5nZSB0aGUgbW9kZSB0byBoaWRkZW5cbiAgICB2YXIgbW9kZSA9IHRyYWNrLm1vZGU7XG4gICAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICB9XG4gICAgaWYgKHRyYWNrLmN1ZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0cmFjay5jdWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBpZiAoZW50ZXJIYW5kbGVyKSB7XG4gICAgICAgICAgdHJhY2suY3Vlc1tpXS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcicsIGVudGVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdHJhY2subW9kZSA9IG1vZGU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUN1ZXNJblJhbmdlKHRyYWNrLCBzdGFydCwgZW5kLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kZSA9IHRyYWNrLm1vZGU7XG4gICAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICB9XG4gICAgaWYgKHRyYWNrLmN1ZXMgJiYgdHJhY2suY3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgY3VlcyA9IGdldEN1ZXNJblJhbmdlKHRyYWNrLmN1ZXMsIHN0YXJ0LCBlbmQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShjdWVzW2ldKSkge1xuICAgICAgICAgIHRyYWNrLnJlbW92ZUN1ZShjdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdHJhY2subW9kZSA9IG1vZGU7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBmaXJzdCBjdWUgc3RhcnRpbmcgYXQgb3IgYWZ0ZXIgZ2l2ZW4gdGltZS5cbiAgLy8gTW9kaWZpZWQgdmVyc2lvbiBvZiBiaW5hcnkgc2VhcmNoIE8obG9nKG4pKS5cbiAgZnVuY3Rpb24gZ2V0Rmlyc3RDdWVJbmRleEZyb21UaW1lKGN1ZXMsIHRpbWUpIHtcbiAgICAvLyBJZiBmaXJzdCBjdWUgc3RhcnRzIGF0IG9yIGFmdGVyIHRpbWUsIHN0YXJ0IHRoZXJlXG4gICAgaWYgKHRpbWUgPD0gY3Vlc1swXS5zdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbGFzdCBjdWUgZW5kcyBiZWZvcmUgdGltZSB0aGVyZSBpcyBubyBvdmVybGFwXG4gICAgdmFyIGxlbiA9IGN1ZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAodGltZSA+IGN1ZXNbbGVuXS5lbmRUaW1lKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciBsZWZ0ID0gMDtcbiAgICB2YXIgcmlnaHQgPSBsZW47XG4gICAgdmFyIG1pZDtcbiAgICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgICAgbWlkID0gTWF0aC5mbG9vcigocmlnaHQgKyBsZWZ0KSAvIDIpO1xuICAgICAgaWYgKHRpbWUgPCBjdWVzW21pZF0uc3RhcnRUaW1lKSB7XG4gICAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAodGltZSA+IGN1ZXNbbWlkXS5zdGFydFRpbWUgJiYgbGVmdCA8IGxlbikge1xuICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGxvd2VyIG9yIGhpZ2hlciwgaXQgbXVzdCBiZSBlcXVhbC5cbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgbGVmdCBhbmQgcmlnaHQgaGF2ZSBzd2FwcGVkLlxuICAgIC8vIE5vIGRpcmVjdCBtYXRjaCB3YXMgZm91bmQsIGxlZnQgb3IgcmlnaHQgZWxlbWVudCBtdXN0IGJlIHRoZSBjbG9zZXN0LiBDaGVjayB3aGljaCBvbmUgaGFzIHRoZSBzbWFsbGVzdCBkaWZmLlxuICAgIHJldHVybiBjdWVzW2xlZnRdLnN0YXJ0VGltZSAtIHRpbWUgPCB0aW1lIC0gY3Vlc1tyaWdodF0uc3RhcnRUaW1lID8gbGVmdCA6IHJpZ2h0O1xuICB9XG4gIGZ1bmN0aW9uIGdldEN1ZXNJblJhbmdlKGN1ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgY3Vlc0ZvdW5kID0gW107XG4gICAgdmFyIGZpcnN0Q3VlSW5SYW5nZSA9IGdldEZpcnN0Q3VlSW5kZXhGcm9tVGltZShjdWVzLCBzdGFydCk7XG4gICAgaWYgKGZpcnN0Q3VlSW5SYW5nZSA+IC0xKSB7XG4gICAgICBmb3IgKHZhciBpID0gZmlyc3RDdWVJblJhbmdlLCBsZW4gPSBjdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuICAgICAgICBpZiAoY3VlLnN0YXJ0VGltZSA+PSBzdGFydCAmJiBjdWUuZW5kVGltZSA8PSBlbmQpIHtcbiAgICAgICAgICBjdWVzRm91bmQucHVzaChjdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPiBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gY3Vlc0ZvdW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdWVzRm91bmQ7XG4gIH1cbiAgZnVuY3Rpb24gZmlsdGVyU3VidGl0bGVUcmFja3ModGV4dFRyYWNrTGlzdCkge1xuICAgIHZhciB0cmFja3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRleHRUcmFja0xpc3RbaV07XG4gICAgICAvLyBFZGdlIGFkZHMgYSB0cmFjayB3aXRob3V0IGEgbGFiZWw7IHdlIGRvbid0IHdhbnQgdG8gdXNlIGl0XG4gICAgICBpZiAoKHRyYWNrLmtpbmQgPT09ICdzdWJ0aXRsZXMnIHx8IHRyYWNrLmtpbmQgPT09ICdjYXB0aW9ucycpICYmIHRyYWNrLmxhYmVsKSB7XG4gICAgICAgIHRyYWNrcy5wdXNoKHRleHRUcmFja0xpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhY2tzO1xuICB9XG5cbiAgdmFyIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVBsYXlsaXN0Q29udHJvbGwpIHtcbiAgICBmdW5jdGlvbiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcihobHMpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX0Jhc2VQbGF5bGlzdENvbnRyb2xsLmNhbGwodGhpcywgaGxzLCAnc3VidGl0bGUtdHJhY2stY29udHJvbGxlcicpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICBfdGhpcy50cmFja3MgPSBbXTtcbiAgICAgIF90aGlzLmdyb3VwSWRzID0gbnVsbDtcbiAgICAgIF90aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICAgIF90aGlzLnRyYWNrSWQgPSAtMTtcbiAgICAgIF90aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgICBfdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICAgICAgX3RoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTE7XG4gICAgICBfdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID0gZmFsc2U7XG4gICAgICBfdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IC0xO1xuICAgICAgX3RoaXMuX3N1YnRpdGxlRGlzcGxheSA9IHRydWU7XG4gICAgICBfdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnBvbGxUcmFja0NoYW5nZSgwKTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5vblRleHRUcmFja3NDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgICAgICBzZWxmLmNsZWFySW50ZXJ2YWwoX3RoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcbiAgICAgICAgaWYgKCFfdGhpcy5tZWRpYSB8fCAhX3RoaXMuaGxzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHRUcmFjayA9IG51bGw7XG4gICAgICAgIHZhciB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhfdGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodHJhY2tzW2ldLm1vZGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmFja3NbaV0ubW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIGludGVybmFsIHRyYWNrIGluZGV4IGZvciBUZXh0VHJhY2tcbiAgICAgICAgdmFyIHRyYWNrSWQgPSBfdGhpcy5maW5kVHJhY2tGb3JUZXh0VHJhY2sodGV4dFRyYWNrKTtcbiAgICAgICAgaWYgKF90aGlzLnN1YnRpdGxlVHJhY2sgIT09IHRyYWNrSWQpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKHRyYWNrSWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIF9CYXNlUGxheWxpc3RDb250cm9sbCk7XG4gICAgdmFyIF9wcm90byA9IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMudHJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCA9IHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSBudWxsO1xuICAgICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cbiAgICA7XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID4gLTEpIHtcbiAgICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTE7XG4gICAgICB9XG4gICAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICBpZiAodGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICAgIHRoaXMucG9sbFRyYWNrQ2hhbmdlKDUwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucG9sbFRyYWNrQ2hhbmdlID0gZnVuY3Rpb24gcG9sbFRyYWNrQ2hhbmdlKHRpbWVvdXQpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICAgIHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCwgdGltZW91dCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFuc2ZlcnJpbmdNZWRpYSA9ICEhZGF0YS50cmFuc2Zlck1lZGlhO1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgaWYgKCF0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgICAgbWVkaWEudGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRyYWNrSWQgPiAtMSkge1xuICAgICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IHRoaXMudHJhY2tJZDtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzIGJlZm9yZSBkZXRhY2htZW50IHNvIHdoZW4gcmVhdHRhY2hlZCBvbmx5IHRyYWNrcyBpbiB0aGF0IGNvbnRlbnQgYXJlIGVuYWJsZWQuXG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSAtMTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgaWYgKHRyYW5zZmVycmluZ01lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICAvLyBDbGVhciBsb2FkZWQgY3VlcyBvbiBtZWRpYSBkZXRhY2htZW50IGZyb20gdHJhY2tzXG4gICAgICB0ZXh0VHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIGNsZWFyQ3VycmVudEN1ZXModHJhY2spO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICB0aGlzLmdyb3VwSWRzID0gbnVsbDtcbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmlyZWQgd2hlbmV2ZXIgYSBuZXcgbWFuaWZlc3QgaXMgbG9hZGVkLlxuICAgIDtcbiAgICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgICB9O1xuICAgIF9wcm90by5vblN1YnRpdGxlVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICAgIGdyb3VwSWQgPSBkYXRhLmdyb3VwSWQsXG4gICAgICAgIGRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICB2YXIgdHJhY2tJbkFjdGl2ZUdyb3VwID0gdGhpcy50cmFja3NJbkdyb3VwW2lkXTtcbiAgICAgIGlmICghdHJhY2tJbkFjdGl2ZUdyb3VwIHx8IHRyYWNrSW5BY3RpdmVHcm91cC5ncm91cElkICE9PSBncm91cElkKSB7XG4gICAgICAgIHRoaXMud2FybihcIlN1YnRpdGxlIHRyYWNrIHdpdGggaWQ6XCIgKyBpZCArIFwiIGFuZCBncm91cDpcIiArIGdyb3VwSWQgKyBcIiBub3QgZm91bmQgaW4gYWN0aXZlIGdyb3VwIFwiICsgKHRyYWNrSW5BY3RpdmVHcm91cCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN1ckRldGFpbHMgPSB0cmFja0luQWN0aXZlR3JvdXAuZGV0YWlscztcbiAgICAgIHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgdGhpcy5sb2coXCJTdWJ0aXRsZSB0cmFjayBcIiArIGlkICsgXCIgXFxcIlwiICsgdHJhY2tJbkFjdGl2ZUdyb3VwLm5hbWUgKyBcIlxcXCIgbGFuZzpcIiArIHRyYWNrSW5BY3RpdmVHcm91cC5sYW5nICsgXCIgZ3JvdXA6XCIgKyBncm91cElkICsgXCIgbG9hZGVkIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiLVwiICsgZGV0YWlscy5lbmRTTiArIFwiXVwiKTtcbiAgICAgIGlmIChpZCA9PT0gdGhpcy50cmFja0lkKSB7XG4gICAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQoaWQsIGRhdGEsIGN1ckRldGFpbHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbFN3aXRjaGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3dpdGNoTGV2ZWwgPSBmdW5jdGlvbiBzd2l0Y2hMZXZlbChsZXZlbEluZGV4KSB7XG4gICAgICB2YXIgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN1YnRpdGxlR3JvdXBzID0gbGV2ZWxJbmZvLnN1YnRpdGxlR3JvdXBzIHx8IG51bGw7XG4gICAgICB2YXIgY3VycmVudEdyb3VwcyA9IHRoaXMuZ3JvdXBJZHM7XG4gICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICBpZiAoIXN1YnRpdGxlR3JvdXBzIHx8IChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmxlbmd0aCkgIT09IChzdWJ0aXRsZUdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogc3VidGl0bGVHcm91cHMubGVuZ3RoKSB8fCBzdWJ0aXRsZUdyb3VwcyAhPSBudWxsICYmIHN1YnRpdGxlR3JvdXBzLnNvbWUoZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkpID09PSAtMTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBJZHMgPSBzdWJ0aXRsZUdyb3VwcztcbiAgICAgICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgIHJldHVybiAhc3VidGl0bGVHcm91cHMgfHwgc3VidGl0bGVHcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3VidGl0bGVUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRGlzYWJsZSBzZWxlY3REZWZhdWx0VHJhY2sgaWYgdGhlcmUgYXJlIG5vIGRlZmF1bHQgdHJhY2tzXG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrICYmICFzdWJ0aXRsZVRyYWNrcy5zb21lKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrLmRlZmF1bHQ7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHRyYWNrLmlkIHNob3VsZCBtYXRjaCBobHMuYXVkaW9UcmFja3MgaW5kZXhcbiAgICAgICAgICBzdWJ0aXRsZVRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaywgaSkge1xuICAgICAgICAgICAgdHJhY2suaWQgPSBpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFjdXJyZW50VHJhY2sgJiYgIXRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEbyBub3QgZGlzcGF0Y2ggU1VCVElUTEVfVFJBQ0tTX1VQREFURUQgd2hlbiB0aGVyZSB3ZXJlIGFuZCBhcmUgbm8gdHJhY2tzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IHN1YnRpdGxlVHJhY2tzO1xuXG4gICAgICAgIC8vIEZpbmQgcHJlZmVycmVkIHRyYWNrXG4gICAgICAgIHZhciBzdWJ0aXRsZVByZWZlcmVuY2UgPSB0aGlzLmhscy5jb25maWcuc3VidGl0bGVQcmVmZXJlbmNlO1xuICAgICAgICBpZiAoIWN1cnJlbnRUcmFjayAmJiBzdWJ0aXRsZVByZWZlcmVuY2UpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICAgIHZhciBncm91cEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKHN1YnRpdGxlUHJlZmVyZW5jZSwgc3VidGl0bGVUcmFja3MpO1xuICAgICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUcmFjayA9IHN1YnRpdGxlVHJhY2tzW2dyb3VwSW5kZXhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWxsSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oc3VidGl0bGVQcmVmZXJlbmNlLCB0aGlzLnRyYWNrcyk7XG4gICAgICAgICAgICBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1thbGxJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0IGluaXRpYWwgdHJhY2tcbiAgICAgICAgdmFyIHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKGN1cnJlbnRUcmFjayk7XG4gICAgICAgIGlmICh0cmFja0lkID09PSAtMSAmJiBjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGV2ZW50cyBhbmQgbG9hZCB0cmFjayBpZiBuZWVkZWRcbiAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgICBzdWJ0aXRsZVRyYWNrczogc3VidGl0bGVUcmFja3NcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2coXCJVcGRhdGluZyBzdWJ0aXRsZSB0cmFja3MsIFwiICsgc3VidGl0bGVUcmFja3MubGVuZ3RoICsgXCIgdHJhY2socykgZm91bmQgaW4gXFxcIlwiICsgKHN1YnRpdGxlR3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBzdWJ0aXRsZUdyb3Vwcy5qb2luKCcsJykpICsgXCJcXFwiIGdyb3VwLWlkXCIpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgc3VidGl0bGVUcmFja3NVcGRhdGVkKTtcbiAgICAgICAgaWYgKHRyYWNrSWQgIT09IC0xICYmIHRoaXMudHJhY2tJZCA9PT0gLTEpIHtcbiAgICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sodHJhY2tJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5maW5kVHJhY2tJZCA9IGZ1bmN0aW9uIGZpbmRUcmFja0lkKGN1cnJlbnRUcmFjaykge1xuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICAgIHZhciBzZWxlY3REZWZhdWx0ID0gdGhpcy5zZWxlY3REZWZhdWx0VHJhY2s7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgIGlmIChzZWxlY3REZWZhdWx0ICYmICF0cmFjay5kZWZhdWx0IHx8ICFzZWxlY3REZWZhdWx0ICYmICFjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRUcmFjayB8fCBtYXRjaGVzT3B0aW9uKHRyYWNrLCBjdXJyZW50VHJhY2spKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRyYWNrcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX3RyYWNrID0gdHJhY2tzW19pXTtcbiAgICAgICAgICBpZiAobWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGN1cnJlbnRUcmFjay5hdHRycywgX3RyYWNrLmF0dHJzLCBbJ0xBTkdVQUdFJywgJ0FTU09DLUxBTkdVQUdFJywgJ0NIQVJBQ1RFUklTVElDUyddKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB0cmFja3MubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfdHJhY2syID0gdHJhY2tzW19pMl07XG4gICAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIF90cmFjazIuYXR0cnMsIFsnTEFOR1VBR0UnXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfaTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBfcHJvdG8uZmluZFRyYWNrRm9yVGV4dFRyYWNrID0gZnVuY3Rpb24gZmluZFRyYWNrRm9yVGV4dFRyYWNrKHRleHRUcmFjaykge1xuICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgICAgICBpZiAoc3VidGl0bGVUcmFja01hdGNoZXNUZXh0VHJhY2sodHJhY2ssIHRleHRUcmFjaykpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBkYXRhLmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiAoIXRoaXMuZ3JvdXBJZHMgfHwgdGhpcy5ncm91cElkcy5pbmRleE9mKGRhdGEuY29udGV4dC5ncm91cElkKSAhPT0gLTEpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zZXRTdWJ0aXRsZU9wdGlvbiA9IGZ1bmN0aW9uIHNldFN1YnRpdGxlT3B0aW9uKHN1YnRpdGxlT3B0aW9uKSB7XG4gICAgICB0aGlzLmhscy5jb25maWcuc3VidGl0bGVQcmVmZXJlbmNlID0gc3VidGl0bGVPcHRpb247XG4gICAgICBpZiAoc3VidGl0bGVPcHRpb24pIHtcbiAgICAgICAgaWYgKHN1YnRpdGxlT3B0aW9uLmlkID09PSAtMSkge1xuICAgICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjaygtMSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbFN1YnRpdGxlVHJhY2tzID0gdGhpcy5hbGxTdWJ0aXRsZVRyYWNrcztcbiAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFsbFN1YnRpdGxlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEZpcnN0IHNlZSBpZiBjdXJyZW50IG9wdGlvbiBtYXRjaGVzIChubyBzd2l0Y2ggb3ApXG4gICAgICAgICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgICAgICAgIGlmIChjdXJyZW50VHJhY2sgJiYgbWF0Y2hlc09wdGlvbihzdWJ0aXRsZU9wdGlvbiwgY3VycmVudFRyYWNrKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRUcmFjaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRmluZCBvcHRpb24gaW4gY3VycmVudCBncm91cFxuICAgICAgICAgIHZhciBncm91cEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKHN1YnRpdGxlT3B0aW9uLCB0aGlzLnRyYWNrc0luR3JvdXApO1xuICAgICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFtncm91cEluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhncm91cEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGluaXRpYWwgc2VsZWN0aW9uIHJldHVybiBudWxsXG4gICAgICAgICAgICAvLyBvcHRpb24gc2hvdWxkIGhhdmUgbWF0Y2hlZCBvbmUgaW4gYWN0aXZlIGdyb3VwXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgb3B0aW9uIGluIGFsbCB0cmFja3MgZm9yIGluaXRpYWwgc2VsZWN0aW9uXG4gICAgICAgICAgICB2YXIgYWxsSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oc3VidGl0bGVPcHRpb24sIGFsbFN1YnRpdGxlVHJhY2tzKTtcbiAgICAgICAgICAgIGlmIChhbGxJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhbGxTdWJ0aXRsZVRyYWNrc1thbGxJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkUGxheWxpc3QgPSBmdW5jdGlvbiBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5sb2FkUGxheWxpc3QuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh0aGlzLnNob3VsZExvYWRQbGF5bGlzdCh0aGlzLmN1cnJlbnRUcmFjaykpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZUxvYWRpbmcodGhpcy5jdXJyZW50VHJhY2ssIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWRpbmdQbGF5bGlzdCA9IGZ1bmN0aW9uIGxvYWRpbmdQbGF5bGlzdChjdXJyZW50VHJhY2ssIGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUubG9hZGluZ1BsYXlsaXN0LmNhbGwodGhpcywgY3VycmVudFRyYWNrLCBobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICAgIHZhciBpZCA9IGN1cnJlbnRUcmFjay5pZDtcbiAgICAgIHZhciBncm91cElkID0gY3VycmVudFRyYWNrLmdyb3VwSWQ7XG4gICAgICB2YXIgdXJsID0gdGhpcy5nZXRVcmxXaXRoRGlyZWN0aXZlcyhjdXJyZW50VHJhY2sudXJsLCBobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICAgIHZhciBkZXRhaWxzID0gY3VycmVudFRyYWNrLmRldGFpbHM7XG4gICAgICB2YXIgYWdlID0gZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5hZ2U7XG4gICAgICB0aGlzLmxvZyhcIkxvYWRpbmcgc3VidGl0bGUgXCIgKyBpZCArIFwiIFxcXCJcIiArIGN1cnJlbnRUcmFjay5uYW1lICsgXCJcXFwiIGxhbmc6XCIgKyBjdXJyZW50VHJhY2subGFuZyArIFwiIGdyb3VwOlwiICsgZ3JvdXBJZCArICgoaGxzVXJsUGFyYW1ldGVycyA9PSBudWxsID8gdm9pZCAwIDogaGxzVXJsUGFyYW1ldGVycy5tc24pICE9PSB1bmRlZmluZWQgPyAnIGF0IHNuICcgKyBobHNVcmxQYXJhbWV0ZXJzLm1zbiArICcgcGFydCAnICsgaGxzVXJsUGFyYW1ldGVycy5wYXJ0IDogJycpICsgKGFnZSAmJiBkZXRhaWxzLmxpdmUgPyAnIGFnZSAnICsgYWdlLnRvRml4ZWQoMSkgKyAoZGV0YWlscy50eXBlID8gJyAnICsgZGV0YWlscy50eXBlIHx8ICcnIDogJycpIDogJycpICsgXCIgXCIgKyB1cmwpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbCxcbiAgICAgICAgdHJhY2s6IGN1cnJlbnRUcmFja1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIG9sZCBzdWJ0aXRsZVRyYWNrIGFuZCBzZXRzIGN1cnJlbnQgbW9kZSBvbiB0aGUgbmV4dCBzdWJ0aXRsZVRyYWNrLlxuICAgICAqIFRoaXMgb3BlcmF0ZXMgb24gdGhlIERPTSB0ZXh0VHJhY2tzLlxuICAgICAqIEEgdmFsdWUgb2YgLTEgd2lsbCBkaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MuXG4gICAgICovO1xuICAgIF9wcm90by50b2dnbGVUcmFja01vZGVzID0gZnVuY3Rpb24gdG9nZ2xlVHJhY2tNb2RlcygpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICB2YXIgbmV4dFRyYWNrO1xuICAgICAgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgICBuZXh0VHJhY2sgPSB0ZXh0VHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tNYXRjaGVzVGV4dFRyYWNrKGN1cnJlbnRUcmFjaywgdGV4dFRyYWNrKTtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIGlmICghbmV4dFRyYWNrKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwiVW5hYmxlIHRvIGZpbmQgc3VidGl0bGUgVGV4dFRyYWNrIHdpdGggbmFtZSBcXFwiXCIgKyBjdXJyZW50VHJhY2submFtZSArIFwiXFxcIiBhbmQgbGFuZ3VhZ2UgXFxcIlwiICsgY3VycmVudFRyYWNrLmxhbmcgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFtdLnNsaWNlLmNhbGwodGV4dFRyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgaWYgKHRyYWNrLm1vZGUgIT09ICdkaXNhYmxlZCcgJiYgdHJhY2sgIT09IG5leHRUcmFjaykge1xuICAgICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChuZXh0VHJhY2spIHtcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLnN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgICAgICBpZiAobmV4dFRyYWNrLm1vZGUgIT09IG1vZGUpIHtcbiAgICAgICAgICBuZXh0VHJhY2subW9kZSA9IG1vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyB0aGUgc3VidGl0bGUgaW5kZXggYW5kIHBlcmlvZGljYWxseSByZWxvYWRpbmcgaWYgbGl2ZS5cbiAgICAgKiBEaXNwYXRjaGVzIHRoZSBTVUJUSVRMRV9UUkFDS19TV0lUQ0ggZXZlbnQsIHdoaWNoIGluc3RydWN0cyB0aGUgc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgdG8gbG9hZCB0aGUgc2VsZWN0ZWQgdHJhY2suXG4gICAgICovO1xuICAgIF9wcm90by5zZXRTdWJ0aXRsZVRyYWNrID0gZnVuY3Rpb24gc2V0U3VidGl0bGVUcmFjayhuZXdJZCkge1xuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcblxuICAgICAgLy8gc2V0dGluZyB0aGlzLnN1YnRpdGxlVHJhY2sgd2lsbCB0cmlnZ2VyIGludGVybmFsIGxvZ2ljXG4gICAgICAvLyBpZiBtZWRpYSBoYXMgbm90IGJlZW4gYXR0YWNoZWQgeWV0LCBpdCB3aWxsIGZhaWxcbiAgICAgIC8vIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgdHJhY2sgaWRcbiAgICAgIC8vIGFuZCB3ZSdsbCBzZXQgc3VidGl0bGVUcmFjayB3aGVuIG9uTWVkaWFBdHRhY2hlZCBpcyB0cmlnZ2VyZWRcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IG5ld0lkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGV4aXQgaWYgdHJhY2sgaWQgYXMgYWxyZWFkeSBzZXQgb3IgaW52YWxpZFxuICAgICAgaWYgKG5ld0lkIDwgLTEgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCB8fCAhaXNGaW5pdGVOdW1iZXIobmV3SWQpKSB7XG4gICAgICAgIHRoaXMud2FybihcIkludmFsaWQgc3VidGl0bGUgdHJhY2sgaWQ6IFwiICsgbmV3SWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgdmFyIGxhc3RUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW25ld0lkXSB8fCBudWxsO1xuICAgICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFjayA9IHRyYWNrO1xuICAgICAgdGhpcy50b2dnbGVUcmFja01vZGVzKCk7XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIC8vIHN3aXRjaCB0byAtMVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHtcbiAgICAgICAgICBpZDogbmV3SWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFja0xvYWRlZCA9ICEhdHJhY2suZGV0YWlscyAmJiAhdHJhY2suZGV0YWlscy5saXZlO1xuICAgICAgaWYgKG5ld0lkID09PSB0aGlzLnRyYWNrSWQgJiYgdHJhY2sgPT09IGxhc3RUcmFjayAmJiB0cmFja0xvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcIlN3aXRjaGluZyB0byBzdWJ0aXRsZS10cmFjayBcIiArIG5ld0lkICsgKHRyYWNrID8gXCIgXFxcIlwiICsgdHJhY2submFtZSArIFwiXFxcIiBsYW5nOlwiICsgdHJhY2subGFuZyArIFwiIGdyb3VwOlwiICsgdHJhY2suZ3JvdXBJZCA6ICcnKSk7XG4gICAgICB2YXIgaWQgPSB0cmFjay5pZCxcbiAgICAgICAgX3RyYWNrJGdyb3VwSWQgPSB0cmFjay5ncm91cElkLFxuICAgICAgICBncm91cElkID0gX3RyYWNrJGdyb3VwSWQgPT09IHZvaWQgMCA/ICcnIDogX3RyYWNrJGdyb3VwSWQsXG4gICAgICAgIG5hbWUgPSB0cmFjay5uYW1lLFxuICAgICAgICB0eXBlID0gdHJhY2sudHlwZSxcbiAgICAgICAgdXJsID0gdHJhY2sudXJsO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH0pO1xuICAgICAgdmFyIGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PSBudWxsID8gdm9pZCAwIDogbGFzdFRyYWNrLmRldGFpbHMsIHRyYWNrLmRldGFpbHMpO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcInN1YnRpdGxlRGlzcGxheVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJ0aXRsZURpc3BsYXk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrSWQgPiAtMSkge1xuICAgICAgICAgIHRoaXMudG9nZ2xlVHJhY2tNb2RlcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFsbFN1YnRpdGxlVHJhY2tzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICAgICAgfVxuXG4gICAgICAvKiogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgICB9XG5cbiAgICAgIC8qKiBnZXQvc2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoYmFzZWQgb24gaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdJZCkge1xuICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sobmV3SWQpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShCYXNlUGxheWxpc3RDb250cm9sbGVyKTtcblxuICAvKipcbiAgICpcbiAgICogVGhpcyBjb2RlIHdhcyBwb3J0ZWQgZnJvbSB0aGUgZGFzaC5qcyBwcm9qZWN0IGF0OlxuICAgKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICAgKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvY29tbWl0LzgyNjliMjZhNzYxZTA4NTNiYjIxZDc4NzgwZWQ5NDUxNDRlY2RkNGQjZGlmZi03MWJjMjk1YTJkNmI2YjcwOTNhMWQzMjkwZDUzYTRiMlxuICAgKlxuICAgKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gICAqXG4gICAqIFRoZSBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBpcyBiZWluZyBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UsXG4gICAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICAgKiByaWdodHMsIGluY2x1ZGluZyBwYXRlbnQgcmlnaHRzLCBhbmQgbm8gc3VjaCByaWdodHMgYXJlIGdyYW50ZWQgdW5kZXIgdGhpcyBsaWNlbnNlLlxuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAgICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICpcbiAgICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAgICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICAgKiAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgKiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3JcbiAgICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gICAqICAyLiBOZWl0aGVyIHRoZSBuYW1lIG9mIERhc2ggSW5kdXN0cnkgRm9ydW0gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAgICogIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICAgKlxuICAgKiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBBUyBJUyBBTkQgQU5ZXG4gICAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXG4gICAqICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICAgKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICAgKiAgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgKiAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gICAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gICAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgKiAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gICAqL1xuICAvKipcbiAgICogIEV4Y2VwdGlvbnMgZnJvbSByZWd1bGFyIEFTQ0lJLiBDb2RlUG9pbnRzIGFyZSBtYXBwZWQgdG8gVVRGLTE2IGNvZGVzXG4gICAqL1xuXG4gIHZhciBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcbiAgICAweDJhOiAweGUxLFxuICAgIC8vIGxvd2VyY2FzZSBhLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVjOiAweGU5LFxuICAgIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVlOiAweGVkLFxuICAgIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcbiAgICAweDVmOiAweGYzLFxuICAgIC8vIGxvd2VyY2FzZSBvLCBhY3V0ZSBhY2NlbnRcbiAgICAweDYwOiAweGZhLFxuICAgIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgICAweDdiOiAweGU3LFxuICAgIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAgIDB4N2M6IDB4ZjcsXG4gICAgLy8gZGl2aXNpb24gc3ltYm9sXG4gICAgMHg3ZDogMHhkMSxcbiAgICAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAgIDB4N2U6IDB4ZjEsXG4gICAgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgICAweDdmOiAweDI1ODgsXG4gICAgLy8gRnVsbCBibG9ja1xuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gICAgLy8gVEhJUyBNRUFOUyBUSEFUIFxceDUwIE1VU1QgQkUgQURERUQgVE8gVEhFIFZBTFVFU1xuICAgIDB4ODA6IDB4YWUsXG4gICAgLy8gUmVnaXN0ZXJlZCBzeW1ib2wgKFIpXG4gICAgMHg4MTogMHhiMCxcbiAgICAvLyBkZWdyZWUgc2lnblxuICAgIDB4ODI6IDB4YmQsXG4gICAgLy8gMS8yIHN5bWJvbFxuICAgIDB4ODM6IDB4YmYsXG4gICAgLy8gSW52ZXJ0ZWQgKG9wZW4pIHF1ZXN0aW9uIG1hcmtcbiAgICAweDg0OiAweDIxMjIsXG4gICAgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXG4gICAgMHg4NTogMHhhMixcbiAgICAvLyBDZW50cyBzeW1ib2xcbiAgICAweDg2OiAweGEzLFxuICAgIC8vIFBvdW5kcyBzdGVybGluZ1xuICAgIDB4ODc6IDB4MjY2YSxcbiAgICAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgICAweDg4OiAweGUwLFxuICAgIC8vIGxvd2VyY2FzZSBhLCBncmF2ZSBhY2NlbnRcbiAgICAweDg5OiAweDIwLFxuICAgIC8vIHRyYW5zcGFyZW50IHNwYWNlIChyZWd1bGFyKVxuICAgIDB4OGE6IDB4ZTgsXG4gICAgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxuICAgIDB4OGI6IDB4ZTIsXG4gICAgLy8gbG93ZXJjYXNlIGEsIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4YzogMHhlYSxcbiAgICAvLyBsb3dlcmNhc2UgZSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAweDhkOiAweGVlLFxuICAgIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGU6IDB4ZjQsXG4gICAgLy8gbG93ZXJjYXNlIG8sIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZjogMHhmYixcbiAgICAvLyBsb3dlcmNhc2UgdSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAgIDB4OTA6IDB4YzEsXG4gICAgLy8gY2FwaXRhbCBsZXR0ZXIgQSB3aXRoIGFjdXRlXG4gICAgMHg5MTogMHhjOSxcbiAgICAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcbiAgICAweDkyOiAweGQzLFxuICAgIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAgIDB4OTM6IDB4ZGEsXG4gICAgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGFjdXRlXG4gICAgMHg5NDogMHhkYyxcbiAgICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcbiAgICAweDk1OiAweGZjLFxuICAgIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAgIDB4OTY6IDB4MjAxOCxcbiAgICAvLyBvcGVuaW5nIHNpbmdsZSBxdW90ZVxuICAgIDB4OTc6IDB4YTEsXG4gICAgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAgIDB4OTg6IDB4MmEsXG4gICAgLy8gYXN0ZXJpc2tcbiAgICAweDk5OiAweDIwMTksXG4gICAgLy8gY2xvc2luZyBzaW5nbGUgcXVvdGVcbiAgICAweDlhOiAweDI1MDEsXG4gICAgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgICAweDliOiAweGE5LFxuICAgIC8vIGNvcHlyaWdodCBzaWduXG4gICAgMHg5YzogMHgyMTIwLFxuICAgIC8vIFNlcnZpY2UgbWFya1xuICAgIDB4OWQ6IDB4MjAyMixcbiAgICAvLyAocm91bmQpIGJ1bGxldFxuICAgIDB4OWU6IDB4MjAxYyxcbiAgICAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAgIDB4OWY6IDB4MjAxZCxcbiAgICAvLyBSaWdodCBkb3VibGUgcXVvdGF0aW9uIG1hcmtcbiAgICAweGEwOiAweGMwLFxuICAgIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcbiAgICAweGExOiAweGMyLFxuICAgIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gICAgMHhhMjogMHhjNyxcbiAgICAvLyB1cHBlcmNhc2UgQyB3aXRoIGNlZGlsbGFcbiAgICAweGEzOiAweGM4LFxuICAgIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcbiAgICAweGE0OiAweGNhLFxuICAgIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gICAgMHhhNTogMHhjYixcbiAgICAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggZGlhcmVzaXNcbiAgICAweGE2OiAweGViLFxuICAgIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXG4gICAgMHhhNzogMHhjZSxcbiAgICAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAgIDB4YTg6IDB4Y2YsXG4gICAgLy8gdXBwZXJjYXNlIEksIHdpdGggZGlhcmVzaXNcbiAgICAweGE5OiAweGVmLFxuICAgIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXG4gICAgMHhhYTogMHhkNCxcbiAgICAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAgIDB4YWI6IDB4ZDksXG4gICAgLy8gdXBwZXJjYXNlIFUsIGdyYXZlIGFjY2VudFxuICAgIDB4YWM6IDB4ZjksXG4gICAgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxuICAgIDB4YWQ6IDB4ZGIsXG4gICAgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgICAweGFlOiAweGFiLFxuICAgIC8vIGxlZnQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gICAgMHhhZjogMHhiYixcbiAgICAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAgIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAgIDB4YjA6IDB4YzMsXG4gICAgLy8gVXBwZXJjYXNlIEEsIHRpbGRlXG4gICAgMHhiMTogMHhlMyxcbiAgICAvLyBMb3dlcmNhc2UgYSwgdGlsZGVcbiAgICAweGIyOiAweGNkLFxuICAgIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgICAweGIzOiAweGNjLFxuICAgIC8vIFVwcGVyY2FzZSBJLCBncmF2ZSBhY2NlbnRcbiAgICAweGI0OiAweGVjLFxuICAgIC8vIExvd2VyY2FzZSBpLCBncmF2ZSBhY2NlbnRcbiAgICAweGI1OiAweGQyLFxuICAgIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgICAweGI2OiAweGYyLFxuICAgIC8vIExvd2VyY2FzZSBvLCBncmF2ZSBhY2NlbnRcbiAgICAweGI3OiAweGQ1LFxuICAgIC8vIFVwcGVyY2FzZSBPLCB0aWxkZVxuICAgIDB4Yjg6IDB4ZjUsXG4gICAgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gICAgMHhiOTogMHg3YixcbiAgICAvLyBPcGVuIGN1cmx5IGJyYWNlXG4gICAgMHhiYTogMHg3ZCxcbiAgICAvLyBDbG9zaW5nIGN1cmx5IGJyYWNlXG4gICAgMHhiYjogMHg1YyxcbiAgICAvLyBCYWNrc2xhc2hcbiAgICAweGJjOiAweDVlLFxuICAgIC8vIENhcmV0XG4gICAgMHhiZDogMHg1ZixcbiAgICAvLyBVbmRlcnNjb3JlXG4gICAgMHhiZTogMHg3YyxcbiAgICAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAgIDB4YmY6IDB4MjIzYyxcbiAgICAvLyBUaWxkZSBvcGVyYXRvclxuICAgIDB4YzA6IDB4YzQsXG4gICAgLy8gVXBwZXJjYXNlIEEsIHVtbGF1dFxuICAgIDB4YzE6IDB4ZTQsXG4gICAgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAgIDB4YzI6IDB4ZDYsXG4gICAgLy8gVXBwZXJjYXNlIE8sIHVtbGF1dFxuICAgIDB4YzM6IDB4ZjYsXG4gICAgLy8gTG93ZXJjYXNlIG8sIHVtbGF1dFxuICAgIDB4YzQ6IDB4ZGYsXG4gICAgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgICAweGM1OiAweGE1LFxuICAgIC8vIFllbiBzeW1ib2xcbiAgICAweGM2OiAweGE0LFxuICAgIC8vIEdlbmVyaWMgY3VycmVuY3kgc2lnblxuICAgIDB4Yzc6IDB4MjUwMyxcbiAgICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgICAweGM4OiAweGM1LFxuICAgIC8vIFVwcGVyY2FzZSBBLCByaW5nXG4gICAgMHhjOTogMHhlNSxcbiAgICAvLyBMb3dlcmNhc2UgQSwgcmluZ1xuICAgIDB4Y2E6IDB4ZDgsXG4gICAgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAgIDB4Y2I6IDB4ZjgsXG4gICAgLy8gTG93ZXJjYXNlIG8sIHN0cm9rXG4gICAgMHhjYzogMHgyNTBmLFxuICAgIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCByaWdodFxuICAgIDB4Y2Q6IDB4MjUxMyxcbiAgICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAgIDB4Y2U6IDB4MjUxNyxcbiAgICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdXAgYW5kIHJpZ2h0XG4gICAgMHhjZjogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxuICB9O1xuXG4gIC8qKlxuICAgKiBVdGlsc1xuICAgKi9cbiAgdmFyIGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24gZ2V0Q2hhckZvckJ5dGUoX2J5dGUpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlc1tfYnl0ZV0gfHwgX2J5dGUpO1xuICB9O1xuICB2YXIgTlJfUk9XUyA9IDE1O1xuICB2YXIgTlJfQ09MUyA9IDEwMDtcbiAgLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbiAgdmFyIHJvd3NMb3dDaDEgPSB7XG4gICAgMHgxMTogMSxcbiAgICAweDEyOiAzLFxuICAgIDB4MTU6IDUsXG4gICAgMHgxNjogNyxcbiAgICAweDE3OiA5LFxuICAgIDB4MTA6IDExLFxuICAgIDB4MTM6IDEyLFxuICAgIDB4MTQ6IDE0XG4gIH07XG4gIHZhciByb3dzSGlnaENoMSA9IHtcbiAgICAweDExOiAyLFxuICAgIDB4MTI6IDQsXG4gICAgMHgxNTogNixcbiAgICAweDE2OiA4LFxuICAgIDB4MTc6IDEwLFxuICAgIDB4MTM6IDEzLFxuICAgIDB4MTQ6IDE1XG4gIH07XG4gIHZhciByb3dzTG93Q2gyID0ge1xuICAgIDB4MTk6IDEsXG4gICAgMHgxYTogMyxcbiAgICAweDFkOiA1LFxuICAgIDB4MWU6IDcsXG4gICAgMHgxZjogOSxcbiAgICAweDE4OiAxMSxcbiAgICAweDFiOiAxMixcbiAgICAweDFjOiAxNFxuICB9O1xuICB2YXIgcm93c0hpZ2hDaDIgPSB7XG4gICAgMHgxOTogMixcbiAgICAweDFhOiA0LFxuICAgIDB4MWQ6IDYsXG4gICAgMHgxZTogOCxcbiAgICAweDFmOiAxMCxcbiAgICAweDFiOiAxMyxcbiAgICAweDFjOiAxNVxuICB9O1xuICB2YXIgYmFja2dyb3VuZENvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICdibGFjaycsICd0cmFuc3BhcmVudCddO1xuICB2YXIgQ2FwdGlvbnNMb2dnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcHRpb25zTG9nZ2VyKCkge1xuICAgICAgdGhpcy50aW1lID0gbnVsbDtcbiAgICAgIHRoaXMudmVyYm9zZUxldmVsID0gMDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENhcHRpb25zTG9nZ2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ubG9nID0gZnVuY3Rpb24gbG9nKHNldmVyaXR5LCBtc2cpIHtcbiAgICAgIGlmICh0aGlzLnZlcmJvc2VMZXZlbCA+PSBzZXZlcml0eSkge1xuICAgICAgICB2YXIgbSA9IHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicgPyBtc2coKSA6IG1zZztcbiAgICAgICAgbG9nZ2VyLmxvZyh0aGlzLnRpbWUgKyBcIiBbXCIgKyBzZXZlcml0eSArIFwiXSBcIiArIG0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhcHRpb25zTG9nZ2VyO1xuICB9KCk7XG4gIHZhciBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiBudW1BcnJheVRvSGV4QXJyYXkobnVtQXJyYXkpIHtcbiAgICB2YXIgaGV4QXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhBcnJheTtcbiAgfTtcbiAgdmFyIFBlblN0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZW5TdGF0ZSgpIHtcbiAgICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgICAgdGhpcy5mbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvMiA9IFBlblN0YXRlLnByb3RvdHlwZTtcbiAgICBfcHJvdG8yLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcbiAgICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90bzIuc2V0U3R5bGVzID0gZnVuY3Rpb24gc2V0U3R5bGVzKHN0eWxlcykge1xuICAgICAgdmFyIGF0dHJpYnMgPSBbJ2ZvcmVncm91bmQnLCAndW5kZXJsaW5lJywgJ2l0YWxpY3MnLCAnYmFja2dyb3VuZCcsICdmbGFzaCddO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8yLmlzRGVmYXVsdCA9IGZ1bmN0aW9uIGlzRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSAnYmxhY2snICYmICF0aGlzLmZsYXNoO1xuICAgIH07XG4gICAgX3Byb3RvMi5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09IG90aGVyLmZvcmVncm91bmQgJiYgdGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSAmJiB0aGlzLml0YWxpY3MgPT09IG90aGVyLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSBvdGhlci5iYWNrZ3JvdW5kICYmIHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoO1xuICAgIH07XG4gICAgX3Byb3RvMi5jb3B5ID0gZnVuY3Rpb24gY29weShuZXdQZW5TdGF0ZSkge1xuICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgIHRoaXMudW5kZXJsaW5lID0gbmV3UGVuU3RhdGUudW5kZXJsaW5lO1xuICAgICAgdGhpcy5pdGFsaWNzID0gbmV3UGVuU3RhdGUuaXRhbGljcztcbiAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgICB0aGlzLmZsYXNoID0gbmV3UGVuU3RhdGUuZmxhc2g7XG4gICAgfTtcbiAgICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2NvbG9yPScgKyB0aGlzLmZvcmVncm91bmQgKyAnLCB1bmRlcmxpbmU9JyArIHRoaXMudW5kZXJsaW5lICsgJywgaXRhbGljcz0nICsgdGhpcy5pdGFsaWNzICsgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2g7XG4gICAgfTtcbiAgICByZXR1cm4gUGVuU3RhdGU7XG4gIH0oKTtcbiAgLyoqXG4gICAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgU3R5bGVkVW5pY29kZUNoYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlZFVuaWNvZGVDaGFyKCkge1xuICAgICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90bzMgPSBTdHlsZWRVbmljb2RlQ2hhci5wcm90b3R5cGU7XG4gICAgX3Byb3RvMy5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICAgIHRoaXMucGVuU3RhdGUucmVzZXQoKTtcbiAgICB9O1xuICAgIF9wcm90bzMuc2V0Q2hhciA9IGZ1bmN0aW9uIHNldENoYXIodWNoYXIsIG5ld1BlblN0YXRlKSB7XG4gICAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICAgIH07XG4gICAgX3Byb3RvMy5zZXRQZW5TdGF0ZSA9IGZ1bmN0aW9uIHNldFBlblN0YXRlKG5ld1BlblN0YXRlKSB7XG4gICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICAgIH07XG4gICAgX3Byb3RvMy5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBvdGhlci51Y2hhciAmJiB0aGlzLnBlblN0YXRlLmVxdWFscyhvdGhlci5wZW5TdGF0ZSk7XG4gICAgfTtcbiAgICBfcHJvdG8zLmNvcHkgPSBmdW5jdGlvbiBjb3B5KG5ld0NoYXIpIHtcbiAgICAgIHRoaXMudWNoYXIgPSBuZXdDaGFyLnVjaGFyO1xuICAgICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xuICAgIH07XG4gICAgX3Byb3RvMy5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVjaGFyID09PSAnICcgJiYgdGhpcy5wZW5TdGF0ZS5pc0RlZmF1bHQoKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHlsZWRVbmljb2RlQ2hhcjtcbiAgfSgpO1xuICAvKipcbiAgICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgUm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3cobG9nZ2VyKSB7XG4gICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICAgICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICB0aGlzLmNoYXJzLnB1c2gobmV3IFN0eWxlZFVuaWNvZGVDaGFyKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuICAgIHZhciBfcHJvdG80ID0gUm93LnByb3RvdHlwZTtcbiAgICBfcHJvdG80LmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmVxdWFscyhvdGhlci5jaGFyc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvNC5jb3B5ID0gZnVuY3Rpb24gY29weShvdGhlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgdGhpcy5jaGFyc1tpXS5jb3B5KG90aGVyLmNoYXJzW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90bzQuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0IHRoZSBjdXJzb3IgdG8gYSB2YWxpZCBjb2x1bW4uXG4gICAgICovO1xuICAgIF9wcm90bzQuc2V0Q3Vyc29yID0gZnVuY3Rpb24gc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgICAgaWYgKHRoaXMucG9zICE9PSBhYnNQb3MpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wb3MgPCAwKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wb3MgPiBOUl9DT0xTKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICovO1xuICAgIF9wcm90bzQubW92ZUN1cnNvciA9IGZ1bmN0aW9uIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgICB2YXIgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG4gICAgICBpZiAocmVsUG9zID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wb3MgKyAxOyBpIDwgbmV3UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q3Vyc29yKG5ld1Bvcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmFja3NwYWNlLCBtb3ZlIG9uZSBzdGVwIGJhY2sgYW5kIGNsZWFyIGNoYXJhY3Rlci5cbiAgICAgKi87XG4gICAgX3Byb3RvNC5iYWNrU3BhY2UgPSBmdW5jdGlvbiBiYWNrU3BhY2UoKSB7XG4gICAgICB0aGlzLm1vdmVDdXJzb3IoLTEpO1xuICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB9O1xuICAgIF9wcm90bzQuaW5zZXJ0Q2hhciA9IGZ1bmN0aW9uIGluc2VydENoYXIoX2J5dGUyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKF9ieXRlMiA+PSAweDkwKSB7XG4gICAgICAgIC8vIEV4dGVuZGVkIGNoYXJcbiAgICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciBfY2hhciA9IGdldENoYXJGb3JCeXRlKF9ieXRlMik7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnQ2Fubm90IGluc2VydCAnICsgX2J5dGUyLnRvU3RyaW5nKDE2KSArICcgKCcgKyBfY2hhciArICcpIGF0IHBvc2l0aW9uICcgKyBfdGhpcy5wb3MgKyAnLiBTa2lwcGluZyBpdCEnO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihfY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yKDEpO1xuICAgIH07XG4gICAgX3Byb3RvNC5jbGVhckZyb21Qb3MgPSBmdW5jdGlvbiBjbGVhckZyb21Qb3Moc3RhcnRQb3MpIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gc3RhcnRQb3M7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvNC5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICAgIH07XG4gICAgX3Byb3RvNC5jbGVhclRvRW5kT2ZSb3cgPSBmdW5jdGlvbiBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgICB0aGlzLmNsZWFyRnJvbVBvcyh0aGlzLnBvcyk7XG4gICAgfTtcbiAgICBfcHJvdG80LmdldFRleHRTdHJpbmcgPSBmdW5jdGlvbiBnZXRUZXh0U3RyaW5nKCkge1xuICAgICAgdmFyIGNoYXJzID0gW107XG4gICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgICAgdmFyIF9jaGFyMiA9IHRoaXMuY2hhcnNbaV0udWNoYXI7XG4gICAgICAgIGlmIChfY2hhcjIgIT09ICcgJykge1xuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMucHVzaChfY2hhcjIpO1xuICAgICAgfVxuICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90bzQuc2V0UGVuU3R5bGVzID0gZnVuY3Rpb24gc2V0UGVuU3R5bGVzKHN0eWxlcykge1xuICAgICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgICB2YXIgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcbiAgICAgIGN1cnJDaGFyLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB9O1xuICAgIHJldHVybiBSb3c7XG4gIH0oKTtcblxuICAvKipcbiAgICogS2VlcCBhIENFQS02MDggc2NyZWVuIG9mIDMyeDE1IHN0eWxlZCBjaGFyYWN0ZXJzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdmFyIENhcHRpb25TY3JlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcHRpb25TY3JlZW4obG9nZ2VyKSB7XG4gICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgICAgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbnVsbDtcbiAgICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb3dzLnB1c2gobmV3IFJvdyhsb2dnZXIpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvNSA9IENhcHRpb25TY3JlZW4ucHJvdG90eXBlO1xuICAgIF9wcm90bzUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgfTtcbiAgICBfcHJvdG81LmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgdmFyIGVxdWFsID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlcXVhbDtcbiAgICB9O1xuICAgIF9wcm90bzUuY29weSA9IGZ1bmN0aW9uIGNvcHkob3RoZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvNS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMucm93c1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHk7XG4gICAgfTtcbiAgICBfcHJvdG81LmJhY2tTcGFjZSA9IGZ1bmN0aW9uIGJhY2tTcGFjZSgpIHtcbiAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgIHJvdy5iYWNrU3BhY2UoKTtcbiAgICB9O1xuICAgIF9wcm90bzUuY2xlYXJUb0VuZE9mUm93ID0gZnVuY3Rpb24gY2xlYXJUb0VuZE9mUm93KCkge1xuICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgcm93LmNsZWFyVG9FbmRPZlJvdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIGNoYXJhY3RlciAod2l0aG91dCBzdHlsaW5nKSBpbiB0aGUgY3VycmVudCByb3cuXG4gICAgICovO1xuICAgIF9wcm90bzUuaW5zZXJ0Q2hhciA9IGZ1bmN0aW9uIGluc2VydENoYXIoX2NoYXIzKSB7XG4gICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICByb3cuaW5zZXJ0Q2hhcihfY2hhcjMpO1xuICAgIH07XG4gICAgX3Byb3RvNS5zZXRQZW4gPSBmdW5jdGlvbiBzZXRQZW4oc3R5bGVzKSB7XG4gICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICByb3cuc2V0UGVuU3R5bGVzKHN0eWxlcyk7XG4gICAgfTtcbiAgICBfcHJvdG81Lm1vdmVDdXJzb3IgPSBmdW5jdGlvbiBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgcm93Lm1vdmVDdXJzb3IocmVsUG9zKTtcbiAgICB9O1xuICAgIF9wcm90bzUuc2V0Q3Vyc29yID0gZnVuY3Rpb24gc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdzZXRDdXJzb3I6ICcgKyBhYnNQb3MpO1xuICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgcm93LnNldEN1cnNvcihhYnNQb3MpO1xuICAgIH07XG4gICAgX3Byb3RvNS5zZXRQQUMgPSBmdW5jdGlvbiBzZXRQQUMocGFjRGF0YSkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdwYWNEYXRhID0gJyArIHN0cmluZ2lmeShwYWNEYXRhKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcbiAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgICAgbmV3Um93ID0gdGhpcy5uclJvbGxVcFJvd3MgLSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhpcyBvbmx5IGFmZmVjdHMgUm9sbC11cCBDYXB0aW9ucyBieSBjaGVja2luZyB0aGlzLm5yUm9sbFVwUm93c1xuICAgICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIHRoaXMuY3VyclJvdyAhPT0gbmV3Um93KSB7XG4gICAgICAgIC8vIGNsZWFyIGFsbCByb3dzIGZpcnN0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAgIC8vIHRvcFJvd0luZGV4IC0gdGhlIHN0YXJ0IG9mIHJvd3MgdG8gY29weSAoaW5jbHVzaXZlIGluZGV4KVxuICAgICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgICAgIC8vIFdlIG9ubHkgY29weSBpZiB0aGUgbGFzdCBwb3NpdGlvbiB3YXMgYWxyZWFkeSBzaG93bi5cbiAgICAgICAgLy8gV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cbiAgICAgICAgdmFyIGxhc3RPdXRwdXRTY3JlZW4gPSB0aGlzLmxhc3RPdXRwdXRTY3JlZW47XG4gICAgICAgIGlmIChsYXN0T3V0cHV0U2NyZWVuKSB7XG4gICAgICAgICAgdmFyIHByZXZMaW5lVGltZSA9IGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleF0uY3VlU3RhcnRUaW1lO1xuICAgICAgICAgIHZhciB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcbiAgICAgICAgICBpZiAocHJldkxpbmVUaW1lICE9PSBudWxsICYmIHRpbWUgIT09IG51bGwgJiYgcHJldkxpbmVUaW1lIDwgdGltZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMubnJSb2xsVXBSb3dzOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMucm93c1tuZXdSb3cgLSB0aGlzLm5yUm9sbFVwUm93cyArIF9pICsgMV0uY29weShsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXggKyBfaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgaWYgKHBhY0RhdGEuaW5kZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSBwYWNEYXRhLmluZGVudDtcbiAgICAgICAgdmFyIHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQgLSAxLCAwKTtcbiAgICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICAgIHBhY0RhdGEuY29sb3IgPSByb3cuY2hhcnNbcHJldlBvc10ucGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgIGZvcmVncm91bmQ6IHBhY0RhdGEuY29sb3IsXG4gICAgICAgIHVuZGVybGluZTogcGFjRGF0YS51bmRlcmxpbmUsXG4gICAgICAgIGl0YWxpY3M6IHBhY0RhdGEuaXRhbGljcyxcbiAgICAgICAgYmFja2dyb3VuZDogJ2JsYWNrJyxcbiAgICAgICAgZmxhc2g6IGZhbHNlXG4gICAgICB9O1xuICAgICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAgICovO1xuICAgIF9wcm90bzUuc2V0QmtnRGF0YSA9IGZ1bmN0aW9uIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdia2dEYXRhID0gJyArIHN0cmluZ2lmeShia2dEYXRhKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xuICAgICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvLyBTcGFjZVxuICAgIH07XG4gICAgX3Byb3RvNS5zZXRSb2xsVXBSb3dzID0gZnVuY3Rpb24gc2V0Um9sbFVwUm93cyhuclJvd3MpIHtcbiAgICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICAgIH07XG4gICAgX3Byb3RvNS5yb2xsVXAgPSBmdW5jdGlvbiByb2xsVXAoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgICByZXR1cm47IC8vIE5vdCBwcm9wZXJseSBzZXR1cFxuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5nZXREaXNwbGF5VGV4dCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgICB2YXIgdG9wUm93ID0gdGhpcy5yb3dzLnNwbGljZSh0b3BSb3dJbmRleCwgMSlbMF07XG4gICAgICB0b3BSb3cuY2xlYXIoKTtcbiAgICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdSb2xsaW5nIHVwJyk7XG4gICAgICAvLyB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAgICovO1xuICAgIF9wcm90bzUuZ2V0RGlzcGxheVRleHQgPSBmdW5jdGlvbiBnZXREaXNwbGF5VGV4dChhc09uZVJvdykge1xuICAgICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICAgIHZhciBkaXNwbGF5VGV4dCA9IFtdO1xuICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgIHZhciByb3dOciA9IC0xO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgdmFyIHJvd1RleHQgPSB0aGlzLnJvd3NbaV0uZ2V0VGV4dFN0cmluZygpO1xuICAgICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICAgIHJvd05yID0gaSArIDE7XG4gICAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgXCI6ICdcIiArIHJvd1RleHQgKyBcIidcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2gocm93VGV4dC50cmltKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgdGV4dCA9ICdbJyArIGRpc3BsYXlUZXh0LmpvaW4oJyB8ICcpICsgJ10nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICBfcHJvdG81LmdldFRleHRBbmRGb3JtYXQgPSBmdW5jdGlvbiBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucm93cztcbiAgICB9O1xuICAgIHJldHVybiBDYXB0aW9uU2NyZWVuO1xuICB9KCk7XG5cbiAgLy8gdmFyIG1vZGVzID0gWydNT0RFX1JPTEwtVVAnLCAnTU9ERV9QT1AtT04nLCAnTU9ERV9QQUlOVC1PTicsICdNT0RFX1RFWFQnXTtcbiAgdmFyIENlYTYwOENoYW5uZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlYTYwOENoYW5uZWwoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyLCBsb2dnZXIpIHtcbiAgICAgIHRoaXMuY2hOciA9IHZvaWQgMDtcbiAgICAgIHRoaXMub3V0cHV0RmlsdGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5tb2RlID0gdm9pZCAwO1xuICAgICAgdGhpcy52ZXJib3NlID0gdm9pZCAwO1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHZvaWQgMDtcbiAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHZvaWQgMDtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB2b2lkIDA7XG4gICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xuICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbihsb2dnZXIpO1xuICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuICAgIHZhciBfcHJvdG82ID0gQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGU7XG4gICAgX3Byb3RvNi5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLnJlc2V0KCk7XG4gICAgICB0aGlzLm91dHB1dEZpbHRlci5yZXNldCgpO1xuICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvNi5nZXRIYW5kbGVyID0gZnVuY3Rpb24gZ2V0SGFuZGxlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dEZpbHRlcjtcbiAgICB9O1xuICAgIF9wcm90bzYuc2V0SGFuZGxlciA9IGZ1bmN0aW9uIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xuICAgIH07XG4gICAgX3Byb3RvNi5zZXRQQUMgPSBmdW5jdGlvbiBzZXRQQUMocGFjRGF0YSkge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gICAgfTtcbiAgICBfcHJvdG82LnNldEJrZ0RhdGEgPSBmdW5jdGlvbiBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICB9O1xuICAgIF9wcm90bzYuc2V0TW9kZSA9IGZ1bmN0aW9uIHNldE1vZGUobmV3TW9kZSkge1xuICAgICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNT0RFPScgKyBuZXdNb2RlO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgfTtcbiAgICBfcHJvdG82Lmluc2VydENoYXJzID0gZnVuY3Rpb24gaW5zZXJ0Q2hhcnMoY2hhcnMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmluc2VydENoYXIoY2hhcnNbaV0pO1xuICAgICAgfVxuICAgICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzY3JlZW4gKyAnOiAnICsgX3RoaXMzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QQUlOVC1PTicgfHwgdGhpcy5tb2RlID09PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnRElTUExBWUVEOiAnICsgX3RoaXMzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvNi5jY1JDTCA9IGZ1bmN0aW9uIGNjUkNMKCkge1xuICAgICAgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdSQ0wgLSBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nJyk7XG4gICAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gICAgfTtcbiAgICBfcHJvdG82LmNjQlMgPSBmdW5jdGlvbiBjY0JTKCkge1xuICAgICAgLy8gQmFja1NwYWNlXG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9URVhUJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvNi5jY0FPRiA9IGZ1bmN0aW9uIGNjQU9GKCkge1xuICAgICAgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9mZilcbiAgICB9O1xuICAgIF9wcm90bzYuY2NBT04gPSBmdW5jdGlvbiBjY0FPTigpIHtcbiAgICAgIC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgICB9O1xuICAgIF9wcm90bzYuY2NERVIgPSBmdW5jdGlvbiBjY0RFUigpIHtcbiAgICAgIC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9O1xuICAgIF9wcm90bzYuY2NSVSA9IGZ1bmN0aW9uIGNjUlUobnJSb3dzKSB7XG4gICAgICAvLyBSb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUlUoJyArIG5yUm93cyArICcpIC0gUm9sbCBVcCcpO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0Um9sbFVwUm93cyhuclJvd3MpO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY0ZPTiA9IGZ1bmN0aW9uIGNjRk9OKCkge1xuICAgICAgLy8gRmxhc2ggT25cbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtcbiAgICAgICAgZmxhc2g6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY1JEQyA9IGZ1bmN0aW9uIGNjUkRDKCkge1xuICAgICAgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdSREMgLSBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcnKTtcbiAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY1RSID0gZnVuY3Rpb24gY2NUUigpIHtcbiAgICAgIC8vIFRleHQgUmVzdGFydCBpbiB0ZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1RSJyk7XG4gICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY1JURCA9IGZ1bmN0aW9uIGNjUlREKCkge1xuICAgICAgLy8gUmVzdW1lIFRleHQgRGlzcGxheSBpbiBUZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JURCcpO1xuICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgICB9O1xuICAgIF9wcm90bzYuY2NFRE0gPSBmdW5jdGlvbiBjY0VETSgpIHtcbiAgICAgIC8vIEVyYXNlIERpc3BsYXllZCBNZW1vcnlcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgICB9O1xuICAgIF9wcm90bzYuY2NDUiA9IGZ1bmN0aW9uIGNjQ1IoKSB7XG4gICAgICAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gICAgfTtcbiAgICBfcHJvdG82LmNjRU5NID0gZnVuY3Rpb24gY2NFTk0oKSB7XG4gICAgICAvLyBFcmFzZSBOb24tRGlzcGxheWVkIE1lbW9yeVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB9O1xuICAgIF9wcm90bzYuY2NFT0MgPSBmdW5jdGlvbiBjY0VPQygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgLy8gRW5kIG9mIENhcHRpb24gKEZsaXAgTWVtb3JpZXMpXG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gJ0RJU1A6ICcgKyBfdGhpczQuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY1RPID0gZnVuY3Rpb24gY2NUTyhuckNvbHMpIHtcbiAgICAgIC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnVE8oJyArIG5yQ29scyArICcpIC0gVGFiIE9mZnNldCcpO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gICAgfTtcbiAgICBfcHJvdG82LmNjTUlEUk9XID0gZnVuY3Rpb24gY2NNSURST1coc2Vjb25kQnl0ZSkge1xuICAgICAgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgIGZsYXNoOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcbiAgICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuICAgICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgICB2YXIgY29sb3JJbmRleCA9IE1hdGguZmxvb3Ioc2Vjb25kQnl0ZSAvIDIpIC0gMHgxMDtcbiAgICAgICAgdmFyIGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnTUlEUk9XOiAnICsgc3RyaW5naWZ5KHN0eWxlcykpO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcbiAgICB9O1xuICAgIF9wcm90bzYub3V0cHV0RGF0YVVwZGF0ZSA9IGZ1bmN0aW9uIG91dHB1dERhdGFVcGRhdGUoZGlzcGF0Y2gpIHtcbiAgICAgIGlmIChkaXNwYXRjaCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRpc3BhdGNoID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG4gICAgICBpZiAodGltZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VlU3RhcnRUaW1lID09PSBudWxsICYmICF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAvLyBTdGFydCBvZiBhIG5ldyBjdWVcbiAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRpbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0aW1lLCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoICYmIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKSB7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSA/IG51bGwgOiB0aW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG82LmN1ZVNwbGl0QXRUaW1lID0gZnVuY3Rpb24gY3VlU3BsaXRBdFRpbWUodCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENlYTYwOENoYW5uZWw7XG4gIH0oKTsgLy8gV2lsbCBiZSAxIG9yIDIgd2hlbiBwYXJzaW5nIGNhcHRpb25zXG4gIHZhciBDZWE2MDhQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlYTYwOFBhcnNlcihmaWVsZCwgb3V0MSwgb3V0Mikge1xuICAgICAgdGhpcy5jaGFubmVscyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSAwO1xuICAgICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICAgICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgICB2YXIgbG9nZ2VyID0gdGhpcy5sb2dnZXIgPSBuZXcgQ2FwdGlvbnNMb2dnZXIoKTtcbiAgICAgIHRoaXMuY2hhbm5lbHMgPSBbbnVsbCwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQsIG91dDEsIGxvZ2dlciksIG5ldyBDZWE2MDhDaGFubmVsKGZpZWxkICsgMSwgb3V0MiwgbG9nZ2VyKV07XG4gICAgfVxuICAgIHZhciBfcHJvdG83ID0gQ2VhNjA4UGFyc2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG83LmdldEhhbmRsZXIgPSBmdW5jdGlvbiBnZXRIYW5kbGVyKGNoYW5uZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLmdldEhhbmRsZXIoKTtcbiAgICB9O1xuICAgIF9wcm90bzcuc2V0SGFuZGxlciA9IGZ1bmN0aW9uIHNldEhhbmRsZXIoY2hhbm5lbCwgbmV3SGFuZGxlcikge1xuICAgICAgdGhpcy5jaGFubmVsc1tjaGFubmVsXS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhIGZvciB0aW1lIHQgaW4gZm9ybXMgb2YgbGlzdCBvZiBieXRlcyAodW5zaWduZWQgaW50cykuIFRoZSBieXRlcyBhcmUgdHJlYXRlZCBhcyBwYWlycy5cbiAgICAgKi87XG4gICAgX3Byb3RvNy5hZGREYXRhID0gZnVuY3Rpb24gYWRkRGF0YSh0aW1lLCBieXRlTGlzdCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB0aGlzLmxvZ2dlci50aW1lID0gdGltZTtcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICB2YXIgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgICAgICB2YXIgYiA9IGJ5dGVMaXN0W2kgKyAxXSAmIDB4N2Y7XG4gICAgICAgICAgdmFyIGNtZEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGNoYXJzRm91bmQgPSBudWxsO1xuICAgICAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczUubG9nZ2VyLmxvZygzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSArICddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNtZEhpc3RvcnkgPSBfdGhpczUuY21kSGlzdG9yeTtcbiAgICAgICAgICB2YXIgaXNDb250cm9sQ29kZSA9IGEgPj0gMHgxMCAmJiBhIDw9IDB4MWY7XG4gICAgICAgICAgaWYgKGlzQ29udHJvbENvZGUpIHtcbiAgICAgICAgICAgIC8vIFNraXAgcmVkdW5kYW50IGNvbnRyb2wgY29kZXNcbiAgICAgICAgICAgIGlmIChoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSkge1xuICAgICAgICAgICAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIGNtZEhpc3RvcnkpO1xuICAgICAgICAgICAgICBfdGhpczUubG9nZ2VyLmxvZygzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TGFzdENtZChhLCBiLCBfdGhpczUuY21kSGlzdG9yeSk7XG4gICAgICAgICAgICBjbWRGb3VuZCA9IF90aGlzNS5wYXJzZUNtZChhLCBiKTtcbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgY21kRm91bmQgPSBfdGhpczUucGFyc2VNaWRyb3coYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgIGNtZEZvdW5kID0gX3RoaXM1LnBhcnNlUEFDKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICBjbWRGb3VuZCA9IF90aGlzNS5wYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIGNtZEhpc3RvcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICBjaGFyc0ZvdW5kID0gX3RoaXM1LnBhcnNlQ2hhcnMoYSwgYik7XG4gICAgICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgICAgICB2YXIgY3VyckNoTnIgPSBfdGhpczUuY3VycmVudENoYW5uZWw7XG4gICAgICAgICAgICAgIGlmIChjdXJyQ2hOciAmJiBjdXJyQ2hOciA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IF90aGlzNS5jaGFubmVsc1tjdXJyQ2hOcl07XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5pbnNlcnRDaGFycyhjaGFyc0ZvdW5kKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczUubG9nZ2VyLmxvZygyLCAnTm8gY2hhbm5lbCBmb3VuZCB5ZXQuIFRFWFQtTU9ERT8nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNtZEZvdW5kICYmICFjaGFyc0ZvdW5kKSB7XG4gICAgICAgICAgICBfdGhpczUubG9nZ2VyLmxvZygyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIkNvdWxkbid0IHBhcnNlIGNsZWFuZWQgZGF0YSBcIiArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyBvcmlnOiAnICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9yZXQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVMaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIF9yZXQgPSBfbG9vcChpKTtcbiAgICAgICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIENvbW1hbmQuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAgICovO1xuICAgIF9wcm90bzcucGFyc2VDbWQgPSBmdW5jdGlvbiBwYXJzZUNtZChhLCBiKSB7XG4gICAgICB2YXIgY29uZDEgPSAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFjIHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxZCkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZjtcbiAgICAgIHZhciBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIGIgPj0gMHgyMSAmJiBiIDw9IDB4MjM7XG4gICAgICBpZiAoIShjb25kMSB8fCBjb25kMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGNoTnIgPSBhID09PSAweDE0IHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxNyA/IDEgOiAyO1xuICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFjIHx8IGEgPT09IDB4MWQpIHtcbiAgICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMSkge1xuICAgICAgICAgIGNoYW5uZWwuY2NCUygpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcbiAgICAgICAgICBjaGFubmVsLmNjQU9GKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI0KSB7XG4gICAgICAgICAgY2hhbm5lbC5jY0RFUigpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcbiAgICAgICAgICBjaGFubmVsLmNjUlUoMik7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI3KSB7XG4gICAgICAgICAgY2hhbm5lbC5jY1JVKDQpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcbiAgICAgICAgICBjaGFubmVsLmNjRk9OKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJhKSB7XG4gICAgICAgICAgY2hhbm5lbC5jY1RSKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYikge1xuICAgICAgICAgIGNoYW5uZWwuY2NSVEQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJjKSB7XG4gICAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgICBjaGFubmVsLmNjQ1IoKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJlKSB7XG4gICAgICAgICAgY2hhbm5lbC5jY0VOTSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGEgPT0gMHgxNyB8fCBhID09IDB4MUZcbiAgICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSBjaE5yO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgbWlkcm93IHN0eWxpbmcgY29tbWFuZFxuICAgICAqLztcbiAgICBfcHJvdG83LnBhcnNlTWlkcm93ID0gZnVuY3Rpb24gcGFyc2VNaWRyb3coYSwgYikge1xuICAgICAgdmFyIGNoTnIgPSAwO1xuICAgICAgaWYgKChhID09PSAweDExIHx8IGEgPT09IDB4MTkpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmYpIHtcbiAgICAgICAgaWYgKGEgPT09IDB4MTEpIHtcbiAgICAgICAgICBjaE5yID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaE5yID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyZW50Q2hhbm5lbCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygwLCAnTWlzbWF0Y2ggY2hhbm5lbCBpbiBtaWRyb3cgcGFyc2luZycpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICAgKi87XG4gICAgX3Byb3RvNy5wYXJzZVBBQyA9IGZ1bmN0aW9uIHBhcnNlUEFDKGEsIGIpIHtcbiAgICAgIHZhciByb3c7XG4gICAgICB2YXIgY2FzZTEgPSAoYSA+PSAweDExICYmIGEgPD0gMHgxNyB8fCBhID49IDB4MTkgJiYgYSA8PSAweDFmKSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDdmO1xuICAgICAgdmFyIGNhc2UyID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgYiA+PSAweDQwICYmIGIgPD0gMHg1ZjtcbiAgICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgICAgaWYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NWYpIHtcbiAgICAgICAgcm93ID0gY2hOciA9PT0gMSA/IHJvd3NMb3dDaDFbYV0gOiByb3dzTG93Q2gyW2FdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgICAgcm93ID0gY2hOciA9PT0gMSA/IHJvd3NIaWdoQ2gxW2FdIDogcm93c0hpZ2hDaDJbYV07XG4gICAgICB9XG4gICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hhbm5lbC5zZXRQQUModGhpcy5pbnRlcnByZXRQQUMocm93LCBiKSk7XG4gICAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybnMgcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnNcbiAgICAgKi87XG4gICAgX3Byb3RvNy5pbnRlcnByZXRQQUMgPSBmdW5jdGlvbiBpbnRlcnByZXRQQUMocm93LCBfYnl0ZTMpIHtcbiAgICAgIHZhciBwYWNJbmRleDtcbiAgICAgIHZhciBwYWNEYXRhID0ge1xuICAgICAgICBjb2xvcjogbnVsbCxcbiAgICAgICAgaXRhbGljczogZmFsc2UsXG4gICAgICAgIGluZGVudDogbnVsbCxcbiAgICAgICAgdW5kZXJsaW5lOiBmYWxzZSxcbiAgICAgICAgcm93OiByb3dcbiAgICAgIH07XG4gICAgICBpZiAoX2J5dGUzID4gMHg1Zikge1xuICAgICAgICBwYWNJbmRleCA9IF9ieXRlMyAtIDB4NjA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWNJbmRleCA9IF9ieXRlMyAtIDB4NDA7XG4gICAgICB9XG4gICAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgICAgaWYgKHBhY0luZGV4IDw9IDB4ZCkge1xuICAgICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleCAvIDIpXTtcbiAgICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XG4gICAgICAgIHBhY0RhdGEuY29sb3IgPSAnd2hpdGUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFjRGF0YS5pbmRlbnQgPSBNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikgKiA0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhY0RhdGE7IC8vIE5vdGUgdGhhdCByb3cgaGFzIHplcm8gb2Zmc2V0LiBUaGUgc3BlYyB1c2VzIDEuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgY2hhcmFjdGVycy5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXG4gICAgICovO1xuICAgIF9wcm90bzcucGFyc2VDaGFycyA9IGZ1bmN0aW9uIHBhcnNlQ2hhcnMoYSwgYikge1xuICAgICAgdmFyIGNoYW5uZWxOcjtcbiAgICAgIHZhciBjaGFyQ29kZXMgPSBudWxsO1xuICAgICAgdmFyIGNoYXJDb2RlMSA9IG51bGw7XG4gICAgICBpZiAoYSA+PSAweDE5KSB7XG4gICAgICAgIGNoYW5uZWxOciA9IDI7XG4gICAgICAgIGNoYXJDb2RlMSA9IGEgLSA4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbm5lbE5yID0gMTtcbiAgICAgICAgY2hhckNvZGUxID0gYTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyQ29kZTEgPj0gMHgxMSAmJiBjaGFyQ29kZTEgPD0gMHgxMykge1xuICAgICAgICAvLyBTcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICB2YXIgb25lQ29kZTtcbiAgICAgICAgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMSkge1xuICAgICAgICAgIG9uZUNvZGUgPSBiICsgMHg1MDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgICBvbmVDb2RlID0gYiArIDB4NzA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiU3BlY2lhbCBjaGFyICdcIiArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgXCInIGluIGNoYW5uZWwgXCIgKyBjaGFubmVsTnI7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFyQ29kZXMgPSBbb25lQ29kZV07XG4gICAgICB9IGVsc2UgaWYgKGEgPj0gMHgyMCAmJiBhIDw9IDB4N2YpIHtcbiAgICAgICAgY2hhckNvZGVzID0gYiA9PT0gMCA/IFthXSA6IFthLCBiXTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyQ29kZXMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gJ0NoYXIgY29kZXMgPSAgJyArIG51bUFycmF5VG9IZXhBcnJheShjaGFyQ29kZXMpLmpvaW4oJywnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhckNvZGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGV4dGVuZGVkIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIG5ldyBmb3JlZ3JvdW5kIGNvbG9yIGJsYWNrLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuICAgICAqLztcbiAgICBfcHJvdG83LnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpIHtcbiAgICAgIHZhciBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiBiID49IDB4MmQgJiYgYiA8PSAweDJmO1xuICAgICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleDtcbiAgICAgIHZhciBia2dEYXRhID0ge307XG4gICAgICBpZiAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSB7XG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoYiAtIDB4MjApIC8gMik7XG4gICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcnNbaW5kZXhdO1xuICAgICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG4gICAgICAgIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgICAgYmtnRGF0YS51bmRlcmxpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgICAgY2hhbm5lbC5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXG4gICAgICovO1xuICAgIF9wcm90bzcucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT2JqZWN0LmtleXModGhpcy5jaGFubmVscykubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgIGNoYW5uZWwucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0TGFzdENtZChudWxsLCBudWxsLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAgICovO1xuICAgIF9wcm90bzcuY3VlU3BsaXRBdFRpbWUgPSBmdW5jdGlvbiBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgIGNoYW5uZWwuY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDZWE2MDhQYXJzZXI7XG4gIH0oKTtcbiAgZnVuY3Rpb24gc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KSB7XG4gICAgY21kSGlzdG9yeS5hID0gYTtcbiAgICBjbWRIaXN0b3J5LmIgPSBiO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpIHtcbiAgICByZXR1cm4gY21kSGlzdG9yeS5hID09PSBhICYmIGNtZEhpc3RvcnkuYiA9PT0gYjtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDbWRIaXN0b3J5KCkge1xuICAgIHJldHVybiB7XG4gICAgICBhOiBudWxsLFxuICAgICAgYjogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICAgKlxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICpcbiAgICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICpcbiAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICovXG5cbiAgdmFyIFZUVEN1ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdGlvbmFsU2VsZiAhPSBudWxsICYmIG9wdGlvbmFsU2VsZi5WVFRDdWUpIHtcbiAgICAgIHJldHVybiBzZWxmLlZUVEN1ZTtcbiAgICB9XG4gICAgdmFyIEFsbG93ZWREaXJlY3Rpb25zID0gWycnLCAnbHInLCAncmwnXTtcbiAgICB2YXIgQWxsb3dlZEFsaWdubWVudHMgPSBbJ3N0YXJ0JywgJ21pZGRsZScsICdlbmQnLCAnbGVmdCcsICdyaWdodCddO1xuICAgIGZ1bmN0aW9uIGlzQWxsb3dlZFZhbHVlKGFsbG93ZWQsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBuZWNlc3NhcnkgZm9yIGFzc3VyaW5nIHRoZSBnZW5lcmljIGNvbmZvcm1zIHRvIHRoZSBBcnJheSBpbnRlcmZhY2VcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhbGxvd2VkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyByZXNldCB0aGUgdHlwZSBzbyB0aGF0IHRoZSBuZXh0IG5hcnJvd2luZyB3b3JrcyB3ZWxsXG4gICAgICB2YXIgbGNWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAvLyB1c2UgdGhlIGFsbG93IGxpc3QgdG8gbmFycm93IHRoZSB0eXBlIHRvIGEgc3BlY2lmaWMgc3Vic2V0IG9mIHN0cmluZ3NcbiAgICAgIGlmICh+YWxsb3dlZC5pbmRleE9mKGxjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBsY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWREaXJlY3Rpb25zLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FsbG93ZWRWYWx1ZShBbGxvd2VkQWxpZ25tZW50cywgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHJlc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSAxO1xuICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29iaikge1xuICAgICAgICAgIG9ialtwXSA9IGNvYmpbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICAgIHZhciBjdWUgPSB0aGlzO1xuICAgICAgdmFyIGJhc2VPYmogPSB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAgICAgKiB0aGUgc3BlYy5cbiAgICAgICAqL1xuXG4gICAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgICAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAgICAgLy8gbGF6aWx5LlxuICAgICAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gICAgICAvKipcbiAgICAgICAqIFZUVEN1ZSBhbmQgVGV4dFRyYWNrQ3VlIHByb3BlcnRpZXNcbiAgICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgICAgICovXG5cbiAgICAgIHZhciBfaWQgPSAnJztcbiAgICAgIHZhciBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgICAgIHZhciBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgIHZhciBfdGV4dCA9IHRleHQ7XG4gICAgICB2YXIgX3JlZ2lvbiA9IG51bGw7XG4gICAgICB2YXIgX3ZlcnRpY2FsID0gJyc7XG4gICAgICB2YXIgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgICAgIHZhciBfbGluZSA9ICdhdXRvJztcbiAgICAgIHZhciBfbGluZUFsaWduID0gJ3N0YXJ0JztcbiAgICAgIHZhciBfcG9zaXRpb24gPSA1MDtcbiAgICAgIHZhciBfcG9zaXRpb25BbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgdmFyIF9zaXplID0gNTA7XG4gICAgICB2YXIgX2FsaWduID0gJ21pZGRsZSc7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnaWQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBfaWQgPSAnJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncGF1c2VPbkV4aXQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc3RhcnRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdGFydCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX2VuZFRpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZW5kVGltZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3RleHQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIF90ZXh0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgLy8gdG9kbzogaW1wbGVtZW50IFZUVFJlZ2lvbiBwb2x5ZmlsbD9cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWdpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3ZlcnRpY2FsJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfdmVydGljYWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYmVjYXVzZSB0aGUgc2V0dGluZyBhbiBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3ZlcnRpY2FsID0gc2V0dGluZztcbiAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzbmFwVG9MaW5lcycsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3NuYXBUb0xpbmVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9saW5lQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfcG9zaXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbkFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9wb3NpdGlvbkFsaWduID0gc2V0dGluZztcbiAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX2FsaWduO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2FsaWduID0gc2V0dGluZztcbiAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICAgKi9cblxuICAgICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gICAgICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZUVEN1ZSBtZXRob2RzXG4gICAgICovXG5cbiAgICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICAgICAgdmFyIFdlYlZUVCA9IHNlbGYuV2ViVlRUO1xuICAgICAgcmV0dXJuIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlKHNlbGYsIHRoaXMudGV4dCk7XG4gICAgfTtcbiAgICAvLyB0aGlzIGlzIGEgcG9seWZpbGwgaGFja1xuICAgIHJldHVybiBWVFRDdWU7XG4gIH0pKCk7XG5cbiAgLypcbiAgICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvZGlzdC92dHQuanNcbiAgICovXG5cbiAgdmFyIFN0cmluZ0RlY29kZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoKSB7fVxuICAgIHZhciBfcHJvdG8gPSBTdHJpbmdEZWNvZGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdEZWNvZGVyO1xuICB9KCk7IC8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG4gIGZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wKGlucHV0KSB7XG4gICAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMoaCwgbSwgcywgZikge1xuICAgICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIHBhcnNlRmxvYXQoZiB8fCAwKTtcbiAgICB9XG4gICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXig/OihcXGQrKTopPyhcXGR7Mn0pOihcXGR7Mn0pKFxcLlxcZCspPy8pO1xuICAgIGlmICghbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwYXJzZUZsb2F0KG1bMl0pID4gNTkpIHtcbiAgICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMl0sIG1bM10sIDAsIG1bNF0pO1xuICAgIH1cbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzIChvcHRpb25hbCldOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgbVszXSwgbVs0XSk7XG4gIH1cblxuICAvLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3RcbiAgLy8gYXNzaWdubWVudCB0byBhIHNwZWNpZmljIGtleS5cbiAgdmFyIFNldHRpbmdzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgdmFyIF9wcm90bzIgPSBTZXR0aW5ncy5wcm90b3R5cGU7XG4gICAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgICBfcHJvdG8yLnNldCA9IGZ1bmN0aW9uIHNldChrLCB2KSB7XG4gICAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAgIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgICA7XG4gICAgX3Byb3RvMi5nZXQgPSBmdW5jdGlvbiBnZXQoaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICAgIH1cbiAgICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gICAgO1xuICAgIF9wcm90bzIuaGFzID0gZnVuY3Rpb24gaGFzKGspIHtcbiAgICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICAgIH1cbiAgICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgICA7XG4gICAgX3Byb3RvMi5hbHQgPSBmdW5jdGlvbiBhbHQoaywgdiwgYSkge1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGlmICh2ID09PSBhW25dKSB7XG4gICAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICAgIDtcbiAgICBfcHJvdG8yLmludGVnZXIgPSBmdW5jdGlvbiBpbnRlZ2VyKGssIHYpIHtcbiAgICAgIGlmICgvXi0/XFxkKyQvLnRlc3QodikpIHtcbiAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gICAgO1xuICAgIF9wcm90bzIucGVyY2VudCA9IGZ1bmN0aW9uIHBlcmNlbnQoaywgdikge1xuICAgICAgaWYgKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvLnRlc3QodikpIHtcbiAgICAgICAgdmFyIF9wZXJjZW50ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgICAgaWYgKF9wZXJjZW50ID49IDAgJiYgX3BlcmNlbnQgPD0gMTAwKSB7XG4gICAgICAgICAgdGhpcy5zZXQoaywgX3BlcmNlbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gU2V0dGluZ3M7XG4gIH0oKTsgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuICAvLyBpbnRlcnByZXQgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG4gIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgICB2YXIgZ3JvdXBzID0gZ3JvdXBEZWxpbSA/IGlucHV0LnNwbGl0KGdyb3VwRGVsaW0pIDogW2lucHV0XTtcbiAgICBmb3IgKHZhciBpIGluIGdyb3Vwcykge1xuICAgICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0ga3ZbMF07XG4gICAgICB2YXIgdiA9IGt2WzFdO1xuICAgICAgY2FsbGJhY2soaywgdik7XG4gICAgfVxuICB9XG4gIHZhciBkZWZhdWx0cyA9IG5ldyBWVFRDdWUoMCwgMCwgJycpO1xuICAvLyAnbWlkZGxlJyB3YXMgY2hhbmdlZCB0byAnY2VudGVyJyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2dHQvcHVsbC8yNDRcbiAgLy8gIFNhZmFyaSBkb2Vzbid0IHlldCBzdXBwb3J0IHRoaXMgY2hhbmdlLCBidXQgRkYgYW5kIENocm9tZSBkby5cbiAgdmFyIGNlbnRlciA9IGRlZmF1bHRzLmFsaWduID09PSAnbWlkZGxlJyA/ICdtaWRkbGUnIDogJ2NlbnRlcic7XG4gIGZ1bmN0aW9uIHBhcnNlQ3VlKGlucHV0LCBjdWUsIHJlZ2lvbkxpc3QpIHtcbiAgICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgICB2YXIgb0lucHV0ID0gaW5wdXQ7XG4gICAgLy8gNC4xIFdlYlZUVCB0aW1lc3RhbXBcbiAgICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuICAgICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sICcnKTtcbiAgICAgIHJldHVybiB0cztcbiAgICB9XG5cbiAgICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gICAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICB2YXIgdmFscztcbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsncmwnLCAnbHInXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHNbMF0pO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSkpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KCdzbmFwVG9MaW5lcycsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzWzBdLCBbJ2F1dG8nXSk7XG4gICAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XG4gICAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdwb3NpdGlvbkFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsaW5lLWxlZnQnLCAnbGluZS1yaWdodCcsICdhdXRvJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvOi8sIC9cXHMvKTtcblxuICAgICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cbiAgICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgICAgY3VlLnZlcnRpY2FsID0gc2V0dGluZ3MuZ2V0KCd2ZXJ0aWNhbCcsICcnKTtcbiAgICAgIHZhciBsaW5lID0gc2V0dGluZ3MuZ2V0KCdsaW5lJywgJ2F1dG8nKTtcbiAgICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgICAgLy8gc2V0IG51bWVyaWMgbGluZSBudW1iZXIgZm9yIFNhZmFyaVxuICAgICAgICBsaW5lID0gLTE7XG4gICAgICB9XG4gICAgICBjdWUubGluZSA9IGxpbmU7XG4gICAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICAgIGN1ZS5zaXplID0gc2V0dGluZ3MuZ2V0KCdzaXplJywgMTAwKTtcbiAgICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5wb3NpdGlvbiA9PT0gNTApIHtcbiAgICAgICAgLy8gc2V0IG51bWVyaWMgcG9zaXRpb24gZm9yIFNhZmFyaVxuICAgICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgICAgfVxuICAgICAgY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgICB9XG5cbiAgICAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGlmIChpbnB1dC5zbGljZSgwLCAzKSAhPT0gJy0tPicpIHtcbiAgICAgIC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCAnLS0+J1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5ICctLT4nKTogXCIgKyBvSW5wdXQpO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpO1xuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY3VlLmVuZFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gICAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbiAgfVxuICBmdW5jdGlvbiBmaXhMaW5lQnJlYWtzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcbiAgfVxuICB2YXIgVlRUUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWVFRQYXJzZXIoKSB7XG4gICAgICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xuICAgICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG4gICAgICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbiAgICAgIHRoaXMuY3VlID0gbnVsbDtcbiAgICAgIHRoaXMub25jdWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLm9ucGFyc2luZ2Vycm9yID0gdm9pZCAwO1xuICAgICAgdGhpcy5vbmZsdXNoID0gdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvMyA9IFZUVFBhcnNlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvMy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXG4gICAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXG4gICAgICAgIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZShkYXRhLCB7XG4gICAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gX3RoaXMuYnVmZmVyO1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgYnVmZmVyID0gZml4TGluZUJyZWFrcyhidWZmZXIpO1xuICAgICAgICB3aGlsZSAocG9zIDwgYnVmZmVyLmxlbmd0aCAmJiBidWZmZXJbcG9zXSAhPT0gJ1xccicgJiYgYnVmZmVyW3Bvc10gIT09ICdcXG4nKSB7XG4gICAgICAgICAgKytwb3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmUgPSBidWZmZXIuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICArK3BvcztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5idWZmZXIgPSBidWZmZXIuc2xpY2UocG9zKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9XG5cbiAgICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgIC8vIHN3aXRjaCAoaykge1xuICAgICAgICAgIC8vIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXJzZSByZWdpb24nLCB2KTtcbiAgICAgICAgICAvLyBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH0sIC86Lyk7XG4gICAgICB9XG5cbiAgICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGxpbmUgPSAnJztcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChfdGhpcy5idWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICAgIC8vIHN0cmlwIG9mIFVURi04IEJPTSBpZiBhbnlcbiAgICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjVVRGLThcbiAgICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL14ow6/Cu8K/KT9XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgICBpZiAoIShtICE9IG51bGwgJiYgbVswXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0hFQURFUic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChfdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3QoX3RoaXMuYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChfdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdOT1RFJzpcbiAgICAgICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnTk9URSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbmV3IFZUVEN1ZSgwLCAwLCAnJyk7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRSc7XG4gICAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJy0tPicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ0NVRSc6XG4gICAgICAgICAgICAgIC8vIDQwIC0gQ29sbGVjdCBjdWUgdGltaW5ncyBhbmQgc2V0dGluZ3MuXG4gICAgICAgICAgICAgIGlmICghX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQkFEQ1VFJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIF90aGlzLmN1ZSwgX3RoaXMucmVnaW9uTGlzdCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRVRFWFQnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJ0NVRVRFWFQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xO1xuICAgICAgICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25jdWUgJiYgX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uY3VlKF90aGlzLmN1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAnQkFEQ1VFJzpcbiAgICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxuICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdDVUVURVhUJyAmJiBfdGhpcy5jdWUgJiYgX3RoaXMub25jdWUpIHtcbiAgICAgICAgICBfdGhpcy5vbmN1ZShfdGhpcy5jdWUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgICAvLyBhbm90aGVyIGV4Y2VwdGlvbiBvY2N1cnJlZCBzbyBlbnRlciBCQURDVUUgc3RhdGUuXG4gICAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90bzMuZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgLy8gX3RoaXMuYnVmZmVyICs9IF90aGlzLmRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgICBpZiAoX3RoaXMuY3VlIHx8IF90aGlzLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICAgIF90aGlzLmJ1ZmZlciArPSAnXFxuXFxuJztcbiAgICAgICAgICBfdGhpcy5wYXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cbiAgICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgICAvLyBsaW5lLlxuICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyB8fCBfdGhpcy5zdGF0ZSA9PT0gJ0JBRFdFQlZUVCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChfdGhpcy5vbnBhcnNpbmdlcnJvcikge1xuICAgICAgICAgIF90aGlzLm9ucGFyc2luZ2Vycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMub25mbHVzaCkge1xuICAgICAgICBfdGhpcy5vbmZsdXNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBWVFRQYXJzZXI7XG4gIH0oKTtcblxuICB2YXIgTElORUJSRUFLUyA9IC9cXHJcXG58XFxuXFxyfFxcbnxcXHIvZztcblxuICAvLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG4gIHZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBwb3NpdGlvbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xuICB9O1xuICB2YXIgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uIGN1ZVN0cmluZzJtaWxsaXModGltZVN0cmluZykge1xuICAgIHZhciB0cyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTMpKTtcbiAgICB2YXIgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTYsIC00KSk7XG4gICAgdmFyIG1pbnMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC05LCAtNykpO1xuICAgIHZhciBob3VycyA9IHRpbWVTdHJpbmcubGVuZ3RoID4gOSA/IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyaW5nKDAsIHRpbWVTdHJpbmcuaW5kZXhPZignOicpKSkgOiAwO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIodHMpIHx8ICFpc0Zpbml0ZU51bWJlcihzZWNzKSB8fCAhaXNGaW5pdGVOdW1iZXIobWlucykgfHwgIWlzRmluaXRlTnVtYmVyKGhvdXJzKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiBMb2NhbDpcIiArIHRpbWVTdHJpbmcpO1xuICAgIH1cbiAgICB0cyArPSAxMDAwICogc2VjcztcbiAgICB0cyArPSA2MCAqIDEwMDAgKiBtaW5zO1xuICAgIHRzICs9IDYwICogNjAgKiAxMDAwICogaG91cnM7XG4gICAgcmV0dXJuIHRzO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIGlkIGZvciBhIGN1ZSBiYXNlZCBvbiBzdGFydC9lbmQgdGltZXMgYW5kIHRleHQuXG4gIC8vIFRoaXMgaGVscHMgdGltZWxpbmUtY29udHJvbGxlciB0byBhdm9pZCBzaG93aW5nIHJlcGVhdGVkIGNhcHRpb25zLlxuICBmdW5jdGlvbiBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICAgIHJldHVybiBoYXNoKHN0YXJ0VGltZS50b1N0cmluZygpKSArIGhhc2goZW5kVGltZS50b1N0cmluZygpKSArIGhhc2godGV4dCk7XG4gIH1cbiAgdmFyIGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJDQyA9IHZ0dENDc1tjY107XG4gICAgdmFyIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgICAvLyBPZmZzZXQgPSBjdXJyZW50IGRpc2NvbnRpbnVpdHkgdGltZVxuICAgIGlmICghcHJldkNDIHx8ICFwcmV2Q0MubmV3ICYmIGN1cnJDQy5uZXcpIHtcbiAgICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlcmUgaGF2ZSBiZWVuIGRpc2NvbnRpbnVpdGllcyBzaW5jZSBjdWVzIHdlcmUgbGFzdCBwYXJzZWQuXG4gICAgLy8gT2Zmc2V0ID0gdGltZSBlbGFwc2VkXG4gICAgd2hpbGUgKChfcHJldkNDID0gcHJldkNDKSAhPSBudWxsICYmIF9wcmV2Q0MubmV3KSB7XG4gICAgICB2YXIgX3ByZXZDQztcbiAgICAgIHZ0dENDcy5jY09mZnNldCArPSBjdXJyQ0Muc3RhcnQgLSBwcmV2Q0Muc3RhcnQ7XG4gICAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgICBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XG4gICAgfVxuICAgIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lO1xuICB9O1xuICBmdW5jdGlvbiBwYXJzZVdlYlZUVCh2dHRCeXRlQXJyYXksIGluaXRQVFMsIHZ0dENDcywgY2MsIHRpbWVPZmZzZXQsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBWVFRQYXJzZXIoKTtcbiAgICAvLyBDb252ZXJ0IGJ5dGVBcnJheSBpbnRvIHN0cmluZywgcmVwbGFjaW5nIGFueSBzb21ld2hhdCBleG90aWMgbGluZWZlZWRzIHdpdGggXCJcXG5cIiwgdGhlbiBzcGxpdCBvbiB0aGF0IGNoYXJhY3Rlci5cbiAgICAvLyBVaW50OEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgaXMgbm90IGltcGxlbWVudGVkIGluIElFMTFcbiAgICB2YXIgdnR0TGluZXMgPSB1dGY4QXJyYXlUb1N0cihuZXcgVWludDhBcnJheSh2dHRCeXRlQXJyYXkpKS50cmltKCkucmVwbGFjZShMSU5FQlJFQUtTLCAnXFxuJykuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBjdWVzID0gW107XG4gICAgdmFyIGluaXQ5MGtIeiA9IGluaXRQVFMgPyB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZShpbml0UFRTLmJhc2VUaW1lLCBpbml0UFRTLnRpbWVzY2FsZSkgOiAwO1xuICAgIHZhciBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gICAgdmFyIHRpbWVzdGFtcE1hcE1QRUdUUyA9IDA7XG4gICAgdmFyIHRpbWVzdGFtcE1hcExPQ0FMID0gMDtcbiAgICB2YXIgcGFyc2luZ0Vycm9yO1xuICAgIHZhciBpbkhlYWRlciA9IHRydWU7XG4gICAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXG4gICAgICB2YXIgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICAgIHZhciBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzdWJ0aXRsZSBQVFMgb2Zmc2V0XG4gICAgICB2YXIgd2ViVnR0TXBlZ1RzTWFwT2Zmc2V0ID0gKHRpbWVzdGFtcE1hcE1QRUdUUyAtIGluaXQ5MGtIeikgLyA5MDAwMDtcblxuICAgICAgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcbiAgICAgIGlmIChjdXJyQ0MgIT0gbnVsbCAmJiBjdXJyQ0MubmV3KSB7XG4gICAgICAgIGlmICh0aW1lc3RhbXBNYXBMT0NBTCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod2ViVnR0TXBlZ1RzTWFwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghaW5pdFBUUykge1xuICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignTWlzc2luZyBpbml0UFRTIGZvciBWVFQgTVBFR1RTJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgTVBFR1RTLCBvZmZzZXQgPSBwcmVzZW50YXRpb24gdGltZSArIGRpc2NvbnRpbnVpdHkgb2Zmc2V0XG4gICAgICAgIGN1ZU9mZnNldCA9IHdlYlZ0dE1wZWdUc01hcE9mZnNldCAtIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQ7XG4gICAgICB9XG4gICAgICB2YXIgZHVyYXRpb24gPSBjdWUuZW5kVGltZSAtIGN1ZS5zdGFydFRpbWU7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gbm9ybWFsaXplUHRzKChjdWUuc3RhcnRUaW1lICsgY3VlT2Zmc2V0IC0gdGltZXN0YW1wTWFwTE9DQUwpICogOTAwMDAsIHRpbWVPZmZzZXQgKiA5MDAwMCkgLyA5MDAwMDtcbiAgICAgIGN1ZS5zdGFydFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUsIDApO1xuICAgICAgY3VlLmVuZFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUgKyBkdXJhdGlvbiwgMCk7XG5cbiAgICAgIC8vdHJpbSB0cmFpbGluZyB3ZWJ2dHQgYmxvY2sgd2hpdGVzcGFjZXNcbiAgICAgIHZhciB0ZXh0ID0gY3VlLnRleHQudHJpbSgpO1xuXG4gICAgICAvLyBGaXggZW5jb2Rpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQodGV4dCkpO1xuXG4gICAgICAvLyBJZiB0aGUgY3VlIHdhcyBub3QgYXNzaWduZWQgYW4gaWQgZnJvbSB0aGUgVlRUIGZpbGUgKGxpbmUgYWJvdmUgdGhlIGNvbnRlbnQpLCBjcmVhdGUgb25lLlxuICAgICAgaWYgKCFjdWUuaWQpIHtcbiAgICAgICAgY3VlLmlkID0gZ2VuZXJhdGVDdWVJZChjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgdGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAoY3VlLmVuZFRpbWUgPiAwKSB7XG4gICAgICAgIGN1ZXMucHVzaChjdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgICB9O1xuICAgIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBhcnNpbmdFcnJvcikge1xuICAgICAgICBlcnJvckNhbGxCYWNrKHBhcnNpbmdFcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxCYWNrKGN1ZXMpO1xuICAgIH07XG5cbiAgICAvLyBHbyB0aHJvdWdoIGNvbnRlbnRzIGxpbmUgYnkgbGluZS5cbiAgICB2dHRMaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAoaW5IZWFkZXIpIHtcbiAgICAgICAgLy8gTG9vayBmb3IgWC1USU1FU1RBTVAtTUFQIGluIGhlYWRlci5cbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgobGluZSwgJ1gtVElNRVNUQU1QLU1BUD0nKSkge1xuICAgICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgIC8vIEV4dHJhY3QgTE9DQUwgYW5kIE1QRUdUUy5cbiAgICAgICAgICBsaW5lLnNsaWNlKDE2KS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTE9DQUw6JykpIHtcbiAgICAgICAgICAgICAgY3VlVGltZSA9IHRpbWVzdGFtcC5zbGljZSg2KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdNUEVHVFM6JykpIHtcbiAgICAgICAgICAgICAgdGltZXN0YW1wTWFwTVBFR1RTID0gcGFyc2VJbnQodGltZXN0YW1wLnNsaWNlKDcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgICB0aW1lc3RhbXBNYXBMT0NBTCA9IGN1ZVN0cmluZzJtaWxsaXMoY3VlVGltZSkgLyAxMDAwO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHdpdGhvdXQgcGFyc2luZyBYLVRJTUVTVEFNUC1NQVAgbGluZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXG4gICAgICBwYXJzZXIucGFyc2UobGluZSArICdcXG4nKTtcbiAgICB9KTtcbiAgICBwYXJzZXIuZmx1c2goKTtcbiAgfVxuXG4gIHZhciBJTVNDMV9DT0RFQyA9ICdzdHBwLnR0bWwuaW0xdCc7XG5cbiAgLy8gVGltZSBmb3JtYXQ6IGg6bTpzOmZyYW1lcyguc3ViZnJhbWVzKVxuICB2YXIgSE1TRl9SRUdFWCA9IC9eKFxcZHsyLH0pOihcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pXFwuPyhcXGQrKT8kLztcblxuICAvLyBUaW1lIGZvcm1hdDogaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgZnJhbWVzLCB0aWNrc1xuICB2YXIgVElNRV9VTklUX1JFR0VYID0gL14oXFxkKig/OlxcLlxcZCopPykoaHxtfHN8bXN8Znx0KSQvO1xuICB2YXIgdGV4dEFsaWduVG9MaW5lQWxpZ24gPSB7XG4gICAgbGVmdDogJ3N0YXJ0JyxcbiAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgIHJpZ2h0OiAnZW5kJyxcbiAgICBzdGFydDogJ3N0YXJ0JyxcbiAgICBlbmQ6ICdlbmQnXG4gIH07XG4gIGZ1bmN0aW9uIHBhcnNlSU1TQzEocGF5bG9hZCwgaW5pdFBUUywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgICB2YXIgcmVzdWx0cyA9IGZpbmRCb3gobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIFsnbWRhdCddKTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGVycm9yQ2FsbEJhY2sobmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgSU1TQzEgbWRhdCcpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHR0bWxMaXN0ID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKG1kYXQpIHtcbiAgICAgIHJldHVybiB1dGY4QXJyYXlUb1N0cihtZGF0KTtcbiAgICB9KTtcbiAgICB2YXIgc3luY1RpbWUgPSB0b1RpbWVzY2FsZUZyb21TY2FsZShpbml0UFRTLmJhc2VUaW1lLCAxLCBpbml0UFRTLnRpbWVzY2FsZSk7XG4gICAgdHJ5IHtcbiAgICAgIHR0bWxMaXN0LmZvckVhY2goZnVuY3Rpb24gKHR0bWwpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxCYWNrKHBhcnNlVFRNTCh0dG1sLCBzeW5jVGltZSkpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVycm9yQ2FsbEJhY2soZXJyb3IpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXJzZVRUTUwodHRtbCwgc3luY1RpbWUpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgIHZhciB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHR0bWwsICd0ZXh0L3htbCcpO1xuICAgIHZhciB0dCA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHQnKVswXTtcbiAgICBpZiAoIXR0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHRtbCcpO1xuICAgIH1cbiAgICB2YXIgZGVmYXVsdFJhdGVJbmZvID0ge1xuICAgICAgZnJhbWVSYXRlOiAzMCxcbiAgICAgIHN1YkZyYW1lUmF0ZTogMSxcbiAgICAgIGZyYW1lUmF0ZU11bHRpcGxpZXI6IDAsXG4gICAgICB0aWNrUmF0ZTogMFxuICAgIH07XG4gICAgdmFyIHJhdGVJbmZvID0gT2JqZWN0LmtleXMoZGVmYXVsdFJhdGVJbmZvKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IHR0LmdldEF0dHJpYnV0ZShcInR0cDpcIiArIGtleSkgfHwgZGVmYXVsdFJhdGVJbmZvW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICB2YXIgdHJpbSA9IHR0LmdldEF0dHJpYnV0ZSgneG1sOnNwYWNlJykgIT09ICdwcmVzZXJ2ZSc7XG4gICAgdmFyIHN0eWxlRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnc3R5bGluZycsICdzdHlsZScpKTtcbiAgICB2YXIgcmVnaW9uRWxlbWVudHMgPSBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnbGF5b3V0JywgJ3JlZ2lvbicpKTtcbiAgICB2YXIgY3VlRWxlbWVudHMgPSBnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ2JvZHknLCAnW2JlZ2luXScpO1xuICAgIHJldHVybiBbXS5tYXAuY2FsbChjdWVFbGVtZW50cywgZnVuY3Rpb24gKGN1ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBjdWVUZXh0ID0gZ2V0VGV4dENvbnRlbnQoY3VlRWxlbWVudCwgdHJpbSk7XG4gICAgICBpZiAoIWN1ZVRleHQgfHwgIWN1ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdiZWdpbicpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXJ0VGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2JlZ2luJyksIHJhdGVJbmZvKTtcbiAgICAgIHZhciBkdXJhdGlvbiA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2R1cicpLCByYXRlSW5mbyk7XG4gICAgICB2YXIgZW5kVGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2VuZCcpLCByYXRlSW5mbyk7XG4gICAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IHRpbWVzdGFtcFBhcnNpbmdFcnJvcihjdWVFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRUaW1lID09PSBudWxsKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IHRpbWVzdGFtcFBhcnNpbmdFcnJvcihjdWVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgICB9XG4gICAgICB2YXIgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUgLSBzeW5jVGltZSwgZW5kVGltZSAtIHN5bmNUaW1lLCBjdWVUZXh0KTtcbiAgICAgIGN1ZS5pZCA9IGdlbmVyYXRlQ3VlSWQoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIGN1ZS50ZXh0KTtcbiAgICAgIHZhciByZWdpb24gPSByZWdpb25FbGVtZW50c1tjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgncmVnaW9uJyldO1xuICAgICAgdmFyIHN0eWxlID0gc3R5bGVFbGVtZW50c1tjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKV07XG5cbiAgICAgIC8vIEFwcGx5IHN0eWxlcyB0byBjdWVcbiAgICAgIHZhciBzdHlsZXMgPSBnZXRUdG1sU3R5bGVzKHJlZ2lvbiwgc3R5bGUsIHN0eWxlRWxlbWVudHMpO1xuICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlcy50ZXh0QWxpZ247XG4gICAgICBpZiAodGV4dEFsaWduKSB7XG4gICAgICAgIC8vIGN1ZS5wb3NpdGlvbkFsaWduIG5vdCBzZXR0YWJsZSBpbiBGRn4yMDE2XG4gICAgICAgIHZhciBsaW5lQWxpZ24gPSB0ZXh0QWxpZ25Ub0xpbmVBbGlnblt0ZXh0QWxpZ25dO1xuICAgICAgICBpZiAobGluZUFsaWduKSB7XG4gICAgICAgICAgY3VlLmxpbmVBbGlnbiA9IGxpbmVBbGlnbjtcbiAgICAgICAgfVxuICAgICAgICBjdWUuYWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICB9XG4gICAgICBfZXh0ZW5kcyhjdWUsIHN0eWxlcyk7XG4gICAgICByZXR1cm4gY3VlO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoY3VlKSB7XG4gICAgICByZXR1cm4gY3VlICE9PSBudWxsO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRDb2xsZWN0aW9uKGZyb21FbGVtZW50LCBwYXJlbnROYW1lLCBjaGlsZE5hbWUpIHtcbiAgICB2YXIgcGFyZW50ID0gZnJvbUVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUocGFyZW50TmFtZSlbMF07XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2hpbGROYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBmdW5jdGlvbiBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGVsZW1lbnRzV2l0aElkKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzV2l0aElkLnJlZHVjZShmdW5jdGlvbiAoZGljdCwgZWxlbWVudCkge1xuICAgICAgdmFyIGlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3htbDppZCcpO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGRpY3RbaWRdID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWN0O1xuICAgIH0sIHt9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRUZXh0Q29udGVudChlbGVtZW50LCB0cmltKSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoZWxlbWVudC5jaGlsZE5vZGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgbm9kZSwgaSkge1xuICAgICAgdmFyIF9ub2RlJGNoaWxkTm9kZXM7XG4gICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ2JyJyAmJiBpKSB7XG4gICAgICAgIHJldHVybiBzdHIgKyAnXFxuJztcbiAgICAgIH1cbiAgICAgIGlmICgoX25vZGUkY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcykgIT0gbnVsbCAmJiBfbm9kZSRjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZ2V0VGV4dENvbnRlbnQobm9kZSwgdHJpbSk7XG4gICAgICB9IGVsc2UgaWYgKHRyaW0pIHtcbiAgICAgICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIgKyBub2RlLnRleHRDb250ZW50O1xuICAgIH0sICcnKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRUdG1sU3R5bGVzKHJlZ2lvbiwgc3R5bGUsIHN0eWxlRWxlbWVudHMpIHtcbiAgICB2YXIgdHRzTnMgPSAnaHR0cDovL3d3dy53My5vcmcvbnMvdHRtbCNzdHlsaW5nJztcbiAgICB2YXIgcmVnaW9uU3R5bGUgPSBudWxsO1xuICAgIHZhciBzdHlsZUF0dHJpYnV0ZXMgPSBbJ2Rpc3BsYXlBbGlnbicsICd0ZXh0QWxpZ24nLCAnY29sb3InLCAnYmFja2dyb3VuZENvbG9yJywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknXG4gICAgLy8gJ2ZvbnRXZWlnaHQnLFxuICAgIC8vICdsaW5lSGVpZ2h0JyxcbiAgICAvLyAnd3JhcE9wdGlvbicsXG4gICAgLy8gJ2ZvbnRTdHlsZScsXG4gICAgLy8gJ2RpcmVjdGlvbicsXG4gICAgLy8gJ3dyaXRpbmdNb2RlJ1xuICAgIF07XG4gICAgdmFyIHJlZ2lvblN0eWxlTmFtZSA9IHJlZ2lvbiAhPSBudWxsICYmIHJlZ2lvbi5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykgPyByZWdpb24uZ2V0QXR0cmlidXRlKCdzdHlsZScpIDogbnVsbDtcbiAgICBpZiAocmVnaW9uU3R5bGVOYW1lICYmIHN0eWxlRWxlbWVudHMuaGFzT3duUHJvcGVydHkocmVnaW9uU3R5bGVOYW1lKSkge1xuICAgICAgcmVnaW9uU3R5bGUgPSBzdHlsZUVsZW1lbnRzW3JlZ2lvblN0eWxlTmFtZV07XG4gICAgfVxuICAgIHJldHVybiBzdHlsZUF0dHJpYnV0ZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZXMsIG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldEF0dHJpYnV0ZU5TKHN0eWxlLCB0dHNOcywgbmFtZSkgfHwgZ2V0QXR0cmlidXRlTlMocmVnaW9uLCB0dHNOcywgbmFtZSkgfHwgZ2V0QXR0cmlidXRlTlMocmVnaW9uU3R5bGUsIHR0c05zLCBuYW1lKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzdHlsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5TKGVsZW1lbnQsIG5zLCBuYW1lKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlTlMobnMsIG5hbWUpID8gZWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhucywgbmFtZSkgOiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHRpbWVzdGFtcFBhcnNpbmdFcnJvcihub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSB0dG1sIHRpbWVzdGFtcCBcIiArIG5vZGUpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVHRtbFRpbWUodGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbykge1xuICAgIGlmICghdGltZUF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNlY29uZHMgPSBwYXJzZVRpbWVTdGFtcCh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICAgIGlmIChzZWNvbmRzID09PSBudWxsKSB7XG4gICAgICBpZiAoSE1TRl9SRUdFWC50ZXN0KHRpbWVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgICAgc2Vjb25kcyA9IHBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKTtcbiAgICAgIH0gZWxzZSBpZiAoVElNRV9VTklUX1JFR0VYLnRlc3QodGltZUF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgICBzZWNvbmRzID0gcGFyc2VUaW1lVW5pdHModGltZUF0dHJpYnV0ZVZhbHVlLCByYXRlSW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWNvbmRzO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gICAgdmFyIG0gPSBITVNGX1JFR0VYLmV4ZWModGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgICB2YXIgZnJhbWVzID0gKG1bNF0gfCAwKSArIChtWzVdIHwgMCkgLyByYXRlSW5mby5zdWJGcmFtZVJhdGU7XG4gICAgcmV0dXJuIChtWzFdIHwgMCkgKiAzNjAwICsgKG1bMl0gfCAwKSAqIDYwICsgKG1bM10gfCAwKSArIGZyYW1lcyAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVRpbWVVbml0cyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gICAgdmFyIG0gPSBUSU1FX1VOSVRfUkVHRVguZXhlYyh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICAgIHZhciB2YWx1ZSA9IE51bWJlcihtWzFdKTtcbiAgICB2YXIgdW5pdCA9IG1bMl07XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICdoJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlICogMzYwMDtcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICByZXR1cm4gdmFsdWUgKiA2MDtcbiAgICAgIGNhc2UgJ21zJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlICogMTAwMDtcbiAgICAgIGNhc2UgJ2YnOlxuICAgICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby5mcmFtZVJhdGU7XG4gICAgICBjYXNlICd0JzpcbiAgICAgICAgcmV0dXJuIHZhbHVlIC8gcmF0ZUluZm8udGlja1JhdGU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHZhciBPdXRwdXRGaWx0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE91dHB1dEZpbHRlcih0aW1lbGluZUNvbnRyb2xsZXIsIHRyYWNrTmFtZSkge1xuICAgICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgICAgdGhpcy50cmFja05hbWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgICB0aGlzLmVuZFRpbWUgPSBudWxsO1xuICAgICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICAgICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgICB0aGlzLnRyYWNrTmFtZSA9IHRyYWNrTmFtZTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE91dHB1dEZpbHRlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRpc3BhdGNoQ3VlID0gZnVuY3Rpb24gZGlzcGF0Y2hDdWUoKSB7XG4gICAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4sIHRoaXMuY3VlUmFuZ2VzKTtcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5uZXdDdWUgPSBmdW5jdGlvbiBuZXdDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcbiAgICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmNyZWF0ZUNhcHRpb25zVHJhY2sodGhpcy50cmFja05hbWUpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE91dHB1dEZpbHRlcjtcbiAgfSgpO1xuXG4gIHZhciBUaW1lbGluZUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVsaW5lQ29udHJvbGxlcihobHMpIHtcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLkN1ZXMgPSB2b2lkIDA7XG4gICAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gdm9pZCAwO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gdm9pZCAwO1xuICAgICAgdGhpcy5sYXN0Q2MgPSAtMTtcbiAgICAgIC8vIExhc3QgdmlkZW8gKENFQS02MDgpIGZyYWdtZW50IENDXG4gICAgICB0aGlzLmxhc3RTbiA9IC0xO1xuICAgICAgLy8gTGFzdCB2aWRlbyAoQ0VBLTYwOCkgZnJhZ21lbnQgTVNOXG4gICAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSAtMTtcbiAgICAgIC8vIExhc3QgdmlkZW8gKENFQS02MDgpIGZyYWdtZW50IFBhcnQgSW5kZXhcbiAgICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgICAvLyBMYXN0IHN1YnRpdGxlIGZyYWdtZW50IENDXG4gICAgICB0aGlzLnZ0dENDcyA9IG5ld1ZUVENDcygpO1xuICAgICAgdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgIHRoaXMuQ3VlcyA9IGhscy5jb25maWcuY3VlSGFuZGxlcjtcbiAgICAgIHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0ge1xuICAgICAgICB0ZXh0VHJhY2sxOiB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxuICAgICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRUcmFjazI6IHtcbiAgICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwsXG4gICAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGVcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dFRyYWNrMzoge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazNMYWJlbCxcbiAgICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZVxuICAgICAgICB9LFxuICAgICAgICB0ZXh0VHJhY2s0OiB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhYmVsLFxuICAgICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkZSQUdfREVDUllQVEVELCB0aGlzLm9uRnJhZ0RlY3J5cHRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nVXNlcmRhdGEsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLU19DTEVBUkVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NDbGVhcmVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gdGhpcy5jb25maWcgPSB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMiA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIF9wcm90by5pbml0Q2VhNjA4UGFyc2VycyA9IGZ1bmN0aW9uIGluaXRDZWE2MDhQYXJzZXJzKCkge1xuICAgICAgdmFyIGNoYW5uZWwxID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMScpO1xuICAgICAgdmFyIGNoYW5uZWwyID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMicpO1xuICAgICAgdmFyIGNoYW5uZWwzID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMycpO1xuICAgICAgdmFyIGNoYW5uZWw0ID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrNCcpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gbmV3IENlYTYwOFBhcnNlcigxLCBjaGFubmVsMSwgY2hhbm5lbDIpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gbmV3IENlYTYwOFBhcnNlcigzLCBjaGFubmVsMywgY2hhbm5lbDQpO1xuICAgIH07XG4gICAgX3Byb3RvLmFkZEN1ZXMgPSBmdW5jdGlvbiBhZGRDdWVzKHRyYWNrTmFtZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4sIGN1ZVJhbmdlcykge1xuICAgICAgLy8gc2tpcCBjdWVzIHdoaWNoIG92ZXJsYXAgbW9yZSB0aGFuIDUwJSB3aXRoIHByZXZpb3VzbHkgcGFyc2VkIHRpbWUgcmFuZ2VzXG4gICAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gY3VlUmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgY3VlUmFuZ2UgPSBjdWVSYW5nZXNbaV07XG4gICAgICAgIHZhciBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICAgICAgaWYgKG92ZXJsYXAgPj0gMCkge1xuICAgICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XG4gICAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XG4gICAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob3ZlcmxhcCAvIChlbmRUaW1lIC0gc3RhcnRUaW1lKSA+IDAuNSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgICAgY3VlUmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIHRoaXMuQ3Vlcy5uZXdDdWUodHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdWVzID0gdGhpcy5DdWVzLm5ld0N1ZShudWxsLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgICAgdHlwZTogJ2NhcHRpb25zJyxcbiAgICAgICAgICBjdWVzOiBjdWVzLFxuICAgICAgICAgIHRyYWNrOiB0cmFja05hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gICAgO1xuICAgIF9wcm90by5vbkluaXRQdHNGb3VuZCA9IGZ1bmN0aW9uIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCBfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGZyYWcgPSBfcmVmLmZyYWcsXG4gICAgICAgIGlkID0gX3JlZi5pZCxcbiAgICAgICAgaW5pdFBUUyA9IF9yZWYuaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlID0gX3JlZi50aW1lc2NhbGUsXG4gICAgICAgIHRyYWNrSWQgPSBfcmVmLnRyYWNrSWQ7XG4gICAgICB2YXIgdW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncztcbiAgICAgIGlmIChpZCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgdHJhY2tJZDogdHJhY2tJZFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXG4gICAgICBpZiAodW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICAgIHVucGFyc2VkVnR0RnJhZ3MuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGlmIChfdGhpcy5pbml0UFRTW2RhdGEuZnJhZy5jY10pIHtcbiAgICAgICAgICAgIF90aGlzLm9uRnJhZ0xvYWRlZChFdmVudHMuRlJBR19MT0FERUQsIGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGZyYWc6IGRhdGEuZnJhZyxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignU3VidGl0bGUgZGlzY29udGludWl0eSBkb21haW4gZG9lcyBub3QgbWF0Y2ggbWFpbicpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldEV4aXN0aW5nVHJhY2sgPSBmdW5jdGlvbiBnZXRFeGlzdGluZ1RyYWNrKGxhYmVsLCBsYW5ndWFnZSkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgICBpZiAoY2FuUmV1c2VWdHRUZXh0VHJhY2sodGV4dFRyYWNrLCB7XG4gICAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICAgIGxhbmc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiAndHJhbnNjcmliZXMtc3Bva2VuLWRpYWxvZyxkZXNjcmliZXMtbXVzaWMtYW5kLXNvdW5kJ30pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlQ2FwdGlvbnNUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZUNhcHRpb25zVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVOYXRpdmVUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVRyYWNrKHRyYWNrTmFtZSkge1xuICAgICAgaWYgKHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY2FwdGlvbnNQcm9wZXJ0aWVzID0gdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMsXG4gICAgICAgIGNhcHRpb25zVHJhY2tzID0gdGhpcy5jYXB0aW9uc1RyYWNrcyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgdmFyIF9jYXB0aW9uc1Byb3BlcnRpZXMkdCA9IGNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdLFxuICAgICAgICBsYWJlbCA9IF9jYXB0aW9uc1Byb3BlcnRpZXMkdC5sYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlID0gX2NhcHRpb25zUHJvcGVydGllcyR0Lmxhbmd1YWdlQ29kZTtcbiAgICAgIC8vIEVuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgICAgdmFyIGV4aXN0aW5nVHJhY2sgPSB0aGlzLmdldEV4aXN0aW5nVHJhY2sobGFiZWwsIGxhbmd1YWdlQ29kZSk7XG4gICAgICBpZiAoIWV4aXN0aW5nVHJhY2spIHtcbiAgICAgICAgdmFyIHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsIGxhYmVsLCBsYW5ndWFnZUNvZGUpO1xuICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgLy8gU2V0IGEgc3BlY2lhbCBwcm9wZXJ0eSBvbiB0aGUgdHJhY2sgc28gd2Uga25vdyBpdCdzIG1hbmFnZWQgYnkgSGxzLmpzXG4gICAgICAgICAgdGV4dFRyYWNrW3RyYWNrTmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSBleGlzdGluZ1RyYWNrO1xuICAgICAgICBjbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgICBzZW5kQWRkVHJhY2tFdmVudChjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBtZWRpYSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlTm9uTmF0aXZlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVOb25OYXRpdmVUcmFjayh0cmFja05hbWUpIHtcbiAgICAgIGlmICh0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBhIHNpbmdsZSB0cmFjayBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICAgIHZhciB0cmFja1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgICAgaWYgKCF0cmFja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxhYmVsID0gdHJhY2tQcm9wZXJ0aWVzLmxhYmVsO1xuICAgICAgdmFyIHRyYWNrID0ge1xuICAgICAgICBfaWQ6IHRyYWNrTmFtZSxcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBraW5kOiAnY2FwdGlvbnMnLFxuICAgICAgICBkZWZhdWx0OiB0cmFja1Byb3BlcnRpZXMubWVkaWEgPyAhIXRyYWNrUHJvcGVydGllcy5tZWRpYS5kZWZhdWx0IDogZmFsc2UsXG4gICAgICAgIGNsb3NlZENhcHRpb25zOiB0cmFja1Byb3BlcnRpZXMubWVkaWFcbiAgICAgIH07XG4gICAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFjaztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgICAgdHJhY2tzOiBbdHJhY2tdXG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgIGlmICghZGF0YS5tZWRpYVNvdXJjZSkge1xuICAgICAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgdHJhbnNmZXJyaW5nTWVkaWEgPSAhIWRhdGEudHJhbnNmZXJNZWRpYTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgaWYgKHRyYW5zZmVycmluZ01lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3M7XG4gICAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgIGNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICAgIGRlbGV0ZSBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHZpZGVvIGZyYWdtZW50IChDRUEtNjA4KSBwYXJzaW5nXG4gICAgICB0aGlzLmxhc3RDYyA9IC0xO1xuICAgICAgdGhpcy5sYXN0U24gPSAtMTtcbiAgICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xO1xuICAgICAgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gc3VidGl0bGUgbWFuaWZlc3RzXG4gICAgICB0aGlzLnByZXZDQyA9IC0xO1xuICAgICAgdGhpcy52dHRDQ3MgPSBuZXdWVFRDQ3MoKTtcbiAgICAgIC8vIFJlc2V0IHRyYWNrc1xuICAgICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgICBpZiAodGhpcy5jZWE2MDhQYXJzZXIxICYmIHRoaXMuY2VhNjA4UGFyc2VyMikge1xuICAgICAgICB0aGlzLmNlYTYwOFBhcnNlcjEucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uX2NsZWFuVHJhY2tzID0gZnVuY3Rpb24gX2NsZWFuVHJhY2tzKCkge1xuICAgICAgLy8gY2xlYXIgb3V0ZGF0ZWQgc3VidGl0bGVzXG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKCFtZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGV4dFRyYWNrcyA9IG1lZGlhLnRleHRUcmFja3M7XG4gICAgICBpZiAodGV4dFRyYWNrcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRleHRUcmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgdHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcyB8fCBbXTtcbiAgICAgIHZhciBoYXNJTVNDMSA9IHRyYWNrcy5zb21lKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gdHJhY2sudGV4dENvZGVjID09PSBJTVNDMV9DT0RFQztcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVdlYlZUVCB8fCBoYXNJTVNDMSAmJiB0aGlzLmNvbmZpZy5lbmFibGVJTVNDMSkge1xuICAgICAgICB2YXIgbGlzdElzSWRlbnRpY2FsID0gc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRoaXMudHJhY2tzLCB0cmFja3MpO1xuICAgICAgICBpZiAobGlzdElzSWRlbnRpY2FsKSB7XG4gICAgICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICAgICAgdmFyIGluVXNlVHJhY2tzID0gbWVkaWEgPyBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhtZWRpYS50ZXh0VHJhY2tzKSA6IG51bGw7XG4gICAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2ssIGluZGV4KSB7XG4gICAgICAgICAgICAvLyBSZXVzZSB0cmFja3Mgd2l0aCB0aGUgc2FtZSBsYWJlbCBhbmQgbGFuZywgYnV0IGRvIG5vdCByZXVzZSA2MDgvNzA4IHRyYWNrc1xuICAgICAgICAgICAgdmFyIHRleHRUcmFjaztcbiAgICAgICAgICAgIGlmIChpblVzZVRyYWNrcykge1xuICAgICAgICAgICAgICB2YXIgaW5Vc2VUcmFjayA9IG51bGw7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5Vc2VUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Vc2VUcmFja3NbaV0gJiYgY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFja3NbaV0sIHRyYWNrKSkge1xuICAgICAgICAgICAgICAgICAgaW5Vc2VUcmFjayA9IGluVXNlVHJhY2tzW2ldO1xuICAgICAgICAgICAgICAgICAgaW5Vc2VUcmFja3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpblVzZVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdGV4dFRyYWNrID0gaW5Vc2VUcmFjaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRleHRUcmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdGV4dFRyYWNrS2luZCA9IGNhcHRpb25zT3JTdWJ0aXRsZXNGcm9tQ2hhcmFjdGVyaXN0aWNzKHRyYWNrKTtcbiAgICAgICAgICAgICAgdGV4dFRyYWNrID0gX3RoaXMyLmNyZWF0ZVRleHRUcmFjayh0ZXh0VHJhY2tLaW5kLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcbiAgICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICBfdGhpczIudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gV2FybiB3aGVuIHZpZGVvIGVsZW1lbnQgaGFzIGNhcHRpb25zIG9yIHN1YnRpdGxlIFRleHRUcmFja3MgY2FycmllZCBvdmVyIGZyb20gYW5vdGhlciBzb3VyY2VcbiAgICAgICAgICBpZiAoaW5Vc2VUcmFja3MgIT0gbnVsbCAmJiBpblVzZVRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB1bnVzZWRUZXh0VHJhY2tzID0gaW5Vc2VUcmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0ICE9PSBudWxsO1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0LmxhYmVsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodW51c2VkVGV4dFRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5obHMubG9nZ2VyLndhcm4oXCJNZWRpYSBlbGVtZW50IGNvbnRhaW5zIHVudXNlZCBzdWJ0aXRsZSB0cmFja3M6IFwiICsgdW51c2VkVGV4dFRyYWNrcy5qb2luKCcsICcpICsgXCIuIFJlcGxhY2UgbWVkaWEgZWxlbWVudCBmb3IgZWFjaCBzb3VyY2UgdG8gY2xlYXIgVGV4dFRyYWNrcyBhbmQgY2FwdGlvbnMgbWVudS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgdHJhY2tzIGZvciB0aGUgcHJvdmlkZXIgdG8gY29uc3VtZVxuICAgICAgICAgIHZhciB0cmFja3NMaXN0ID0gdGhpcy50cmFja3MubWFwKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbGFiZWw6IHRyYWNrLm5hbWUsXG4gICAgICAgICAgICAgIGtpbmQ6IHRyYWNrLnR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgZGVmYXVsdDogdHJhY2suZGVmYXVsdCxcbiAgICAgICAgICAgICAgc3VidGl0bGVUcmFjazogdHJhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCwge1xuICAgICAgICAgICAgdHJhY2tzOiB0cmFja3NMaXN0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGVkID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgJiYgZGF0YS5jYXB0aW9ucykge1xuICAgICAgICBkYXRhLmNhcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNhcHRpb25zVHJhY2spIHtcbiAgICAgICAgICB2YXIgaW5zdHJlYW1JZE1hdGNoID0gLyg/OkNDfFNFUlZJQ0UpKFsxLTRdKS8uZXhlYyhjYXB0aW9uc1RyYWNrLmluc3RyZWFtSWQpO1xuICAgICAgICAgIGlmICghaW5zdHJlYW1JZE1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0cmFja05hbWUgPSBcInRleHRUcmFja1wiICsgaW5zdHJlYW1JZE1hdGNoWzFdO1xuICAgICAgICAgIHZhciB0cmFja1Byb3BlcnRpZXMgPSBfdGhpczMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgICAgICAgaWYgKCF0cmFja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLmxhYmVsID0gY2FwdGlvbnNUcmFjay5uYW1lO1xuICAgICAgICAgIGlmIChjYXB0aW9uc1RyYWNrLmxhbmcpIHtcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsIGF0dHJpYnV0ZVxuICAgICAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLmxhbmd1YWdlQ29kZSA9IGNhcHRpb25zVHJhY2subGFuZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLm1lZGlhID0gY2FwdGlvbnNUcmFjaztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbCA9IGZ1bmN0aW9uIGNsb3NlZENhcHRpb25zRm9yTGV2ZWwoZnJhZykge1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgcmV0dXJuIGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5hdHRyc1snQ0xPU0VELUNBUFRJT05TJ107XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnTG9hZGluZyA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIC8vIGlmIHRoaXMgZnJhZyBpc24ndCBjb250aWd1b3VzLCBjbGVhciB0aGUgcGFyc2VyIHNvIGN1ZXMgd2l0aCBiYWQgc3RhcnQvZW5kIHRpbWVzIGFyZW4ndCBhZGRlZCB0byB0aGUgdGV4dFRyYWNrXG4gICAgICBpZiAodGhpcy5lbmFibGVkICYmIGRhdGEuZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICAgIHZhciBfZGF0YSRwYXJ0JGluZGV4LCBfZGF0YSRwYXJ0O1xuICAgICAgICB2YXIgY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMSxcbiAgICAgICAgICBjZWE2MDhQYXJzZXIyID0gdGhpcy5jZWE2MDhQYXJzZXIyLFxuICAgICAgICAgIGxhc3RTbiA9IHRoaXMubGFzdFNuO1xuICAgICAgICB2YXIgX2RhdGEkZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgICBjYyA9IF9kYXRhJGZyYWcuY2MsXG4gICAgICAgICAgc24gPSBfZGF0YSRmcmFnLnNuO1xuICAgICAgICB2YXIgcGFydEluZGV4ID0gKF9kYXRhJHBhcnQkaW5kZXggPSAoX2RhdGEkcGFydCA9IGRhdGEucGFydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJHBhcnQuaW5kZXgpICE9IG51bGwgPyBfZGF0YSRwYXJ0JGluZGV4IDogLTE7XG4gICAgICAgIGlmIChjZWE2MDhQYXJzZXIxICYmIGNlYTYwOFBhcnNlcjIpIHtcbiAgICAgICAgICBpZiAoc24gIT09IGxhc3RTbiArIDEgfHwgc24gPT09IGxhc3RTbiAmJiBwYXJ0SW5kZXggIT09IHRoaXMubGFzdFBhcnRJbmRleCArIDEgfHwgY2MgIT09IHRoaXMubGFzdENjKSB7XG4gICAgICAgICAgICBjZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICAgICAgICBjZWE2MDhQYXJzZXIyLnJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENjID0gY2M7XG4gICAgICAgIHRoaXMubGFzdFNuID0gc247XG4gICAgICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IHBhcnRJbmRleDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgc3VidGl0bGUgdHlwZSwgcGFyc2UgYXMgV2ViVlRULlxuICAgICAgICBpZiAocGF5bG9hZC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgICAgICAvLyBmcmFnbWVudCBhZnRlciBkZWNyeXB0aW9uIGhhcyBhIHN0YXRzIG9iamVjdFxuICAgICAgICAgIHZhciBkZWNyeXB0ZWQgPSAnc3RhdHMnIGluIGRhdGE7XG4gICAgICAgICAgLy8gSWYgdGhlIHN1YnRpdGxlcyBhcmUgbm90IGVuY3J5cHRlZCwgcGFyc2UgVlRUcyBub3cuIE90aGVyd2lzZSwgd2UgbmVlZCB0byB3YWl0LlxuICAgICAgICAgIGlmIChkZWNyeXB0RGF0YSA9PSBudWxsIHx8ICFkZWNyeXB0RGF0YS5lbmNyeXB0ZWQgfHwgZGVjcnlwdGVkKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tQbGF5bGlzdE1lZGlhID0gdGhpcy50cmFja3NbZnJhZy5sZXZlbF07XG4gICAgICAgICAgICB2YXIgdnR0Q0NzID0gdGhpcy52dHRDQ3M7XG4gICAgICAgICAgICBpZiAoIXZ0dENDc1tmcmFnLmNjXSkge1xuICAgICAgICAgICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZyYWcuc3RhcnQsXG4gICAgICAgICAgICAgICAgcHJldkNDOiB0aGlzLnByZXZDQyxcbiAgICAgICAgICAgICAgICBuZXc6IHRydWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdGhpcy5wcmV2Q0MgPSBmcmFnLmNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNrUGxheWxpc3RNZWRpYSAmJiB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID09PSBJTVNDMV9DT0RFQykge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VWVFRzKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHBheWxvYWQsIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRW1wdHkgc3VidGl0bGUgcGF5bG9hZCcpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5fcGFyc2VJTVNDMSA9IGZ1bmN0aW9uIF9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgcGFyc2VJTVNDMShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICAgIF90aGlzNC5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBmcmFnOiBmcmFnXG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGhscy5sb2dnZXIubG9nKFwiRmFpbGVkIHRvIHBhcnNlIElNU0MxOiBcIiArIGVycm9yKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5fcGFyc2VWVFRzID0gZnVuY3Rpb24gX3BhcnNlVlRUcyhkYXRhKSB7XG4gICAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQsXG4gICAgICAgIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcbiAgICAgIC8vIFdlIG5lZWQgYW4gaW5pdGlhbCBzeW5jaHJvbmlzYXRpb24gUFRTLiBTdG9yZSBmcmFnbWVudHMgYXMgbG9uZyBhcyBub25lIGhhcyBhcnJpdmVkXG4gICAgICB2YXIgaW5pdFBUUyA9IHRoaXMuaW5pdFBUUyxcbiAgICAgICAgdW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncztcbiAgICAgIHZhciBtYXhBdkNDID0gaW5pdFBUUy5sZW5ndGggLSAxO1xuICAgICAgaWYgKCFpbml0UFRTW2ZyYWcuY2NdICYmIG1heEF2Q0MgPT09IC0xKSB7XG4gICAgICAgIHVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxuICAgICAgdmFyIHBheWxvYWRXZWJWVFQgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSAhPSBudWxsICYmIF9mcmFnJGluaXRTZWdtZW50LmRhdGEgPyBhcHBlbmRVaW50OEFycmF5KGZyYWcuaW5pdFNlZ21lbnQuZGF0YSwgbmV3IFVpbnQ4QXJyYXkocGF5bG9hZCkpLmJ1ZmZlciA6IHBheWxvYWQ7XG4gICAgICBwYXJzZVdlYlZUVChwYXlsb2FkV2ViVlRULCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHRoaXMudnR0Q0NzLCBmcmFnLmNjLCBmcmFnLnN0YXJ0LCBmdW5jdGlvbiAoY3Vlcykge1xuICAgICAgICBfdGhpczUuX2FwcGVuZEN1ZXMoY3VlcywgZnJhZy5sZXZlbCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgZnJhZzogZnJhZ1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB2YXIgbWlzc2luZ0luaXRQVFMgPSBlcnJvci5tZXNzYWdlID09PSAnTWlzc2luZyBpbml0UFRTIGZvciBWVFQgTVBFR1RTJztcbiAgICAgICAgaWYgKG1pc3NpbmdJbml0UFRTKSB7XG4gICAgICAgICAgdW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzNS5fZmFsbGJhY2tUb0lNU0MxKGZyYWcsIHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcuIFRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIGZhbHNlLlxuICAgICAgICBobHMubG9nZ2VyLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiBcIiArIGVycm9yKTtcbiAgICAgICAgaWYgKG1pc3NpbmdJbml0UFRTICYmIG1heEF2Q0MgPiBmcmFnLmNjKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2ZhbGxiYWNrVG9JTVNDMSA9IGZ1bmN0aW9uIF9mYWxsYmFja1RvSU1TQzEoZnJhZywgcGF5bG9hZCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICAvLyBJZiB0ZXh0Q29kZWMgaXMgdW5rbm93biwgdHJ5IHBhcnNpbmcgYXMgSU1TQzEuIFNldCB0ZXh0Q29kZWMgYmFzZWQgb24gdGhlIHJlc3VsdFxuICAgICAgdmFyIHRyYWNrUGxheWxpc3RNZWRpYSA9IHRoaXMudHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgICAgaWYgKCF0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjKSB7XG4gICAgICAgIHBhcnNlSU1TQzEocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9IElNU0MxX0NPREVDO1xuICAgICAgICAgIF90aGlzNi5fcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSAnd3Z0dCc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl9hcHBlbmRDdWVzID0gZnVuY3Rpb24gX2FwcGVuZEN1ZXMoY3VlcywgZnJhZ0xldmVsKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAgIHZhciB0ZXh0VHJhY2sgPSB0aGlzLnRleHRUcmFja3NbZnJhZ0xldmVsXTtcbiAgICAgICAgLy8gV2ViVlRUUGFyc2VyLnBhcnNlIGlzIGFuIGFzeW5jIG1ldGhvZCBhbmQgaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IHRyYWNrIG1vZGUgaXMgc2V0IHRvIFwiZGlzYWJsZWRcIlxuICAgICAgICAvLyBiZWZvcmUgcGFyc2luZyBpcyBkb25lIHRoZW4gZG9uJ3QgdHJ5IHRvIGFjY2VzcyBjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkIGFzIGN1ZXMgd2lsbCBiZSBudWxsXG4gICAgICAgIC8vIGFuZCB0cnlpbmcgdG8gYWNjZXNzIGdldEN1ZUJ5SWQgbWV0aG9kIG9mIGN1ZXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gQmVjYXVzZSB3ZSBjaGVjayBpZiB0aGUgbW9kZSBpcyBkaXNhYmxlZCwgd2UgY2FuIGZvcmNlIGNoZWNrIGBjdWVzYCBiZWxvdy4gVGhleSBjYW4ndCBiZSBudWxsLlxuICAgICAgICBpZiAoIXRleHRUcmFjayB8fCB0ZXh0VHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdWVzLmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICAgIHJldHVybiBhZGRDdWVUb1RyYWNrKHRleHRUcmFjaywgY3VlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbZnJhZ0xldmVsXTtcbiAgICAgICAgaWYgKCFjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYWNrID0gY3VycmVudFRyYWNrLmRlZmF1bHQgPyAnZGVmYXVsdCcgOiAnc3VidGl0bGVzJyArIGZyYWdMZXZlbDtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgICAgdHlwZTogJ3N1YnRpdGxlcycsXG4gICAgICAgICAgY3VlczogY3VlcyxcbiAgICAgICAgICB0cmFjazogdHJhY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnRGVjcnlwdGVkID0gZnVuY3Rpb24gb25GcmFnRGVjcnlwdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICAgIHRoaXMub25GcmFnTG9hZGVkKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCgpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnUGFyc2luZ1VzZXJkYXRhID0gZnVuY3Rpb24gb25GcmFnUGFyc2luZ1VzZXJkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHNhbXBsZXMgPSBkYXRhLnNhbXBsZXM7XG4gICAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmIHRoaXMuY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbChmcmFnKSA9PT0gJ05PTkUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBldmVudCBjb250YWlucyBjYXB0aW9ucyAoZm91bmQgaW4gdGhlIGJ5dGVzIHByb3BlcnR5KSwgcHVzaCBhbGwgYnl0ZXMgaW50byB0aGUgcGFyc2VyIGltbWVkaWF0ZWx5XG4gICAgICAvLyBJdCB3aWxsIGNyZWF0ZSB0aGUgcHJvcGVyIHRpbWVzdGFtcHMgYmFzZWQgb24gdGhlIFBUUyB2YWx1ZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjY0J5dGVzID0gc2FtcGxlc1tpXS5ieXRlcztcbiAgICAgICAgaWYgKGNjQnl0ZXMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuY2VhNjA4UGFyc2VyMSkge1xuICAgICAgICAgICAgdGhpcy5pbml0Q2VhNjA4UGFyc2VycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoY2NCeXRlcyk7XG4gICAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxLmFkZERhdGEoc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXNbMF0pO1xuICAgICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMi5hZGREYXRhKHNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uQnVmZmVyRmx1c2hpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBfcmVmMikge1xuICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gX3JlZjIuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldCA9IF9yZWYyLmVuZE9mZnNldCxcbiAgICAgICAgZW5kT2Zmc2V0U3VidGl0bGVzID0gX3JlZjIuZW5kT2Zmc2V0U3VidGl0bGVzLFxuICAgICAgICB0eXBlID0gX3JlZjIudHlwZTtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhIHx8IG1lZGlhLmN1cnJlbnRUaW1lIDwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIDYwOCBjYXB0aW9uIGN1ZXMgZnJvbSB0aGUgY2FwdGlvbnMgVGV4dFRyYWNrcyB3aGVuIHRoZSB2aWRlbyBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgICAvLyBGb3J3YXJkIGN1ZXMgYXJlIG5ldmVyIHJlbW92ZWQgYmVjYXVzZSB3ZSBjYW4gbG9vc2Ugc3RyZWFtZWQgNjA4IGNvbnRlbnQgZnJvbSByZWNlbnQgZnJhZ21lbnRzXG4gICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICB2YXIgY2FwdGlvbnNUcmFja3MgPSB0aGlzLmNhcHRpb25zVHJhY2tzO1xuICAgICAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbW92ZUN1ZXNJblJhbmdlKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgLy8gQ2xlYXIgVlRUL0lNU0MxIHN1YnRpdGxlIGN1ZXMgZnJvbSB0aGUgc3VidGl0bGUgVGV4dFRyYWNrcyB3aGVuIHRoZSBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXRTdWJ0aXRsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciB0ZXh0VHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRleHRUcmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUN1ZXNJblJhbmdlKHRleHRUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5leHRyYWN0Q2VhNjA4RGF0YSA9IGZ1bmN0aW9uIGV4dHJhY3RDZWE2MDhEYXRhKGJ5dGVBcnJheSkge1xuICAgICAgdmFyIGFjdHVhbENDQnl0ZXMgPSBbW10sIFtdXTtcbiAgICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDB4MWY7XG4gICAgICB2YXIgcG9zaXRpb24gPSAyO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIHZhciB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgICB2YXIgY2NieXRlMSA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICAgIHZhciBjY2J5dGUyID0gMHg3ZiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKGNjYnl0ZTEgPT09IDAgJiYgY2NieXRlMiA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjY1ZhbGlkID0gKDB4MDQgJiB0bXBCeXRlKSAhPT0gMDsgLy8gU3VwcG9ydCBhbGwgZm91ciBjaGFubmVsc1xuICAgICAgICBpZiAoY2NWYWxpZCkge1xuICAgICAgICAgIHZhciBjY1R5cGUgPSAweDAzICYgdG1wQnl0ZTtcbiAgICAgICAgICBpZiAoMHgwMCAvKiBDRUE2MDggZmllbGQxKi8gPT09IGNjVHlwZSB8fCAweDAxIC8qIENFQTYwOCBmaWVsZDIqLyA9PT0gY2NUeXBlKSB7XG4gICAgICAgICAgICAvLyBFeGNsdWRlIENFQTcwOCBDQyBkYXRhLlxuICAgICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgICBhY3R1YWxDQ0J5dGVzW2NjVHlwZV0ucHVzaChjY2J5dGUyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVsaW5lQ29udHJvbGxlcjtcbiAgfSgpO1xuICBmdW5jdGlvbiBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyh0cmFjaykge1xuICAgIGlmICh0cmFjay5jaGFyYWN0ZXJpc3RpY3MpIHtcbiAgICAgIGlmICgvdHJhbnNjcmliZXMtc3Bva2VuLWRpYWxvZy9naS50ZXN0KHRyYWNrLmNoYXJhY3RlcmlzdGljcykgJiYgL2Rlc2NyaWJlcy1tdXNpYy1hbmQtc291bmQvZ2kudGVzdCh0cmFjay5jaGFyYWN0ZXJpc3RpY3MpKSB7XG4gICAgICAgIHJldHVybiAnY2FwdGlvbnMnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3N1YnRpdGxlcyc7XG4gIH1cbiAgZnVuY3Rpb24gY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFjaywgbWFuaWZlc3RUcmFjaykge1xuICAgIHJldHVybiAhIWluVXNlVHJhY2sgJiYgaW5Vc2VUcmFjay5raW5kID09PSBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyhtYW5pZmVzdFRyYWNrKSAmJiBzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayhtYW5pZmVzdFRyYWNrLCBpblVzZVRyYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3VlRUQ0NzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjY09mZnNldDogMCxcbiAgICAgIHByZXNlbnRhdGlvbk9mZnNldDogMCxcbiAgICAgIDA6IHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIHByZXZDQzogLTEsXG4gICAgICAgIG5ldzogdHJ1ZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgV0hJVEVTUEFDRV9DSEFSID0gL1xccy87XG4gIHZhciBDdWVzID0ge1xuICAgIG5ld0N1ZTogZnVuY3Rpb24gbmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciByb3c7XG4gICAgICAvLyB0aGUgdHlwZSBkYXRhIHN0YXRlcyB0aGlzIGlzIFZUVEN1ZSwgYnV0IGl0IGNhbiBwb3RlbnRpYWxseSBiZSBhIFRleHRUcmFja0N1ZSBvbiBvbGQgYnJvd3NlcnNcbiAgICAgIHZhciBjdWU7XG4gICAgICB2YXIgaW5kZW50aW5nO1xuICAgICAgdmFyIGluZGVudDtcbiAgICAgIHZhciB0ZXh0O1xuICAgICAgdmFyIEN1ZSA9IHNlbGYuVlRUQ3VlIHx8IHNlbGYuVGV4dFRyYWNrQ3VlO1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspIHtcbiAgICAgICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgICAgICBpbmRlbnRpbmcgPSB0cnVlO1xuICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgIGlmICghcm93LmlzRW1wdHkoKSkge1xuICAgICAgICAgIHZhciBfdHJhY2skY3VlcztcbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHJvdy5jaGFycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgaWYgKFdISVRFU1BBQ0VfQ0hBUi50ZXN0KHJvdy5jaGFyc1tjXS51Y2hhcikgJiYgaW5kZW50aW5nKSB7XG4gICAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGV4dCArPSByb3cuY2hhcnNbY10udWNoYXI7XG4gICAgICAgICAgICAgIGluZGVudGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUbyBiZSB1c2VkIGZvciBjbGVhbmluZy11cCBvcnBoYW5lZCByb2xsLXVwIGNhcHRpb25zXG4gICAgICAgICAgcm93LmN1ZVN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcblxuICAgICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG4gICAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgICAgZW5kVGltZSArPSAwLjAwMDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRlbnQgPj0gMTYpIHtcbiAgICAgICAgICAgIGluZGVudC0tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1ZVRleHQgPSBmaXhMaW5lQnJlYWtzKHRleHQudHJpbSgpKTtcbiAgICAgICAgICB2YXIgaWQgPSBnZW5lcmF0ZUN1ZUlkKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIGN1ZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgdHJhY2sgZG8gbm90IHB1c2ggaXRcbiAgICAgICAgICBpZiAoISh0cmFjayAhPSBudWxsICYmIChfdHJhY2skY3VlcyA9IHRyYWNrLmN1ZXMpICE9IG51bGwgJiYgX3RyYWNrJGN1ZXMuZ2V0Q3VlQnlJZChpZCkpKSB7XG4gICAgICAgICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgY3VlVGV4dCk7XG4gICAgICAgICAgICBjdWUuaWQgPSBpZDtcbiAgICAgICAgICAgIGN1ZS5saW5lID0gciArIDE7XG4gICAgICAgICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAvLyBDbGFtcCB0aGUgcG9zaXRpb24gYmV0d2VlbiAxMCBhbmQgODAgcGVyY2VudCAoQ0VBLTYwOCBQQUMgaW5kZW50IGNvZGUpXG4gICAgICAgICAgICAvLyBodHRwczovL2R2Y3MudzMub3JnL2hnL3RleHQtdHJhY2tzL3Jhdy1maWxlL2RlZmF1bHQvNjA4dG9WVFQvNjA4dG9WVFQuaHRtbCNwb3NpdGlvbmluZy1pbi1jZWEtNjA4XG4gICAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gYW5kIGNhcHRpb25zIGJyZWFrIHdpdGggb3V0IG9mIGJvdW5kcyAwLTEwMCB2YWx1ZXNcbiAgICAgICAgICAgIGN1ZS5wb3NpdGlvbiA9IDEwICsgTWF0aC5taW4oODAsIE1hdGguZmxvb3IoaW5kZW50ICogOCAvIDMyKSAqIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHJhY2sgJiYgcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAvLyBTb3J0IGJvdHRvbSBjdWVzIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCB0aGV5IHJlbmRlciBpbiBsaW5lIG9yZGVyIHdoZW4gb3ZlcmxhcHBpbmcgaW4gQ2hyb21lXG4gICAgICAgIHJlc3VsdC5zb3J0KGZ1bmN0aW9uIChjdWVBLCBjdWVCKSB7XG4gICAgICAgICAgaWYgKGN1ZUEubGluZSA9PT0gJ2F1dG8nIHx8IGN1ZUIubGluZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1ZUEubGluZSA+IDggJiYgY3VlQi5saW5lID4gOCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1ZUIubGluZSAtIGN1ZUEubGluZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGN1ZUEubGluZSAtIGN1ZUIubGluZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgICByZXR1cm4gYWRkQ3VlVG9UcmFjayh0cmFjaywgY3VlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBmZXRjaFN1cHBvcnRlZCgpIHtcbiAgICBpZiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNlbGYuZmV0Y2ggJiYgc2VsZi5BYm9ydENvbnRyb2xsZXIgJiYgc2VsZi5SZWFkYWJsZVN0cmVhbSAmJiBzZWxmLlJlcXVlc3QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBzZWxmLlJlYWRhYmxlU3RyZWFtKHt9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIG5vb3AgKi9cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBCWVRFUkFOR0UgPSAvKFxcZCspLShcXGQrKVxcLyhcXGQrKS87XG4gIHZhciBGZXRjaExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmV0Y2hMb2FkZXIoY29uZmlnKSB7XG4gICAgICB0aGlzLmZldGNoU2V0dXAgPSB2b2lkIDA7XG4gICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgICAgdGhpcy5jb250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhdHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgICB0aGlzLmZldGNoU2V0dXAgPSBjb25maWcuZmV0Y2hTZXR1cCB8fCBnZXRSZXF1ZXN0O1xuICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3IHNlbGYuQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRmV0Y2hMb2FkZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMubG9hZGVyID0gdGhpcy5jYWxsYmFja3MgPSB0aGlzLmNvbnRleHQgPSB0aGlzLmNvbmZpZyA9IHRoaXMucmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5mZXRjaFNldHVwID0gdGhpcy5jb250cm9sbGVyID0gdGhpcy5zdGF0cyA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uYWJvcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgICBpZiAodGhpcy5jb250cm9sbGVyICYmICF0aGlzLnN0YXRzLmxvYWRpbmcuZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzO1xuICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPSBudWxsICYmIF90aGlzJGNhbGxiYWNrcy5vbkFib3J0KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICBpZiAoc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgICB9XG4gICAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHZhciBpbml0UGFyYW1zID0gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dCwgdGhpcy5jb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xuICAgICAgdmFyIExFTkdUSCA9IGlzQXJyYXlCdWZmZXIgPyAnYnl0ZUxlbmd0aCcgOiAnbGVuZ3RoJztcbiAgICAgIHZhciBfY29uZmlnJGxvYWRQb2xpY3kgPSBjb25maWcubG9hZFBvbGljeSxcbiAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXMgPSBfY29uZmlnJGxvYWRQb2xpY3kubWF4VGltZVRvRmlyc3RCeXRlTXMsXG4gICAgICAgIG1heExvYWRUaW1lTXMgPSBfY29uZmlnJGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5mZXRjaFNldHVwKGNvbnRleHQsIGluaXRQYXJhbXMpO1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBjb25maWcudGltZW91dCA9IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIGlzRmluaXRlTnVtYmVyKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zIDogbWF4TG9hZFRpbWVNcztcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgICAgX3RoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICAgIF90aGlzLmNhbGxiYWNrcy5vblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIF90aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgdmFyIGZldGNoUHJvbWlzZSA9IGlzUHJvbWlzZSh0aGlzLnJlcXVlc3QpID8gdGhpcy5yZXF1ZXN0LnRoZW4oc2VsZi5mZXRjaCkgOiBzZWxmLmZldGNoKHRoaXMucmVxdWVzdCk7XG4gICAgICBmZXRjaFByb21pc2UudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzJGNhbGxiYWNrczI7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gX3RoaXMubG9hZGVyID0gcmVzcG9uc2U7XG4gICAgICAgIHZhciBmaXJzdCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgICAgICBzZWxmLmNsZWFyVGltZW91dChfdGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIGNvbmZpZy50aW1lb3V0ID0gbWF4TG9hZFRpbWVNcztcbiAgICAgICAgX3RoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIF90aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgICAgICAgIF90aGlzLmNhbGxiYWNrcy5vblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIF90aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG1heExvYWRUaW1lTXMgLSAoZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB2YXIgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXR1c1RleHQ7XG4gICAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3Ioc3RhdHVzVGV4dCB8fCAnZmV0Y2gsIGJhZCBuZXR3b3JrIHJlc3BvbnNlJywgc3RhdHVzLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IGZpcnN0O1xuICAgICAgICBzdGF0cy50b3RhbCA9IGdldENvbnRlbnRMZW5ndGgocmVzcG9uc2UuaGVhZGVycykgfHwgc3RhdHMudG90YWw7XG4gICAgICAgIHZhciBvblByb2dyZXNzID0gKF90aGlzJGNhbGxiYWNrczIgPSBfdGhpcy5jYWxsYmFja3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjYWxsYmFja3MyLm9uUHJvZ3Jlc3M7XG4gICAgICAgIGlmIChvblByb2dyZXNzICYmIGlzRmluaXRlTnVtYmVyKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5sb2FkUHJvZ3Jlc3NpdmVseShyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIGNvbmZpZy5oaWdoV2F0ZXJNYXJrLCBvblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VEYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyRjYWxsYmFja3MzLCBfdGhpcyRjYWxsYmFja3M0O1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBfdGhpcy5yZXNwb25zZTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbG9hZGVyIGRlc3Ryb3llZCcpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KF90aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgdmFyIHRvdGFsID0gcmVzcG9uc2VEYXRhW0xFTkdUSF07XG4gICAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvYWRlclJlc3BvbnNlID0ge1xuICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uUHJvZ3Jlc3MgPSAoX3RoaXMkY2FsbGJhY2tzMyA9IF90aGlzLmNhbGxiYWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNhbGxiYWNrczMub25Qcm9ncmVzcztcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgIWlzRmluaXRlTnVtYmVyKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIHJlc3BvbnNlRGF0YSwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIChfdGhpcyRjYWxsYmFja3M0ID0gX3RoaXMuY2FsbGJhY2tzKSA9PSBudWxsIHx8IF90aGlzJGNhbGxiYWNrczQub25TdWNjZXNzKGxvYWRlclJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgcmVzcG9uc2UpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyRjYWxsYmFja3M1O1xuICAgICAgICBzZWxmLmNsZWFyVGltZW91dChfdGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENPUlMgZXJyb3JzIHJlc3VsdCBpbiBhbiB1bmRlZmluZWQgY29kZS4gU2V0IGl0IHRvIDAgaGVyZSB0byBhbGlnbiB3aXRoIFhIUidzIGJlaGF2aW9yXG4gICAgICAgIC8vIHdoZW4gZGVzdHJveWluZywgJ2Vycm9yJyBpdHNlbGYgY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICB2YXIgY29kZSA9ICFlcnJvciA/IDAgOiBlcnJvci5jb2RlIHx8IDA7XG4gICAgICAgIHZhciB0ZXh0ID0gIWVycm9yID8gbnVsbCA6IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgIChfdGhpcyRjYWxsYmFja3M1ID0gX3RoaXMuY2FsbGJhY2tzKSA9PSBudWxsIHx8IF90aGlzJGNhbGxiYWNrczUub25FcnJvcih7XG4gICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH0sIGNvbnRleHQsIGVycm9yID8gZXJyb3IuZGV0YWlscyA6IG51bGwsIHN0YXRzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmdldENhY2hlQWdlID0gZnVuY3Rpb24gZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBhZ2VIZWFkZXIgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdhZ2UnKTtcbiAgICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNwb25zZSA/IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSkgOiBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRQcm9ncmVzc2l2ZWx5ID0gZnVuY3Rpb24gbG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBoaWdoV2F0ZXJNYXJrLCBvblByb2dyZXNzKSB7XG4gICAgICBpZiAoaGlnaFdhdGVyTWFyayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGhpZ2hXYXRlck1hcmsgPSAwO1xuICAgICAgfVxuICAgICAgdmFyIGNodW5rQ2FjaGUgPSBuZXcgQ2h1bmtDYWNoZSgpO1xuICAgICAgdmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICB2YXIgX3B1bXAgPSBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGEuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCkuYnVmZmVyLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjaHVuayA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBzdGF0cy5sb2FkZWQgKz0gbGVuO1xuICAgICAgICAgIGlmIChsZW4gPCBoaWdoV2F0ZXJNYXJrIHx8IGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgY2h1bmsgaXMgdG9vIHNtYWxsIHRvIHRvIGJlIGVtaXR0ZWQgb3IgdGhlIGNhY2hlIGFscmVhZHkgaGFzIGRhdGFcbiAgICAgICAgICAgIC8vIFB1c2ggaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgICAgICBjaHVua0NhY2hlLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCA+PSBoaWdoV2F0ZXJNYXJrKSB7XG4gICAgICAgICAgICAgIC8vIGZsdXNoIGluIG9yZGVyIHRvIGpvaW4gdGhlIHR5cGVkIGFycmF5c1xuICAgICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCkuYnVmZmVyLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm90aGluZyBjYWNoZWQgYWxyZWFkeSwgYW5kIHRoZSBjaGFjaGUgaXMgbGFyZ2UgZW5vdWdoXG4gICAgICAgICAgICAvLyBqdXN0IGVtaXQgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVuay5idWZmZXIsIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9wdW1wKCk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvKiBhYm9ydGVkICovXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfcHVtcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEZldGNoTG9hZGVyO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHNpZ25hbCkge1xuICAgIHZhciBpbml0UGFyYW1zID0ge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgc2lnbmFsOiBzaWduYWwsXG4gICAgICBoZWFkZXJzOiBuZXcgc2VsZi5IZWFkZXJzKF9leHRlbmRzKHt9LCBjb250ZXh0LmhlYWRlcnMpKVxuICAgIH07XG4gICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICAgIGluaXRQYXJhbXMuaGVhZGVycy5zZXQoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyBTdHJpbmcoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRQYXJhbXM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Qnl0ZVJhbmdlTGVuZ3RoKGJ5dGVSYW5nZUhlYWRlcikge1xuICAgIHZhciByZXN1bHQgPSBCWVRFUkFOR0UuZXhlYyhieXRlUmFuZ2VIZWFkZXIpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChyZXN1bHRbMl0pIC0gcGFyc2VJbnQocmVzdWx0WzFdKSArIDE7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldENvbnRlbnRMZW5ndGgoaGVhZGVycykge1xuICAgIHZhciBjb250ZW50UmFuZ2UgPSBoZWFkZXJzLmdldCgnQ29udGVudC1SYW5nZScpO1xuICAgIGlmIChjb250ZW50UmFuZ2UpIHtcbiAgICAgIHZhciBieXRlUmFuZ2VMZW5ndGggPSBnZXRCeXRlUmFuZ2VMZW5ndGgoY29udGVudFJhbmdlKTtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihieXRlUmFuZ2VMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBieXRlUmFuZ2VMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmVxdWVzdChjb250ZXh0LCBpbml0UGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBzZWxmLlJlcXVlc3QoY29udGV4dC51cmwsIGluaXRQYXJhbXMpO1xuICB9XG4gIHZhciBGZXRjaEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgICBmdW5jdGlvbiBGZXRjaEVycm9yKG1lc3NhZ2UsIGNvZGUsIGRldGFpbHMpIHtcbiAgICAgIHZhciBfdGhpczI7XG4gICAgICBfdGhpczIgPSBfRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgX3RoaXMyLmNvZGUgPSB2b2lkIDA7XG4gICAgICBfdGhpczIuZGV0YWlscyA9IHZvaWQgMDtcbiAgICAgIF90aGlzMi5jb2RlID0gY29kZTtcbiAgICAgIF90aGlzMi5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKEZldGNoRXJyb3IsIF9FcnJvcik7XG4gICAgcmV0dXJuIEZldGNoRXJyb3I7XG4gIH0oLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuICB2YXIgQUdFX0hFQURFUl9MSU5FX1JFR0VYID0gL15hZ2U6XFxzKltcXGQuXStcXHMqJC9pbTtcbiAgdmFyIFhockxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGhyTG9hZGVyKGNvbmZpZykge1xuICAgICAgdGhpcy54aHJTZXR1cCA9IHZvaWQgMDtcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMucmV0cnlEZWxheSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgICB0aGlzLnN0YXRzID0gdm9pZCAwO1xuICAgICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZyA/IGNvbmZpZy54aHJTZXR1cCB8fCBudWxsIDogbnVsbDtcbiAgICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgICB0aGlzLnJldHJ5RGVsYXkgPSAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gWGhyTG9hZGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLnhoclNldHVwID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5hYm9ydEludGVybmFsID0gZnVuY3Rpb24gYWJvcnRJbnRlcm5hbCgpIHtcbiAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgbG9hZGVyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICBpZiAobG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHZhciBfdGhpcyRjYWxsYmFja3M7XG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIGlmICgoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpICE9IG51bGwgJiYgX3RoaXMkY2FsbGJhY2tzLm9uQWJvcnQpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgaWYgKHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRJbnRlcm5hbCA9IGZ1bmN0aW9uIGxvYWRJbnRlcm5hbCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICBpZiAoIWNvbmZpZyB8fCAhY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgc2VsZi5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSAwO1xuICAgICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICAgIHN0YXRzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XG4gICAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLmxvYWRlciAhPT0geGhyIHx8IF90aGlzLnN0YXRzLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmIChfdGhpcy5sb2FkZXIgIT09IHhociB8fCBfdGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5sb2FkZXIgIT09IHhociB8fCBfdGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgX3RoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzMjtcbiAgICAgICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICAgICAgKF90aGlzJGNhbGxiYWNrczIgPSBfdGhpcy5jYWxsYmFja3MpID09IG51bGwgfHwgX3RoaXMkY2FsbGJhY2tzMi5vbkVycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IHhoci5zdGF0dXMsXG4gICAgICAgICAgICB0ZXh0OiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfSwgY29udGV4dCwgeGhyLCBzdGF0cyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9wZW5BbmRTZW5kWGhyID0gZnVuY3Rpb24gb3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpIHtcbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoZWFkZXJzID0gY29udGV4dC5oZWFkZXJzO1xuICAgICAgdmFyIF9jb25maWckbG9hZFBvbGljeSA9IGNvbmZpZy5sb2FkUG9saWN5LFxuICAgICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNcyA9IF9jb25maWckbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNcyxcbiAgICAgICAgbWF4TG9hZFRpbWVNcyA9IF9jb25maWckbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zO1xuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaGVhZGVyIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQgLSAxKSk7XG4gICAgICB9XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XG4gICAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgY29uZmlnLnRpbWVvdXQgPSBtYXhUaW1lVG9GaXJzdEJ5dGVNcyAmJiBpc0Zpbml0ZU51bWJlcihtYXhUaW1lVG9GaXJzdEJ5dGVNcykgPyBtYXhUaW1lVG9GaXJzdEJ5dGVNcyA6IG1heExvYWRUaW1lTXM7XG4gICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9O1xuICAgIF9wcm90by5yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICB4aHIgPSB0aGlzLmxvYWRlcixcbiAgICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgaWYgKCFjb250ZXh0IHx8ICF4aHIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXG4gICAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgIGlmIChzdGF0cy5sb2FkaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgICAgICAgIC8vIHJlYWR5U3RhdGUgPj0gMiBBTkQgcmVhZHlTdGF0ZSAhPT00IChyZWFkeVN0YXRlID0gSEVBREVSU19SRUNFSVZFRCB8fCBMT0FESU5HKSByZWFybSB0aW1lb3V0IGFzIHhociBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgICAgaWYgKGNvbmZpZy50aW1lb3V0ICE9PSBjb25maWcubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zKSB7XG4gICAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgICAgIGNvbmZpZy50aW1lb3V0ID0gY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcztcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zIC0gKHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgIHZhciBfc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgICAvLyBodHRwIHN0YXR1cyBiZXR3ZWVuIDIwMCB0byAyOTkgYXJlIGFsbCBzdWNjZXNzZnVsXG4gICAgICAgICAgdmFyIHVzZVJlc3BvbnNlVGV4dCA9IHhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHhoci5yZXNwb25zZVRleHQgOiBudWxsO1xuICAgICAgICAgIGlmIChfc3RhdHVzID49IDIwMCAmJiBfc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHVzZVJlc3BvbnNlVGV4dCAhPSBudWxsID8gdXNlUmVzcG9uc2VUZXh0IDogeGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzMywgX3RoaXMkY2FsbGJhY2tzNDtcbiAgICAgICAgICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICAgICAgICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSBzdGF0cy50b3RhbCAqIDgwMDAgLyAoc3RhdHMubG9hZGluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgICAgICAgdmFyIG9uUHJvZ3Jlc3MgPSAoX3RoaXMkY2FsbGJhY2tzMyA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY2FsbGJhY2tzMy5vblByb2dyZXNzO1xuICAgICAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEsIHhocik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIF9yZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IF9zdGF0dXNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgKF90aGlzJGNhbGxiYWNrczQgPSB0aGlzLmNhbGxiYWNrcykgPT0gbnVsbCB8fCBfdGhpcyRjYWxsYmFja3M0Lm9uU3VjY2VzcyhfcmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCB4aHIpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSGFuZGxlIGJhZCBzdGF0dXMgb3IgbnVsbGlzaCByZXNwb25zZVxuICAgICAgICAgIHZhciByZXRyeUNvbmZpZyA9IGNvbmZpZy5sb2FkUG9saWN5LmVycm9yUmV0cnk7XG4gICAgICAgICAgdmFyIHJldHJ5Q291bnQgPSBzdGF0cy5yZXRyeTtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHVybDogY29udGV4dC51cmwsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2RlOiBfc3RhdHVzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGZhbHNlLCByZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzNTtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihfc3RhdHVzICsgXCIgd2hpbGUgbG9hZGluZyBcIiArIGNvbnRleHQudXJsKTtcbiAgICAgICAgICAgIChfdGhpcyRjYWxsYmFja3M1ID0gdGhpcy5jYWxsYmFja3MpID09IG51bGwgfHwgX3RoaXMkY2FsbGJhY2tzNS5vbkVycm9yKHtcbiAgICAgICAgICAgICAgY29kZTogX3N0YXR1cyxcbiAgICAgICAgICAgICAgdGV4dDogeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgIH0sIGNvbnRleHQsIHhociwgc3RhdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWR0aW1lb3V0ID0gZnVuY3Rpb24gbG9hZHRpbWVvdXQoKSB7XG4gICAgICBpZiAoIXRoaXMuY29uZmlnKSByZXR1cm47XG4gICAgICB2YXIgcmV0cnlDb25maWcgPSB0aGlzLmNvbmZpZy5sb2FkUG9saWN5LnRpbWVvdXRSZXRyeTtcbiAgICAgIHZhciByZXRyeUNvdW50ID0gdGhpcy5zdGF0cy5yZXRyeTtcbiAgICAgIGlmIChzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5yZXRyeShyZXRyeUNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3RoaXMkY29udGV4dDtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJ0aW1lb3V0IHdoaWxlIGxvYWRpbmcgXCIgKyAoKF90aGlzJGNvbnRleHQgPSB0aGlzLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb250ZXh0LnVybCkpO1xuICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3M7XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmV0cnkgPSBmdW5jdGlvbiByZXRyeShyZXRyeUNvbmZpZykge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgIHRoaXMucmV0cnlEZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHN0YXRzLnJldHJ5KTtcbiAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICBsb2dnZXIud2Fybigoc3RhdHVzID8gJ0hUVFAgU3RhdHVzICcgKyBzdGF0dXMgOiAnVGltZW91dCcpICsgXCIgd2hpbGUgbG9hZGluZyBcIiArIChjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LnVybCkgKyBcIiwgcmV0cnlpbmcgXCIgKyBzdGF0cy5yZXRyeSArIFwiL1wiICsgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgKyBcIiBpbiBcIiArIHRoaXMucmV0cnlEZWxheSArIFwibXNcIik7XG4gICAgICAvLyBhYm9ydCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGVcbiAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgICAgLy8gc2NoZWR1bGUgcmV0cnlcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZEludGVybmFsLmJpbmQodGhpcyksIHRoaXMucmV0cnlEZWxheSk7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZHByb2dyZXNzID0gZnVuY3Rpb24gbG9hZHByb2dyZXNzKGV2ZW50KSB7XG4gICAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgICAgc3RhdHMubG9hZGVkID0gZXZlbnQubG9hZGVkO1xuICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZXRDYWNoZUFnZSA9IGZ1bmN0aW9uIGdldENhY2hlQWdlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5sb2FkZXIgJiYgQUdFX0hFQURFUl9MSU5FX1JFR0VYLnRlc3QodGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgIHZhciBhZ2VIZWFkZXIgPSB0aGlzLmxvYWRlci5nZXRSZXNwb25zZUhlYWRlcignYWdlJyk7XG4gICAgICAgIHJlc3VsdCA9IGFnZUhlYWRlciA/IHBhcnNlRmxvYXQoYWdlSGVhZGVyKSA6IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSkge1xuICAgICAgaWYgKHRoaXMubG9hZGVyICYmIG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lICsgXCI6XFxcXHMqW1xcXFxkLl0rXFxcXHMqJFwiLCAnaW0nKS50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBYaHJMb2FkZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyYWdMb2FkUG9saWN5LmRlZmF1bHRcbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBtYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdCBhbmQgcGxheWxpc3RMb2FkUG9saWN5LmRlZmF1bHRcbiAgICovXG5cbiAgdmFyIGRlZmF1bHRMb2FkUG9saWN5ID0ge1xuICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiA4MDAwLFxuICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgIHRpbWVvdXRSZXRyeTogbnVsbCxcbiAgICBlcnJvclJldHJ5OiBudWxsXG4gIH07XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICogSWYgcG9zc2libGUsIGtlZXAgaGxzRGVmYXVsdENvbmZpZyBzaGFsbG93XG4gICAqIEl0IGlzIGNsb25lZCB3aGVuZXZlciBhIG5ldyBIbHMgaW5zdGFuY2UgaXMgY3JlYXRlZCwgYnkga2VlcGluZyB0aGUgY29uZmlnXG4gICAqIHNoYWxsb3cgdGhlIHByb3BlcnRpZXMgYXJlIGNsb25lZCwgYW5kIHdlIGRvbid0IGVuZCB1cCBtYW5pcHVsYXRpbmcgdGhlIGRlZmF1bHRcbiAgICovXG4gIHZhciBobHNEZWZhdWx0Q29uZmlnID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgIGF1dG9TdGFydExvYWQ6IHRydWUsXG4gICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgIHN0YXJ0UG9zaXRpb246IC0xLFxuICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLFxuICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgLy8gdXNlZCBieSBsb2dnZXJcbiAgICBjYXBMZXZlbE9uRlBTRHJvcDogZmFsc2UsXG4gICAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICAgIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gICAgaWdub3JlRGV2aWNlUGl4ZWxSYXRpbzogZmFsc2UsXG4gICAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICAgIG1heERldmljZVBpeGVsUmF0aW86IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gICAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlOiB0cnVlLFxuICAgIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLFxuICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICBiYWNrQnVmZmVyTGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gICAgZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZDogSW5maW5pdHksXG4gICAgc3RhcnRPblNlZ21lbnRCb3VuZGFyeTogZmFsc2UsXG4gICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMjUsXG4gICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgIG1heEJ1ZmZlckhvbGU6IDAuMSxcbiAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyIGFuZCBnYXAtY29udHJvbGxlclxuICAgIGRldGVjdFN0YWxsV2l0aEN1cnJlbnRUaW1lTXM6IDEyNTAsXG4gICAgLy8gdXNlZCBieSBnYXAtY29udHJvbGxlclxuICAgIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMixcbiAgICAvLyB1c2VkIGJ5IGdhcC1jb250cm9sbGVyXG4gICAgbnVkZ2VPZmZzZXQ6IDAuMSxcbiAgICAvLyB1c2VkIGJ5IGdhcC1jb250cm9sbGVyXG4gICAgbnVkZ2VNYXhSZXRyeTogMyxcbiAgICAvLyB1c2VkIGJ5IGdhcC1jb250cm9sbGVyXG4gICAgbnVkZ2VPblZpZGVvSG9sZTogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IGdhcC1jb250cm9sbGVyXG4gICAgbGl2ZVN5bmNNb2RlOiAnZWRnZScsXG4gICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgIGxpdmVTeW5jRHVyYXRpb25Db3VudDogMyxcbiAgICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICAgIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlOiAxLFxuICAgIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gICAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSxcbiAgICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICAgIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICAgIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICAgIG1heExpdmVTeW5jUGxheWJhY2tSYXRlOiAxLFxuICAgIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gICAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYmFja0J1ZmZlckxlbmd0aFxuICAgICAqL1xuICAgIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBudWxsLFxuICAgIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgICBtYXhNYXhCdWZmZXJMZW5ndGg6IDYwMCxcbiAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgZW5hYmxlV29ya2VyOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdHJhbnNtdXhlclxuICAgIHdvcmtlclBhdGg6IG51bGwsXG4gICAgLy8gdXNlZCBieSB0cmFuc211eGVyXG4gICAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsXG4gICAgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgICBzdGFydExldmVsOiB1bmRlZmluZWQsXG4gICAgLy8gdXNlZCBieSBsZXZlbC1jb250cm9sbGVyXG4gICAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCxcbiAgICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gICAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMixcbiAgICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gICAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMyxcbiAgICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gICAgaWdub3JlUGxheWxpc3RQYXJzaW5nRXJyb3JzOiBmYWxzZSxcbiAgICBsb2FkZXI6IFhockxvYWRlcixcbiAgICAvLyBsb2FkZXI6IEZldGNoTG9hZGVyLFxuICAgIGZMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICAgIHBMb2FkZXI6IHVuZGVmaW5lZCxcbiAgICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICAgIHhoclNldHVwOiB1bmRlZmluZWQsXG4gICAgLy8gdXNlZCBieSB4aHItbG9hZGVyXG4gICAgbGljZW5zZVhoclNldHVwOiB1bmRlZmluZWQsXG4gICAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICAgIGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrOiB1bmRlZmluZWQsXG4gICAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICAgIGFickNvbnRyb2xsZXI6IEFickNvbnRyb2xsZXIsXG4gICAgYnVmZmVyQ29udHJvbGxlcjogQnVmZmVyQ29udHJvbGxlcixcbiAgICBjYXBMZXZlbENvbnRyb2xsZXI6IENhcExldmVsQ29udHJvbGxlcixcbiAgICBlcnJvckNvbnRyb2xsZXI6IEVycm9yQ29udHJvbGxlcixcbiAgICBmcHNDb250cm9sbGVyOiBGUFNDb250cm9sbGVyLFxuICAgIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiAxLFxuICAgIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdHMtZGVtdXhlclxuICAgIGFickV3bWFGYXN0TGl2ZTogMyxcbiAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgYWJyRXdtYVNsb3dMaXZlOiA5LFxuICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICBhYnJFd21hRmFzdFZvRDogMyxcbiAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgYWJyRXdtYVNsb3dWb0Q6IDksXG4gICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSxcbiAgICAvLyA1MDAga2JwcyAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgIGFickV3bWFEZWZhdWx0RXN0aW1hdGVNYXg6IDVlNixcbiAgICAvLyA1IG1icHNcbiAgICBhYnJCYW5kV2lkdGhGYWN0b3I6IDAuOTUsXG4gICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsXG4gICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgIGFick1heFdpdGhSZWFsQml0cmF0ZTogZmFsc2UsXG4gICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgIG1heFN0YXJ2YXRpb25EZWxheTogNCxcbiAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgbWF4TG9hZGluZ0RlbGF5OiA0LFxuICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICBtaW5BdXRvQml0cmF0ZTogMCxcbiAgICAvLyB1c2VkIGJ5IGhsc1xuICAgIGVtZUVuYWJsZWQ6IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgICB3aWRldmluZUxpY2Vuc2VVcmw6IHVuZGVmaW5lZCxcbiAgICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gICAgZHJtU3lzdGVtczoge30sXG4gICAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICAgIGRybVN5c3RlbU9wdGlvbnM6IHt9LFxuICAgIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jOiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgLFxuICAgIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgICByZXF1aXJlS2V5U3lzdGVtQWNjZXNzT25TdGFydDogZmFsc2UsXG4gICAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICAgIHRlc3RCYW5kd2lkdGg6IHRydWUsXG4gICAgcHJvZ3Jlc3NpdmU6IGZhbHNlLFxuICAgIGxvd0xhdGVuY3lNb2RlOiB0cnVlLFxuICAgIGNtY2Q6IHVuZGVmaW5lZCxcbiAgICBlbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXM6IHRydWUsXG4gICAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgICBlbmFibGVFbXNnS0xWTWV0YWRhdGE6IGZhbHNlLFxuICAgIGVuYWJsZUlEM01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgICBlbmFibGVJbnRlcnN0aXRpYWxQbGF5YmFjazogdHJ1ZSxcbiAgICBpbnRlcnN0aXRpYWxBcHBlbmRJblBsYWNlOiB0cnVlLFxuICAgIGludGVyc3RpdGlhbExpdmVMb29rQWhlYWQ6IDEwLFxuICAgIHVzZU1lZGlhQ2FwYWJpbGl0aWVzOiB0cnVlLFxuICAgIHByZXNlcnZlTWFudWFsTGV2ZWxPbkVycm9yOiBmYWxzZSxcbiAgICBjZXJ0TG9hZFBvbGljeToge1xuICAgICAgZGVmYXVsdDogZGVmYXVsdExvYWRQb2xpY3lcbiAgICB9LFxuICAgIGtleUxvYWRQb2xpY3k6IHtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDgwMDAsXG4gICAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAyMDAwMCxcbiAgICAgICAgICBiYWNrb2ZmOiAnbGluZWFyJ1xuICAgICAgICB9LFxuICAgICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgICAgbWF4TnVtUmV0cnk6IDgsXG4gICAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICAgIG1heFJldHJ5RGVsYXlNczogMjAwMDAsXG4gICAgICAgICAgYmFja29mZjogJ2xpbmVhcidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBJbmZpbml0eSxcbiAgICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGxheWxpc3RMb2FkUG9saWN5OiB7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZnJhZ0xvYWRQb2xpY3k6IHtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgICBtYXhMb2FkVGltZU1zOiAxMjAwMDAsXG4gICAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiA0LFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiA2LFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RlZXJpbmdNYW5pZmVzdExvYWRQb2xpY3k6IHtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgICB9LFxuICAgICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgICAgbWF4TnVtUmV0cnk6IDEsXG4gICAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgICB9XG4gICAgICB9IFxuICAgIH0sXG4gICAgaW50ZXJzdGl0aWFsQXNzZXRMaXN0TG9hZFBvbGljeToge1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICAgIG1heExvYWRUaW1lTXM6IDMwMDAwLFxuICAgICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgICBtYXhOdW1SZXRyeTogMCxcbiAgICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgICBtYXhOdW1SZXRyeTogMCxcbiAgICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwXG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgfSxcbiAgICAvLyBUaGVzZSBkZWZhdWx0IHNldHRpbmdzIGFyZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHRoZSBhYm92ZSBwb2xpY2llc1xuICAgIC8vIGFuZCBhcmUgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSxcbiAgICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAgIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gICAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gICAgbGV2ZWxMb2FkaW5nTWF4UmV0cnk6IDQsXG4gICAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAgIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsXG4gICAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNixcbiAgICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gICAgZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwXG4gIH0sIHRpbWVsaW5lQ29uZmlnKCkpLCB7fSwge1xuICAgIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogU3VidGl0bGVTdHJlYW1Db250cm9sbGVyICxcbiAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgLFxuICAgIHRpbWVsaW5lQ29udHJvbGxlcjogVGltZWxpbmVDb250cm9sbGVyICxcbiAgICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IEF1ZGlvU3RyZWFtQ29udHJvbGxlciAsXG4gICAgYXVkaW9UcmFja0NvbnRyb2xsZXI6IEF1ZGlvVHJhY2tDb250cm9sbGVyICxcbiAgICBlbWVDb250cm9sbGVyOiBFTUVDb250cm9sbGVyICxcbiAgICBjbWNkQ29udHJvbGxlcjogQ01DRENvbnRyb2xsZXIgLFxuICAgIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI6IENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgLFxuICAgIGludGVyc3RpdGlhbHNDb250cm9sbGVyOiBJbnRlcnN0aXRpYWxzQ29udHJvbGxlciBcbiAgfSk7XG4gIGZ1bmN0aW9uIHRpbWVsaW5lQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjdWVIYW5kbGVyOiBDdWVzLFxuICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgICBlbmFibGVXZWJWVFQ6IHRydWUsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGVuYWJsZUlNU0MxOiB0cnVlLFxuICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgICBlbmFibGVDRUE3MDhDYXB0aW9uczogdHJ1ZSxcbiAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWw6ICdFbmdsaXNoJyxcbiAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLFxuICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgICBjYXB0aW9uc1RleHRUcmFjazJMYWJlbDogJ1NwYW5pc2gnLFxuICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgICBjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6ICdlcycsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiAnVW5rbm93biBDQycsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTogJycsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGNhcHRpb25zVGV4dFRyYWNrNExhYmVsOiAnVW5rbm93biBDQycsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTogJycsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIHJlbmRlclRleHRUcmFja3NOYXRpdmVseTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgdXNlckNvbmZpZywgbG9nZ2VyKSB7XG4gICAgaWYgKCh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvbid0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb25cIik7XG4gICAgfVxuICAgIGlmICh1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCA9PT0gdW5kZWZpbmVkIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IDw9IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICAgIH1cbiAgICBpZiAodXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uXCInKTtcbiAgICB9XG4gICAgdmFyIGRlZmF1bHRzQ29weSA9IGRlZXBDcHkoZGVmYXVsdENvbmZpZyk7XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGRlcHJlY2F0ZWQgY29uZmlnIHZhbHVlc1xuICAgIHZhciBkZXByZWNhdGVkU2V0dGluZ1R5cGVzID0gWydtYW5pZmVzdCcsICdsZXZlbCcsICdmcmFnJ107XG4gICAgdmFyIGRlcHJlY2F0ZWRTZXR0aW5ncyA9IFsnVGltZU91dCcsICdNYXhSZXRyeScsICdSZXRyeURlbGF5JywgJ01heFJldHJ5VGltZW91dCddO1xuICAgIGRlcHJlY2F0ZWRTZXR0aW5nVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIHBvbGljeU5hbWUgPSAodHlwZSA9PT0gJ2xldmVsJyA/ICdwbGF5bGlzdCcgOiB0eXBlKSArIFwiTG9hZFBvbGljeVwiO1xuICAgICAgdmFyIHBvbGljeU5vdFNldCA9IHVzZXJDb25maWdbcG9saWN5TmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXBvcnQgPSBbXTtcbiAgICAgIGRlcHJlY2F0ZWRTZXR0aW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChzZXR0aW5nKSB7XG4gICAgICAgIHZhciBkZXByZWNhdGVkU2V0dGluZyA9IHR5cGUgKyBcIkxvYWRpbmdcIiArIHNldHRpbmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHVzZXJDb25maWdbZGVwcmVjYXRlZFNldHRpbmddO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwb2xpY3lOb3RTZXQpIHtcbiAgICAgICAgICByZXBvcnQucHVzaChkZXByZWNhdGVkU2V0dGluZyk7XG4gICAgICAgICAgdmFyIHNldHRpbmdzID0gZGVmYXVsdHNDb3B5W3BvbGljeU5hbWVdLmRlZmF1bHQ7XG4gICAgICAgICAgdXNlckNvbmZpZ1twb2xpY3lOYW1lXSA9IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHNldHRpbmdzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzd2l0Y2ggKHNldHRpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RpbWVPdXQnOlxuICAgICAgICAgICAgICBzZXR0aW5ncy5tYXhMb2FkVGltZU1zID0gdmFsdWU7XG4gICAgICAgICAgICAgIHNldHRpbmdzLm1heFRpbWVUb0ZpcnN0Qnl0ZU1zID0gdmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTWF4UmV0cnknOlxuICAgICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5Lm1heE51bVJldHJ5ID0gdmFsdWU7XG4gICAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeS5tYXhOdW1SZXRyeSA9IHZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JldHJ5RGVsYXknOlxuICAgICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5LnJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkucmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTWF4UmV0cnlUaW1lb3V0JzpcbiAgICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeS5tYXhSZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5Lm1heFJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcG9ydC5sZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJobHMuanMgY29uZmlnOiBcXFwiXCIgKyByZXBvcnQuam9pbignXCIsIFwiJykgKyBcIlxcXCIgc2V0dGluZyhzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIFxcXCJcIiArIHBvbGljeU5hbWUgKyBcIlxcXCI6IFwiICsgc3RyaW5naWZ5KHVzZXJDb25maWdbcG9saWN5TmFtZV0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRzQ29weSksIHVzZXJDb25maWcpO1xuICB9XG4gIGZ1bmN0aW9uIGRlZXBDcHkob2JqKSB7XG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqLm1hcChkZWVwQ3B5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwQ3B5KG9ialtrZXldKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZywgbG9nZ2VyKSB7XG4gICAgdmFyIGN1cnJlbnRMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGlmIChjdXJyZW50TG9hZGVyICE9PSBGZXRjaExvYWRlciAmJiBjdXJyZW50TG9hZGVyICE9PSBYaHJMb2FkZXIpIHtcbiAgICAgIC8vIElmIGEgZGV2ZWxvcGVyIGhhcyBjb25maWd1cmVkIHRoZWlyIG93biBsb2FkZXIsIHJlc3BlY3QgdGhhdCBjaG9pY2VcbiAgICAgIGxvZ2dlci5sb2coJ1tjb25maWddOiBDdXN0b20gbG9hZGVyIGRldGVjdGVkLCBjYW5ub3QgZW5hYmxlIHByb2dyZXNzaXZlIHN0cmVhbWluZycpO1xuICAgICAgY29uZmlnLnByb2dyZXNzaXZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5ID0gZmV0Y2hTdXBwb3J0ZWQoKTtcbiAgICAgIGlmIChjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5KSB7XG4gICAgICAgIGNvbmZpZy5sb2FkZXIgPSBGZXRjaExvYWRlcjtcbiAgICAgICAgY29uZmlnLnByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTID0gdHJ1ZTtcbiAgICAgICAgbG9nZ2VyLmxvZygnW2NvbmZpZ106IFByb2dyZXNzaXZlIHN0cmVhbWluZyBlbmFibGVkLCB1c2luZyBGZXRjaExvYWRlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBNQVhfU1RBUlRfR0FQX0pVTVAgPSAyLjA7XG4gIHZhciBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyA9IDAuMTtcbiAgdmFyIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJUID0gMC4wNTtcbiAgdmFyIFRJQ0tfSU5URVJWQUwkMSA9IDEwMDtcbiAgdmFyIEdhcENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UYXNrTG9vcCkge1xuICAgIGZ1bmN0aW9uIEdhcENvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX1Rhc2tMb29wLmNhbGwodGhpcywgJ2dhcC1jb250cm9sbGVyJywgaGxzLmxvZ2dlcikgfHwgdGhpcztcbiAgICAgIF90aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIF90aGlzLmZyYWdtZW50VHJhY2tlciA9IHZvaWQgMDtcbiAgICAgIF90aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIF90aGlzLm1lZGlhU291cmNlID0gdm9pZCAwO1xuICAgICAgX3RoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICBfdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICBfdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIF90aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgICBfdGhpcy5zZWVraW5nID0gZmFsc2U7XG4gICAgICBfdGhpcy5idWZmZXJlZCA9IHt9O1xuICAgICAgX3RoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICAgIF90aGlzLmVuZGVkID0gMDtcbiAgICAgIF90aGlzLndhaXRpbmcgPSAwO1xuICAgICAgX3RoaXMub25NZWRpYVBsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmVuZGVkID0gMDtcbiAgICAgICAgX3RoaXMud2FpdGluZyA9IDA7XG4gICAgICB9O1xuICAgICAgX3RoaXMub25NZWRpYVdhaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgICAgaWYgKChfdGhpcyRtZWRpYSA9IF90aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMud2FpdGluZyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIF90aGlzLnRpY2soKTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5vbk1lZGlhRW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5obHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWEyO1xuICAgICAgICAgIC8vIGVuZGVkIGlzIHNldCB3aGVuIHRyaWdnZXJpbmcgTUVESUFfRU5ERUQgc28gdGhhdCB3ZSBkbyBub3QgdHJpZ2dlciBpdCBhZ2FpbiBvbiBzdGFsbCBvciBvbiB0aWNrIHdpdGggbWVkaWEuZW5kZWRcbiAgICAgICAgICBfdGhpcy5lbmRlZCA9ICgoX3RoaXMkbWVkaWEyID0gX3RoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYTIuY3VycmVudFRpbWUpIHx8IDE7XG4gICAgICAgICAgX3RoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0VOREVELCB7XG4gICAgICAgICAgICBzdGFsbGVkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMuaGxzID0gaGxzO1xuICAgICAgX3RoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgICAgX3RoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoR2FwQ29udHJvbGxlciwgX1Rhc2tMb29wKTtcbiAgICB2YXIgX3Byb3RvID0gR2FwQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoaGxzKSB7XG4gICAgICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKGhscykge1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIF9UYXNrTG9vcC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLm1lZGlhID0gdGhpcy5obHMgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDEpO1xuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IGRhdGEubWVkaWFTb3VyY2U7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobWVkaWEsICdwbGF5aW5nJywgdGhpcy5vbk1lZGlhUGxheWluZyk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAnd2FpdGluZycsIHRoaXMub25NZWRpYVdhaXRpbmcpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ2VuZGVkJywgdGhpcy5vbk1lZGlhRW5kZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3BsYXlpbmcnLCB0aGlzLm9uTWVkaWFQbGF5aW5nKTtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3dhaXRpbmcnLCB0aGlzLm9uTWVkaWFXYWl0aW5nKTtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ2VuZGVkJywgdGhpcy5vbk1lZGlhRW5kZWQpO1xuICAgICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJBcHBlbmRlZCA9IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuYnVmZmVyZWQgPSBkYXRhLnRpbWVSYW5nZXM7XG4gICAgfTtcbiAgICBfcHJvdG8udGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICB2YXIgX3RoaXMkbWVkaWEzO1xuICAgICAgaWYgKCEoKF90aGlzJG1lZGlhMyA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEzLnJlYWR5U3RhdGUpIHx8ICF0aGlzLmhhc0J1ZmZlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLnBvbGwoY3VycmVudFRpbWUsIHRoaXMubGFzdEN1cnJlbnRUaW1lKTtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBwbGF5aGVhZCBpcyBzdHVjayB3aXRoaW4gYSBnYXAsIGFuZCBpZiBzbywgYXR0ZW1wdHMgdG8gZnJlZSBpdC5cbiAgICAgKiBBIGdhcCBpcyBhbiB1bmJ1ZmZlcmVkIHJhbmdlIGJldHdlZW4gdHdvIGJ1ZmZlcmVkIHJhbmdlcyAob3IgdGhlIHN0YXJ0IGFuZCB0aGUgZmlyc3QgYnVmZmVyZWQgcmFuZ2UpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhc3RDdXJyZW50VGltZSAtIFByZXZpb3VzbHkgcmVhZCBwbGF5aGVhZCBwb3NpdGlvblxuICAgICAqLztcbiAgICBfcHJvdG8ucG9sbCA9IGZ1bmN0aW9uIHBvbGwoY3VycmVudFRpbWUsIGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgdmFyIF90aGlzJGhscywgX3RoaXMkaGxzMjtcbiAgICAgIHZhciBjb25maWcgPSAoX3RoaXMkaGxzID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMuY29uZmlnO1xuICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNlZWtpbmcgPSBtZWRpYS5zZWVraW5nO1xuICAgICAgdmFyIHNlZWtlZCA9IHRoaXMuc2Vla2luZyAmJiAhc2Vla2luZztcbiAgICAgIHZhciBiZWdpblNlZWsgPSAhdGhpcy5zZWVraW5nICYmIHNlZWtpbmc7XG4gICAgICB2YXIgcGF1c2VkRW5kZWRPckhhbHRlZCA9IG1lZGlhLnBhdXNlZCAmJiAhc2Vla2luZyB8fCBtZWRpYS5lbmRlZCB8fCBtZWRpYS5wbGF5YmFja1JhdGUgPT09IDA7XG4gICAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nO1xuXG4gICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbW92aW5nLCBuby1vcFxuICAgICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgICAgIHRoaXMuZW5kZWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXNlZWtpbmcpIHtcbiAgICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgICAgIC8vIFdoZW4gY3Jvc3NpbmcgYmV0d2VlbiBidWZmZXJlZCB2aWRlbyB0aW1lIHJhbmdlcywgYnV0IG5vdCBhdWRpbywgZmx1c2ggcGlwZWxpbmUgd2l0aCBzZWVrIChDaHJvbWUpXG4gICAgICAgICAgaWYgKGNvbmZpZy5udWRnZU9uVmlkZW9Ib2xlICYmICFwYXVzZWRFbmRlZE9ySGFsdGVkICYmIGN1cnJlbnRUaW1lID4gbGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLm51ZGdlT25WaWRlb0hvbGUoY3VycmVudFRpbWUsIGxhc3RDdXJyZW50VGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndhaXRpbmcgPT09IDApIHtcbiAgICAgICAgICB0aGlzLnN0YWxsUmVzb2x2ZWQoY3VycmVudFRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgc3RhbGxlZCBzdGF0ZSB3aGVuIGJlZ2lubmluZyBvciBmaW5pc2hpbmcgc2Vla2luZyBzbyB0aGF0IHdlIGRvbid0IHJlcG9ydCBzdGFsbHMgY29taW5nIG91dCBvZiBhIHNlZWtcbiAgICAgIGlmIChiZWdpblNlZWsgfHwgc2Vla2VkKSB7XG4gICAgICAgIGlmIChzZWVrZWQpIHtcbiAgICAgICAgICB0aGlzLnN0YWxsUmVzb2x2ZWQoY3VycmVudFRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHBsYXloZWFkIHNob3VsZCBub3QgYmUgbW92aW5nXG4gICAgICBpZiAocGF1c2VkRW5kZWRPckhhbHRlZCkge1xuICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgICB0aGlzLnN0YWxsUmVzb2x2ZWQoY3VycmVudFRpbWUpO1xuICAgICAgICAvLyBGaXJlIE1FRElBX0VOREVEIHRvIHdvcmthcm91bmQgZXZlbnQgbm90IGJlaW5nIGRpc3BhdGNoZWQgYnkgYnJvd3NlclxuICAgICAgICBpZiAoIXRoaXMuZW5kZWQgJiYgbWVkaWEuZW5kZWQgJiYgdGhpcy5obHMpIHtcbiAgICAgICAgICB0aGlzLmVuZGVkID0gY3VycmVudFRpbWUgfHwgMTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9FTkRFRCwge1xuICAgICAgICAgICAgc3RhbGxlZDogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIUJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzb2x2ZSBzdGFsbHMgYXQgYnVmZmVyIGhvbGVzIHVzaW5nIHRoZSBtYWluIGJ1ZmZlciwgd2hvc2UgcmFuZ2VzIGFyZSB0aGUgaW50ZXJzZWN0aW9ucyBvZiB0aGUgQS9WIHNvdXJjZWJ1ZmZlcnNcbiAgICAgIHZhciBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICAgIHZhciBuZXh0U3RhcnQgPSBidWZmZXJJbmZvLm5leHRTdGFydCB8fCAwO1xuICAgICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyO1xuICAgICAgaWYgKHNlZWtpbmcgJiYgZnJhZ21lbnRUcmFja2VyICYmIHRoaXMuaGxzKSB7XG4gICAgICAgIC8vIElzIHRoZXJlIGEgZnJhZ21lbnQgbG9hZGluZy9wYXJzaW5nL2FwcGVuZGluZyBiZWZvcmUgY3VycmVudFRpbWU/XG4gICAgICAgIHZhciBpbkZsaWdodERlcGVuZGVuY3kgPSBnZXRJbkZsaWdodERlcGVuZGVuY3kodGhpcy5obHMuaW5GbGlnaHRGcmFnbWVudHMsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgICAvLyBXYWl0aW5nIGZvciBzZWVraW5nIGluIGEgYnVmZmVyZWQgcmFuZ2UgdG8gY29tcGxldGVcbiAgICAgICAgdmFyIGhhc0Vub3VnaEJ1ZmZlciA9IGJ1ZmZlckluZm8ubGVuID4gTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgICAvLyBOZXh0IGJ1ZmZlcmVkIHJhbmdlIGlzIHRvbyBmYXIgYWhlYWQgdG8ganVtcCB0byB3aGlsZSBzdGlsbCBzZWVraW5nXG4gICAgICAgIHZhciBub0J1ZmZlckhvbGUgPSAhbmV4dFN0YXJ0IHx8IGluRmxpZ2h0RGVwZW5kZW5jeSB8fCBuZXh0U3RhcnQgLSBjdXJyZW50VGltZSA+IE1BWF9TVEFSVF9HQVBfSlVNUCAmJiAhZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgICAgIGlmIChoYXNFbm91Z2hCdWZmZXIgfHwgbm9CdWZmZXJIb2xlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IG1vdmVkIHN0YXRlIHdoZW4gc2Vla2luZyB0byBhIHBvaW50IGluIG9yIGJlZm9yZSBhIGdhcC9ob2xlXG4gICAgICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBzdGFydCBnYXBzIGlmIHdlIGhhdmVuJ3QgcGxheWVkLCBidXQgdGhlIGxhc3QgcG9sbCBkZXRlY3RlZCB0aGUgc3RhcnQgb2YgYSBzdGFsbFxuICAgICAgLy8gVGhlIGFkZGl0aW9uIHBvbGwgZ2l2ZXMgdGhlIGJyb3dzZXIgYSBjaGFuY2UgdG8ganVtcCB0aGUgZ2FwIGZvciB1c1xuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IChfdGhpcyRobHMyID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMyLmxhdGVzdExldmVsRGV0YWlscztcbiAgICAgIGlmICghdGhpcy5tb3ZlZCAmJiB0aGlzLnN0YWxsZWQgIT09IG51bGwgJiYgZnJhZ21lbnRUcmFja2VyKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHBsYXlhYmxlIGJ1ZmZlciAoc2Vla2VkLCB3YWl0aW5nIGZvciBidWZmZXIpXG4gICAgICAgIHZhciBpc0J1ZmZlcmVkID0gYnVmZmVySW5mby5sZW4gPiAwO1xuICAgICAgICBpZiAoIWlzQnVmZmVyZWQgJiYgIW5leHRTdGFydCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBKdW1wIHN0YXJ0IGdhcHMgd2l0aGluIGp1bXAgdGhyZXNob2xkXG4gICAgICAgIHZhciBzdGFydEp1bXAgPSBNYXRoLm1heChuZXh0U3RhcnQsIGJ1ZmZlckluZm8uc3RhcnQgfHwgMCkgLSBjdXJyZW50VGltZTtcblxuICAgICAgICAvLyBXaGVuIGpvaW5pbmcgYSBsaXZlIHN0cmVhbSB3aXRoIGF1ZGlvIHRyYWNrcywgYWNjb3VudCBmb3IgbGl2ZSBwbGF5bGlzdCB3aW5kb3cgc2xpZGluZyBieSBhbGxvd2luZ1xuICAgICAgICAvLyBhIGxhcmdlciBqdW1wIG92ZXIgc3RhcnQgZ2FwcyBjYXVzZWQgYnkgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGJ1ZmZlcmluZyBhIHN0YXJ0IGZyYWdtZW50XG4gICAgICAgIC8vIHRoYXQgYmVnaW5zIG92ZXIgMSB0YXJnZXQgZHVyYXRpb24gYWZ0ZXIgdGhlIHZpZGVvIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAgICB2YXIgaXNMaXZlID0gISEobGV2ZWxEZXRhaWxzICE9IG51bGwgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpO1xuICAgICAgICB2YXIgbWF4U3RhcnRHYXBKdW1wID0gaXNMaXZlID8gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMiA6IE1BWF9TVEFSVF9HQVBfSlVNUDtcbiAgICAgICAgdmFyIGFwcGVuZGVkID0gYXBwZW5kZWRGcmFnQXRQb3NpdGlvbihjdXJyZW50VGltZSwgZnJhZ21lbnRUcmFja2VyKTtcbiAgICAgICAgaWYgKHN0YXJ0SnVtcCA+IDAgJiYgKHN0YXJ0SnVtcCA8PSBtYXhTdGFydEdhcEp1bXAgfHwgYXBwZW5kZWQpKSB7XG4gICAgICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKGFwcGVuZGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IHRyYWNraW5nIHN0YWxsIHRpbWVcbiAgICAgIHZhciBkZXRlY3RTdGFsbFdpdGhDdXJyZW50VGltZU1zID0gY29uZmlnLmRldGVjdFN0YWxsV2l0aEN1cnJlbnRUaW1lTXM7XG4gICAgICB2YXIgdG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgdFdhaXRpbmcgPSB0aGlzLndhaXRpbmc7XG4gICAgICB2YXIgc3RhbGxlZCA9IHRoaXMuc3RhbGxlZDtcbiAgICAgIGlmIChzdGFsbGVkID09PSBudWxsKSB7XG4gICAgICAgIC8vIFVzZSB0aW1lIG9mIHJlY2VudCBcIndhaXRpbmdcIiBldmVudFxuICAgICAgICBpZiAodFdhaXRpbmcgPiAwICYmIHRub3cgLSB0V2FpdGluZyA8IGRldGVjdFN0YWxsV2l0aEN1cnJlbnRUaW1lTXMpIHtcbiAgICAgICAgICBzdGFsbGVkID0gdGhpcy5zdGFsbGVkID0gdFdhaXRpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gc3RhbGxlZDtcbiAgICAgIGlmICghc2Vla2luZyAmJiAoc3RhbGxlZER1cmF0aW9uID49IGRldGVjdFN0YWxsV2l0aEN1cnJlbnRUaW1lTXMgfHwgdFdhaXRpbmcpICYmIHRoaXMuaGxzKSB7XG4gICAgICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTtcbiAgICAgICAgLy8gRGlzcGF0Y2ggTUVESUFfRU5ERUQgd2hlbiBtZWRpYS5lbmRlZC9lbmRlZCBldmVudCBpcyBub3Qgc2lnbmFsbGVkIGF0IGVuZCBvZiBzdHJlYW1cbiAgICAgICAgaWYgKCgoX3RoaXMkbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSkgPT09ICdlbmRlZCcgJiYgIShsZXZlbERldGFpbHMgIT0gbnVsbCAmJiBsZXZlbERldGFpbHMubGl2ZSkgJiYgTWF0aC5hYnMoY3VycmVudFRpbWUgLSAoKGxldmVsRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLmVkZ2UpIHx8IDApKSA8IDEpIHtcbiAgICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVuZGVkID0gY3VycmVudFRpbWUgfHwgMTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9FTkRFRCwge1xuICAgICAgICAgICAgc3RhbGxlZDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxuICAgICAgICB0aGlzLl9yZXBvcnRTdGFsbChidWZmZXJJbmZvKTtcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhIHx8ICF0aGlzLmhscykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlcmVkV2l0aEhvbGVzID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCBjb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgICB0aGlzLl90cnlGaXhCdWZmZXJTdGFsbChidWZmZXJlZFdpdGhIb2xlcywgc3RhbGxlZER1cmF0aW9uLCBjdXJyZW50VGltZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhbGxSZXNvbHZlZCA9IGZ1bmN0aW9uIHN0YWxsUmVzb2x2ZWQoY3VycmVudFRpbWUpIHtcbiAgICAgIHZhciBzdGFsbGVkID0gdGhpcy5zdGFsbGVkO1xuICAgICAgaWYgKHN0YWxsZWQgJiYgdGhpcy5obHMpIHtcbiAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIHBsYXloZWFkIGlzIG5vdyBtb3ZpbmcsIGJ1dCB3YXMgcHJldmlvdXNseSBzdGFsbGVkXG4gICAgICAgIGlmICh0aGlzLnN0YWxsUmVwb3J0ZWQpIHtcbiAgICAgICAgICB2YXIgc3RhbGxlZER1cmF0aW9uID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YWxsZWQ7XG4gICAgICAgICAgdGhpcy5sb2coXCJwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAXCIgKyBjdXJyZW50VGltZSArIFwiLCBhZnRlciBcIiArIE1hdGgucm91bmQoc3RhbGxlZER1cmF0aW9uKSArIFwibXNcIik7XG4gICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy53YWl0aW5nID0gMDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVEFMTF9SRVNPTFZFRCwge30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubnVkZ2VPblZpZGVvSG9sZSA9IGZ1bmN0aW9uIG51ZGdlT25WaWRlb0hvbGUoY3VycmVudFRpbWUsIGxhc3RDdXJyZW50VGltZSkge1xuICAgICAgdmFyIF90aGlzJGJ1ZmZlcmVkJGF1ZGlvO1xuICAgICAgLy8gQ2hyb21lIHdpbGwgcGxheSBvbmUgc2Vjb25kIHBhc3QgYSBob2xlIGluIHZpZGVvIGJ1ZmZlcmVkIHRpbWUgcmFuZ2VzIHdpdGhvdXQgcmVuZGVyaW5nIGFueSB2aWRlbyBmcm9tIHRoZSBzdWJzZXF1ZW50IHJhbmdlIGFuZCB0aGVuIHN0YWxsIGFzIGxvbmcgYXMgYXVkaW8gaXMgYnVmZmVyZWQ6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvNTYzMVxuICAgICAgLy8gaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MDI4MDYxMyNjb21tZW50MTBcbiAgICAgIC8vIERldGVjdCB0aGUgcG90ZW50aWFsIGZvciB0aGlzIHNpdHVhdGlvbiBhbmQgcHJvYWN0aXZlbHkgc2VlayB0byBmbHVzaCB0aGUgdmlkZW8gcGlwZWxpbmUgb25jZSB0aGUgcGxheWhlYWQgcGFzc2VzIHRoZSBzdGFydCBvZiB0aGUgdmlkZW8gaG9sZS5cbiAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIGF1ZGlvIGFuZCB2aWRlbyBidWZmZXJzIGFuZCBjdXJyZW50VGltZSBpcyBwYXN0IHRoZSBlbmQgb2YgdGhlIGZpcnN0IHZpZGVvIGJ1ZmZlcmVkIHJhbmdlLi4uXG4gICAgICB2YXIgdmlkZW9Tb3VyY2VCdWZmZXJlZCA9IHRoaXMuYnVmZmVyZWQudmlkZW87XG4gICAgICBpZiAodGhpcy5obHMgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLmZyYWdtZW50VHJhY2tlciAmJiAoX3RoaXMkYnVmZmVyZWQkYXVkaW8gPSB0aGlzLmJ1ZmZlcmVkLmF1ZGlvKSAhPSBudWxsICYmIF90aGlzJGJ1ZmZlcmVkJGF1ZGlvLmxlbmd0aCAmJiB2aWRlb1NvdXJjZUJ1ZmZlcmVkICYmIHZpZGVvU291cmNlQnVmZmVyZWQubGVuZ3RoID4gMSAmJiBjdXJyZW50VGltZSA+IHZpZGVvU291cmNlQnVmZmVyZWQuZW5kKDApKSB7XG4gICAgICAgIC8vIGFuZCBhdWRpbyBpcyBidWZmZXJlZCBhdCB0aGUgcGxheWhlYWRcbiAgICAgICAgdmFyIGF1ZGlvQnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8oQnVmZmVySGVscGVyLnRpbWVSYW5nZXNUb0FycmF5KHRoaXMuYnVmZmVyZWQuYXVkaW8pLCBjdXJyZW50VGltZSwgMCk7XG4gICAgICAgIGlmIChhdWRpb0J1ZmZlckluZm8ubGVuID4gMSAmJiBsYXN0Q3VycmVudFRpbWUgPj0gYXVkaW9CdWZmZXJJbmZvLnN0YXJ0KSB7XG4gICAgICAgICAgdmFyIHZpZGVvVGltZXMgPSBCdWZmZXJIZWxwZXIudGltZVJhbmdlc1RvQXJyYXkodmlkZW9Tb3VyY2VCdWZmZXJlZCk7XG4gICAgICAgICAgdmFyIGxhc3RCdWZmZXJlZEluZGV4ID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyh2aWRlb1RpbWVzLCBsYXN0Q3VycmVudFRpbWUsIDApLmJ1ZmZlcmVkSW5kZXg7XG4gICAgICAgICAgLy8gbnVkZ2Ugd2hlbiBjcm9zc2luZyBpbnRvIGFub3RoZXIgdmlkZW8gYnVmZmVyZWQgcmFuZ2UgKGhvbGUpLlxuICAgICAgICAgIGlmIChsYXN0QnVmZmVyZWRJbmRleCA+IC0xICYmIGxhc3RCdWZmZXJlZEluZGV4IDwgdmlkZW9UaW1lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyZWRJbmRleCA9IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8odmlkZW9UaW1lcywgY3VycmVudFRpbWUsIDApLmJ1ZmZlcmVkSW5kZXg7XG4gICAgICAgICAgICB2YXIgaG9sZVN0YXJ0ID0gdmlkZW9UaW1lc1tsYXN0QnVmZmVyZWRJbmRleF0uZW5kO1xuICAgICAgICAgICAgdmFyIGhvbGVFbmQgPSB2aWRlb1RpbWVzW2xhc3RCdWZmZXJlZEluZGV4ICsgMV0uc3RhcnQ7XG4gICAgICAgICAgICBpZiAoKGJ1ZmZlcmVkSW5kZXggPT09IC0xIHx8IGJ1ZmZlcmVkSW5kZXggPiBsYXN0QnVmZmVyZWRJbmRleCkgJiYgaG9sZUVuZCAtIGhvbGVTdGFydCA8IDEgJiZcbiAgICAgICAgICAgIC8vIGBtYXhCdWZmZXJIb2xlYCBtYXkgYmUgdG9vIHNtYWxsIGFuZCBzZXR0aW5nIGl0IHRvIDAgc2hvdWxkIG5vdCBkaXNhYmxlIHRoaXMgZmVhdHVyZVxuICAgICAgICAgICAgY3VycmVudFRpbWUgLSBob2xlU3RhcnQgPCAyKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIm51ZGdpbmcgcGxheWhlYWQgdG8gZmx1c2ggcGlwZWxpbmUgYWZ0ZXIgdmlkZW8gaG9sZS4gY3VycmVudFRpbWU6IFwiICsgY3VycmVudFRpbWUgKyBcIiBob2xlOiBcIiArIGhvbGVTdGFydCArIFwiIC0+IFwiICsgaG9sZUVuZCArIFwiIGJ1ZmZlcmVkIGluZGV4OiBcIiArIGJ1ZmZlcmVkSW5kZXgpO1xuICAgICAgICAgICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgIC8vIE1hZ2ljIG51bWJlciB0byBmbHVzaCB0aGUgcGlwZWxpbmUgd2l0aG91dCBpbnRlcnVwdGlvbiB0byBhdWRpbyBwbGF5YmFjazpcbiAgICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSArPSAwLjAwMDAwMTtcbiAgICAgICAgICAgICAgdmFyIGZyYWcgPSBhcHBlbmRlZEZyYWdBdFBvc2l0aW9uKGN1cnJlbnRUaW1lLCB0aGlzLmZyYWdtZW50VHJhY2tlcik7XG4gICAgICAgICAgICAgIGlmIChmcmFnICYmICdmcmFnbWVudCcgaW4gZnJhZykge1xuICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnLmZyYWdtZW50O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgICAgICAgZnJhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgICBidWZmZXI6IGJ1ZmZlckluZm8ubGVuLFxuICAgICAgICAgICAgICAgIGJ1ZmZlckluZm86IGJ1ZmZlckluZm9cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyBhbmQgYXR0ZW1wdHMgdG8gZml4IGtub3duIGJ1ZmZlciBzdGFsbGluZyBpc3N1ZXMuXG4gICAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAgICogQHBhcmFtIHN0YWxsZWREdXJhdGlvbk1zIC0gVGhlIGFtb3VudCBvZiB0aW1lIEhscy5qcyBoYXMgYmVlbiBzdGFsbGluZyBmb3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi87XG4gICAgX3Byb3RvLl90cnlGaXhCdWZmZXJTdGFsbCA9IGZ1bmN0aW9uIF90cnlGaXhCdWZmZXJTdGFsbChidWZmZXJJbmZvLCBzdGFsbGVkRHVyYXRpb25NcywgY3VycmVudFRpbWUpIHtcbiAgICAgIHZhciBfdGhpcyRobHMzLCBfdGhpcyRobHM0O1xuICAgICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICB2YXIgY29uZmlnID0gKF90aGlzJGhsczMgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczMuY29uZmlnO1xuICAgICAgaWYgKCFtZWRpYSB8fCAhZnJhZ21lbnRUcmFja2VyIHx8ICFjb25maWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IChfdGhpcyRobHM0ID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHM0LmxhdGVzdExldmVsRGV0YWlscztcbiAgICAgIHZhciBhcHBlbmRlZCA9IGFwcGVuZGVkRnJhZ0F0UG9zaXRpb24oY3VycmVudFRpbWUsIGZyYWdtZW50VHJhY2tlcik7XG4gICAgICBpZiAoYXBwZW5kZWQgfHwgbGV2ZWxEZXRhaWxzICE9IG51bGwgJiYgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgY3VycmVudFRpbWUgPCBsZXZlbERldGFpbHMuZnJhZ21lbnRTdGFydCkge1xuICAgICAgICAvLyBUcnkgdG8gc2tpcCBvdmVyIHRoZSBidWZmZXIgaG9sZSBjYXVzZWQgYnkgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzbid0IGxpbWl0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIGJ1ZmZlcmVkIHJhbmdlc1xuICAgICAgICB2YXIgdGFyZ2V0VGltZSA9IHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKGFwcGVuZGVkKTtcbiAgICAgICAgLy8gd2UgcmV0dXJuIGhlcmUgaW4gdGhpcyBjYXNlLCBtZWFuaW5nXG4gICAgICAgIC8vIHRoZSBicmFuY2ggYmVsb3cgb25seSBleGVjdXRlcyB3aGVuIHdlIGhhdmVuJ3Qgc2Vla2VkIHRvIGEgbmV3IHBvc2l0aW9uXG4gICAgICAgIGlmICh0YXJnZXRUaW1lIHx8ICF0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGhhdmVuJ3QgaGFkIHRvIHNraXAgb3ZlciBhIGJ1ZmZlciBob2xlIG9mIGEgcGFydGlhbCBmcmFnbWVudFxuICAgICAgLy8gd2UgbWF5IGp1c3QgaGF2ZSB0byBcIm51ZGdlXCIgdGhlIHBsYXlsaXN0IGFzIHRoZSBicm93c2VyIGRlY29kaW5nL3JlbmRlcmluZyBlbmdpbmVcbiAgICAgIC8vIG5lZWRzIHRvIGNyb3NzIHNvbWUgc29ydCBvZiB0aHJlc2hvbGQgY292ZXJpbmcgYWxsIHNvdXJjZS1idWZmZXJzIGNvbnRlbnRcbiAgICAgIC8vIHRvIHN0YXJ0IHBsYXlpbmcgcHJvcGVybHkuXG4gICAgICB2YXIgYnVmZmVyZWRSYW5nZXMgPSBidWZmZXJJbmZvLmJ1ZmZlcmVkO1xuICAgICAgdmFyIGFkamFjZW50VHJhdmVyc2FsID0gdGhpcy5hZGphY2VudFRyYXZlcnNhbChidWZmZXJJbmZvLCBjdXJyZW50VGltZSk7XG4gICAgICBpZiAoKGJ1ZmZlcmVkUmFuZ2VzICYmIGJ1ZmZlcmVkUmFuZ2VzLmxlbmd0aCA+IDEgJiYgYnVmZmVySW5mby5sZW4gPiBjb25maWcubWF4QnVmZmVySG9sZSB8fCBidWZmZXJJbmZvLm5leHRTdGFydCAmJiAoYnVmZmVySW5mby5uZXh0U3RhcnQgLSBjdXJyZW50VGltZSA8IGNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8IGFkamFjZW50VHJhdmVyc2FsKSkgJiYgKHN0YWxsZWREdXJhdGlvbk1zID4gY29uZmlnLmhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDAgfHwgdGhpcy53YWl0aW5nKSkge1xuICAgICAgICB0aGlzLndhcm4oJ1RyeWluZyB0byBudWRnZSBwbGF5aGVhZCBvdmVyIGJ1ZmZlci1ob2xlJyk7XG4gICAgICAgIC8vIFRyeSB0byBudWRnZSBjdXJyZW50VGltZSBvdmVyIGEgYnVmZmVyIGhvbGUgaWYgd2UndmUgYmVlbiBzdGFsbGluZyBmb3IgdGhlIGNvbmZpZ3VyZWQgYW1vdW50IG9mIHNlY29uZHNcbiAgICAgICAgLy8gV2Ugb25seSB0cnkgdG8ganVtcCB0aGUgaG9sZSBpZiBpdCdzIHVuZGVyIHRoZSBjb25maWd1cmVkIHNpemVcbiAgICAgICAgdGhpcy5fdHJ5TnVkZ2VCdWZmZXIoYnVmZmVySW5mbyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYWRqYWNlbnRUcmF2ZXJzYWwgPSBmdW5jdGlvbiBhZGphY2VudFRyYXZlcnNhbChidWZmZXJJbmZvLCBjdXJyZW50VGltZSkge1xuICAgICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyO1xuICAgICAgdmFyIG5leHRTdGFydCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0O1xuICAgICAgaWYgKGZyYWdtZW50VHJhY2tlciAmJiBuZXh0U3RhcnQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBmcmFnbWVudFRyYWNrZXIuZ2V0RnJhZ0F0UG9zKGN1cnJlbnRUaW1lLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgdmFyIG5leHQgPSBmcmFnbWVudFRyYWNrZXIuZ2V0RnJhZ0F0UG9zKG5leHRTdGFydCwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgIGlmIChjdXJyZW50ICYmIG5leHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dC5zbiAtIGN1cnJlbnQuc24gPCAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYSBCVUZGRVJfU1RBTExFRF9FUlJPUiBldmVudCwgYnV0IG9ubHkgb25jZSBwZXIgc3RhbGwgcGVyaW9kLlxuICAgICAqIEBwYXJhbSBidWZmZXJMZW4gLSBUaGUgcGxheWhlYWQgZGlzdGFuY2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciBzZWdtZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovO1xuICAgIF9wcm90by5fcmVwb3J0U3RhbGwgPSBmdW5jdGlvbiBfcmVwb3J0U3RhbGwoYnVmZmVySW5mbykge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHN0YWxsUmVwb3J0ZWQgPSB0aGlzLnN0YWxsUmVwb3J0ZWQsXG4gICAgICAgIHN0YWxsZWQgPSB0aGlzLnN0YWxsZWQ7XG4gICAgICBpZiAoIXN0YWxsUmVwb3J0ZWQgJiYgc3RhbGxlZCAhPT0gbnVsbCAmJiBtZWRpYSAmJiBobHMpIHtcbiAgICAgICAgLy8gUmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJQbGF5YmFjayBzdGFsbGluZyBhdCBAXCIgKyBtZWRpYS5jdXJyZW50VGltZSArIFwiIGR1ZSB0byBsb3cgYnVmZmVyIChcIiArIHN0cmluZ2lmeShidWZmZXJJbmZvKSArIFwiKVwiKTtcbiAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgIGJ1ZmZlcjogYnVmZmVySW5mby5sZW4sXG4gICAgICAgICAgYnVmZmVySW5mbzogYnVmZmVySW5mbyxcbiAgICAgICAgICBzdGFsbGVkOiB7XG4gICAgICAgICAgICBzdGFydDogc3RhbGxlZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkganVtcGluZyBvdmVyIGtub3duIGdhcHMgY2F1c2VkIGJ5IHBhcnRpYWwgZnJhZ21lbnRzXG4gICAgICogQHBhcmFtIGFwcGVuZGVkIC0gVGhlIGZyYWdtZW50IG9yIHBhcnQgZm91bmQgYXQgdGhlIGN1cnJlbnQgdGltZSAod2hlcmUgcGxheWJhY2sgaXMgc3RhbGxpbmcpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovO1xuICAgIF9wcm90by5fdHJ5U2tpcEJ1ZmZlckhvbGUgPSBmdW5jdGlvbiBfdHJ5U2tpcEJ1ZmZlckhvbGUoYXBwZW5kZWQpIHtcbiAgICAgIHZhciBfdGhpcyRobHM1O1xuICAgICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICB2YXIgY29uZmlnID0gKF90aGlzJGhsczUgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhsczUuY29uZmlnO1xuICAgICAgaWYgKCFtZWRpYSB8fCAhZnJhZ21lbnRUcmFja2VyIHx8ICFjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnRUaW1lIGlzIGJldHdlZW4gdW5idWZmZXJlZCByZWdpb25zIG9mIHBhcnRpYWwgZnJhZ21lbnRzXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIHZhciBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBjdXJyZW50VGltZSA8IGJ1ZmZlckluZm8uc3RhcnQgPyBidWZmZXJJbmZvLnN0YXJ0IDogYnVmZmVySW5mby5uZXh0U3RhcnQ7XG4gICAgICBpZiAoc3RhcnRUaW1lICYmIHRoaXMuaGxzKSB7XG4gICAgICAgIHZhciBidWZmZXJTdGFydmVkID0gYnVmZmVySW5mby5sZW4gPD0gY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICAgIHZhciB3YWl0aW5nID0gYnVmZmVySW5mby5sZW4gPiAwICYmIGJ1ZmZlckluZm8ubGVuIDwgMSAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgMztcbiAgICAgICAgdmFyIGdhcExlbmd0aCA9IHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lO1xuICAgICAgICBpZiAoZ2FwTGVuZ3RoID4gMCAmJiAoYnVmZmVyU3RhcnZlZCB8fCB3YWl0aW5nKSkge1xuICAgICAgICAgIC8vIE9ubHkgYWxsb3cgbGFyZ2UgZ2FwcyB0byBiZSBza2lwcGVkIGlmIGl0IGlzIGEgc3RhcnQgZ2FwLCBvciBhbGwgZnJhZ21lbnRzIGluIHNraXAgcmFuZ2UgYXJlIHBhcnRpYWxcbiAgICAgICAgICBpZiAoZ2FwTGVuZ3RoID4gY29uZmlnLm1heEJ1ZmZlckhvbGUpIHtcbiAgICAgICAgICAgIHZhciBzdGFydEdhcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydEZyYWcgPSBmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKDAsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICAgICAgICBpZiAoc3RhcnRGcmFnICYmIHN0YXJ0VGltZSA8IHN0YXJ0RnJhZy5lbmQpIHtcbiAgICAgICAgICAgICAgICBzdGFydEdhcCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhcnRHYXAgJiYgYXBwZW5kZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzJGhscyRsb2FkTGV2ZWxPYjtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IHNlZWsgd2hlbiBzZWxlY3RlZCB2YXJpYW50IHBsYXlsaXN0IGlzIHVubG9hZGVkXG4gICAgICAgICAgICAgIGlmICghKChfdGhpcyRobHMkbG9hZExldmVsT2IgPSB0aGlzLmhscy5sb2FkTGV2ZWxPYmopICE9IG51bGwgJiYgX3RoaXMkaGxzJGxvYWRMZXZlbE9iLmRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRG8gbm90IHNlZWsgd2hlbiByZXF1aXJlZCBmcmFnbWVudHMgYXJlIGluZmxpZ2h0IG9yIGFwcGVuZGluZ1xuICAgICAgICAgICAgICB2YXIgaW5GbGlnaHREZXBlbmRlbmN5ID0gZ2V0SW5GbGlnaHREZXBlbmRlbmN5KHRoaXMuaGxzLmluRmxpZ2h0RnJhZ21lbnRzLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICBpZiAoaW5GbGlnaHREZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRG8gbm90IHNlZWsgaWYgd2UgY2FuJ3Qgd2FsayB0cmFja2VkIGZyYWdtZW50cyB0byBlbmQgb2YgZ2FwXG4gICAgICAgICAgICAgIHZhciBtb3JlVG9Mb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBwb3MgPSBhcHBlbmRlZC5lbmQ7XG4gICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlzaW9uZWQgPSBhcHBlbmRlZEZyYWdBdFBvc2l0aW9uKHBvcywgZnJhZ21lbnRUcmFja2VyKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlzaW9uZWQpIHtcbiAgICAgICAgICAgICAgICAgIHBvcyArPSBwcm92aXNpb25lZC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbW9yZVRvTG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1vcmVUb0xvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFyZ2V0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJULCBjdXJyZW50VGltZSArIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTKTtcbiAgICAgICAgICB0aGlzLndhcm4oXCJza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyB0YXJnZXRUaW1lKTtcbiAgICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICAgICAgaWYgKCEoYXBwZW5kZWQgIT0gbnVsbCAmJiBhcHBlbmRlZC5nYXApKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJmcmFnbWVudCBsb2FkZWQgd2l0aCBidWZmZXIgaG9sZXMsIHNlZWtpbmcgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyB0YXJnZXRUaW1lKTtcbiAgICAgICAgICAgIHZhciBlcnJvckRhdGEgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgIGJ1ZmZlcjogYnVmZmVySW5mby5sZW4sXG4gICAgICAgICAgICAgIGJ1ZmZlckluZm86IGJ1ZmZlckluZm9cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoYXBwZW5kZWQpIHtcbiAgICAgICAgICAgICAgaWYgKCdmcmFnbWVudCcgaW4gYXBwZW5kZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvckRhdGEucGFydCA9IGFwcGVuZGVkO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yRGF0YS5mcmFnID0gYXBwZW5kZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkgYWR2YW5jaW5nIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUgYnkgYSBzbWFsbCBhbW91bnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi87XG4gICAgX3Byb3RvLl90cnlOdWRnZUJ1ZmZlciA9IGZ1bmN0aW9uIF90cnlOdWRnZUJ1ZmZlcihidWZmZXJJbmZvKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgbnVkZ2VSZXRyeSA9IHRoaXMubnVkZ2VSZXRyeTtcbiAgICAgIHZhciBjb25maWcgPSBobHMgPT0gbnVsbCA/IHZvaWQgMCA6IGhscy5jb25maWc7XG4gICAgICBpZiAoIW1lZGlhIHx8ICFjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMubnVkZ2VSZXRyeSsrO1xuICAgICAgaWYgKG51ZGdlUmV0cnkgPCBjb25maWcubnVkZ2VNYXhSZXRyeSkge1xuICAgICAgICB2YXIgdGFyZ2V0VGltZSA9IGN1cnJlbnRUaW1lICsgKG51ZGdlUmV0cnkgKyAxKSAqIGNvbmZpZy5udWRnZU9mZnNldDtcbiAgICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJOdWRnaW5nICdjdXJyZW50VGltZScgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyB0YXJnZXRUaW1lKTtcbiAgICAgICAgdGhpcy53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCxcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGJ1ZmZlcjogYnVmZmVySW5mby5sZW4sXG4gICAgICAgICAgYnVmZmVySW5mbzogYnVmZmVySW5mb1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZXJyb3IgPSBuZXcgRXJyb3IoXCJQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEBcIiArIGN1cnJlbnRUaW1lICsgXCIgYWZ0ZXIgXCIgKyBjb25maWcubnVkZ2VNYXhSZXRyeSArIFwiIG51ZGdlc1wiKTtcbiAgICAgICAgdGhpcy5lcnJvcihfZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICAgIGVycm9yOiBfZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgYnVmZmVyOiBidWZmZXJJbmZvLmxlbixcbiAgICAgICAgICBidWZmZXJJbmZvOiBidWZmZXJJbmZvXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhHYXBDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcImhhc0J1ZmZlcmVkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuYnVmZmVyZWQpLmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KFRhc2tMb29wKTtcbiAgZnVuY3Rpb24gZ2V0SW5GbGlnaHREZXBlbmRlbmN5KGluRmxpZ2h0RnJhZ21lbnRzLCBjdXJyZW50VGltZSkge1xuICAgIHZhciBtYWluID0gaW5GbGlnaHQoaW5GbGlnaHRGcmFnbWVudHMubWFpbik7XG4gICAgaWYgKG1haW4gJiYgbWFpbi5zdGFydCA8PSBjdXJyZW50VGltZSkge1xuICAgICAgcmV0dXJuIG1haW47XG4gICAgfVxuICAgIHZhciBhdWRpbyA9IGluRmxpZ2h0KGluRmxpZ2h0RnJhZ21lbnRzLmF1ZGlvKTtcbiAgICBpZiAoYXVkaW8gJiYgYXVkaW8uc3RhcnQgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIHJldHVybiBhdWRpbztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gaW5GbGlnaHQoaW5GbGlnaHREYXRhKSB7XG4gICAgaWYgKCFpbkZsaWdodERhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKGluRmxpZ2h0RGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5JRExFOlxuICAgICAgY2FzZSBTdGF0ZS5TVE9QUEVEOlxuICAgICAgY2FzZSBTdGF0ZS5FTkRFRDpcbiAgICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW5GbGlnaHREYXRhLmZyYWc7XG4gIH1cbiAgZnVuY3Rpb24gYXBwZW5kZWRGcmFnQXRQb3NpdGlvbihwb3MsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHJldHVybiBmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHBvcywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTikgfHwgZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChwb3MpO1xuICB9XG5cbiAgdmFyIE1JTl9DVUVfRFVSQVRJT04gPSAwLjI1O1xuICBmdW5jdGlvbiBnZXRDdWVDbGFzcygpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDdWVXaXRoRGF0YUZpZWxkcyhDdWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgZGF0YSwgdHlwZSkge1xuICAgIHZhciBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICAgIHRyeSB7XG4gICAgICBjdWUudmFsdWUgPSBkYXRhO1xuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgY3VlLnR5cGUgPSB0eXBlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBzdHJpbmdpZnkodHlwZSA/IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfSwgZGF0YSkgOiBkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiBjdWU7XG4gIH1cblxuICAvLyBWVFRDdWUgbGF0ZXN0IGRyYWZ0IGFsbG93cyBhbiBpbmZpbml0ZSBkdXJhdGlvbiwgZmFsbGJhY2tcbiAgLy8gdG8gTUFYX1ZBTFVFIGlmIG5lY2Vzc2FyeVxuICB2YXIgTUFYX0NVRV9FTkRUSU1FID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgIHRyeSB7XG4gICAgICBDdWUgJiYgbmV3IEN1ZSgwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICcnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfSgpO1xuICB2YXIgSUQzVHJhY2tDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJRDNUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICAgIHRoaXMucmVtb3ZlQ3VlcyA9IHRydWU7XG4gICAgICB0aGlzLmFzc2V0Q3VlID0gdm9pZCAwO1xuICAgICAgdGhpcy5vbkV2ZW50Q3VlRW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghX3RoaXMuaGxzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FVkVOVF9DVUVfRU5URVIsIHt9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBJRDNUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5obHMgPSB0aGlzLm9uRXZlbnRDdWVFbnRlciA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKGhscykge1xuICAgICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsIHRoaXMub25MZXZlbFB0c1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoaGxzKSB7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSwgdGhpcyk7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCB0aGlzLm9uTGV2ZWxQdHNVcGRhdGVkLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICAgIF9wcm90by5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9kYXRhJG92ZXJyaWRlcztcbiAgICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgICAgaWYgKCgoX2RhdGEkb3ZlcnJpZGVzID0gZGF0YS5vdmVycmlkZXMpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRvdmVycmlkZXMuY3VlUmVtb3ZhbCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ3VlcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZCgpIHtcbiAgICAgIHZhciBfdGhpcyRobHM7XG4gICAgICB2YXIgZGV0YWlscyA9IChfdGhpcyRobHMgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscy5sYXRlc3RMZXZlbERldGFpbHM7XG4gICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGVSYW5nZUN1ZXMoZGV0YWlscyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdmFyIHRyYW5zZmVycmluZ01lZGlhID0gISFkYXRhLnRyYW5zZmVyTWVkaWE7XG4gICAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaWQzVHJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZlQ3Vlcykge1xuICAgICAgICAgIGNsZWFyQ3VycmVudEN1ZXModGhpcy5pZDNUcmFjaywgdGhpcy5vbkV2ZW50Q3VlRW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVRyYWNrKG1lZGlhKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLmdldElEM1RyYWNrKG1lZGlhLnRleHRUcmFja3MpO1xuICAgICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElEM1RyYWNrID0gZnVuY3Rpb24gZ2V0SUQzVHJhY2sodGV4dFRyYWNrcykge1xuICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGV4dFRyYWNrID0gdGV4dFRyYWNrc1tpXTtcbiAgICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgICAvLyBzZW5kICdhZGR0cmFjaycgd2hlbiByZXVzaW5nIHRoZSB0ZXh0VHJhY2sgZm9yIG1ldGFkYXRhLFxuICAgICAgICAgIC8vIHNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgY2FwdGlvbnNcbiAgICAgICAgICBzZW5kQWRkVHJhY2tFdmVudCh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnUGFyc2luZ01ldGFkYXRhID0gZnVuY3Rpb24gb25GcmFnUGFyc2luZ01ldGFkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAoIXRoaXMubWVkaWEgfHwgIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRobHMkY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxuICAgICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzID0gX3RoaXMkaGxzJGNvbmZpZy5lbmFibGVFbXNnTWV0YWRhdGFDdWVzLFxuICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXMgPSBfdGhpcyRobHMkY29uZmlnLmVuYWJsZUlEM01ldGFkYXRhQ3VlcztcbiAgICAgIGlmICghZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyAmJiAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzYW1wbGVzID0gZGF0YS5zYW1wbGVzO1xuXG4gICAgICAvLyBjcmVhdGUgdHJhY2sgZHluYW1pY2FsbHlcbiAgICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICAgIH1cbiAgICAgIHZhciBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgICAgaWYgKCFDdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gc2FtcGxlc1tpXS50eXBlO1xuICAgICAgICBpZiAodHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiAhZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyB8fCAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyYW1lcyA9IGdldElkM0ZyYW1lcyhzYW1wbGVzW2ldLmRhdGEpO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gc2FtcGxlc1tpXS5wdHM7XG4gICAgICAgIHZhciBlbmRUaW1lID0gc3RhcnRUaW1lICsgc2FtcGxlc1tpXS5kdXJhdGlvbjtcbiAgICAgICAgaWYgKGVuZFRpbWUgPiBNQVhfQ1VFX0VORFRJTUUpIHtcbiAgICAgICAgICBlbmRUaW1lID0gTUFYX0NVRV9FTkRUSU1FO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lRGlmZiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIGlmICh0aW1lRGlmZiA8PSAwKSB7XG4gICAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIE1JTl9DVUVfRFVSQVRJT047XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmcmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbal07XG4gICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuICAgICAgICAgIGlmICghaXNJZDNUaW1lc3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhIGJvdW5kcyB0byBhbnkgdW5ib3VuZGVkIGN1ZXNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWQzQ3VlRW5kcyhzdGFydFRpbWUsIHR5cGUpO1xuICAgICAgICAgICAgdmFyIGN1ZSA9IGNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzKEN1ZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBmcmFtZSwgdHlwZSk7XG4gICAgICAgICAgICBpZiAoY3VlKSB7XG4gICAgICAgICAgICAgIHRoaXMuaWQzVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlSWQzQ3VlRW5kcyA9IGZ1bmN0aW9uIHVwZGF0ZUlkM0N1ZUVuZHMoc3RhcnRUaW1lLCB0eXBlKSB7XG4gICAgICB2YXIgX3RoaXMkaWQzVHJhY2s7XG4gICAgICB2YXIgY3VlcyA9IChfdGhpcyRpZDNUcmFjayA9IHRoaXMuaWQzVHJhY2spID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRpZDNUcmFjay5jdWVzO1xuICAgICAgaWYgKGN1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGN1ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XG4gICAgICAgICAgaWYgKGN1ZS50eXBlID09PSB0eXBlICYmIGN1ZS5zdGFydFRpbWUgPCBzdGFydFRpbWUgJiYgY3VlLmVuZFRpbWUgPT09IE1BWF9DVUVfRU5EVElNRSkge1xuICAgICAgICAgICAgY3VlLmVuZFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJGbHVzaGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIF9yZWYpIHtcbiAgICAgIHZhciBzdGFydE9mZnNldCA9IF9yZWYuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldCA9IF9yZWYuZW5kT2Zmc2V0LFxuICAgICAgICB0eXBlID0gX3JlZi50eXBlO1xuICAgICAgdmFyIGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjayxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoIWhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgX2hscyRjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzID0gX2hscyRjb25maWcuZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyxcbiAgICAgICAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzID0gX2hscyRjb25maWcuZW5hYmxlSUQzTWV0YWRhdGFDdWVzO1xuICAgICAgaWYgKGlkM1RyYWNrICYmIChlbmFibGVFbXNnTWV0YWRhdGFDdWVzIHx8IGVuYWJsZUlEM01ldGFkYXRhQ3VlcykpIHtcbiAgICAgICAgdmFyIHByZWRpY2F0ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbiBwcmVkaWNhdGUoY3VlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzICYmIGVuYWJsZUlEM01ldGFkYXRhQ3VlcztcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbiBwcmVkaWNhdGUoY3VlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcztcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uIHByZWRpY2F0ZShjdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMgJiYgZW5hYmxlSUQzTWV0YWRhdGFDdWVzIHx8IGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVDdWVzSW5SYW5nZShpZDNUcmFjaywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgcHJlZGljYXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCBfcmVmMikge1xuICAgICAgdmFyIGRldGFpbHMgPSBfcmVmMi5kZXRhaWxzO1xuICAgICAgdGhpcy51cGRhdGVEYXRlUmFuZ2VDdWVzKGRldGFpbHMsIHRydWUpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxQdHNVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbFB0c1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIGlmIChNYXRoLmFicyhkYXRhLmRyaWZ0KSA+IDAuMDEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRlUmFuZ2VDdWVzKGRhdGEuZGV0YWlscyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlRGF0ZVJhbmdlQ3VlcyA9IGZ1bmN0aW9uIHVwZGF0ZURhdGVSYW5nZUN1ZXMoZGV0YWlscywgcmVtb3ZlT2xkQ3Vlcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuaGxzIHx8ICF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRobHMkY29uZmlnMiA9IHRoaXMuaGxzLmNvbmZpZyxcbiAgICAgICAgYXNzZXRQbGF5ZXJJZCA9IF90aGlzJGhscyRjb25maWcyLmFzc2V0UGxheWVySWQsXG4gICAgICAgIHRpbWVsaW5lT2Zmc2V0ID0gX3RoaXMkaGxzJGNvbmZpZzIudGltZWxpbmVPZmZzZXQsXG4gICAgICAgIGVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3VlcyA9IF90aGlzJGhscyRjb25maWcyLmVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3VlcyxcbiAgICAgICAgaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgPSBfdGhpcyRobHMkY29uZmlnMi5pbnRlcnN0aXRpYWxzQ29udHJvbGxlcjtcbiAgICAgIGlmICghZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgICAgaWYgKGFzc2V0UGxheWVySWQgJiYgdGltZWxpbmVPZmZzZXQgJiYgIWludGVyc3RpdGlhbHNDb250cm9sbGVyKSB7XG4gICAgICAgIHZhciBmcmFnbWVudFN0YXJ0ID0gZGV0YWlscy5mcmFnbWVudFN0YXJ0LFxuICAgICAgICAgIGZyYWdtZW50RW5kID0gZGV0YWlscy5mcmFnbWVudEVuZDtcbiAgICAgICAgdmFyIGN1ZSA9IHRoaXMuYXNzZXRDdWU7XG4gICAgICAgIGlmIChjdWUpIHtcbiAgICAgICAgICBjdWUuc3RhcnRUaW1lID0gZnJhZ21lbnRTdGFydDtcbiAgICAgICAgICBjdWUuZW5kVGltZSA9IGZyYWdtZW50RW5kO1xuICAgICAgICB9IGVsc2UgaWYgKEN1ZSkge1xuICAgICAgICAgIGN1ZSA9IHRoaXMuYXNzZXRDdWUgPSBjcmVhdGVDdWVXaXRoRGF0YUZpZWxkcyhDdWUsIGZyYWdtZW50U3RhcnQsIGZyYWdtZW50RW5kLCB7XG4gICAgICAgICAgICBhc3NldFBsYXllcklkOiB0aGlzLmhscy5jb25maWcuYXNzZXRQbGF5ZXJJZFxuICAgICAgICAgIH0sICdobHNqcy5pbnRlcnN0aXRpYWwuYXNzZXQnKTtcbiAgICAgICAgICBpZiAoY3VlKSB7XG4gICAgICAgICAgICBjdWUuaWQgPSBhc3NldFBsYXllcklkO1xuICAgICAgICAgICAgdGhpcy5pZDNUcmFjayB8fCAodGhpcy5pZDNUcmFjayA9IHRoaXMuY3JlYXRlVHJhY2sodGhpcy5tZWRpYSkpO1xuICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICAgIGN1ZS5hZGRFdmVudExpc3RlbmVyKCdlbnRlcicsIHRoaXMub25FdmVudEN1ZUVudGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGlkM1RyYWNrID0gdGhpcy5pZDNUcmFjaztcbiAgICAgIHZhciBkYXRlUmFuZ2VzID0gZGV0YWlscy5kYXRlUmFuZ2VzO1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZXMpO1xuICAgICAgdmFyIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkO1xuICAgICAgLy8gUmVtb3ZlIGN1ZXMgZnJvbSB0cmFjayBub3QgZm91bmQgaW4gZGV0YWlscy5kYXRlUmFuZ2VzXG4gICAgICBpZiAoaWQzVHJhY2sgJiYgcmVtb3ZlT2xkQ3Vlcykge1xuICAgICAgICB2YXIgX2lkM1RyYWNrJGN1ZXM7XG4gICAgICAgIGlmICgoX2lkM1RyYWNrJGN1ZXMgPSBpZDNUcmFjay5jdWVzKSAhPSBudWxsICYmIF9pZDNUcmFjayRjdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBpZHNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCkuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuICFpZHMuaW5jbHVkZXMoaWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgICAgdmFyIF9kYXRlUmFuZ2VDdWVzQXBwZW5kZTtcbiAgICAgICAgICAgIHZhciBpZCA9IGlkc1RvUmVtb3ZlW2ldO1xuICAgICAgICAgICAgdmFyIGN1ZXMgPSAoX2RhdGVSYW5nZUN1ZXNBcHBlbmRlID0gZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRlUmFuZ2VDdWVzQXBwZW5kZS5jdWVzO1xuICAgICAgICAgICAgZGVsZXRlIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICAgICAgICBpZiAoY3Vlcykge1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VlID0gY3Vlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChjdWUpIHtcbiAgICAgICAgICAgICAgICAgIGN1ZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcicsIF90aGlzMi5vbkV2ZW50Q3VlRW50ZXIpO1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWQzVHJhY2sucmVtb3ZlQ3VlKGN1ZSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIG5vLW9wICovXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSBpZHNUb1JlbW92ZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEV4aXQgaWYgdGhlIHBsYXlsaXN0IGRvZXMgbm90IGhhdmUgRGF0ZSBSYW5nZXMgb3IgZG9lcyBub3QgaGF2ZSBQcm9ncmFtIERhdGUgVGltZVxuICAgICAgdmFyIGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDAgfHwgIWlzRmluaXRlTnVtYmVyKGxhc3RGcmFnbWVudCA9PSBudWxsID8gdm9pZCAwIDogbGFzdEZyYWdtZW50LnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pZDNUcmFjayB8fCAodGhpcy5pZDNUcmFjayA9IHRoaXMuY3JlYXRlVHJhY2sodGhpcy5tZWRpYSkpO1xuICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW19pXTtcbiAgICAgICAgdmFyIGRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gZGF0ZVJhbmdlLnN0YXJ0VGltZTtcblxuICAgICAgICAvLyBQcm9jZXNzIERhdGVSYW5nZXMgdG8gZGV0ZXJtaW5lIGVuZC10aW1lIChrbm93biBEVVJBVElPTiwgRU5ELURBVEUsIG9yIEVORC1PTi1ORVhUKVxuICAgICAgICB2YXIgYXBwZW5kZWREYXRlUmFuZ2VDdWVzID0gZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgICAgdmFyIGN1ZXMgPSAoYXBwZW5kZWREYXRlUmFuZ2VDdWVzID09IG51bGwgPyB2b2lkIDAgOiBhcHBlbmRlZERhdGVSYW5nZUN1ZXMuY3VlcykgfHwge307XG4gICAgICAgIHZhciBkdXJhdGlvbktub3duID0gKGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9PSBudWxsID8gdm9pZCAwIDogYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmR1cmF0aW9uS25vd24pIHx8IGZhbHNlO1xuICAgICAgICB2YXIgZW5kVGltZSA9IE1BWF9DVUVfRU5EVElNRTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gZGF0ZVJhbmdlLmR1cmF0aW9uLFxuICAgICAgICAgIGVuZERhdGUgPSBkYXRlUmFuZ2UuZW5kRGF0ZTtcbiAgICAgICAgaWYgKGVuZERhdGUgJiYgZHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgICAgICAgZHVyYXRpb25Lbm93biA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0ZVJhbmdlLmVuZE9uTmV4dCAmJiAhZHVyYXRpb25Lbm93bikge1xuICAgICAgICAgIHZhciBuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcyA9IGlkcy5yZWR1Y2UoZnVuY3Rpb24gKGNhbmRpZGF0ZURhdGVSYW5nZSwgaWQpIHtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gZGF0ZVJhbmdlLmlkKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlckRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgICAgICAgICBpZiAob3RoZXJEYXRlUmFuZ2UuY2xhc3MgPT09IGRhdGVSYW5nZS5jbGFzcyAmJiBvdGhlckRhdGVSYW5nZS5zdGFydERhdGUgPiBkYXRlUmFuZ2Uuc3RhcnREYXRlICYmICghY2FuZGlkYXRlRGF0ZVJhbmdlIHx8IGRhdGVSYW5nZS5zdGFydERhdGUgPCBjYW5kaWRhdGVEYXRlUmFuZ2Uuc3RhcnREYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlckRhdGVSYW5nZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZURhdGVSYW5nZTtcbiAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgICBpZiAobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3MpIHtcbiAgICAgICAgICAgIGVuZFRpbWUgPSBuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcy5zdGFydFRpbWU7XG4gICAgICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgVGV4dFRyYWNrIEN1ZXMgZm9yIGVhY2ggTWV0YWRhdGFHcm91cCBJdGVtIChzZWxlY3QgRGF0ZVJhbmdlIGF0dHJpYnV0ZSlcbiAgICAgICAgLy8gVGhpcyBpcyB0byBlbXVsYXRlIFNhZmFyaSBITFMgcGxheWJhY2sgaGFuZGxpbmcgb2YgRGF0ZVJhbmdlIHRhZ3NcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2UuYXR0cik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBrZXkgPSBhdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgIGlmICghaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfY3VlID0gY3Vlc1trZXldO1xuICAgICAgICAgIGlmIChfY3VlKSB7XG4gICAgICAgICAgICBpZiAoZHVyYXRpb25Lbm93biAmJiAhKGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyAhPSBudWxsICYmIGFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5kdXJhdGlvbktub3duKSkge1xuICAgICAgICAgICAgICBfY3VlLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhfY3VlLnN0YXJ0VGltZSAtIHN0YXJ0VGltZSkgPiAwLjAxKSB7XG4gICAgICAgICAgICAgIF9jdWUuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICBfY3VlLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoQ3VlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGVSYW5nZS5hdHRyW2tleV07XG4gICAgICAgICAgICBpZiAoaXNTQ1RFMzVBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgICAgICBkYXRhID0gaGV4VG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfY3VlMiA9IGNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzKEN1ZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBwYXlsb2FkLCBNZXRhZGF0YVNjaGVtYS5kYXRlUmFuZ2UpO1xuICAgICAgICAgICAgaWYgKF9jdWUyKSB7XG4gICAgICAgICAgICAgIF9jdWUyLmlkID0gaWQ7XG4gICAgICAgICAgICAgIF90aGlzMi5pZDNUcmFjay5hZGRDdWUoX2N1ZTIpO1xuICAgICAgICAgICAgICBjdWVzW2tleV0gPSBfY3VlMjtcbiAgICAgICAgICAgICAgaWYgKGludGVyc3RpdGlhbHNDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ1gtQVNTRVQtTElTVCcgfHwga2V5ID09PSAnWC1BU1NFVC1VUkwnKSB7XG4gICAgICAgICAgICAgICAgICBfY3VlMi5hZGRFdmVudExpc3RlbmVyKCdlbnRlcicsIF90aGlzMi5vbkV2ZW50Q3VlRW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgcHJvY2Vzc2VkIERhdGVSYW5nZXMgYnkgSUQgZm9yIHVwZGF0aW5nIGN1ZXMgd2l0aCBuZXcgRGF0ZVJhbmdlIHRhZyBhdHRyaWJ1dGVzXG4gICAgICAgIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0gPSB7XG4gICAgICAgICAgY3VlczogY3VlcyxcbiAgICAgICAgICBkYXRlUmFuZ2U6IGRhdGVSYW5nZSxcbiAgICAgICAgICBkdXJhdGlvbktub3duOiBkdXJhdGlvbktub3duXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGlkcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgX2xvb3AyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSUQzVHJhY2tDb250cm9sbGVyO1xuICB9KCk7XG5cbiAgdmFyIExhdGVuY3lDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXRlbmN5Q29udHJvbGxlcihobHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgIHRoaXMuc3RhbGxDb3VudCA9IDA7XG4gICAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcbiAgICAgIHRoaXMuX3RhcmdldExhdGVuY3lVcGRhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm9uVGltZXVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gX3RoaXMubWVkaWE7XG4gICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBfdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICB2YXIgbGF0ZW5jeSA9IF90aGlzLmNvbXB1dGVMYXRlbmN5KCk7XG4gICAgICAgIGlmIChsYXRlbmN5ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9sYXRlbmN5ID0gbGF0ZW5jeTtcblxuICAgICAgICAvLyBBZGFwdCBwbGF5YmFja1JhdGUgdG8gbWVldCB0YXJnZXQgbGF0ZW5jeSBpbiBsb3ctbGF0ZW5jeSBtb2RlXG4gICAgICAgIHZhciBfdGhpcyRjb25maWcgPSBfdGhpcy5jb25maWcsXG4gICAgICAgICAgbG93TGF0ZW5jeU1vZGUgPSBfdGhpcyRjb25maWcubG93TGF0ZW5jeU1vZGUsXG4gICAgICAgICAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgPSBfdGhpcyRjb25maWcubWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU7XG4gICAgICAgIGlmICghbG93TGF0ZW5jeU1vZGUgfHwgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgPT09IDEgfHwgIWxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gX3RoaXMudGFyZ2V0TGF0ZW5jeTtcbiAgICAgICAgaWYgKHRhcmdldExhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpc3RhbmNlRnJvbVRhcmdldCA9IGxhdGVuY3kgLSB0YXJnZXRMYXRlbmN5O1xuICAgICAgICAvLyBPbmx5IGFkanVzdCBwbGF5YmFja1JhdGUgd2hlbiB3aXRoaW4gb25lIHRhcmdldCBkdXJhdGlvbiBvZiB0YXJnZXRMYXRlbmN5XG4gICAgICAgIC8vIGFuZCBtb3JlIHRoYW4gb25lIHNlY29uZCBmcm9tIHVuZGVyLWJ1ZmZlcmluZy5cbiAgICAgICAgLy8gUGxheWJhY2sgZnVydGhlciB0aGFuIG9uZSB0YXJnZXQgZHVyYXRpb24gZnJvbSB0YXJnZXQgY2FuIGJlIGNvbnNpZGVyZWQgRFZSIHBsYXliYWNrLlxuICAgICAgICB2YXIgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbiA9IE1hdGgubWluKF90aGlzLm1heExhdGVuY3ksIHRhcmdldExhdGVuY3kgKyBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICB2YXIgaW5MaXZlUmFuZ2UgPSBkaXN0YW5jZUZyb21UYXJnZXQgPCBsaXZlTWluTGF0ZW5jeUR1cmF0aW9uO1xuICAgICAgICBpZiAoaW5MaXZlUmFuZ2UgJiYgZGlzdGFuY2VGcm9tVGFyZ2V0ID4gMC4wNSAmJiBfdGhpcy5mb3J3YXJkQnVmZmVyTGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1pbigyLCBNYXRoLm1heCgxLjAsIG1heExpdmVTeW5jUGxheWJhY2tSYXRlKSk7XG4gICAgICAgICAgdmFyIHJhdGUgPSBNYXRoLnJvdW5kKDIgLyAoMSArIE1hdGguZXhwKC0wLjc1ICogZGlzdGFuY2VGcm9tVGFyZ2V0IC0gX3RoaXMuZWRnZVN0YWxsZWQpKSAqIDIwKSAvIDIwO1xuICAgICAgICAgIHZhciBwbGF5YmFja1JhdGUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDEsIHJhdGUpKTtcbiAgICAgICAgICBfdGhpcy5jaGFuZ2VNZWRpYVBsYXliYWNrUmF0ZShtZWRpYSwgcGxheWJhY2tSYXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYS5wbGF5YmFja1JhdGUgIT09IDEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwKSB7XG4gICAgICAgICAgX3RoaXMuY2hhbmdlTWVkaWFQbGF5YmFja1JhdGUobWVkaWEsIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBMYXRlbmN5Q29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKCFobHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoIWhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLm9uVGltZXVwZGF0ZSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLm9uVGltZXVwZGF0ZSk7XG4gICAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhbGxDb3VudCA9IDA7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbFVwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsVXBkYXRlZChldmVudCwgX3JlZikge1xuICAgICAgdmFyIGRldGFpbHMgPSBfcmVmLmRldGFpbHM7XG4gICAgICBpZiAoZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgICB0aGlzLm9uVGltZXVwZGF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCFkZXRhaWxzLmxpdmUgJiYgdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLm9uVGltZXVwZGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyRsZXZlbERldGFpbHM7XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgICBpZiAodGhpcy5obHMgJiYgKF90aGlzJGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzKSAhPSBudWxsICYmIF90aGlzJGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIHRoaXMuaGxzLmxvZ2dlci53YXJuKCdbbGF0ZW5jeS1jb250cm9sbGVyXTogU3RhbGwgZGV0ZWN0ZWQsIGFkanVzdGluZyB0YXJnZXQgbGF0ZW5jeScpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNoYW5nZU1lZGlhUGxheWJhY2tSYXRlID0gZnVuY3Rpb24gY2hhbmdlTWVkaWFQbGF5YmFja1JhdGUobWVkaWEsIHBsYXliYWNrUmF0ZSkge1xuICAgICAgdmFyIF90aGlzJGhscywgX3RoaXMkdGFyZ2V0TGF0ZW5jeTtcbiAgICAgIGlmIChtZWRpYS5wbGF5YmFja1JhdGUgPT09IHBsYXliYWNrUmF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAoX3RoaXMkaGxzID0gdGhpcy5obHMpID09IG51bGwgfHwgX3RoaXMkaGxzLmxvZ2dlci5kZWJ1ZyhcIltsYXRlbmN5LWNvbnRyb2xsZXJdOiBsYXRlbmN5PVwiICsgdGhpcy5sYXRlbmN5LnRvRml4ZWQoMykgKyBcIiwgdGFyZ2V0TGF0ZW5jeT1cIiArICgoX3RoaXMkdGFyZ2V0TGF0ZW5jeSA9IHRoaXMudGFyZ2V0TGF0ZW5jeSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRhcmdldExhdGVuY3kudG9GaXhlZCgzKSkgKyBcIiwgZm9yd2FyZEJ1ZmZlckxlbmd0aD1cIiArIHRoaXMuZm9yd2FyZEJ1ZmZlckxlbmd0aC50b0ZpeGVkKDMpICsgXCI6IGFkanVzdGluZyBwbGF5YmFjayByYXRlIGZyb20gXCIgKyBtZWRpYS5wbGF5YmFja1JhdGUgKyBcIiB0byBcIiArIHBsYXliYWNrUmF0ZSk7XG4gICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGU7XG4gICAgfTtcbiAgICBfcHJvdG8uZXN0aW1hdGVMaXZlRWRnZSA9IGZ1bmN0aW9uIGVzdGltYXRlTGl2ZUVkZ2UoKSB7XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVsRGV0YWlscy5lZGdlICsgbGV2ZWxEZXRhaWxzLmFnZTtcbiAgICB9O1xuICAgIF9wcm90by5jb21wdXRlTGF0ZW5jeSA9IGZ1bmN0aW9uIGNvbXB1dGVMYXRlbmN5KCkge1xuICAgICAgdmFyIGxpdmVFZGdlID0gdGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCk7XG4gICAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGl2ZUVkZ2UgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgIH07XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMYXRlbmN5Q29udHJvbGxlciwgW3tcbiAgICAgIGtleTogXCJsZXZlbERldGFpbHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkaGxzMjtcbiAgICAgICAgcmV0dXJuICgoX3RoaXMkaGxzMiA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaGxzMi5sYXRlc3RMZXZlbERldGFpbHMpIHx8IG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxhdGVuY3lcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZW5jeSB8fCAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXhMYXRlbmN5XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICAgIHJldHVybiBsZXZlbERldGFpbHMgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uIDogMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidGFyZ2V0TGF0ZW5jeVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCB8fCB0aGlzLmhscyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkQmFjayA9IGxldmVsRGV0YWlscy5ob2xkQmFjayxcbiAgICAgICAgICBwYXJ0SG9sZEJhY2sgPSBsZXZlbERldGFpbHMucGFydEhvbGRCYWNrLFxuICAgICAgICAgIHRhcmdldGR1cmF0aW9uID0gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgICB2YXIgX3RoaXMkY29uZmlnMiA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgIGxpdmVTeW5jRHVyYXRpb24gPSBfdGhpcyRjb25maWcyLmxpdmVTeW5jRHVyYXRpb24sXG4gICAgICAgICAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50ID0gX3RoaXMkY29uZmlnMi5saXZlU3luY0R1cmF0aW9uQ291bnQsXG4gICAgICAgICAgbG93TGF0ZW5jeU1vZGUgPSBfdGhpcyRjb25maWcyLmxvd0xhdGVuY3lNb2RlO1xuICAgICAgICB2YXIgdXNlckNvbmZpZyA9IHRoaXMuaGxzLnVzZXJDb25maWc7XG4gICAgICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gbG93TGF0ZW5jeU1vZGUgPyBwYXJ0SG9sZEJhY2sgfHwgaG9sZEJhY2sgOiBob2xkQmFjaztcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldExhdGVuY3lVcGRhdGVkIHx8IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB0YXJnZXRMYXRlbmN5ID09PSAwKSB7XG4gICAgICAgICAgdGFyZ2V0TGF0ZW5jeSA9IGxpdmVTeW5jRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGxpdmVTeW5jRHVyYXRpb24gOiBsaXZlU3luY0R1cmF0aW9uQ291bnQgKiB0YXJnZXRkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UgPSB0YXJnZXRkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRhcmdldExhdGVuY3kgKyBNYXRoLm1pbih0aGlzLnN0YWxsQ291bnQgKiB0aGlzLmNvbmZpZy5saXZlU3luY09uU3RhbGxJbmNyZWFzZSwgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxhdGVuY3kpIHtcbiAgICAgICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9IGxhdGVuY3k7XG4gICAgICAgIHRoaXMuX3RhcmdldExhdGVuY3lVcGRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGl2ZVN5bmNQb3NpdGlvblwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgICAgICB2YXIgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMudGFyZ2V0TGF0ZW5jeTtcbiAgICAgICAgaWYgKGxpdmVFZGdlID09PSBudWxsIHx8IHRhcmdldExhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRnZSA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgICAgICB2YXIgc3luY1Bvc2l0aW9uID0gbGl2ZUVkZ2UgLSB0YXJnZXRMYXRlbmN5IC0gdGhpcy5lZGdlU3RhbGxlZDtcbiAgICAgICAgdmFyIG1pbiA9IGVkZ2UgLSBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICAgICAgdmFyIG1heCA9IGVkZ2UgLSAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgfHwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgc3luY1Bvc2l0aW9uKSwgbWF4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJpZnRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmRyaWZ0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlZGdlU3RhbGxlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhMZXZlbFVwZGF0ZUFnZSA9ICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCB8fCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pICogMztcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGxldmVsRGV0YWlscy5hZ2UgLSBtYXhMZXZlbFVwZGF0ZUFnZSwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvcndhcmRCdWZmZXJMZW5ndGhcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXJlZFJhbmdlcyA9IG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIChidWZmZXJlZFJhbmdlcyA/IG1lZGlhLmJ1ZmZlcmVkLmVuZChidWZmZXJlZFJhbmdlcyAtIDEpIDogbGV2ZWxEZXRhaWxzLmVkZ2UpIC0gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcblxuICB2YXIgTGV2ZWxDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVBsYXlsaXN0Q29udHJvbGwpIHtcbiAgICBmdW5jdGlvbiBMZXZlbENvbnRyb2xsZXIoaGxzLCBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyKSB7XG4gICAgICB2YXIgX3RoaXM7XG4gICAgICBfdGhpcyA9IF9CYXNlUGxheWxpc3RDb250cm9sbC5jYWxsKHRoaXMsIGhscywgJ2xldmVsLWNvbnRyb2xsZXInKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuX2xldmVscyA9IFtdO1xuICAgICAgX3RoaXMuX2ZpcnN0TGV2ZWwgPSAtMTtcbiAgICAgIF90aGlzLl9tYXhBdXRvTGV2ZWwgPSAtMTtcbiAgICAgIF90aGlzLl9zdGFydExldmVsID0gdm9pZCAwO1xuICAgICAgX3RoaXMuY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgIF90aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgICBfdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgICBfdGhpcy5zdGVlcmluZyA9IHZvaWQgMDtcbiAgICAgIF90aGlzLm9uUGFyc2VkQ29tcGxldGUgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5zdGVlcmluZyA9IGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI7XG4gICAgICBfdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2luaGVyaXRzTG9vc2UoTGV2ZWxDb250cm9sbGVyLCBfQmFzZVBsYXlsaXN0Q29udHJvbGwpO1xuICAgIHZhciBfcHJvdG8gPSBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgdGhpcy5zdGVlcmluZyA9IG51bGw7XG4gICAgICB0aGlzLnJlc2V0TGV2ZWxzKCk7XG4gICAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVscztcblxuICAgICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgIH0pO1xuICAgICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5zdG9wTG9hZC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0TGV2ZWxzID0gZnVuY3Rpb24gcmVzZXRMZXZlbHMoKSB7XG4gICAgICB0aGlzLl9zdGFydExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IG51bGw7XG4gICAgICB0aGlzLl9sZXZlbHMgPSBbXTtcbiAgICAgIHRoaXMuX21heEF1dG9MZXZlbCA9IC0xO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGVkID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdGhpcy5obHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICAgIHZhciByZWR1bmRhbnRTZXQgPSB7fTtcbiAgICAgIHZhciBnZW5lcmF0ZVBhdGh3YXlTZXQgPSB7fTtcbiAgICAgIHZhciByZXNvbHV0aW9uRm91bmQgPSBmYWxzZTtcbiAgICAgIHZhciB2aWRlb0NvZGVjRm91bmQgPSBmYWxzZTtcbiAgICAgIHZhciBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZTtcbiAgICAgIGRhdGEubGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsUGFyc2VkKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbGV2ZWxQYXJzZWQuYXR0cnM7XG4gICAgICAgIHZhciBhdWRpb0NvZGVjID0gbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYyxcbiAgICAgICAgICB2aWRlb0NvZGVjID0gbGV2ZWxQYXJzZWQudmlkZW9Db2RlYztcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICAvLyBSZXR1cm5zIGVtcHR5IGFuZCBzZXQgdG8gdW5kZWZpbmVkIGZvciAnbXA0YS40MC4zNCcgd2l0aCBmYWxsYmFjayB0byAnYXVkaW8vbXBlZycgU291cmNlQnVmZmVyXG4gICAgICAgICAgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWMgPSBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKGF1ZGlvQ29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWRlb0NvZGVjKSB7XG4gICAgICAgICAgdmlkZW9Db2RlYyA9IGxldmVsUGFyc2VkLnZpZGVvQ29kZWMgPSBjb252ZXJ0QVZDMVRvQVZDT1RJKHZpZGVvQ29kZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcbiAgICAgICAgdmFyIHdpZHRoID0gbGV2ZWxQYXJzZWQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gbGV2ZWxQYXJzZWQuaGVpZ2h0LFxuICAgICAgICAgIHVua25vd25Db2RlY3MgPSBsZXZlbFBhcnNlZC51bmtub3duQ29kZWNzO1xuICAgICAgICB2YXIgdW5rbm93blVuc3VwcG9ydGVkQ29kZWNDb3VudCA9ICh1bmtub3duQ29kZWNzID09IG51bGwgPyB2b2lkIDAgOiB1bmtub3duQ29kZWNzLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgcmVzb2x1dGlvbkZvdW5kIHx8IChyZXNvbHV0aW9uRm91bmQgPSAhISh3aWR0aCAmJiBoZWlnaHQpKTtcbiAgICAgICAgdmlkZW9Db2RlY0ZvdW5kIHx8ICh2aWRlb0NvZGVjRm91bmQgPSAhIXZpZGVvQ29kZWMpO1xuICAgICAgICBhdWRpb0NvZGVjRm91bmQgfHwgKGF1ZGlvQ29kZWNGb3VuZCA9ICEhYXVkaW9Db2RlYyk7XG4gICAgICAgIGlmICh1bmtub3duVW5zdXBwb3J0ZWRDb2RlY0NvdW50IHx8IGF1ZGlvQ29kZWMgJiYgIV90aGlzMi5pc0F1ZGlvU3VwcG9ydGVkKGF1ZGlvQ29kZWMpIHx8IHZpZGVvQ29kZWMgJiYgIV90aGlzMi5pc1ZpZGVvU3VwcG9ydGVkKHZpZGVvQ29kZWMpKSB7XG4gICAgICAgICAgX3RoaXMyLmxvZyhcIlNvbWUgb3IgYWxsIENPREVDUyBub3Qgc3VwcG9ydGVkIFxcXCJcIiArIGF0dHJpYnV0ZXMuQ09ERUNTICsgXCJcXFwiXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQ09ERUNTID0gYXR0cmlidXRlcy5DT0RFQ1MsXG4gICAgICAgICAgRlJBTUVSQVRFID0gYXR0cmlidXRlc1snRlJBTUUtUkFURSddLFxuICAgICAgICAgIEhEQ1AgPSBhdHRyaWJ1dGVzWydIRENQLUxFVkVMJ10sXG4gICAgICAgICAgUEFUSFdBWSA9IGF0dHJpYnV0ZXNbJ1BBVEhXQVktSUQnXSxcbiAgICAgICAgICBSRVNPTFVUSU9OID0gYXR0cmlidXRlcy5SRVNPTFVUSU9OLFxuICAgICAgICAgIFZJREVPX1JBTkdFID0gYXR0cmlidXRlc1snVklERU8tUkFOR0UnXTtcbiAgICAgICAgdmFyIGNvbnRlbnRTdGVlcmluZ1ByZWZpeCA9IChQQVRIV0FZIHx8ICcuJykgKyBcIi1cIjtcbiAgICAgICAgdmFyIGxldmVsS2V5ID0gXCJcIiArIGNvbnRlbnRTdGVlcmluZ1ByZWZpeCArIGxldmVsUGFyc2VkLmJpdHJhdGUgKyBcIi1cIiArIFJFU09MVVRJT04gKyBcIi1cIiArIEZSQU1FUkFURSArIFwiLVwiICsgQ09ERUNTICsgXCItXCIgKyBWSURFT19SQU5HRSArIFwiLVwiICsgSERDUDtcbiAgICAgICAgaWYgKCFyZWR1bmRhbnRTZXRbbGV2ZWxLZXldKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gX3RoaXMyLmNyZWF0ZUxldmVsKGxldmVsUGFyc2VkKTtcbiAgICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldID0gbGV2ZWw7XG4gICAgICAgICAgZ2VuZXJhdGVQYXRod2F5U2V0W2xldmVsS2V5XSA9IDE7XG4gICAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZHVuZGFudFNldFtsZXZlbEtleV0udXJpICE9PSBsZXZlbFBhcnNlZC51cmwgJiYgIWxldmVsUGFyc2VkLmF0dHJzWydQQVRIV0FZLUlEJ10pIHtcbiAgICAgICAgICAvLyBBc3NpZ24gUGF0aHdheSBJRHMgdG8gUmVkdW5kYW50IFN0cmVhbXMgKGRlZmF1bHQgUGF0aHdheXMgaXMgXCIuXCIuIFJlZHVuZGFudCBTdHJlYW1zIFwiLi5cIiwgXCIuLi5cIiwgYW5kIHNvIG9uLilcbiAgICAgICAgICAvLyBDb250ZW50IFN0ZWVyaW5nIGNvbnRyb2xsZXIgdG8gaGFuZGxlcyBQYXRod2F5IGZhbGxiYWNrIG9uIGVycm9yXG4gICAgICAgICAgdmFyIHBhdGh3YXlDb3VudCA9IGdlbmVyYXRlUGF0aHdheVNldFtsZXZlbEtleV0gKz0gMTtcbiAgICAgICAgICBsZXZlbFBhcnNlZC5hdHRyc1snUEFUSFdBWS1JRCddID0gbmV3IEFycmF5KHBhdGh3YXlDb3VudCArIDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgX2xldmVsID0gX3RoaXMyLmNyZWF0ZUxldmVsKGxldmVsUGFyc2VkKTtcbiAgICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldID0gX2xldmVsO1xuICAgICAgICAgIGxldmVscy5wdXNoKF9sZXZlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVkdW5kYW50U2V0W2xldmVsS2V5XS5hZGRHcm91cElkKCdhdWRpbycsIGF0dHJpYnV0ZXMuQVVESU8pO1xuICAgICAgICAgIHJlZHVuZGFudFNldFtsZXZlbEtleV0uYWRkR3JvdXBJZCgndGV4dCcsIGF0dHJpYnV0ZXMuU1VCVElUTEVTKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMobGV2ZWxzLCBkYXRhLCByZXNvbHV0aW9uRm91bmQsIHZpZGVvQ29kZWNGb3VuZCwgYXVkaW9Db2RlY0ZvdW5kKTtcbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVMZXZlbCA9IGZ1bmN0aW9uIGNyZWF0ZUxldmVsKGxldmVsUGFyc2VkKSB7XG4gICAgICB2YXIgbGV2ZWwgPSBuZXcgTGV2ZWwobGV2ZWxQYXJzZWQpO1xuICAgICAgdmFyIHN1cHBsZW1lbnRhbCA9IGxldmVsUGFyc2VkLnN1cHBsZW1lbnRhbDtcbiAgICAgIGlmIChzdXBwbGVtZW50YWwgIT0gbnVsbCAmJiBzdXBwbGVtZW50YWwudmlkZW9Db2RlYyAmJiAhdGhpcy5pc1ZpZGVvU3VwcG9ydGVkKHN1cHBsZW1lbnRhbC52aWRlb0NvZGVjKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJTVVBQTEVNRU5UQUwtQ09ERUNTIG5vdCBzdXBwb3J0ZWQgXFxcIlwiICsgc3VwcGxlbWVudGFsLnZpZGVvQ29kZWMgKyBcIlxcXCJcIik7XG4gICAgICAgIHRoaXMubG9nKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBsZXZlbC5zdXBwb3J0ZWRSZXN1bHQgPSBnZXRVbnN1cHBvcnRlZFJlc3VsdChlcnJvciwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH07XG4gICAgX3Byb3RvLmlzQXVkaW9TdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc0F1ZGlvU3VwcG9ydGVkKGNvZGVjKSB7XG4gICAgICByZXR1cm4gYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWMsICdhdWRpbycsIHRoaXMuaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICAgIH07XG4gICAgX3Byb3RvLmlzVmlkZW9TdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1ZpZGVvU3VwcG9ydGVkKGNvZGVjKSB7XG4gICAgICByZXR1cm4gYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWMsICd2aWRlbycsIHRoaXMuaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMgPSBmdW5jdGlvbiBmaWx0ZXJBbmRTb3J0TWVkaWFPcHRpb25zKGZpbHRlcmVkTGV2ZWxzLCBkYXRhLCByZXNvbHV0aW9uRm91bmQsIHZpZGVvQ29kZWNGb3VuZCwgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICB2YXIgX2RhdGEkc3RhdHMsXG4gICAgICAgIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgYXVkaW9UcmFja3MgPSBbXTtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrcyA9IFtdO1xuICAgICAgdmFyIGxldmVscyA9IGZpbHRlcmVkTGV2ZWxzO1xuICAgICAgdmFyIHN0YXRzUGFyc2luZyA9ICgoX2RhdGEkc3RhdHMgPSBkYXRhLnN0YXRzKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkc3RhdHMucGFyc2luZykgfHwge307XG5cbiAgICAgIC8vIHJlbW92ZSBhdWRpby1vbmx5IGFuZCBpbnZhbGlkIHZpZGVvLXJhbmdlIGxldmVscyBpZiB3ZSBhbHNvIGhhdmUgbGV2ZWxzIHdpdGggdmlkZW8gY29kZWNzIG9yIFJFU09MVVRJT04gc2lnbmFsbGVkXG4gICAgICBpZiAoKHJlc29sdXRpb25Gb3VuZCB8fCB2aWRlb0NvZGVjRm91bmQpICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIHZpZGVvQ29kZWMgPSBfcmVmLnZpZGVvQ29kZWMsXG4gICAgICAgICAgICB2aWRlb1JhbmdlID0gX3JlZi52aWRlb1JhbmdlLFxuICAgICAgICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuICghIXZpZGVvQ29kZWMgfHwgISEod2lkdGggJiYgaGVpZ2h0KSkgJiYgaXNWaWRlb1JhbmdlKHZpZGVvUmFuZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIERpc3BhdGNoIGVycm9yIGFmdGVyIE1BTklGRVNUX0xPQURFRCBpcyBkb25lIHByb3BhZ2F0aW5nXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5obHMpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnO1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlYXNvbiA9IFwib25lIG9yIG1vcmUgQ09ERUNTIGluIHZhcmlhbnQgbm90IHN1cHBvcnRlZDogXCIgKyBzdHJpbmdpZnkoZGF0YS5sZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbC5hdHRycy5DT0RFQ1M7XG4gICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgX3RoaXMzLndhcm4ocmVhc29uKTtcbiAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyByZWFzb24gKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIF90aGlzMy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0c1BhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmF1ZGlvVHJhY2tzKSB7XG4gICAgICAgIGF1ZGlvVHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuICF0cmFjay5hdWRpb0NvZGVjIHx8IF90aGlzMy5pc0F1ZGlvU3VwcG9ydGVkKHRyYWNrLmF1ZGlvQ29kZWMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXNzaWduIGlkcyBhZnRlciBmaWx0ZXJpbmcgYXMgYXJyYXkgaW5kaWNlcyBieSBncm91cC1pZFxuICAgICAgICBhc3NpZ25UcmFja0lkc0J5R3JvdXAoYXVkaW9UcmFja3MpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc3VidGl0bGVzKSB7XG4gICAgICAgIHN1YnRpdGxlVHJhY2tzID0gZGF0YS5zdWJ0aXRsZXM7XG4gICAgICAgIGFzc2lnblRyYWNrSWRzQnlHcm91cChzdWJ0aXRsZVRyYWNrcyk7XG4gICAgICB9XG4gICAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxuICAgICAgdmFyIHVuc29ydGVkTGV2ZWxzID0gbGV2ZWxzLnNsaWNlKDApO1xuICAgICAgLy8gc29ydCBsZXZlbHMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdFxuICAgICAgbGV2ZWxzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuYXR0cnNbJ0hEQ1AtTEVWRUwnXSAhPT0gYi5hdHRyc1snSERDUC1MRVZFTCddKSB7XG4gICAgICAgICAgcmV0dXJuIChhLmF0dHJzWydIRENQLUxFVkVMJ10gfHwgJycpID4gKGIuYXR0cnNbJ0hEQ1AtTEVWRUwnXSB8fCAnJykgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29ydCBvbiBoZWlnaHQgYmVmb3JlIGJpdHJhdGUgZm9yIGNhcC1sZXZlbC1jb250cm9sbGVyXG4gICAgICAgIGlmIChyZXNvbHV0aW9uRm91bmQgJiYgYS5oZWlnaHQgIT09IGIuaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIGEuaGVpZ2h0IC0gYi5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuZnJhbWVSYXRlICE9PSBiLmZyYW1lUmF0ZSkge1xuICAgICAgICAgIHJldHVybiBhLmZyYW1lUmF0ZSAtIGIuZnJhbWVSYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnZpZGVvUmFuZ2UgIT09IGIudmlkZW9SYW5nZSkge1xuICAgICAgICAgIHJldHVybiBWaWRlb1JhbmdlVmFsdWVzLmluZGV4T2YoYS52aWRlb1JhbmdlKSAtIFZpZGVvUmFuZ2VWYWx1ZXMuaW5kZXhPZihiLnZpZGVvUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnZpZGVvQ29kZWMgIT09IGIudmlkZW9Db2RlYykge1xuICAgICAgICAgIHZhciB2YWx1ZUEgPSB2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlKGEudmlkZW9Db2RlYyk7XG4gICAgICAgICAgdmFyIHZhbHVlQiA9IHZpZGVvQ29kZWNQcmVmZXJlbmNlVmFsdWUoYi52aWRlb0NvZGVjKTtcbiAgICAgICAgICBpZiAodmFsdWVBICE9PSB2YWx1ZUIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZUIgLSB2YWx1ZUE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhLnVyaSA9PT0gYi51cmkgJiYgYS5jb2RlY1NldCAhPT0gYi5jb2RlY1NldCkge1xuICAgICAgICAgIHZhciBfdmFsdWVBID0gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGEuY29kZWNTZXQpO1xuICAgICAgICAgIHZhciBfdmFsdWVCID0gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGIuY29kZWNTZXQpO1xuICAgICAgICAgIGlmIChfdmFsdWVBICE9PSBfdmFsdWVCKSB7XG4gICAgICAgICAgICByZXR1cm4gX3ZhbHVlQiAtIF92YWx1ZUE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhLmF2ZXJhZ2VCaXRyYXRlICE9PSBiLmF2ZXJhZ2VCaXRyYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGEuYXZlcmFnZUJpdHJhdGUgLSBiLmF2ZXJhZ2VCaXRyYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmlyc3RMZXZlbEluUGxheWxpc3QgPSB1bnNvcnRlZExldmVsc1swXTtcbiAgICAgIGlmICh0aGlzLnN0ZWVyaW5nKSB7XG4gICAgICAgIGxldmVscyA9IHRoaXMuc3RlZXJpbmcuZmlsdGVyUGFyc2VkTGV2ZWxzKGxldmVscyk7XG4gICAgICAgIGlmIChsZXZlbHMubGVuZ3RoICE9PSB1bnNvcnRlZExldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuc29ydGVkTGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodW5zb3J0ZWRMZXZlbHNbaV0ucGF0aHdheUlkID09PSBsZXZlbHNbMF0ucGF0aHdheUlkKSB7XG4gICAgICAgICAgICAgIGZpcnN0TGV2ZWxJblBsYXlsaXN0ID0gdW5zb3J0ZWRMZXZlbHNbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuXG4gICAgICAvLyBmaW5kIGluZGV4IG9mIGZpcnN0IGxldmVsIGluIHNvcnRlZCBsZXZlbHNcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZXZlbHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGlmIChsZXZlbHNbX2ldID09PSBmaXJzdExldmVsSW5QbGF5bGlzdCkge1xuICAgICAgICAgIHZhciBfdGhpcyRobHMkdXNlckNvbmZpZztcbiAgICAgICAgICB0aGlzLl9maXJzdExldmVsID0gX2k7XG4gICAgICAgICAgdmFyIGZpcnN0TGV2ZWxCaXRyYXRlID0gZmlyc3RMZXZlbEluUGxheWxpc3QuYml0cmF0ZTtcbiAgICAgICAgICB2YXIgYmFuZHdpZHRoRXN0aW1hdGUgPSB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZTtcbiAgICAgICAgICB0aGlzLmxvZyhcIm1hbmlmZXN0IGxvYWRlZCwgXCIgKyBsZXZlbHMubGVuZ3RoICsgXCIgbGV2ZWwocykgZm91bmQsIGZpcnN0IGJpdHJhdGU6IFwiICsgZmlyc3RMZXZlbEJpdHJhdGUpO1xuICAgICAgICAgIC8vIFVwZGF0ZSBkZWZhdWx0IGJ3ZSB0byBmaXJzdCB2YXJpYW50IGJpdHJhdGUgYXMgbG9uZyBpdCBoYXMgbm90IGJlZW4gY29uZmlndXJlZCBvciBzZXRcbiAgICAgICAgICBpZiAoKChfdGhpcyRobHMkdXNlckNvbmZpZyA9IHRoaXMuaGxzLnVzZXJDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMkdXNlckNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRpbmdCd0VzdGltYXRlID0gTWF0aC5taW4oZmlyc3RMZXZlbEJpdHJhdGUsIHRoaXMuaGxzLmNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlTWF4KTtcbiAgICAgICAgICAgIGlmIChzdGFydGluZ0J3RXN0aW1hdGUgPiBiYW5kd2lkdGhFc3RpbWF0ZSAmJiBiYW5kd2lkdGhFc3RpbWF0ZSA9PT0gdGhpcy5obHMuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkge1xuICAgICAgICAgICAgICB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSA9IHN0YXJ0aW5nQndFc3RpbWF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQXVkaW8gaXMgb25seSBhbHRlcm5hdGUgaWYgbWFuaWZlc3QgaW5jbHVkZSBhIFVSSSBhbG9uZyB3aXRoIHRoZSBhdWRpbyBncm91cCB0YWcsXG4gICAgICAvLyBhbmQgdGhpcyBpcyBub3QgYW4gYXVkaW8tb25seSBzdHJlYW0gd2hlcmUgbGV2ZWxzIGNvbnRhaW4gYXVkaW8tb25seVxuICAgICAgdmFyIGF1ZGlvT25seSA9IGF1ZGlvQ29kZWNGb3VuZCAmJiAhdmlkZW9Db2RlY0ZvdW5kO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICAgIHZhciBhbHRBdWRpb0VuYWJsZWQgPSAhIShjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyICYmIGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlcik7XG4gICAgICB2YXIgZWRhdGEgPSB7XG4gICAgICAgIGxldmVsczogbGV2ZWxzLFxuICAgICAgICBhdWRpb1RyYWNrczogYXVkaW9UcmFja3MsXG4gICAgICAgIHN1YnRpdGxlVHJhY2tzOiBzdWJ0aXRsZVRyYWNrcyxcbiAgICAgICAgc2Vzc2lvbkRhdGE6IGRhdGEuc2Vzc2lvbkRhdGEsXG4gICAgICAgIHNlc3Npb25LZXlzOiBkYXRhLnNlc3Npb25LZXlzLFxuICAgICAgICBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLFxuICAgICAgICBzdGF0czogZGF0YS5zdGF0cyxcbiAgICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgICAgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCxcbiAgICAgICAgYWx0QXVkaW86IGFsdEF1ZGlvRW5hYmxlZCAmJiAhYXVkaW9Pbmx5ICYmIGF1ZGlvVHJhY2tzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gISF0LnVybDtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgICBzdGF0c1BhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIGVkYXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgZGF0YS5jb250ZXh0LmxldmVsID09PSB0aGlzLmxldmVsKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXNldCBlcnJvcnMgb24gdGhlIHN1Y2Nlc3NmdWwgbG9hZCBvZiBhIGZyYWdtZW50XG4gICAgO1xuICAgIF9wcm90by5vbkZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBfcmVmMikge1xuICAgICAgdmFyIGZyYWcgPSBfcmVmMi5mcmFnO1xuICAgICAgaWYgKGZyYWcgIT09IHVuZGVmaW5lZCAmJiBmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgICAgdmFyIGVsID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhlbCkuc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHJldHVybiAhIWVsW3R5cGVdO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICAgIGlmIChsZXZlbCAhPSBudWxsICYmIGxldmVsLmxvYWRFcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nKFwiUmVzZXR0aW5nIGxldmVsIGVycm9yIGNvdW50IG9mIFwiICsgbGV2ZWwubG9hZEVycm9yICsgXCIgb24gZnJhZyBidWZmZXJlZFwiKTtcbiAgICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGkyO1xuICAgICAgdmFyIGxldmVsID0gZGF0YS5sZXZlbCxcbiAgICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIHZhciBjdXJMZXZlbCA9IGRhdGEubGV2ZWxJbmZvO1xuICAgICAgaWYgKCFjdXJMZXZlbCkge1xuICAgICAgICB2YXIgX2RhdGEkZGVsaXZlcnlEaXJlY3RpO1xuICAgICAgICB0aGlzLndhcm4oXCJJbnZhbGlkIGxldmVsIGluZGV4IFwiICsgbGV2ZWwpO1xuICAgICAgICBpZiAoKF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aSA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzKSAhPSBudWxsICYmIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aS5za2lwKSB7XG4gICAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsIG9yIHByaW9yIHRvIHN3aXRjaCB3aGVuIG1lZGlhIHBsYXlsaXN0IGlzIGxvYWRlZCBkaXJlY3RseVxuICAgICAgaWYgKGN1ckxldmVsID09PSB0aGlzLmN1cnJlbnRMZXZlbCB8fCBkYXRhLndpdGhvdXRNdWx0aVZhcmlhbnQpIHtcbiAgICAgICAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgbGV2ZWwgbG9hZGVkIG9ubHkgaWYgdGhlcmUgaXMgbm8gaXNzdWVzIHdpdGggZnJhZ21lbnRzXG4gICAgICAgIGlmIChjdXJMZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgICAgY3VyTGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgbWF0Y2hpbmcgZGV0YWlscyBwb3B1bGF0ZWQgYnkgbG9hZGluZyBhIE1lZGlhIFBsYXlsaXN0IGRpcmVjdGx5XG4gICAgICAgIHZhciBwcmV2aW91c0RldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzO1xuICAgICAgICBpZiAocHJldmlvdXNEZXRhaWxzID09PSBkYXRhLmRldGFpbHMgJiYgcHJldmlvdXNEZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICAgICAgcHJldmlvdXNEZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQobGV2ZWwsIGRhdGEsIHByZXZpb3VzRGV0YWlscyk7XG4gICAgICB9IGVsc2UgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkyID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMpICE9IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpMi5za2lwKSB7XG4gICAgICAgIC8vIHJlY2VpdmVkIGEgZGVsdGEgcGxheWxpc3QgdXBkYXRlIHRoYXQgY2Fubm90IGJlIG1lcmdlZFxuICAgICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkUGxheWxpc3QgPSBmdW5jdGlvbiBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5sb2FkUGxheWxpc3QuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh0aGlzLnNob3VsZExvYWRQbGF5bGlzdCh0aGlzLmN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZUxvYWRpbmcodGhpcy5jdXJyZW50TGV2ZWwsIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWRpbmdQbGF5bGlzdCA9IGZ1bmN0aW9uIGxvYWRpbmdQbGF5bGlzdChjdXJyZW50TGV2ZWwsIGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUubG9hZGluZ1BsYXlsaXN0LmNhbGwodGhpcywgY3VycmVudExldmVsLCBobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICAgIHZhciB1cmwgPSB0aGlzLmdldFVybFdpdGhEaXJlY3RpdmVzKGN1cnJlbnRMZXZlbC51cmksIGhsc1VybFBhcmFtZXRlcnMpO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICAgIHZhciBwYXRod2F5SWQgPSBjdXJyZW50TGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXTtcbiAgICAgIHZhciBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHM7XG4gICAgICB2YXIgYWdlID0gZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogZGV0YWlscy5hZ2U7XG4gICAgICB0aGlzLmxvZyhcIkxvYWRpbmcgbGV2ZWwgaW5kZXggXCIgKyBjdXJyZW50TGV2ZWxJbmRleCArICgoaGxzVXJsUGFyYW1ldGVycyA9PSBudWxsID8gdm9pZCAwIDogaGxzVXJsUGFyYW1ldGVycy5tc24pICE9PSB1bmRlZmluZWQgPyAnIGF0IHNuICcgKyBobHNVcmxQYXJhbWV0ZXJzLm1zbiArICcgcGFydCAnICsgaGxzVXJsUGFyYW1ldGVycy5wYXJ0IDogJycpICsgKHBhdGh3YXlJZCA/ICcgUGF0aHdheSAnICsgcGF0aHdheUlkIDogJycpICsgKGFnZSAmJiBkZXRhaWxzLmxpdmUgPyAnIGFnZSAnICsgYWdlLnRvRml4ZWQoMSkgKyAoZGV0YWlscy50eXBlID8gJyAnICsgZGV0YWlscy50eXBlIHx8ICcnIDogJycpIDogJycpICsgXCIgXCIgKyB1cmwpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfTE9BRElORywge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbEluZGV4LFxuICAgICAgICBsZXZlbEluZm86IGN1cnJlbnRMZXZlbCxcbiAgICAgICAgcGF0aHdheUlkOiBjdXJyZW50TGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXSxcbiAgICAgICAgaWQ6IDAsXG4gICAgICAgIC8vIERlcHJlY2F0ZWQgTGV2ZWwgdXJsSWRcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGxcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUxldmVsID0gZnVuY3Rpb24gcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXMsXG4gICAgICAgIF90aGlzJGN1cnJlbnRMZXZlbDtcbiAgICAgIGlmICh0aGlzLl9sZXZlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChsZXZlbCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBsZXZlbEluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzNC5zdGVlcmluZykge1xuICAgICAgICAgIF90aGlzNC5zdGVlcmluZy5yZW1vdmVMZXZlbChsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsID09PSBfdGhpczQuY3VycmVudExldmVsKSB7XG4gICAgICAgICAgX3RoaXM0LmN1cnJlbnRMZXZlbCA9IG51bGw7XG4gICAgICAgICAgX3RoaXM0LmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgICAgICAgaWYgKGxldmVsLmRldGFpbHMpIHtcbiAgICAgICAgICAgIGxldmVsLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGYubGV2ZWwgPSAtMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJlYXNzaWduRnJhZ21lbnRMZXZlbEluZGV4ZXMobGV2ZWxzKTtcbiAgICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID4gLTEgJiYgKF90aGlzJGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsKSAhPSBudWxsICYmIF90aGlzJGN1cnJlbnRMZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbC5kZXRhaWxzLmZyYWdtZW50c1swXS5sZXZlbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgICAgfVxuICAgICAgdmFyIG1heExldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLl9maXJzdExldmVsID0gTWF0aC5taW4odGhpcy5fZmlyc3RMZXZlbCwgbWF4TGV2ZWwpO1xuICAgICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IE1hdGgubWluKHRoaXMuX3N0YXJ0TGV2ZWwsIG1heExldmVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMU19VUERBVEVELCB7XG4gICAgICAgIGxldmVsczogbGV2ZWxzXG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsc1VwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIF9yZWYzKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gX3JlZjMubGV2ZWxzO1xuICAgICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrTWF4QXV0b1VwZGF0ZWQgPSBmdW5jdGlvbiBjaGVja01heEF1dG9VcGRhdGVkKCkge1xuICAgICAgdmFyIF90aGlzJGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBhdXRvTGV2ZWxDYXBwaW5nID0gX3RoaXMkaGxzLmF1dG9MZXZlbENhcHBpbmcsXG4gICAgICAgIG1heEF1dG9MZXZlbCA9IF90aGlzJGhscy5tYXhBdXRvTGV2ZWwsXG4gICAgICAgIG1heEhkY3BMZXZlbCA9IF90aGlzJGhscy5tYXhIZGNwTGV2ZWw7XG4gICAgICBpZiAodGhpcy5fbWF4QXV0b0xldmVsICE9PSBtYXhBdXRvTGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fbWF4QXV0b0xldmVsID0gbWF4QXV0b0xldmVsO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NQVhfQVVUT19MRVZFTF9VUERBVEVELCB7XG4gICAgICAgICAgYXV0b0xldmVsQ2FwcGluZzogYXV0b0xldmVsQ2FwcGluZyxcbiAgICAgICAgICBsZXZlbHM6IHRoaXMubGV2ZWxzLFxuICAgICAgICAgIG1heEF1dG9MZXZlbDogbWF4QXV0b0xldmVsLFxuICAgICAgICAgIG1pbkF1dG9MZXZlbDogdGhpcy5obHMubWluQXV0b0xldmVsLFxuICAgICAgICAgIG1heEhkY3BMZXZlbDogbWF4SGRjcExldmVsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMZXZlbENvbnRyb2xsZXIsIFt7XG4gICAgICBrZXk6IFwibGV2ZWxzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb2FkTGV2ZWxPYmpcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50TGV2ZWw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICAgICAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgICAgIGlmIChuZXdMZXZlbCA8IDAgfHwgbmV3TGV2ZWwgPj0gbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ2ludmFsaWQgbGV2ZWwgaWR4Jyk7XG4gICAgICAgICAgdmFyIGZhdGFsID0gbmV3TGV2ZWwgPCAwO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUixcbiAgICAgICAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgICAgICAgIGZhdGFsOiBmYXRhbCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdMZXZlbCA9IE1hdGgubWluKG5ld0xldmVsLCBsZXZlbHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICAgICAgdmFyIGxhc3RMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgICAgICB2YXIgbGFzdFBhdGh3YXlJZCA9IGxhc3RMZXZlbCA/IGxhc3RMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgICAgICB2YXIgcGF0aHdheUlkID0gbGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICBpZiAobGFzdExldmVsSW5kZXggPT09IG5ld0xldmVsICYmIGxhc3RMZXZlbCAmJiBsYXN0UGF0aHdheUlkID09PSBwYXRod2F5SWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coXCJTd2l0Y2hpbmcgdG8gbGV2ZWwgXCIgKyBuZXdMZXZlbCArIFwiIChcIiArIChsZXZlbC5oZWlnaHQgPyBsZXZlbC5oZWlnaHQgKyAncCAnIDogJycpICsgKGxldmVsLnZpZGVvUmFuZ2UgPyBsZXZlbC52aWRlb1JhbmdlICsgJyAnIDogJycpICsgKGxldmVsLmNvZGVjU2V0ID8gbGV2ZWwuY29kZWNTZXQgKyAnICcgOiAnJykgKyBcIkBcIiArIGxldmVsLmJpdHJhdGUgKyBcIilcIiArIChwYXRod2F5SWQgPyAnIHdpdGggUGF0aHdheSAnICsgcGF0aHdheUlkIDogJycpICsgXCIgZnJvbSBsZXZlbCBcIiArIGxhc3RMZXZlbEluZGV4ICsgKGxhc3RQYXRod2F5SWQgPyAnIHdpdGggUGF0aHdheSAnICsgbGFzdFBhdGh3YXlJZCA6ICcnKSk7XG4gICAgICAgIHZhciBsZXZlbFN3aXRjaGluZ0RhdGEgPSB7XG4gICAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICAgIGF0dHJzOiBsZXZlbC5hdHRycyxcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbC5kZXRhaWxzLFxuICAgICAgICAgIGJpdHJhdGU6IGxldmVsLmJpdHJhdGUsXG4gICAgICAgICAgYXZlcmFnZUJpdHJhdGU6IGxldmVsLmF2ZXJhZ2VCaXRyYXRlLFxuICAgICAgICAgIG1heEJpdHJhdGU6IGxldmVsLm1heEJpdHJhdGUsXG4gICAgICAgICAgcmVhbEJpdHJhdGU6IGxldmVsLnJlYWxCaXRyYXRlLFxuICAgICAgICAgIHdpZHRoOiBsZXZlbC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGxldmVsLmhlaWdodCxcbiAgICAgICAgICBjb2RlY1NldDogbGV2ZWwuY29kZWNTZXQsXG4gICAgICAgICAgYXVkaW9Db2RlYzogbGV2ZWwuYXVkaW9Db2RlYyxcbiAgICAgICAgICB2aWRlb0NvZGVjOiBsZXZlbC52aWRlb0NvZGVjLFxuICAgICAgICAgIGF1ZGlvR3JvdXBzOiBsZXZlbC5hdWRpb0dyb3VwcyxcbiAgICAgICAgICBzdWJ0aXRsZUdyb3VwczogbGV2ZWwuc3VidGl0bGVHcm91cHMsXG4gICAgICAgICAgbG9hZGVkOiBsZXZlbC5sb2FkZWQsXG4gICAgICAgICAgbG9hZEVycm9yOiBsZXZlbC5sb2FkRXJyb3IsXG4gICAgICAgICAgZnJhZ21lbnRFcnJvcjogbGV2ZWwuZnJhZ21lbnRFcnJvcixcbiAgICAgICAgICBuYW1lOiBsZXZlbC5uYW1lLFxuICAgICAgICAgIGlkOiBsZXZlbC5pZCxcbiAgICAgICAgICB1cmk6IGxldmVsLnVyaSxcbiAgICAgICAgICB1cmw6IGxldmVsLnVybCxcbiAgICAgICAgICB1cmxJZDogMCxcbiAgICAgICAgICBhdWRpb0dyb3VwSWRzOiBsZXZlbC5hdWRpb0dyb3VwSWRzLFxuICAgICAgICAgIHRleHRHcm91cElkczogbGV2ZWwudGV4dEdyb3VwSWRzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgbGV2ZWxTd2l0Y2hpbmdEYXRhKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXG4gICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgICB2YXIgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKGxldmVsLnVyaSwgbGFzdExldmVsID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TGV2ZWwuZGV0YWlscywgbGV2ZWxEZXRhaWxzKTtcbiAgICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYW51YWxMZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaXJzdExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGFydExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgLy8gU2V0dGluZyBobHMuc3RhcnRMZXZlbCAodGhpcy5fc3RhcnRMZXZlbCkgb3ZlcnJpZGVzIGNvbmZpZy5zdGFydExldmVsXG4gICAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgY29uZmlnU3RhcnRMZXZlbCA9IHRoaXMuaGxzLmNvbmZpZy5zdGFydExldmVsO1xuICAgICAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5obHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYXRod2F5c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0ZWVyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RlZXJpbmcucGF0aHdheXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhdGh3YXlQcmlvcml0eVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0ZWVyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RlZXJpbmcucGF0aHdheVByaW9yaXR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHBhdGh3YXlQcmlvcml0eSkge1xuICAgICAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgICAgIHZhciBwYXRod2F5c0xpc3QgPSB0aGlzLnN0ZWVyaW5nLnBhdGh3YXlzKCk7XG4gICAgICAgICAgdmFyIGZpbHRlcmVkUGF0aHdheVByaW9yaXR5ID0gcGF0aHdheVByaW9yaXR5LmZpbHRlcihmdW5jdGlvbiAocGF0aHdheUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aHdheXNMaXN0LmluZGV4T2YocGF0aHdheUlkKSAhPT0gLTE7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHBhdGh3YXlQcmlvcml0eS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJwYXRod2F5UHJpb3JpdHkgXCIgKyBwYXRod2F5UHJpb3JpdHkgKyBcIiBzaG91bGQgY29udGFpbiBhdCBsZWFzdCBvbmUgcGF0aHdheSBmcm9tIGxpc3Q6IFwiICsgcGF0aHdheXNMaXN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGVlcmluZy5wYXRod2F5UHJpb3JpdHkgPSBmaWx0ZXJlZFBhdGh3YXlQcmlvcml0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0TG9hZExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhscy5uZXh0QXV0b0xldmVsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dExldmVsKSB7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgfShCYXNlUGxheWxpc3RDb250cm9sbGVyKTtcbiAgZnVuY3Rpb24gYXNzaWduVHJhY2tJZHNCeUdyb3VwKHRyYWNrcykge1xuICAgIHZhciBncm91cHMgPSB7fTtcbiAgICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgIHZhciBncm91cElkID0gdHJhY2suZ3JvdXBJZCB8fCAnJztcbiAgICAgIHRyYWNrLmlkID0gZ3JvdXBzW2dyb3VwSWRdID0gZ3JvdXBzW2dyb3VwSWRdIHx8IDA7XG4gICAgICBncm91cHNbZ3JvdXBJZF0rKztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNvdXJjZUJ1ZmZlcigpIHtcbiAgICByZXR1cm4gc2VsZi5Tb3VyY2VCdWZmZXIgfHwgc2VsZi5XZWJLaXRTb3VyY2VCdWZmZXI7XG4gIH1cbiAgZnVuY3Rpb24gaXNNU0VTdXBwb3J0ZWQoKSB7XG4gICAgdmFyIG1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaWYgU291cmNlQnVmZmVyIGlzIGV4cG9zZWQgZW5zdXJlIGl0cyBBUEkgaXMgdmFsaWRcbiAgICAvLyBPbGRlciBicm93c2VycyBkbyBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcbiAgICB2YXIgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gICAgcmV0dXJuICFzb3VyY2VCdWZmZXIgfHwgc291cmNlQnVmZmVyLnByb3RvdHlwZSAmJiB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUucmVtb3ZlID09PSAnZnVuY3Rpb24nO1xuICB9XG4gIGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgIGlmICghaXNNU0VTdXBwb3J0ZWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuICAgIHJldHVybiB0eXBlb2YgKG1lZGlhU291cmNlID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQpID09PSAnZnVuY3Rpb24nICYmIChbJ2F2YzEuNDJFMDFFLG1wNGEuNDAuMicsICdhdjAxLjAuMDFNLjA4JywgJ3ZwMDkuMDAuNTAuMDgnXS5zb21lKGZ1bmN0aW9uIChjb2RlY3NGb3JWaWRlb0NvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChtaW1lVHlwZUZvckNvZGVjKGNvZGVjc0ZvclZpZGVvQ29udGFpbmVyLCAndmlkZW8nKSk7XG4gICAgfSkgfHwgWydtcDRhLjQwLjInLCAnZkxhQyddLnNvbWUoZnVuY3Rpb24gKGNvZGVjRm9yQXVkaW9Db250YWluZXIpIHtcbiAgICAgIHJldHVybiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQobWltZVR5cGVGb3JDb2RlYyhjb2RlY0ZvckF1ZGlvQ29udGFpbmVyLCAnYXVkaW8nKSk7XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIGNoYW5nZVR5cGVTdXBwb3J0ZWQoKSB7XG4gICAgdmFyIF9zb3VyY2VCdWZmZXIkcHJvdG90eTtcbiAgICB2YXIgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gICAgcmV0dXJuIHR5cGVvZiAoc291cmNlQnVmZmVyID09IG51bGwgfHwgKF9zb3VyY2VCdWZmZXIkcHJvdG90eSA9IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfc291cmNlQnVmZmVyJHByb3RvdHkuY2hhbmdlVHlwZSkgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICB2YXIgVElDS19JTlRFUlZBTCA9IDEwMDsgLy8gaG93IG9mdGVuIHRvIHRpY2sgaW4gbXNcbiAgdmFyIFN0cmVhbUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlU3RyZWFtQ29udHJvbGxlcikge1xuICAgIGZ1bmN0aW9uIFN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfQmFzZVN0cmVhbUNvbnRyb2xsZXIuY2FsbCh0aGlzLCBobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnc3RyZWFtLWNvbnRyb2xsZXInLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICAgIF90aGlzLmxldmVsID0gLTE7XG4gICAgICBfdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICAgIF90aGlzLl9oYXNFbm91Z2hUb1N0YXJ0ID0gZmFsc2U7XG4gICAgICBfdGhpcy5hbHRBdWRpbyA9IDA7XG4gICAgICBfdGhpcy5hdWRpb09ubHkgPSBmYWxzZTtcbiAgICAgIF90aGlzLmZyYWdQbGF5aW5nID0gbnVsbDtcbiAgICAgIF90aGlzLmZyYWdMYXN0S2JwcyA9IDA7XG4gICAgICBfdGhpcy5jb3VsZEJhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgX3RoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgICAgX3RoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGZhbHNlO1xuICAgICAgX3RoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgICAgX3RoaXMub25NZWRpYVBsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR19DSEFOR0VEIHRyaWdnZXJpbmdcbiAgICAgICAgX3RoaXMudGljaygpO1xuICAgICAgfTtcbiAgICAgIF90aGlzLm9uTWVkaWFTZWVrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IF90aGlzLm1lZGlhO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lID09PSBudWxsIHx8ICFpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubG9nKFwiTWVkaWEgc2Vla2VkIHRvIFwiICsgY3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG5cbiAgICAgICAgLy8gSWYgc2Vla2VkIHdhcyBpc3N1ZWQgYmVmb3JlIGJ1ZmZlciB3YXMgYXBwZW5kZWQgZG8gbm90IHRpY2sgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKCFfdGhpcy5nZXRCdWZmZXJlZEZyYWcoY3VycmVudFRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXJJbmZvID0gX3RoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKG1lZGlhLCBjdXJyZW50VGltZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgMCk7XG4gICAgICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsIHx8IGJ1ZmZlckluZm8ubGVuID09PSAwKSB7XG4gICAgICAgICAgX3RoaXMud2FybihcIk1haW4gZm9yd2FyZCBidWZmZXIgbGVuZ3RoIGF0IFwiICsgY3VycmVudFRpbWUgKyBcIiBvbiBcXFwic2Vla2VkXFxcIiBldmVudCBcIiArIChidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAnZW1wdHknKSArIFwiKVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG4gICAgICAgIF90aGlzLnRpY2soKTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfaW5oZXJpdHNMb29zZShTdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIHZhciBfcHJvdG8gPSBTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUucmVnaXN0ZXJMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUudW5yZWdpc3Rlckxpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm9uTWVkaWFQbGF5aW5nID0gdGhpcy5vbk1lZGlhU2Vla2VkID0gbnVsbDtcbiAgICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24sIHNraXBTZWVrVG9TdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgICAgdmFyIGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICAgIHRoaXMubGV2ZWwgPSAtMTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgICAgdmFyIHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcbiAgICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChobHMuY29uZmlnLnRlc3RCYW5kd2lkdGggJiYgdGhpcy5sZXZlbHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnRMZXZlbCA9IGhscy5maXJzdEF1dG9MZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXG4gICAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gICAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBzdGFydExldmVsO1xuICAgICAgICAgIHRoaXMubGV2ZWwgPSBobHMubG9hZExldmVsO1xuICAgICAgICAgIHRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgPSAhIXNraXBTZWVrVG9TdGFydFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xICYmICFza2lwU2Vla1RvU3RhcnRQb3NpdGlvbikge1xuICAgICAgICAgIHRoaXMubG9nKFwiT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAXCIgKyBsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGxhc3RDdXJyZW50VGltZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uICsgdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24gPyAtMSA6IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuc3RvcExvYWQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0xFVkVMOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IGxldmVscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxzW2xldmVsXTtcbiAgICAgICAgICAgIHZhciBkZXRhaWxzID0gY3VycmVudExldmVsID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICAgICAgICAgIGlmIChkZXRhaWxzICYmICghZGV0YWlscy5saXZlIHx8IHRoaXMubGV2ZWxMYXN0TG9hZGVkID09PSBjdXJyZW50TGV2ZWwgJiYgIXRoaXMud2FpdEZvckxpdmUoY3VycmVudExldmVsKSkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5obHMubmV4dExvYWRMZXZlbCAhPT0gdGhpcy5sZXZlbCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgICAgdGhpcy5jaGVja1JldHJ5RGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9uVGlja0VuZCgpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uVGlja0VuZCA9IGZ1bmN0aW9uIG9uVGlja0VuZCgpIHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUub25UaWNrRW5kLmNhbGwodGhpcyk7XG4gICAgICBpZiAoKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYS5yZWFkeVN0YXRlICYmIHRoaXMubWVkaWEuc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0ZyYWdtZW50Q2hhbmdlZCgpO1xuICAgIH07XG4gICAgX3Byb3RvLmRvVGlja0lkbGUgPSBmdW5jdGlvbiBkb1RpY2tJZGxlKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCxcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgICAgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkQgc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBub3QgZW5hYmxlZFxuICAgICAgLy8gZXhpdCBsb29wLCBhcyB3ZSBlaXRoZXIgbmVlZCBtb3JlIGluZm8gKGxldmVsIG5vdCBwYXJzZWQpIG9yIHdlIG5lZWQgbWVkaWEgdG8gYmUgYXR0YWNoZWQgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgIGlmIChsZXZlbExhc3RMb2FkZWQgPT09IG51bGwgfHwgIW1lZGlhICYmICF0aGlzLnByaW1hcnlQcmVmZXRjaCAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWhscy5jb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIFwibWFpblwiIGxldmVsIGlzIGF1ZGlvLW9ubHkgYnV0IHdlIGFyZSBsb2FkaW5nIGFuIGFsdGVybmF0ZSB0cmFjayBpbiB0aGUgc2FtZSBncm91cCwgZG8gbm90IGxvYWQgYW55dGhpbmdcbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvICYmIHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuYnVmZmVyaW5nID8gaGxzLm5leHRMb2FkTGV2ZWwgOiBobHMubG9hZExldmVsO1xuICAgICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW2xldmVsXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxldmVsSW5mbyA9IGxldmVsc1tsZXZlbF07XG5cbiAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuXG4gICAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0RGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICBpZiAobGFzdERldGFpbHMgJiYgdGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGFzdERldGFpbHMpKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIGlmICh0aGlzLmFsdEF1ZGlvID09PSAyKSB7XG4gICAgICAgICAgZGF0YS50eXBlID0gJ3ZpZGVvJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYnVmZmVyaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IG5leHQgbG9hZCBsZXZlbCA6IHRoaXMgd2lsbCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZCBpZiBuZWVkZWRcbiAgICAgIGlmIChobHMubG9hZExldmVsICE9PSBsZXZlbCAmJiBobHMubWFudWFsTGV2ZWwgPT09IC0xKSB7XG4gICAgICAgIHRoaXMubG9nKFwiQWRhcHRpbmcgdG8gbGV2ZWwgXCIgKyBsZXZlbCArIFwiIGZyb20gbGV2ZWwgXCIgKyB0aGlzLmxldmVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIGVuc3VyZSB0aGF0IG5ldyBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgdG8gYXZvaWQgbG9hZGluZy90cnkgdG8gbG9hZFxuICAgICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuICAgICAgaWYgKCFsZXZlbERldGFpbHMgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCB8fCB0aGlzLndhaXRGb3JMaXZlKGxldmVsSW5mbykpIHtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuXG4gICAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgICB2YXIgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxJbmZvLm1heEJpdHJhdGUpO1xuXG4gICAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcbiAgICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQuc3RhcnQgPiBidWZmZXJJbmZvLmVuZCkge1xuICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXRCdWZmZXJUaW1lID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA/IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQuc3RhcnQgOiBidWZmZXJJbmZvLmVuZDtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgIC8vIEF2b2lkIGJhY2t0cmFja2luZyBieSBsb2FkaW5nIGFuIGVhcmxpZXIgc2VnbWVudCBpbiBzdHJlYW1zIHdpdGggc2VnbWVudHMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBhIGtleSBmcmFtZSAoZmxhZ2dlZCBieSBgY291bGRCYWNrdHJhY2tgKVxuICAgICAgaWYgKHRoaXMuY291bGRCYWNrdHJhY2sgJiYgIXRoaXMuZnJhZ1ByZXZpb3VzICYmIGZyYWcgJiYgaXNNZWRpYUZyYWdtZW50KGZyYWcpICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpICE9PSBGcmFnbWVudFN0YXRlLk9LKSB7XG4gICAgICAgIHZhciBfdGhpcyRiYWNrdHJhY2tGcmFnbWU7XG4gICAgICAgIHZhciBiYWNrdHJhY2tTbiA9ICgoX3RoaXMkYmFja3RyYWNrRnJhZ21lID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCkgIT0gbnVsbCA/IF90aGlzJGJhY2t0cmFja0ZyYWdtZSA6IGZyYWcpLnNuO1xuICAgICAgICB2YXIgZnJhZ0lkeCA9IGJhY2t0cmFja1NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAgIHZhciBiYWNrdHJhY2tGcmFnID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tmcmFnSWR4IC0gMV07XG4gICAgICAgIGlmIChiYWNrdHJhY2tGcmFnICYmIGZyYWcuY2MgPT09IGJhY2t0cmFja0ZyYWcuY2MpIHtcbiAgICAgICAgICBmcmFnID0gYmFja3RyYWNrRnJhZztcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChiYWNrdHJhY2tGcmFnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmIGJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gQXZvaWQgbG9vcCBsb2FkaW5nIGJ5IHVzaW5nIG5leHRMb2FkUG9zaXRpb24gc2V0IGZvciBiYWNrdHJhY2tpbmcgYW5kIHNraXBwaW5nIGNvbnNlY3V0aXZlIEdBUCB0YWdzXG4gICAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgICAgdmFyIGdhcFN0YXJ0ID0gZnJhZy5nYXA7XG4gICAgICAgIGlmICghZ2FwU3RhcnQpIHtcbiAgICAgICAgICAvLyBDbGVhbnVwIHRoZSBmcmFnbWVudCB0cmFja2VyIGJlZm9yZSB0cnlpbmcgdG8gZmluZCB0aGUgbmV4dCB1bmJ1ZmZlcmVkIGZyYWdtZW50XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmF1ZGlvT25seSAmJiAhdGhpcy5hbHRBdWRpbyA/IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyA6IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTztcbiAgICAgICAgICB2YXIgbWVkaWFCdWZmZXIgPSAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWFCdWZmZXIpIHx8IHRoaXMubWVkaWE7XG4gICAgICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGZyYWcsIGxldmVsRGV0YWlscywgYnVmZmVySW5mbywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgbWF4QnVmTGVuKTtcbiAgICAgIH1cbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5pbml0U2VnbWVudCAmJiAhZnJhZy5pbml0U2VnbWVudC5kYXRhICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIGZyYWcgPSBmcmFnLmluaXRTZWdtZW50O1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxJbmZvLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIC8vIENoZWNrIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICAgIHZhciBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCkge1xuICAgICAgICBpZiAoIWlzTWVkaWFGcmFnbWVudChmcmFnKSkge1xuICAgICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgICAgIHRoaXMubG9nKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgaXMgYmVpbmcgZG93bmxvYWRlZCB0byB0ZXN0IGJpdHJhdGUgYW5kIHdpbGwgbm90IGJlIGJ1ZmZlcmVkXCIpO1xuICAgICAgICAgIHRoaXMuX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZywgbGV2ZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUubG9hZEZyYWdtZW50LmNhbGwodGhpcywgZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldEJ1ZmZlcmVkRnJhZyA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgfTtcbiAgICBfcHJvdG8uZm9sbG93aW5nQnVmZmVyZWRGcmFnID0gZnVuY3Rpb24gZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kICsgMC41KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qXG4gICAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICAgKi87XG4gICAgX3Byb3RvLmltbWVkaWF0ZUxldmVsU3dpdGNoID0gZnVuY3Rpb24gaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKSB7XG4gICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2s6XG4gICAgICogaW4gb3JkZXIgdG8gZW5zdXJlIHNtb290aCBidXQgcXVpY2sgbGV2ZWwgc3dpdGNoaW5nLFxuICAgICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAgICogd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICAgKi87XG4gICAgX3Byb3RvLm5leHRMZXZlbFN3aXRjaCA9IGZ1bmN0aW9uIG5leHRMZXZlbFN3aXRjaCgpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICAgIGlmIChtZWRpYSAhPSBudWxsICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgdmFyIGZldGNoZGVsYXk7XG4gICAgICAgIHZhciBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0ID4gMSkge1xuICAgICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAgICAgLy8gbWludXMgMXMgdG8gYXZvaWQgdmlkZW8gZnJlZXppbmcsIHRoYXQgY291bGQgaGFwcGVuIGlmIHdlIGZsdXNoIGtleWZyYW1lIG9mIGN1cnJlbnQgdmlkZW8gLi4uXG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMgIT0gbnVsbCAmJiBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgIHZhciBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAgIC8vIERvIG5vdCBmbHVzaCBpbiBsaXZlIHN0cmVhbSB3aXRoIGxvdyBidWZmZXJcbiAgICAgICAgICBpZiAoIWJ1ZmZlckluZm8gfHwgYnVmZmVySW5mby5sZW4gPCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWVkaWEucGF1c2VkICYmIGxldmVscykge1xuICAgICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICAgIHZhciBuZXh0TGV2ZWxJZCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWw7XG4gICAgICAgICAgdmFyIG5leHRMZXZlbCA9IGxldmVsc1tuZXh0TGV2ZWxJZF07XG4gICAgICAgICAgdmFyIGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuICAgICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgICAgZmV0Y2hkZWxheSA9IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwubWF4Qml0cmF0ZSAvICgxMDAwICogZnJhZ0xhc3RLYnBzKSArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgICAgdmFyIGJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICAgIGlmIChidWZmZXJlZEZyYWcpIHtcbiAgICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXG4gICAgICAgICAgdmFyIG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhidWZmZXJlZEZyYWcpO1xuICAgICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIGluIG5leHQgYnVmZmVyZWQgZnJhZy4gTGVhdmUgc29tZSBwYWRkaW5nIGZvciBub24taW5kZXBlbmRlbnQgc2VnbWVudHMgYW5kIHNtb290aGVyIHBsYXliYWNrLlxuICAgICAgICAgICAgdmFyIG1heFN0YXJ0ID0gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUyA/IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgOiBuZXh0QnVmZmVyZWRGcmFnLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIGZyYWdEdXJhdGlvbiA9IG5leHRCdWZmZXJlZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICB2YXIgc3RhcnRQdHMgPSBNYXRoLm1heChidWZmZXJlZEZyYWcuZW5kLCBtYXhTdGFydCArIE1hdGgubWluKE1hdGgubWF4KGZyYWdEdXJhdGlvbiAtIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdEdXJhdGlvbiAqICh0aGlzLmNvdWxkQmFja3RyYWNrID8gMC41IDogMC4xMjUpKSwgZnJhZ0R1cmF0aW9uICogKHRoaXMuY291bGRCYWNrdHJhY2sgPyAwLjc1IDogMC4yNSkpKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0UHRzLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFib3J0Q3VycmVudEZyYWcgPSBmdW5jdGlvbiBhYm9ydEN1cnJlbnRGcmFnKCkge1xuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnQ3VycmVudCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTdGF0ZS5LRVlfTE9BRElORzpcbiAgICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoTWFpbkJ1ZmZlciA9IGZ1bmN0aW9uIGZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmZsdXNoTWFpbkJ1ZmZlci5jYWxsKHRoaXMsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHRoaXMuYWx0QXVkaW8gPT09IDIgPyAndmlkZW8nIDogbnVsbCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFBdHRhY2hlZC5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKTtcbiAgICAgIHZhciBtZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG1lZGlhLCAncGxheWluZycsIHRoaXMub25NZWRpYVBsYXlpbmcpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3NlZWtlZCcsIHRoaXMub25NZWRpYVNlZWtlZCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3BsYXlpbmcnLCB0aGlzLm9uTWVkaWFQbGF5aW5nKTtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihtZWRpYSwgJ3NlZWtlZCcsIHRoaXMub25NZWRpYVNlZWtlZCk7XG4gICAgICB9XG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nLmNhbGwodGhpcywgZXZlbnQsIGRhdGEpO1xuICAgICAgdmFyIHRyYW5zZmVycmluZ01lZGlhID0gISFkYXRhLnRyYW5zZmVyTWVkaWE7XG4gICAgICBpZiAodHJhbnNmZXJyaW5nTWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFzRW5vdWdoVG9TdGFydCA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWFuaWZlc3RMb2FkaW5nLmNhbGwodGhpcyk7XG4gICAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgICAgdGhpcy5sb2coJ1RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHVuZGVmaW5lZCk7XG4gICAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gZmFsc2U7XG4gICAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IDA7XG4gICAgICB0aGlzLmZyYWdQbGF5aW5nID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICB0aGlzLmFsdEF1ZGlvID0gMDtcbiAgICAgIHRoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICB2YXIgYWFjID0gZmFsc2U7XG4gICAgICB2YXIgaGVhYWMgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGVjID0gZGF0YS5sZXZlbHNbaV0uYXVkaW9Db2RlYztcbiAgICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgICAgYWFjID0gYWFjIHx8IGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMTtcbiAgICAgICAgICBoZWFhYyA9IGhlYWFjIHx8IGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gYWFjICYmIGhlYWFjICYmICFjaGFuZ2VUeXBlU3VwcG9ydGVkKCk7XG4gICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgIHRoaXMubG9nKCdCb3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsTG9hZGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICBpZiAoIWxldmVscyB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5JRExFKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbCA9IGRhdGEubGV2ZWxJbmZvO1xuICAgICAgaWYgKCFsZXZlbC5kZXRhaWxzIHx8IGxldmVsLmRldGFpbHMubGl2ZSAmJiAodGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsIHx8IGxldmVsLmRldGFpbHMuZXhwaXJlZCkgfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKGxldmVsLmRldGFpbHMpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxMb2FkZWQgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgX2N1ckxldmVsJGRldGFpbHM7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIHN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkO1xuICAgICAgdmFyIG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICB2YXIgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICB0aGlzLndhcm4oXCJMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsIFwiICsgbmV3TGV2ZWxJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiTGV2ZWwgXCIgKyBuZXdMZXZlbElkICsgXCIgbG9hZGVkIFtcIiArIG5ld0RldGFpbHMuc3RhcnRTTiArIFwiLFwiICsgbmV3RGV0YWlscy5lbmRTTiArIFwiXVwiICsgKG5ld0RldGFpbHMubGFzdFBhcnRTbiA/IFwiW3BhcnQtXCIgKyBuZXdEZXRhaWxzLmxhc3RQYXJ0U24gKyBcIi1cIiArIG5ld0RldGFpbHMubGFzdFBhcnRJbmRleCArIFwiXVwiIDogJycpICsgXCIsIGNjIFtcIiArIG5ld0RldGFpbHMuc3RhcnRDQyArIFwiLCBcIiArIG5ld0RldGFpbHMuZW5kQ0MgKyBcIl0gZHVyYXRpb246XCIgKyBkdXJhdGlvbik7XG4gICAgICB2YXIgY3VyTGV2ZWwgPSBkYXRhLmxldmVsSW5mbztcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSkpIHtcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxldmVsICE9PSBkYXRhLmxldmVsICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2xpZGluZyA9IDA7XG4gICAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfY3VyTGV2ZWwkZGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHMpICE9IG51bGwgJiYgX2N1ckxldmVsJGRldGFpbHMubGl2ZSkge1xuICAgICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgICB0aGlzLmNoZWNrTGl2ZVVwZGF0ZShuZXdEZXRhaWxzKTtcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgY3VyTGV2ZWwuZGV0YWlscywgKF90aGlzJGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGV2ZWxMYXN0TG9hZGVkLmRldGFpbHMpO1xuICAgICAgfVxuICAgICAgLy8gb3ZlcnJpZGUgbGV2ZWwgaW5mb1xuICAgICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IGN1ckxldmVsO1xuICAgICAgaWYgKCFzdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfVVBEQVRFRCwge1xuICAgICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgICBsZXZlbDogbmV3TGV2ZWxJZFxuICAgICAgfSk7XG5cbiAgICAgIC8vIG9ubHkgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKG5ld0RldGFpbHMpKSB7XG4gICAgICAgICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRGcmFnUmVxdWVzdGVkICYmIG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplVG9MaXZlRWRnZShuZXdEZXRhaWxzKTtcbiAgICAgIH1cblxuICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3luY2hyb25pemVUb0xpdmVFZGdlID0gZnVuY3Rpb24gc3luY2hyb25pemVUb0xpdmVFZGdlKGxldmVsRGV0YWlscykge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICB2YXIgc3RhcnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRTdGFydDtcbiAgICAgIHZhciBlbmQgPSBsZXZlbERldGFpbHMuZWRnZTtcbiAgICAgIHZhciB3aXRoaW5TbGlkaW5nV2luZG93ID0gY3VycmVudFRpbWUgPj0gc3RhcnQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAmJiBjdXJyZW50VGltZSA8PSBlbmQ7XG4gICAgICAvLyBDb250aW51ZSBpZiB3ZSBjYW4gc2VlayBmb3J3YXJkIHRvIHN5bmMgcG9zaXRpb24gb3IgaWYgY3VycmVudCB0aW1lIGlzIG91dHNpZGUgb2Ygc2xpZGluZyB3aW5kb3dcbiAgICAgIGlmIChsaXZlU3luY1Bvc2l0aW9uICE9PSBudWxsICYmIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbiAmJiAoY3VycmVudFRpbWUgPCBsaXZlU3luY1Bvc2l0aW9uIHx8ICF3aXRoaW5TbGlkaW5nV2luZG93KSkge1xuICAgICAgICAvLyBDb250aW51ZSBpZiBidWZmZXIgaXMgc3RhcnZpbmcgb3IgaWYgY3VycmVudCB0aW1lIGlzIGJlaGluZCBtYXggbGF0ZW5jeVxuICAgICAgICB2YXIgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICAgIGlmICghd2l0aGluU2xpZGluZ1dpbmRvdyAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgNCB8fCBjdXJyZW50VGltZSA8IGVuZCAtIG1heExhdGVuY3kpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhc0Vub3VnaFRvU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9ubHkgc2VlayBpZiByZWFkeSBhbmQgdGhlcmUgaXMgbm90IGEgc2lnbmlmaWNhbnQgZm9yd2FyZCBidWZmZXIgYXZhaWxhYmxlIGZvciBwbGF5YmFja1xuICAgICAgICAgIGlmIChtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJQbGF5YmFjazogXCIgKyBjdXJyZW50VGltZS50b0ZpeGVkKDMpICsgXCIgaXMgbG9jYXRlZCB0b28gZmFyIGZyb20gdGhlIGVuZCBvZiBsaXZlIHNsaWRpbmcgcGxheWxpc3Q6IFwiICsgZW5kICsgXCIsIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogXCIgKyBsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxpdmVTeW5jTW9kZSA9PT0gJ2J1ZmZlcmVkJykge1xuICAgICAgICAgICAgICB2YXIgX2J1ZmZlckluZm8kYnVmZmVyZWQ7XG4gICAgICAgICAgICAgIHZhciBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGxpdmVTeW5jUG9zaXRpb24sIDApO1xuICAgICAgICAgICAgICBpZiAoISgoX2J1ZmZlckluZm8kYnVmZmVyZWQgPSBidWZmZXJJbmZvLmJ1ZmZlcmVkKSAhPSBudWxsICYmIF9idWZmZXJJbmZvJGJ1ZmZlcmVkLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpc0xpdmVTeW5jSW5CdWZmZXIgPSBidWZmZXJJbmZvLnN0YXJ0IDw9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICBpZiAoaXNMaXZlU3luY0luQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgX0J1ZmZlckhlbHBlciRidWZmZXJlID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyhidWZmZXJJbmZvLmJ1ZmZlcmVkLCBjdXJyZW50VGltZSwgMCksXG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gX0J1ZmZlckhlbHBlciRidWZmZXJlLm5leHRTdGFydDtcbiAgICAgICAgICAgICAgaWYgKG5leHRTdGFydCkge1xuICAgICAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpIHtcbiAgICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgdmFyIHBhcnQgPSBkYXRhLnBhcnQsXG4gICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICB0aGlzLndhcm4oXCJMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBmcmFnbWVudCBsb2FkIHdhcyBpbiBwcm9ncmVzcy4gRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgd2lsbCBub3QgYmUgYnVmZmVyZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBpZiAoIWN1cnJlbnRMZXZlbCkge1xuICAgICAgICB0aGlzLndhcm4oXCJMZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBub3QgZm91bmQgb24gcHJvZ3Jlc3NcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkZXRhaWxzID0gY3VycmVudExldmVsLmRldGFpbHM7XG4gICAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiRHJvcHBpbmcgZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgYWZ0ZXIgbGV2ZWwgZGV0YWlscyB3ZXJlIHJlc2V0XCIpO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHZpZGVvQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcblxuICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgICB2YXIgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgICAgdmFyIGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuICAgICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7XG5cbiAgICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAgIC8vIHRoaXMubG9nKGBUcmFuc211eGluZyAke2ZyYWcuc259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7ZnJhZy5sZXZlbH0sIGNjICR7ZnJhZy5jY31gKTtcbiAgICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyIHx8IG5ldyBUcmFuc211eGVySW50ZXJmYWNlKHRoaXMuaGxzLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOLCB0aGlzLl9oYW5kbGVUcmFuc211eENvbXBsZXRlLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaC5iaW5kKHRoaXMpKTtcbiAgICAgIHZhciBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgICAgdmFyIHBhcnRpYWwgPSBwYXJ0SW5kZXggIT09IC0xO1xuICAgICAgdmFyIGNodW5rTWV0YSA9IG5ldyBDaHVua01ldGFkYXRhKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCwgcGF5bG9hZC5ieXRlTGVuZ3RoLCBwYXJ0SW5kZXgsIHBhcnRpYWwpO1xuICAgICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFNbZnJhZy5jY107XG4gICAgICB0cmFuc211eGVyLnB1c2gocGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgICAgdmFyIGZyb21BbHRBdWRpbyA9IHRoaXMuYWx0QXVkaW8gIT09IDA7XG4gICAgICB2YXIgYWx0QXVkaW8gPSB1c2VBbHRlcm5hdGVBdWRpbyhkYXRhLnVybCwgaGxzKTtcbiAgICAgIC8vIGlmIHdlIHN3aXRjaCBvbiBtYWluIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggbWVkaWEuYnVmZmVyZWRcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgICAgLy8gd2Ugd2lsbCBqdXN0IGhhdmUgdG8gY2hhbmdlIGJ1ZmZlciBzY2hlZHVsaW5nIG9uIGF1ZGlvVHJhY2tTd2l0Y2hlZFxuICAgICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWdDdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZGVzdHJveSB0cmFuc211eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hdWRpb09ubHkpIHtcbiAgICAgICAgICAvLyBSZXNldCBhdWRpbyB0cmFuc211eGVyIHNvIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gbWFpbiBhdWRpbyB3ZSdyZSBub3Qgc3RpbGwgYXBwZW5kaW5nIHdoZXJlIHdlIGxlZnQgb2ZmXG4gICAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBzd2l0Y2hpbmcgZnJvbSBhbHQgdG8gbWFpbiBhdWRpbywgZmx1c2ggYWxsIGF1ZGlvIGFuZCB0cmlnZ2VyIHRyYWNrIHN3aXRjaGVkXG4gICAgICAgIGlmIChmcm9tQWx0QXVkaW8pIHtcbiAgICAgICAgICB0aGlzLmFsdEF1ZGlvID0gMDtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgICAgICBobHMub25jZShFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMyLmhscykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpczIuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICAgIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgdHlwZTogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hbHRBdWRpbyA9IDE7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25BdWRpb1RyYWNrU3dpdGNoZWQgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tTd2l0Y2hlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGFsdEF1ZGlvID0gdXNlQWx0ZXJuYXRlQXVkaW8oZGF0YS51cmwsIHRoaXMuaGxzKTtcbiAgICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgICB2YXIgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgICAvLyBpZiB3ZSBzd2l0Y2hlZCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcbiAgICAgICAgaWYgKHZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHZpZGVvQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBvbiBhbHRlcm5hdGUgYXVkaW8sIHVzZSB2aWRlby5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWx0QXVkaW8gPSBhbHRBdWRpbyA/IDIgOiAwO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3M7XG4gICAgICB2YXIgbWVkaWFUcmFjaztcbiAgICAgIHZhciBuYW1lO1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICAgIG5hbWUgPSB0eXBlO1xuICAgICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHZhciB2aWRlb1RyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKHZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHZpZGVvVHJhY2suYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgICAgdGhpcy5sb2coXCJBbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSBcIiArIG5hbWUgKyBcIi5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdcIik7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuICAgICAgdmFyIGJ1ZmZlcmVkTWFpbkZyYWdtZW50ID0gZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICAgICAgaWYgKGJ1ZmZlcmVkTWFpbkZyYWdtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICAgIC8vIElmIGEgbGV2ZWwgc3dpdGNoIHdhcyByZXF1ZXN0ZWQgd2hpbGUgYSBmcmFnbWVudCB3YXMgYnVmZmVyaW5nLCBpdCB3aWxsIGVtaXQgdGhlIEZSQUdfQlVGRkVSRUQgZXZlbnQgdXBvbiBjb21wbGV0aW9uXG4gICAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBzdGF0ZSBiYWNrIHRvIElETEUsIHNpbmNlIHRoYXQgd2lsbCBpbnRlcmZlcmUgd2l0aCBhIGxldmVsIHN3aXRjaFxuICAgICAgICAgIHRoaXMud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlKTtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBzdGF0cy50b3RhbCAvIChzdGF0cy5idWZmZXJpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5maXJzdCkpO1xuICAgICAgICBpZiAoaXNNZWRpYUZyYWdtZW50KGZyYWcpKSB7XG4gICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKCFtZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgJiYgQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5faGFzRW5vdWdoVG9TdGFydCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2Vla1RvU3RhcnRQb3MoKTtcbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXJlZE1haW5GcmFnbWVudCkge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9kYXRhJGNvbnRleHQ7XG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfR0FQOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIGxldmVsLCBpZiBsZXZlbCBjb250cm9sbGVyIGlzIG5vdCByZXRyeWluZyB0byBsb2FkIGxldmVsLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgICAgaWYgKCFkYXRhLmxldmVsUmV0cnkgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCAmJiAoKF9kYXRhJGNvbnRleHQgPSBkYXRhLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRjb250ZXh0LnR5cGUpID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I6XG4gICAgICAgICAgaWYgKGRhdGEucGFyZW50ICE9PSAnbWFpbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICAgIGlmIChkYXRhLnBhcmVudCAhPT0gJ21haW4nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICB2YXIgaXNBc3NldFBsYXllciA9ICF0aGlzLmNvbmZpZy5pbnRlcnN0aXRpYWxzQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5hc3NldFBsYXllcklkO1xuICAgICAgICAgICAgaWYgKGlzQXNzZXRQbGF5ZXIpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIGN1cnJlbnRUaW1lIGluIGJ1ZmZlciBlc3RpbWF0ZSB0byBwcmV2ZW50IGxvYWRpbmcgbW9yZSB1bnRpbCBwbGF5YmFjayBhZHZhbmNlc1xuICAgICAgICAgICAgICB0aGlzLl9oYXNFbm91Z2hUb1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT046XG4gICAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICAgIGlmICghdGhpcy5faGFzRW5vdWdoVG9TdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uQnVmZmVyRmx1c2hlZCA9IGZ1bmN0aW9uIG9uQnVmZmVyRmx1c2hlZChldmVudCwgX3JlZikge1xuICAgICAgdmFyIHR5cGUgPSBfcmVmLnR5cGU7XG4gICAgICBpZiAodHlwZSAhPT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIHx8ICF0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgIHZhciBtZWRpYUJ1ZmZlciA9ICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbHNVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbHNVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbCA+IC0xICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5sZXZlbCA9IHRoaXMuZnJhZ0N1cnJlbnQubGV2ZWw7XG4gICAgICAgIGlmICh0aGlzLmxldmVsID09PSAtMSkge1xuICAgICAgICAgIHRoaXMucmVzZXRXaGVuTWlzc2luZ0NvbnRleHQodGhpcy5mcmFnQ3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgfTtcbiAgICBfcHJvdG8uc3dhcEF1ZGlvQ29kZWMgPSBmdW5jdGlvbiBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAgICovO1xuICAgIF9wcm90by5zZWVrVG9TdGFydFBvcyA9IGZ1bmN0aW9uIHNlZWtUb1N0YXJ0UG9zKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIC8vIG9ubHkgYWRqdXN0IGN1cnJlbnRUaW1lIGlmIGRpZmZlcmVudCBmcm9tIHN0YXJ0UG9zaXRpb24gb3IgaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXG4gICAgICBpZiAoc3RhcnRQb3NpdGlvbiA+PSAwICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRQb3NpdGlvbikge1xuICAgICAgICBpZiAobWVkaWEuc2Vla2luZykge1xuICAgICAgICAgIHRoaXMubG9nKFwiY291bGQgbm90IHNlZWsgdG8gXCIgKyBzdGFydFBvc2l0aW9uICsgXCIsIGFscmVhZHkgc2Vla2luZyBhdCBcIiArIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPZmZzZXQgc3RhcnQgcG9zaXRpb24gYnkgdGltZWxpbmUgb2Zmc2V0XG4gICAgICAgIHZhciB0aW1lbGluZU9mZnNldCA9IHRoaXMudGltZWxpbmVPZmZzZXQ7XG4gICAgICAgIGlmICh0aW1lbGluZU9mZnNldCAmJiBzdGFydFBvc2l0aW9uKSB7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiArPSB0aW1lbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICAgIHZhciBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICAgIHZhciBidWZmZXJTdGFydCA9IGJ1ZmZlcmVkLmxlbmd0aCA/IGJ1ZmZlcmVkLnN0YXJ0KDApIDogMDtcbiAgICAgICAgdmFyIGRlbHRhID0gYnVmZmVyU3RhcnQgLSBzdGFydFBvc2l0aW9uO1xuICAgICAgICB2YXIgc2tpcFRvbGVyYW5jZSA9IE1hdGgubWF4KHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuc3RhcnRPblNlZ21lbnRCb3VuZGFyeSB8fCBkZWx0YSA+IDAgJiYgKGRlbHRhIDwgc2tpcFRvbGVyYW5jZSB8fCB0aGlzLmxvYWRpbmdQYXJ0cyAmJiBkZWx0YSA8IDIgKiAoKGRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGRldGFpbHMucGFydFRhcmdldCkgfHwgMCkpKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJhZGp1c3Rpbmcgc3RhcnQgcG9zaXRpb24gYnkgXCIgKyBkZWx0YSArIFwiIHRvIG1hdGNoIGJ1ZmZlciBzdGFydFwiKTtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uICs9IGRlbHRhO1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgc3RhcnRQb3NpdGlvbikge1xuICAgICAgICAgIHRoaXMubG9nKFwic2VlayB0byB0YXJnZXQgc3RhcnQgcG9zaXRpb24gXCIgKyBzdGFydFBvc2l0aW9uICsgXCIgZnJvbSBjdXJyZW50IHRpbWUgXCIgKyBjdXJyZW50VGltZSArIFwiIGJ1ZmZlciBzdGFydCBcIiArIGJ1ZmZlclN0YXJ0KTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5fZ2V0QXVkaW9Db2RlYyA9IGZ1bmN0aW9uIF9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCkge1xuICAgICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2FwICYmIGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5sb2coJ1N3YXBwaW5nIGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhdWRpb0NvZGVjO1xuICAgIH07XG4gICAgX3Byb3RvLl9sb2FkQml0cmF0ZVRlc3RGcmFnID0gZnVuY3Rpb24gX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZ21lbnQsIGxldmVsKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGZyYWdtZW50LmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZ21lbnQsIGxldmVsKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBobHMgPSBfdGhpczMuaGxzO1xuICAgICAgICB2YXIgZnJhZyA9IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZnJhZztcbiAgICAgICAgaWYgKCFmcmFnIHx8IF90aGlzMy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICAgIF90aGlzMy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIF90aGlzMy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICAgIC8vIEJpdHJhdGUgdGVzdHMgZnJhZ21lbnRzIGFyZSBuZWl0aGVyIHBhcnNlZCBub3IgYnVmZmVyZWRcbiAgICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHN0YXRzLnBhcnNpbmcuZW5kID0gc3RhdHMuYnVmZmVyaW5nLnN0YXJ0ID0gc3RhdHMuYnVmZmVyaW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKF90aGlzMy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCBfdGhpczMuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMy53YXJuKHJlYXNvbik7XG4gICAgICAgIF90aGlzMy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnbWVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVUcmFuc211eENvbXBsZXRlKHRyYW5zbXV4UmVzdWx0KSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLnBsYXlsaXN0VHlwZTtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHZhciByZW11eFJlc3VsdCA9IHRyYW5zbXV4UmVzdWx0LnJlbXV4UmVzdWx0LFxuICAgICAgICBjaHVua01ldGEgPSB0cmFuc211eFJlc3VsdC5jaHVua01ldGE7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWw7XG4gICAgICB2YXIgdmlkZW8gPSByZW11eFJlc3VsdC52aWRlbyxcbiAgICAgICAgdGV4dCA9IHJlbXV4UmVzdWx0LnRleHQsXG4gICAgICAgIGlkMyA9IHJlbXV4UmVzdWx0LmlkMyxcbiAgICAgICAgaW5pdFNlZ21lbnQgPSByZW11eFJlc3VsdC5pbml0U2VnbWVudDtcbiAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgIC8vIFRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBoYW5kbGVzIGF1ZGlvIGJ1ZmZlcmluZyBpZiBIbHMuanMgaXMgcGxheWluZyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICAgIHZhciBhdWRpbyA9IHRoaXMuYWx0QXVkaW8gPyB1bmRlZmluZWQgOiByZW11eFJlc3VsdC5hdWRpbztcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgIC8vIElmIHdlIGFyZSwgc3Vic2VxdWVudGx5IGNoZWNrIGlmIHRoZSBjdXJyZW50bHkgbG9hZGluZyBmcmFnbWVudCAoZnJhZ0N1cnJlbnQpIGhhcyBjaGFuZ2VkLlxuICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgICB2YXIgdHJhY2tzID0gaW5pdFNlZ21lbnQudHJhY2tzO1xuICAgICAgICBpZiAodHJhY2tzKSB7XG4gICAgICAgICAgdmFyIG1hcEZyYWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCB8fCBmcmFnO1xuICAgICAgICAgIGlmICh0aGlzLnVuaGFuZGxlZEVuY3J5cHRpb25FcnJvcihpbml0U2VnbWVudCwgZnJhZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIHRyYWNrcywgbWFwRnJhZ21lbnQsIGNodW5rTWV0YSk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHtcbiAgICAgICAgICAgIGZyYWc6IG1hcEZyYWdtZW50LFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgdHJhY2tzOiB0cmFja3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVRpbWUgPSBpbml0U2VnbWVudC5pbml0UFRTO1xuICAgICAgICB2YXIgdGltZXNjYWxlID0gaW5pdFNlZ21lbnQudGltZXNjYWxlO1xuICAgICAgICB2YXIgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGJhc2VUaW1lKSAmJiAoIWluaXRQVFMgfHwgaW5pdFBUUy5iYXNlVGltZSAhPT0gYmFzZVRpbWUgfHwgaW5pdFBUUy50aW1lc2NhbGUgIT09IHRpbWVzY2FsZSkpIHtcbiAgICAgICAgICB2YXIgdHJhY2tJZCA9IGluaXRTZWdtZW50LnRyYWNrSWQ7XG4gICAgICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0ge1xuICAgICAgICAgICAgYmFzZVRpbWU6IGJhc2VUaW1lLFxuICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgICB0cmFja0lkOiB0cmFja0lkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpbml0UFRTOiBiYXNlVGltZSxcbiAgICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlLFxuICAgICAgICAgICAgdHJhY2tJZDogdHJhY2tJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEF2b2lkIGJ1ZmZlcmluZyBpZiBiYWNrdHJhY2tpbmcgdGhpcyBmcmFnbWVudFxuICAgICAgaWYgKHZpZGVvICYmIGRldGFpbHMpIHtcbiAgICAgICAgaWYgKGF1ZGlvICYmIHZpZGVvLnR5cGUgPT09ICdhdWRpb3ZpZGVvJykge1xuICAgICAgICAgIHRoaXMubG9nTXV4ZWRFcnIoZnJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZGcmFnID0gZGV0YWlscy5mcmFnbWVudHNbZnJhZy5zbiAtIDEgLSBkZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICB2YXIgaXNGaXJzdEZyYWdtZW50ID0gZnJhZy5zbiA9PT0gZGV0YWlscy5zdGFydFNOO1xuICAgICAgICB2YXIgaXNGaXJzdEluRGlzY29udGludWl0eSA9ICFwcmV2RnJhZyB8fCBmcmFnLmNjID4gcHJldkZyYWcuY2M7XG4gICAgICAgIGlmIChyZW11eFJlc3VsdC5pbmRlcGVuZGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgc3RhcnRQVFMgPSB2aWRlby5zdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUyA9IHZpZGVvLmVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTID0gdmlkZW8uc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFMgPSB2aWRlby5lbmREVFM7XG4gICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbdmlkZW8udHlwZV0gPSB7XG4gICAgICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydFBUUyxcbiAgICAgICAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgICAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgICAgICAgICAgZW5kRFRTOiBlbmREVFNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2aWRlby5maXJzdEtleUZyYW1lICYmIHZpZGVvLmluZGVwZW5kZW50ICYmIGNodW5rTWV0YS5pZCA9PT0gMSAmJiAhaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlby5kcm9wcGVkICYmIHZpZGVvLmluZGVwZW5kZW50KSB7XG4gICAgICAgICAgICAgIC8vIEJhY2t0cmFjayBpZiBkcm9wcGVkIGZyYW1lcyBjcmVhdGUgYSBnYXAgYWZ0ZXIgY3VycmVudFRpbWVcblxuICAgICAgICAgICAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgICAgICAgICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSAoYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8uZW5kIDogdGhpcy5nZXRMb2FkUG9zaXRpb24oKSkgKyB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA/IHZpZGVvLmZpcnN0S2V5RnJhbWVQVFMgOiBzdGFydFBUUztcbiAgICAgICAgICAgICAgaWYgKCFpc0ZpcnN0RnJhZ21lbnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHN0YXJ0VGltZSAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgc2VnbWVudCB3aXRoIGEgZ2FwIHRvIGF2b2lkIGxvb3AgbG9hZGluZ1xuICAgICAgICAgICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBTZXQgdmlkZW8gc3RyZWFtIHN0YXJ0IHRvIGZyYWdtZW50IHN0YXJ0IHNvIHRoYXQgdHJ1bmNhdGVkIHNhbXBsZXMgZG8gbm90IGRpc3RvcnQgdGhlIHRpbWVsaW5lLCBhbmQgbWFyayBpdCBwYXJ0aWFsXG4gICAgICAgICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odmlkZW8udHlwZSwgZnJhZy5zdGFydCwgZW5kUFRTLCBmcmFnLnN0YXJ0LCBlbmREVFMsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0RnJhZ21lbnQgJiYgc3RhcnRQVFMgLSAoZGV0YWlscy5hcHBsaWVkVGltZWxpbmVPZmZzZXQgfHwgMCkgPiBNQVhfU1RBUlRfR0FQX0pVTVApIHtcbiAgICAgICAgICAgICAgLy8gTWFyayBzZWdtZW50IHdpdGggYSBnYXAgdG8gc2tpcCBsYXJnZSBzdGFydCBnYXBcbiAgICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHZpZGVvLnR5cGUsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gZnJhZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEodmlkZW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSwgaXNGaXJzdEZyYWdtZW50IHx8IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmlyc3RGcmFnbWVudCB8fCBpc0ZpcnN0SW5EaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgLy8gTWFyayBzZWdtZW50IHdpdGggYSBnYXAgdG8gYXZvaWQgbG9vcCBsb2FkaW5nXG4gICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYmFja3RyYWNrKGZyYWcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvKSB7XG4gICAgICAgIHZhciBfc3RhcnRQVFMgPSBhdWRpby5zdGFydFBUUyxcbiAgICAgICAgICBfZW5kUFRTID0gYXVkaW8uZW5kUFRTLFxuICAgICAgICAgIF9zdGFydERUUyA9IGF1ZGlvLnN0YXJ0RFRTLFxuICAgICAgICAgIF9lbmREVFMgPSBhdWRpby5lbmREVFM7XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0ge1xuICAgICAgICAgICAgc3RhcnRQVFM6IF9zdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUzogX2VuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTOiBfc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFM6IF9lbmREVFNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBfc3RhcnRQVFMsIF9lbmRQVFMsIF9zdGFydERUUywgX2VuZERUUyk7XG4gICAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgICAgaWYgKGRldGFpbHMgJiYgaWQzICE9IG51bGwgJiYgaWQzLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbWl0dGVkSUQzID0ge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgc2FtcGxlczogaWQzLnNhbXBsZXNcbiAgICAgICAgfTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZW1pdHRlZElEMyk7XG4gICAgICB9XG4gICAgICBpZiAoZGV0YWlscyAmJiB0ZXh0KSB7XG4gICAgICAgIHZhciBlbWl0dGVkVGV4dCA9IHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgIHNhbXBsZXM6IHRleHQuc2FtcGxlc1xuICAgICAgICB9O1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCBlbWl0dGVkVGV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9nTXV4ZWRFcnIgPSBmdW5jdGlvbiBsb2dNdXhlZEVycihmcmFnKSB7XG4gICAgICB0aGlzLndhcm4oKGlzTWVkaWFGcmFnbWVudChmcmFnKSA/ICdNZWRpYScgOiAnSW5pdCcpICsgXCIgc2VnbWVudCB3aXRoIG11eGVkIGF1ZGlvdmlkZW8gd2hlcmUgb25seSB2aWRlbyBleHBlY3RlZDogXCIgKyBmcmFnLnVybCk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2J1ZmZlckluaXRTZWdtZW50ID0gZnVuY3Rpb24gX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdWRpb09ubHkgPSAhIXRyYWNrcy5hdWRpbyAmJiAhdHJhY2tzLnZpZGVvO1xuXG4gICAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvICYmICF0aGlzLmF1ZGlvT25seSkge1xuICAgICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgICAgICBpZiAodHJhY2tzLmF1ZGlvdmlkZW8pIHtcbiAgICAgICAgICB0aGlzLmxvZ011eGVkRXJyKGZyYWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdmFyIGF1ZGlvID0gdHJhY2tzLmF1ZGlvLFxuICAgICAgICB2aWRlbyA9IHRyYWNrcy52aWRlbyxcbiAgICAgICAgYXVkaW92aWRlbyA9IHRyYWNrcy5hdWRpb3ZpZGVvO1xuICAgICAgaWYgKGF1ZGlvKSB7XG4gICAgICAgIHZhciBsZXZlbENvZGVjID0gY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgIHZhciBhdWRpb0NvZGVjID0gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZShhdWRpby5jb2RlYywgbGV2ZWxDb2RlYyk7XG4gICAgICAgIC8vIEFkZCBsZXZlbCBhbmQgcHJvZmlsZSB0byBtYWtlIHVwIGZvciByZW11eGVyIG5vdCBiZWluZyBhYmxlIHRvIHBhcnNlIGZ1bGwgY29kZWNcbiAgICAgICAgLy8gKGxvZ2dlciB3YXJuaW5nIFwiVW5oYW5kbGVkIGF1ZGlvIGNvZGVjLi4uXCIpXG4gICAgICAgIGlmIChhdWRpb0NvZGVjID09PSAnbXA0YScpIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGBhdWRpb0NvZGVjU3dpdGNoYFxuICAgICAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCBBQUMgYW5kIEhFLUFBQyBhdWRpbyBjb2RlY3MgYXJlIHNpZ25hbGxlZCBpbiBtYW5pZmVzdCxcbiAgICAgICAgICAvLyBmb3JjZSBIRS1BQUMsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIGl0LlxuICAgICAgICAgIC8vIGRvbid0IGZvcmNlIEhFLUFBQyBpZiBtb25vIHN0cmVhbSwgb3IgaW4gRmlyZWZveFxuICAgICAgICAgIHZhciBhdWRpb01ldGFkYXRhID0gYXVkaW8ubWV0YWRhdGE7XG4gICAgICAgICAgaWYgKGF1ZGlvTWV0YWRhdGEgJiYgJ2NoYW5uZWxDb3VudCcgaW4gYXVkaW9NZXRhZGF0YSAmJiAoYXVkaW9NZXRhZGF0YS5jaGFubmVsQ291bnQgfHwgMSkgIT09IDEgJiYgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG4gICAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xICYmIHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgYXVkaW8uY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgICAgICAvLyBFeGNsdWRlIG1wZWcgYXVkaW9cbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgdGhpcy5sb2coXCJBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byBcIiArIGF1ZGlvQ29kZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbENvZGVjICYmIGxldmVsQ29kZWMgIT09IGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcIlN3YXBwaW5nIG1hbmlmZXN0IGF1ZGlvIGNvZGVjIFxcXCJcIiArIGxldmVsQ29kZWMgKyBcIlxcXCIgZm9yIFxcXCJcIiArIGF1ZGlvQ29kZWMgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXVkaW8ubGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICAgIGF1ZGlvLmlkID0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTjtcbiAgICAgICAgdGhpcy5sb2coXCJJbml0IGF1ZGlvIGJ1ZmZlciwgY29udGFpbmVyOlwiICsgYXVkaW8uY29udGFpbmVyICsgXCIsIGNvZGVjc1tzZWxlY3RlZC9sZXZlbC9wYXJzZWRdPVtcIiArIChhdWRpb0NvZGVjIHx8ICcnKSArIFwiL1wiICsgKGxldmVsQ29kZWMgfHwgJycpICsgXCIvXCIgKyBhdWRpby5jb2RlYyArIFwiXVwiKTtcbiAgICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpb3ZpZGVvO1xuICAgICAgfVxuICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgIHZpZGVvLmxldmVsQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcbiAgICAgICAgdmlkZW8uaWQgPSBQbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICAgICAgICB2YXIgcGFyc2VkVmlkZW9Db2RlYyA9IHZpZGVvLmNvZGVjO1xuICAgICAgICBpZiAoKHBhcnNlZFZpZGVvQ29kZWMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlZFZpZGVvQ29kZWMubGVuZ3RoKSA9PT0gNCkge1xuICAgICAgICAgIC8vIE1ha2UgdXAgZm9yIHBhc3N0aHJvdWdoLXJlbXV4ZXIgbm90IGJlaW5nIGFibGUgdG8gcGFyc2UgZnVsbCBjb2RlY1xuICAgICAgICAgIC8vIChsb2dnZXIgd2FybmluZyBcIlVuaGFuZGxlZCB2aWRlbyBjb2RlYy4uLlwiKVxuICAgICAgICAgIHN3aXRjaCAocGFyc2VkVmlkZW9Db2RlYykge1xuICAgICAgICAgICAgY2FzZSAnaHZjMSc6XG4gICAgICAgICAgICBjYXNlICdoZXYxJzpcbiAgICAgICAgICAgICAgdmlkZW8uY29kZWMgPSAnaHZjMS4xLjYuTDEyMC45MCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXYwMSc6XG4gICAgICAgICAgICAgIHZpZGVvLmNvZGVjID0gJ2F2MDEuMC4wNE0uMDgnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F2YzEnOlxuICAgICAgICAgICAgICB2aWRlby5jb2RlYyA9ICdhdmMxLjQyZTAxZSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZyhcIkluaXQgdmlkZW8gYnVmZmVyLCBjb250YWluZXI6XCIgKyB2aWRlby5jb250YWluZXIgKyBcIiwgY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgKGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjIHx8ICcnKSArIFwiL1wiICsgcGFyc2VkVmlkZW9Db2RlYyArIFwiXVwiICsgKHZpZGVvLmNvZGVjICE9PSBwYXJzZWRWaWRlb0NvZGVjID8gJyBwYXJzZWQtY29ycmVjdGVkPScgKyB2aWRlby5jb2RlYyA6ICcnKSArICh2aWRlby5zdXBwbGVtZW50YWwgPyAnIHN1cHBsZW1lbnRhbD0nICsgdmlkZW8uc3VwcGxlbWVudGFsIDogJycpKTtcbiAgICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpb3ZpZGVvO1xuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvdmlkZW8pIHtcbiAgICAgICAgdGhpcy5sb2coXCJJbml0IGF1ZGlvdmlkZW8gYnVmZmVyLCBjb250YWluZXI6XCIgKyBhdWRpb3ZpZGVvLmNvbnRhaW5lciArIFwiLCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bXCIgKyBjdXJyZW50TGV2ZWwuY29kZWNzICsgXCIvXCIgKyBhdWRpb3ZpZGVvLmNvZGVjICsgXCJdXCIpO1xuICAgICAgICBkZWxldGUgdHJhY2tzLnZpZGVvO1xuICAgICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgICAgfVxuICAgICAgdmFyIHRyYWNrVHlwZXMgPSBPYmplY3Qua2V5cyh0cmFja3MpO1xuICAgICAgaWYgKHRyYWNrVHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgICAvLyBFeGl0IGFmdGVyIGZhdGFsIHRyYWNrcyBlcnJvclxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICAgICAgdHJhY2tUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpczQuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHtcbiAgICAgICAgICAgICAgdHlwZTogdHJhY2tOYW1lLFxuICAgICAgICAgICAgICBkYXRhOiBpbml0U2VnbWVudCxcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8gPSBmdW5jdGlvbiBnZXRNYWluRndkQnVmZmVySW5mbygpIHtcbiAgICAgIC8vIE9ic2VydmUgdmlkZW8gU291cmNlQnVmZmVyICh0aGlzLm1lZGlhQnVmZmVyKSBvbmx5IHdoZW4gYWx0LWF1ZGlvIGlzIHVzZWQsIG90aGVyd2lzZSBvYnNlcnZlIGNvbWJpbmVkIG1lZGlhIGJ1ZmZlclxuICAgICAgdmFyIGJ1ZmZlck91dHB1dCA9IHRoaXMubWVkaWFCdWZmZXIgJiYgdGhpcy5hbHRBdWRpbyA9PT0gMiA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mbyhidWZmZXJPdXRwdXQsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIH07XG4gICAgX3Byb3RvLmJhY2t0cmFjayA9IGZ1bmN0aW9uIGJhY2t0cmFjayhmcmFnKSB7XG4gICAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayB0aHJvdWdoIGZyYWdtZW50cyB0byBmaW5kIHRoZSBrZXlmcmFtZVxuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgdGhpcy5mbHVzaEJ1ZmZlckdhcChmcmFnKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrRnJhZ21lbnRDaGFuZ2VkID0gZnVuY3Rpb24gY2hlY2tGcmFnbWVudENoYW5nZWQoKSB7XG4gICAgICB2YXIgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgICAgdmFyIGZyYWdQbGF5aW5nQ3VycmVudCA9IG51bGw7XG4gICAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDEgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgICAoYXNzdW1pbmcgdGhhdCBwbGF5YmFjayByYXRlIGlzIHBvc2l0aXZlIC4uLilcbiAgICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICAgIHdyb25nIHBvc2l0aW9uIGFmdGVyIGEgbWVkaWEgZGVjb2RlIGVycm9yXG4gICAgICAgICovXG5cbiAgICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lICsgMC4xKSkge1xuICAgICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICAgIHdoZW4gZmlyc3QgdmlkZW8gZnJhbWUgaXMgZGlzcGxheWVkIGFuZCBwbGF5YmFjayBpcyBwYXVzZWQuXG4gICAgICAgICAgICBhZGQgYSB0b2xlcmFuY2Ugb2YgMTAwbXMsIGluIGNhc2UgY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsXG4gICAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgICBmb3IgRlJBR19DSEFOR0VEIGV2ZW50IHJlcG9ydGluZyAqL1xuICAgICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgdmFyIGZyYWdQbGF5aW5nID0gdGhpcy5mcmFnUGxheWluZztcbiAgICAgICAgICB2YXIgZnJhZ0N1cnJlbnRMZXZlbCA9IGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcbiAgICAgICAgICBpZiAoIWZyYWdQbGF5aW5nIHx8IGZyYWdQbGF5aW5nQ3VycmVudC5zbiAhPT0gZnJhZ1BsYXlpbmcuc24gfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZ0N1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZ1BsYXlpbmdDdXJyZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZnJhZ1BsYXlpbmcgfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENIRUQsIHtcbiAgICAgICAgICAgICAgICBsZXZlbDogZnJhZ0N1cnJlbnRMZXZlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoU3RyZWFtQ29udHJvbGxlciwgW3tcbiAgICAgIGtleTogXCJoYXNFbm91Z2hUb1N0YXJ0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0Vub3VnaFRvU3RhcnQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1heEJ1ZmZlckxlbmd0aFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsc1tsZXZlbF07XG4gICAgICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxJbmZvLm1heEJpdHJhdGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0TGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgZnJhZyA9IHRoaXMubmV4dEJ1ZmZlcmVkRnJhZztcbiAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZy5sZXZlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImN1cnJlbnRGcmFnXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJG1lZGlhMjtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ1BsYXlpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcmFnUGxheWluZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSAoKF90aGlzJG1lZGlhMiA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYTIuY3VycmVudFRpbWUpIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3VycmVudFByb2dyYW1EYXRlVGltZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRtZWRpYTM7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9ICgoX3RoaXMkbWVkaWEzID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhMy5jdXJyZW50VGltZSkgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkpIHtcbiAgICAgICAgICB2YXIgZGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnIHx8IChkZXRhaWxzID8gZmluZEZyYWdtZW50QnlQVFMobnVsbCwgZGV0YWlscy5mcmFnbWVudHMsIGN1cnJlbnRUaW1lKSA6IG51bGwpO1xuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3JhbURhdGVUaW1lID0gZnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgICAgICAgICBpZiAocHJvZ3JhbURhdGVUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBlcG9jTXMgPSBwcm9ncmFtRGF0ZVRpbWUgKyAoY3VycmVudFRpbWUgLSBmcmFnLnN0YXJ0KSAqIDEwMDA7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShlcG9jTXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3VycmVudExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibmV4dEJ1ZmZlcmVkRnJhZ1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvcmNlU3RhcnRMb2FkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcmNlU3RhcnRMb2FkO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShCYXNlU3RyZWFtQ29udHJvbGxlcik7XG5cbiAgdmFyIEtleUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvZ2dlcikge1xuICAgIGZ1bmN0aW9uIEtleUxvYWRlcihjb25maWcsIGxvZ2dlcikge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfTG9nZ2VyLmNhbGwodGhpcywgJ2tleS1sb2FkZXInLCBsb2dnZXIpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5rZXlJZFRvS2V5SW5mbyA9IHt9O1xuICAgICAgX3RoaXMuZW1lQ29udHJvbGxlciA9IG51bGw7XG4gICAgICBfdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9pbmhlcml0c0xvb3NlKEtleUxvYWRlciwgX0xvZ2dlcik7XG4gICAgdmFyIF9wcm90byA9IEtleUxvYWRlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQodHlwZSkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5rZXlJZFRvS2V5SW5mbykge1xuICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5rZXlJZFRvS2V5SW5mb1tpZF0ubG9hZGVyO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgdmFyIF9sb2FkZXIkY29udGV4dDtcbiAgICAgICAgICBpZiAodHlwZSAmJiB0eXBlICE9PSAoKF9sb2FkZXIkY29udGV4dCA9IGxvYWRlci5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2xvYWRlciRjb250ZXh0LmZyYWcudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmtleUlkVG9LZXlJbmZvKSB7XG4gICAgICAgIHZhciBrZXlJbmZvID0gdGhpcy5rZXlJZFRvS2V5SW5mb1tpZF07XG4gICAgICAgIC8vIFJlbW92ZSBjYWNoZWQgRU1FIGtleXMgb24gZGV0YWNoXG4gICAgICAgIGlmIChrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgfHwga2V5SW5mby5kZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5rZXlJZFRvS2V5SW5mb1tpZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmtleUlkVG9LZXlJbmZvKSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmtleUlkVG9LZXlJbmZvW2lkXS5sb2FkZXI7XG4gICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtleUlkVG9LZXlJbmZvID0ge307XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlS2V5TG9hZEVycm9yID0gZnVuY3Rpb24gY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIGRldGFpbHMsIGVycm9yLCBuZXR3b3JrRGV0YWlscywgcmVzcG9uc2UpIHtcbiAgICAgIGlmIChkZXRhaWxzID09PSB2b2lkIDApIHtcbiAgICAgICAgZGV0YWlscyA9IEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRDbGVhciA9IGZ1bmN0aW9uIGxvYWRDbGVhcihsb2FkaW5nRnJhZywgZW5jcnlwdGVkRnJhZ21lbnRzLCBzdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkICYmICF0aGlzLmVtZUNvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRLZXlTeXN0ZW1Gb3JtYXRzKCkubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFjY2VzcyBrZXktc3lzdGVtIHdpdGggbmVhcmVzdCBrZXkgb24gc3RhcnQgKGxvYWRpbmcgZnJhZyBpcyB1bmVuY3J5cHRlZClcbiAgICAgICAgaWYgKGVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICAgICAgdmFyIGZyYWcgPSBlbmNyeXB0ZWRGcmFnbWVudHNbaV07XG4gICAgICAgICAgICAgIC8vIExvYWRpbmcgYXQgb3IgYmVmb3JlIHNlZ21lbnQgd2l0aCBFWFQtWC1LRVksIG9yIGZpcnN0IGZyYWcgbG9hZGluZyBhbmQgbGFzdCBFWFQtWC1LRVlcbiAgICAgICAgICAgICAgaWYgKGxvYWRpbmdGcmFnLmNjIDw9IGZyYWcuY2MgJiYgKCFpc01lZGlhRnJhZ21lbnQobG9hZGluZ0ZyYWcpIHx8ICFpc01lZGlhRnJhZ21lbnQoZnJhZykgfHwgbG9hZGluZ0ZyYWcuc24gPCBmcmFnLnNuKSB8fCAhc3RhcnRGcmFnUmVxdWVzdGVkICYmIGkgPT0gbCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdjogX3RoaXMyLmVtZUNvbnRyb2xsZXIuc2VsZWN0S2V5U3lzdGVtRm9ybWF0KGZyYWcpLnRoZW4oZnVuY3Rpb24gKGtleVN5c3RlbUZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzMi5lbWVDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZyYWcuc2V0S2V5Rm9ybWF0KGtleVN5c3RlbUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlTeXN0ZW0gPSBrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbihrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5U3lzdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5lbWVDb250cm9sbGVyLmdldEtleVN5c3RlbUFjY2Vzcyhba2V5U3lzdGVtXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZXQ7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICAgICAgICAgIGlmIChfcmV0KSByZXR1cm4gX3JldC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWcucmVxdWlyZUtleVN5c3RlbUFjY2Vzc09uU3RhcnQpIHtcbiAgICAgICAgICB2YXIga2V5U3lzdGVtc0luQ29uZmlnID0gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgaWYgKGtleVN5c3RlbXNJbkNvbmZpZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtZUNvbnRyb2xsZXIuZ2V0S2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbXNJbkNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChmcmFnKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSAmJiBmcmFnLmVuY3J5cHRlZCAmJiB0aGlzLmVtZUNvbnRyb2xsZXIgJiYgdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgICAvLyBNdWx0aXBsZSBrZXlzLCBidXQgbm9uZSBzZWxlY3RlZCwgcmVzb2x2ZSBpbiBlbWUtY29udHJvbGxlclxuICAgICAgICByZXR1cm4gdGhpcy5lbWVDb250cm9sbGVyLnNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKS50aGVuKGZ1bmN0aW9uIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmxvYWRJbnRlcm5hbChmcmFnLCBrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxvYWRJbnRlcm5hbChmcmFnKTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkSW50ZXJuYWwgPSBmdW5jdGlvbiBsb2FkSW50ZXJuYWwoZnJhZywga2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgICB2YXIgX2tleUluZm8sIF9rZXlJbmZvMjtcbiAgICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgICAgZnJhZy5zZXRLZXlGb3JtYXQoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgIH1cbiAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgICBpZiAoIWRlY3J5cHRkYXRhKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihrZXlTeXN0ZW1Gb3JtYXQgPyBcIkV4cGVjdGVkIGZyYWcuZGVjcnlwdGRhdGEgdG8gYmUgZGVmaW5lZCBhZnRlciBzZXR0aW5nIGZvcm1hdCBcIiArIGtleVN5c3RlbUZvcm1hdCA6IFwiTWlzc2luZyBkZWNyeXB0aW9uIGRhdGEgb24gZnJhZ21lbnQgaW4gb25LZXlMb2FkaW5nIChlbWVFbmFibGVkIHdpdGggY29udHJvbGxlcjogXCIgKyAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpICsgXCIpXCIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBlcnJvcikpO1xuICAgICAgfVxuICAgICAgdmFyIHVyaSA9IGRlY3J5cHRkYXRhLnVyaTtcbiAgICAgIGlmICghdXJpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihcIkludmFsaWQga2V5IFVSSTogXFxcIlwiICsgdXJpICsgXCJcXFwiXCIpKSk7XG4gICAgICB9XG4gICAgICB2YXIgaWQgPSBnZXRLZXlJZChkZWNyeXB0ZGF0YSk7XG4gICAgICB2YXIga2V5SW5mbyA9IHRoaXMua2V5SWRUb0tleUluZm9baWRdO1xuICAgICAgaWYgKChfa2V5SW5mbyA9IGtleUluZm8pICE9IG51bGwgJiYgX2tleUluZm8uZGVjcnlwdGRhdGEua2V5KSB7XG4gICAgICAgIGRlY3J5cHRkYXRhLmtleSA9IGtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGtleUluZm86IGtleUluZm9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBSZXR1cm4ga2V5IGxvYWQgcHJvbWlzZSBvbmNlIGl0IGhhcyBhIG1lZGlha2V5IHNlc3Npb24gd2l0aCBhbiB1c2FibGUga2V5IHN0YXR1c1xuICAgICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiAoX2tleUluZm8yID0ga2V5SW5mbykgIT0gbnVsbCAmJiBfa2V5SW5mbzIua2V5TG9hZFByb21pc2UpIHtcbiAgICAgICAgdmFyIGtleVN0YXR1cyA9IHRoaXMuZW1lQ29udHJvbGxlci5nZXRLZXlTdGF0dXMoa2V5SW5mby5kZWNyeXB0ZGF0YSk7XG4gICAgICAgIHN3aXRjaCAoa2V5U3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAndXNhYmxlJzpcbiAgICAgICAgICBjYXNlICd1c2FibGUtaW4tZnV0dXJlJzpcbiAgICAgICAgICAgIHJldHVybiBrZXlJbmZvLmtleUxvYWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGtleUxvYWRlZERhdGEpIHtcbiAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjb3JyZWN0IGZyYWdtZW50IHdpdGggdXBkYXRlZCBkZWNyeXB0ZGF0YSBrZXkgYW5kIGxvYWRlZCBrZXlJbmZvXG4gICAgICAgICAgICAgIHZhciBrZXlJbmZvID0ga2V5TG9hZGVkRGF0YS5rZXlJbmZvO1xuICAgICAgICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSBrZXlJbmZvLmRlY3J5cHRkYXRhLmtleTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICAgIGtleUluZm86IGtleUluZm9cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBrZXkgc2Vzc2lvbiBhbmQgc3RhdHVzIGFuZCBpdCBpcyBub3QgcGVuZGluZyBvciB1c2FibGUsIGNvbnRpbnVlXG4gICAgICAgIC8vIFRoaXMgd2lsbCBnbyBiYWNrIHRvIHRoZSBlbWUtY29udHJvbGxlciBmb3IgZXhwaXJlZCBrZXlzIHRvIGdldCBhIG5ldyBrZXlMb2FkUHJvbWlzZVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIHRoZSBrZXkgb3IgcmV0dXJuIHRoZSBsb2FkaW5nIHByb21pc2VcbiAgICAgIHRoaXMubG9nKCh0aGlzLmtleUlkVG9LZXlJbmZvW2lkXSA/ICdSZWwnIDogJ0wnKSArIFwib2FkaW5nXCIgKyAoZGVjcnlwdGRhdGEua2V5SWQgPyAnIGtleUlkOiAnICsgYXJyYXlUb0hleChkZWNyeXB0ZGF0YS5rZXlJZCkgOiAnJykgKyBcIiBVUkk6IFwiICsgZGVjcnlwdGRhdGEudXJpICsgXCIgZnJvbSBcIiArIGZyYWcudHlwZSArIFwiIFwiICsgZnJhZy5sZXZlbCk7XG4gICAgICBrZXlJbmZvID0gdGhpcy5rZXlJZFRvS2V5SW5mb1tpZF0gPSB7XG4gICAgICAgIGRlY3J5cHRkYXRhOiBkZWNyeXB0ZGF0YSxcbiAgICAgICAga2V5TG9hZFByb21pc2U6IG51bGwsXG4gICAgICAgIGxvYWRlcjogbnVsbCxcbiAgICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIHN3aXRjaCAoZGVjcnlwdGRhdGEubWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ1NBTVBMRS1BRVMnOlxuICAgICAgICBjYXNlICdTQU1QTEUtQUVTLUNFTkMnOlxuICAgICAgICBjYXNlICdTQU1QTEUtQUVTLUNUUic6XG4gICAgICAgICAgaWYgKGRlY3J5cHRkYXRhLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgLy8gbG9hZEtleUhUVFAgaGFuZGxlcyBodHRwKHMpIGFuZCBkYXRhIFVSTHNcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5RU1FKGtleUluZm8sIGZyYWcpO1xuICAgICAgICBjYXNlICdBRVMtMTI4JzpcbiAgICAgICAgY2FzZSAnQUVTLTI1Nic6XG4gICAgICAgIGNhc2UgJ0FFUy0yNTYtQ1RSJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoXCJLZXkgc3VwcGxpZWQgd2l0aCB1bnN1cHBvcnRlZCBNRVRIT0Q6IFxcXCJcIiArIGRlY3J5cHRkYXRhLm1ldGhvZCArIFwiXFxcIlwiKSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWRLZXlFTUUgPSBmdW5jdGlvbiBsb2FkS2V5RU1FKGtleUluZm8sIGZyYWcpIHtcbiAgICAgIHZhciBrZXlMb2FkZWREYXRhID0ge1xuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBrZXlJbmZvOiBrZXlJbmZvXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICAgICAgaWYgKCFrZXlJbmZvLmRlY3J5cHRkYXRhLmtleUlkICYmIChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpICE9IG51bGwgJiYgX2ZyYWckaW5pdFNlZ21lbnQuZGF0YSkge1xuICAgICAgICAgIHZhciBrZXlJZHMgPSBwYXJzZUtleUlkc0Zyb21UZW5jKGZyYWcuaW5pdFNlZ21lbnQuZGF0YSk7XG4gICAgICAgICAgaWYgKGtleUlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXlJZCA9IGtleUlkc1swXTtcbiAgICAgICAgICAgIGlmIChrZXlJZC5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiICE9PSAwO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coXCJVc2luZyBrZXlJZCBmb3VuZCBpbiBpbml0IHNlZ21lbnQgXCIgKyBhcnJheVRvSGV4KGtleUlkKSk7XG4gICAgICAgICAgICAgIExldmVsS2V5LnNldEtleUlkRm9yVXJpKGtleUluZm8uZGVjcnlwdGRhdGEudXJpLCBrZXlJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBrZXlJZCA9IExldmVsS2V5LmFkZEtleUlkRm9yVXJpKGtleUluZm8uZGVjcnlwdGRhdGEudXJpKTtcbiAgICAgICAgICAgICAgdGhpcy5sb2coXCJHZW5lcmF0aW5nIGtleUlkIHRvIHBhdGNoIG1lZGlhIFwiICsgYXJyYXlUb0hleChrZXlJZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5SW5mby5kZWNyeXB0ZGF0YS5rZXlJZCA9IGtleUlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtleUluZm8uZGVjcnlwdGRhdGEua2V5SWQgJiYgIWlzTWVkaWFGcmFnbWVudChmcmFnKSkge1xuICAgICAgICAgIC8vIFJlc29sdmUgc28gdGhhdCB1bmVuY3J5cHRlZCBpbml0IHNlZ21lbnQgaXMgbG9hZGVkXG4gICAgICAgICAgLy8ga2V5IGlkIGlzIGV4dHJhY3RlZCBmcm9tIHRlbmMgYm94IHdoZW4gcHJvY2Vzc2luZyBrZXkgZm9yIG5leHQgc2VnbWVudCBhYm92ZVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5TG9hZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMuZW1lQ29udHJvbGxlci5sb2FkS2V5KGtleUxvYWRlZERhdGEpO1xuICAgICAgICByZXR1cm4gKGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UudGhlbihmdW5jdGlvbiAoa2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICAgICAgICBrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSBrZXlTZXNzaW9uQ29udGV4dDtcbiAgICAgICAgICByZXR1cm4ga2V5TG9hZGVkRGF0YTtcbiAgICAgICAgfSkpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIC8vIFJlbW92ZSBwcm9taXNlIGZvciBsaWNlbnNlIHJlbmV3YWwgb3IgcmV0cnlcbiAgICAgICAgICBrZXlJbmZvLmtleUxvYWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICBpZiAoJ2RhdGEnIGluIGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5kYXRhLmZyYWcgPSBmcmFnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleUxvYWRlZERhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRLZXlIVFRQID0gZnVuY3Rpb24gbG9hZEtleUhUVFAoa2V5SW5mbywgZnJhZykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICB2YXIgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICAgIHZhciBrZXlMb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZyk7XG4gICAgICBmcmFnLmtleUxvYWRlciA9IGtleUluZm8ubG9hZGVyID0ga2V5TG9hZGVyO1xuICAgICAgcmV0dXJuIGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBsb2FkZXJDb250ZXh0ID0ge1xuICAgICAgICAgIGtleUluZm86IGtleUluZm8sXG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgICAgICAgdXJsOiBrZXlJbmZvLmRlY3J5cHRkYXRhLnVyaVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1heFJldHJ5IGlzIDAgc28gdGhhdCBpbnN0ZWFkIG9mIHJldHJ5aW5nIHRoZSBzYW1lIGtleSBvbiB0aGUgc2FtZSB2YXJpYW50IG11bHRpcGxlIHRpbWVzLFxuICAgICAgICAvLyBrZXktbG9hZGVyIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBhbmQgcmVseSBvbiBzdHJlYW0tY29udHJvbGxlciB0byBoYW5kbGUgcmV0cnkgbG9naWMuXG4gICAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG4gICAgICAgIHZhciBsb2FkUG9saWN5ID0gY29uZmlnLmtleUxvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICAgICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgICBsb2FkUG9saWN5OiBsb2FkUG9saWN5LFxuICAgICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICAgIG1heFJldHJ5RGVsYXk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgICAgICAgICAga2V5SW5mbyA9IGNvbnRleHQua2V5SW5mbztcbiAgICAgICAgICAgIHZhciBpZCA9IGdldEtleUlkKGtleUluZm8uZGVjcnlwdGRhdGEpO1xuICAgICAgICAgICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhIHx8IGtleUluZm8gIT09IF90aGlzNC5rZXlJZFRvS2V5SW5mb1tpZF0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChfdGhpczQuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKCdhZnRlciBrZXkgbG9hZCwgZGVjcnlwdGRhdGEgdW5zZXQgb3IgY2hhbmdlZCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5SW5mby5kZWNyeXB0ZGF0YS5rZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuXG4gICAgICAgICAgICAvLyBkZXRhY2ggZnJhZ21lbnQga2V5IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICAgICAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgICAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBrZXlJbmZvOiBrZXlJbmZvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykge1xuICAgICAgICAgICAgX3RoaXM0LnJlc2V0TG9hZGVyKGNvbnRleHQpO1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzNC5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoXCJIVFRQIEVycm9yIFwiICsgcmVzcG9uc2UuY29kZSArIFwiIGxvYWRpbmcga2V5IFwiICsgcmVzcG9uc2UudGV4dCksIG5ldHdvcmtEZXRhaWxzLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblRpbWVvdXQ6IGZ1bmN0aW9uIG9uVGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIF90aGlzNC5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICAgIHJlamVjdChfdGhpczQuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VULCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIHRpbWVkIG91dCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25BYm9ydDogZnVuY3Rpb24gb25BYm9ydChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIF90aGlzNC5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICAgIHJlamVjdChfdGhpczQuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIGFib3J0ZWQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGtleUxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0TG9hZGVyID0gZnVuY3Rpb24gcmVzZXRMb2FkZXIoY29udGV4dCkge1xuICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIGtleUluZm8gPSBjb250ZXh0LmtleUluZm8sXG4gICAgICAgIHVyaSA9IGNvbnRleHQudXJsO1xuICAgICAgdmFyIGxvYWRlciA9IGtleUluZm8ubG9hZGVyO1xuICAgICAgaWYgKGZyYWcua2V5TG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgICAgZnJhZy5rZXlMb2FkZXIgPSBudWxsO1xuICAgICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaWQgPSBnZXRLZXlJZChrZXlJbmZvLmRlY3J5cHRkYXRhKSB8fCB1cmk7XG4gICAgICBkZWxldGUgdGhpcy5rZXlJZFRvS2V5SW5mb1tpZF07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gS2V5TG9hZGVyO1xuICB9KExvZ2dlcik7XG4gIGZ1bmN0aW9uIGdldEtleUlkKGRlY3J5cHRkYXRhKSB7XG4gICAgaWYgKGRlY3J5cHRkYXRhLmtleUZvcm1hdCAhPT0gS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWSkge1xuICAgICAgdmFyIGtleUlkID0gZGVjcnlwdGRhdGEua2V5SWQ7XG4gICAgICBpZiAoa2V5SWQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9IZXgoa2V5SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjcnlwdGRhdGEudXJpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpIHtcbiAgICB2YXIgdHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuTUFJTjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICB2YXIgdXJsID0gcmVzcG9uc2UudXJsO1xuICAgIC8vIHJlc3BvbnNlVVJMIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2VycyAoaXQgaXMgdXNlZCB0byBkZXRlY3QgVVJMIHJlZGlyZWN0aW9uKVxuICAgIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXG4gICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAvLyBmYWxsYmFjayB0byBpbml0aWFsIFVSTFxuICAgICAgdXJsID0gY29udGV4dC51cmw7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgdmFyIFBsYXlsaXN0TG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGF5bGlzdExvYWRlcihobHMpIHtcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5sb2FkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMub25NYW5pZmVzdExvYWRlZCA9IHRoaXMuY2hlY2tBdXRvc3RhcnRMb2FkO1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQbGF5bGlzdExvYWRlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7fTtcbiAgICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkZWZhdWx0cyBvciBjb25maWd1cmVkIGxvYWRlci10eXBlIG92ZXJsb2FkcyAocExvYWRlciBhbmQgbG9hZGVyIGNvbmZpZyBwYXJhbXMpXG4gICAgICovO1xuICAgIF9wcm90by5jcmVhdGVJbnRlcm5hbExvYWRlciA9IGZ1bmN0aW9uIGNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICB2YXIgUExvYWRlciA9IGNvbmZpZy5wTG9hZGVyO1xuICAgICAgdmFyIExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgICB2YXIgSW50ZXJuYWxMb2FkZXIgPSBQTG9hZGVyIHx8IExvYWRlcjtcbiAgICAgIHZhciBsb2FkZXIgPSBuZXcgSW50ZXJuYWxMb2FkZXIoY29uZmlnKTtcbiAgICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gbG9hZGVyO1xuICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9O1xuICAgIF9wcm90by5nZXRJbnRlcm5hbExvYWRlciA9IGZ1bmN0aW9uIGdldEludGVybmFsTG9hZGVyKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldEludGVybmFsTG9hZGVyID0gZnVuY3Rpb24gcmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0VHlwZSkge1xuICAgICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgZGVzdHJveWAgb24gYWxsIGludGVybmFsIGxvYWRlciBpbnN0YW5jZXMgbWFwcGVkIChvbmUgcGVyIGNvbnRleHQgdHlwZSlcbiAgICAgKi87XG4gICAgX3Byb3RvLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMgPSBmdW5jdGlvbiBkZXN0cm95SW50ZXJuYWxMb2FkZXJzKCkge1xuICAgICAgZm9yICh2YXIgY29udGV4dFR5cGUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgdXJsID0gZGF0YS51cmw7XG4gICAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLmxvYWQoe1xuICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBudWxsLFxuICAgICAgICBsZXZlbE9yVHJhY2s6IG51bGxcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICAgIGxldmVsID0gZGF0YS5sZXZlbCxcbiAgICAgICAgcGF0aHdheUlkID0gZGF0YS5wYXRod2F5SWQsXG4gICAgICAgIHVybCA9IGRhdGEudXJsLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgICAgbGV2ZWxJbmZvID0gZGF0YS5sZXZlbEluZm87XG4gICAgICB0aGlzLmxvYWQoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgcGF0aHdheUlkOiBwYXRod2F5SWQsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICAgIGxldmVsT3JUcmFjazogbGV2ZWxJbmZvXG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vbkF1ZGlvVHJhY2tMb2FkaW5nID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgZ3JvdXBJZCA9IGRhdGEuZ3JvdXBJZCxcbiAgICAgICAgdXJsID0gZGF0YS51cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgICB0cmFjayA9IGRhdGEudHJhY2s7XG4gICAgICB0aGlzLmxvYWQoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICAgIGxldmVsOiBudWxsLFxuICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgICBsZXZlbE9yVHJhY2s6IHRyYWNrXG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vblN1YnRpdGxlVHJhY2tMb2FkaW5nID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgZ3JvdXBJZCA9IGRhdGEuZ3JvdXBJZCxcbiAgICAgICAgdXJsID0gZGF0YS51cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgICB0cmFjayA9IGRhdGEudHJhY2s7XG4gICAgICB0aGlzLmxvYWQoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICAgIGxldmVsOiBudWxsLFxuICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgICBsZXZlbE9yVHJhY2s6IHRyYWNrXG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsc1VwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIC8vIGFib3J0IGFuZCBkZWxldGUgbG9hZGVyIG9mIHJlbW92ZWQgbGV2ZWxzXG4gICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW1BsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUxdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICB2YXIgY29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuICAgICAgICBpZiAoY29udGV4dCAmJiAhZGF0YS5sZXZlbHMuc29tZShmdW5jdGlvbiAobHZsKSB7XG4gICAgICAgICAgcmV0dXJuIGx2bCA9PT0gY29udGV4dC5sZXZlbE9yVHJhY2s7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQpIHtcbiAgICAgIHZhciBfY29udGV4dCRkZWxpdmVyeURpcmUsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IExvYWRpbmcgcGxheWxpc3Qgb2YgdHlwZSAke2NvbnRleHQudHlwZX0sIGxldmVsOiAke2NvbnRleHQubGV2ZWx9LCBpZDogJHtjb250ZXh0LmlkfWApO1xuXG4gICAgICAvLyBDaGVjayBpZiBhIGxvYWRlciBmb3IgdGhpcyBjb250ZXh0IGFscmVhZHkgZXhpc3RzXG4gICAgICB2YXIgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgdmFyIGxvZ2dlciA9IHRoaXMuaGxzLmxvZ2dlcjtcbiAgICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC5sZXZlbE9yVHJhY2sgPT09IGNvbnRleHQubGV2ZWxPclRyYWNrICYmIChsb2FkZXJDb250ZXh0LnVybCA9PT0gY29udGV4dC51cmwgfHwgbG9hZGVyQ29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMgJiYgIWNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzKSkge1xuICAgICAgICAgIC8vIHNhbWUgVVJMIGNhbid0IG92ZXJsYXAsIG9yIHdhaXQgZm9yIGJsb2NraW5nIHJlcXVlc3RcbiAgICAgICAgICBpZiAobG9hZGVyQ29udGV4dC51cmwgPT09IGNvbnRleHQudXJsKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiW3BsYXlsaXN0LWxvYWRlcl06IGlnbm9yZSBcIiArIGNvbnRleHQudXJsICsgXCIgb25nb2luZyByZXF1ZXN0XCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiW3BsYXlsaXN0LWxvYWRlcl06IGlnbm9yZSBcIiArIGNvbnRleHQudXJsICsgXCIgaW4gZmF2b3Igb2YgXCIgKyBsb2FkZXJDb250ZXh0LnVybCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKFwiW3BsYXlsaXN0LWxvYWRlcl06IGFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogXCIgKyBjb250ZXh0LnR5cGUpO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgZGlmZmVyZW50IGNvbmZpZ3MgZm9yIHJldHJpZXMgZGVwZW5kaW5nIG9uXG4gICAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXG4gICAgICB2YXIgbG9hZFBvbGljeTtcbiAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgICAgbG9hZFBvbGljeSA9IGNvbmZpZy5tYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRQb2xpY3kgPSBfZXh0ZW5kcyh7fSwgY29uZmlnLnBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0LCB7XG4gICAgICAgICAgdGltZW91dFJldHJ5OiBudWxsLFxuICAgICAgICAgIGVycm9yUmV0cnk6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsb2FkZXIgPSB0aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgICAvLyBPdmVycmlkZSBsZXZlbC90cmFjayB0aW1lb3V0IGZvciBMTC1ITFMgcmVxdWVzdHNcbiAgICAgIC8vICh0aGUgZGVmYXVsdCBvZiAxMDAwMG1zIGlzIGNvdW50ZXIgcHJvZHVjdGl2ZSB0byBibG9ja2luZyBwbGF5bGlzdCByZWxvYWQgcmVxdWVzdHMpXG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoKF9jb250ZXh0JGRlbGl2ZXJ5RGlyZSA9IGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRleHQkZGVsaXZlcnlEaXJlLnBhcnQpKSB7XG4gICAgICAgIHZhciBsZXZlbERldGFpbHM7XG4gICAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgY29udGV4dC5sZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLmxldmVsc1tjb250ZXh0LmxldmVsXS5kZXRhaWxzO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBjb250ZXh0LmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuYXVkaW9UcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgY29udGV4dC5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLnN1YnRpdGxlVHJhY2tzW2NvbnRleHQuaWRdLmRldGFpbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICAgIHZhciBwYXJ0VGFyZ2V0ID0gbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQ7XG4gICAgICAgICAgdmFyIHRhcmdldER1cmF0aW9uID0gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgICAgIGlmIChwYXJ0VGFyZ2V0ICYmIHRhcmdldER1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCA9IE1hdGgubWF4KHBhcnRUYXJnZXQgKiAzLCB0YXJnZXREdXJhdGlvbiAqIDAuOCkgKiAxMDAwO1xuICAgICAgICAgICAgbG9hZFBvbGljeSA9IF9leHRlbmRzKHt9LCBsb2FkUG9saWN5LCB7XG4gICAgICAgICAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBNYXRoLm1pbihtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoLCBsb2FkUG9saWN5Lm1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSxcbiAgICAgICAgICAgICAgbWF4TG9hZFRpbWVNczogTWF0aC5taW4obWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCwgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eSA9IGxvYWRQb2xpY3kuZXJyb3JSZXRyeSB8fCBsb2FkUG9saWN5LnRpbWVvdXRSZXRyeSB8fCB7fTtcbiAgICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3k6IGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhOdW1SZXRyeSB8fCAwLFxuICAgICAgICByZXRyeURlbGF5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkucmV0cnlEZWxheU1zIHx8IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhSZXRyeURlbGF5TXMgfHwgMFxuICAgICAgfTtcbiAgICAgIHZhciBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICB2YXIgbG9hZGVyID0gX3RoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgX3RoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgICAgICAgIHZhciBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBpZiAoTTNVOFBhcnNlci5pc01lZGlhUGxheWxpc3Qoc3RyaW5nKSB8fCBjb250ZXh0LnR5cGUgIT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgfHwgbnVsbCwgbG9hZGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpIHtcbiAgICAgICAgICBfdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGZhbHNlLCByZXNwb25zZSwgc3RhdHMpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IGZ1bmN0aW9uIG9uVGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRydWUsIHVuZGVmaW5lZCwgc3RhdHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBDYWxsaW5nIGludGVybmFsIGxvYWRlciBkZWxlZ2F0ZSBmb3IgVVJMOiAke2NvbnRleHQudXJsfWApO1xuXG4gICAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tBdXRvc3RhcnRMb2FkID0gZnVuY3Rpb24gY2hlY2tBdXRvc3RhcnRMb2FkKCkge1xuICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgX3RoaXMkaGxzID0gdGhpcy5obHMsXG4gICAgICAgIF90aGlzJGhscyRjb25maWcgPSBfdGhpcyRobHMuY29uZmlnLFxuICAgICAgICBhdXRvU3RhcnRMb2FkID0gX3RoaXMkaGxzJGNvbmZpZy5hdXRvU3RhcnRMb2FkLFxuICAgICAgICBzdGFydFBvc2l0aW9uID0gX3RoaXMkaGxzJGNvbmZpZy5zdGFydFBvc2l0aW9uLFxuICAgICAgICBmb3JjZVN0YXJ0TG9hZCA9IF90aGlzJGhscy5mb3JjZVN0YXJ0TG9hZDtcbiAgICAgIGlmIChhdXRvU3RhcnRMb2FkIHx8IGZvcmNlU3RhcnRMb2FkKSB7XG4gICAgICAgIHRoaXMuaGxzLmxvZ2dlci5sb2coKGF1dG9TdGFydExvYWQgPyAnYXV0bycgOiAnZm9yY2UnKSArIFwiIHN0YXJ0TG9hZCB3aXRoIGNvbmZpZ3VyZWQgc3RhcnRQb3NpdGlvbiBcIiArIHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICB0aGlzLmhscy5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlTWFzdGVyUGxheWxpc3QgPSBmdW5jdGlvbiBoYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHZhciBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuICAgICAgdmFyIHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgIHZhciBwYXJzZWRSZXN1bHQgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xuICAgICAgaWYgKHBhcnNlZFJlc3VsdC5wbGF5bGlzdFBhcnNpbmdFcnJvcikge1xuICAgICAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBwYXJzZWRSZXN1bHQucGxheWxpc3RQYXJzaW5nRXJyb3IsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjb250ZW50U3RlZXJpbmcgPSBwYXJzZWRSZXN1bHQuY29udGVudFN0ZWVyaW5nLFxuICAgICAgICBsZXZlbHMgPSBwYXJzZWRSZXN1bHQubGV2ZWxzLFxuICAgICAgICBzZXNzaW9uRGF0YSA9IHBhcnNlZFJlc3VsdC5zZXNzaW9uRGF0YSxcbiAgICAgICAgc2Vzc2lvbktleXMgPSBwYXJzZWRSZXN1bHQuc2Vzc2lvbktleXMsXG4gICAgICAgIHN0YXJ0VGltZU9mZnNldCA9IHBhcnNlZFJlc3VsdC5zdGFydFRpbWVPZmZzZXQsXG4gICAgICAgIHZhcmlhYmxlTGlzdCA9IHBhcnNlZFJlc3VsdC52YXJpYWJsZUxpc3Q7XG4gICAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdDtcblxuICAgICAgLy8gVHJlYXQgdW5rbm93biBjb2RlYyBhcyBhdWRpbyBvciB2aWRlbyBjb2RlYyBiYXNlZCBvbiBwYXNzaW5nIGBpc1R5cGVTdXBwb3J0ZWRgIGNoZWNrXG4gICAgICAvLyAoYWxsb3dzIGZvciBwbGF5YmFjayBvZiBhbnkgc3VwcG9ydGVkIGNvZGVjIGV2ZW4gaWYgbm90IGluZGV4ZWQgaW4gdXRpbHMvY29kZWNzKVxuICAgICAgbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsUGFyc2VkKSB7XG4gICAgICAgIHZhciB1bmtub3duQ29kZWNzID0gbGV2ZWxQYXJzZWQudW5rbm93bkNvZGVjcztcbiAgICAgICAgaWYgKHVua25vd25Db2RlY3MpIHtcbiAgICAgICAgICB2YXIgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gX3RoaXMyLmhscy5jb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlO1xuICAgICAgICAgIHZhciBhdWRpb0NvZGVjID0gbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYyxcbiAgICAgICAgICAgIHZpZGVvQ29kZWMgPSBsZXZlbFBhcnNlZC52aWRlb0NvZGVjO1xuICAgICAgICAgIGZvciAodmFyIGkgPSB1bmtub3duQ29kZWNzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIHVua25vd25Db2RlYyA9IHVua25vd25Db2RlY3NbaV07XG4gICAgICAgICAgICBpZiAoYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQodW5rbm93bkNvZGVjLCAnYXVkaW8nLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpKSB7XG4gICAgICAgICAgICAgIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjID0gYXVkaW9Db2RlYyA/IGF1ZGlvQ29kZWMgKyBcIixcIiArIHVua25vd25Db2RlYyA6IHVua25vd25Db2RlYztcbiAgICAgICAgICAgICAgc2FtcGxlRW50cnlDb2Rlc0lTTy5hdWRpb1thdWRpb0NvZGVjLnN1YnN0cmluZygwLCA0KV0gPSAyO1xuICAgICAgICAgICAgICB1bmtub3duQ29kZWNzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQodW5rbm93bkNvZGVjLCAndmlkZW8nLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpKSB7XG4gICAgICAgICAgICAgIGxldmVsUGFyc2VkLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjID0gdmlkZW9Db2RlYyA/IHZpZGVvQ29kZWMgKyBcIixcIiArIHVua25vd25Db2RlYyA6IHVua25vd25Db2RlYztcbiAgICAgICAgICAgICAgc2FtcGxlRW50cnlDb2Rlc0lTTy52aWRlb1t2aWRlb0NvZGVjLnN1YnN0cmluZygwLCA0KV0gPSAyO1xuICAgICAgICAgICAgICB1bmtub3duQ29kZWNzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIF9NM1U4UGFyc2VyJHBhcnNlTWFzdCA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCBwYXJzZWRSZXN1bHQpLFxuICAgICAgICBfTTNVOFBhcnNlciRwYXJzZU1hc3QyID0gX00zVThQYXJzZXIkcGFyc2VNYXN0LkFVRElPLFxuICAgICAgICBhdWRpb1RyYWNrcyA9IF9NM1U4UGFyc2VyJHBhcnNlTWFzdDIgPT09IHZvaWQgMCA/IFtdIDogX00zVThQYXJzZXIkcGFyc2VNYXN0MixcbiAgICAgICAgc3VidGl0bGVzID0gX00zVThQYXJzZXIkcGFyc2VNYXN0LlNVQlRJVExFUyxcbiAgICAgICAgY2FwdGlvbnMgPSBfTTNVOFBhcnNlciRwYXJzZU1hc3RbJ0NMT1NFRC1DQVBUSU9OUyddO1xuICAgICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgICAgdmFyIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGF1ZGlvVHJhY2tzLnNvbWUoZnVuY3Rpb24gKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgICByZXR1cm4gIWF1ZGlvVHJhY2sudXJsO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGhcbiAgICAgICAgLy8gYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbilcbiAgICAgICAgLy8gY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG4gICAgICAgIGlmICghZW1iZWRkZWRBdWRpb0ZvdW5kICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgICB0aGlzLmhscy5sb2dnZXIubG9nKCdbcGxheWxpc3QtbG9hZGVyXTogYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XG4gICAgICAgICAgICB0eXBlOiAnbWFpbicsXG4gICAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgICBncm91cElkOiAnbWFpbicsXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgZm9yY2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGlkOiAtMSxcbiAgICAgICAgICAgIGF0dHJzOiBuZXcgQXR0ckxpc3Qoe30pLFxuICAgICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICAgIHVybDogJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICBsZXZlbHM6IGxldmVscyxcbiAgICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzLFxuICAgICAgICBzdWJ0aXRsZXM6IHN1YnRpdGxlcyxcbiAgICAgICAgY2FwdGlvbnM6IGNhcHRpb25zLFxuICAgICAgICBjb250ZW50U3RlZXJpbmc6IGNvbnRlbnRTdGVlcmluZyxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzZXNzaW9uRGF0YTogc2Vzc2lvbkRhdGEsXG4gICAgICAgIHNlc3Npb25LZXlzOiBzZXNzaW9uS2V5cyxcbiAgICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBzdGFydFRpbWVPZmZzZXQsXG4gICAgICAgIHZhcmlhYmxlTGlzdDogdmFyaWFibGVMaXN0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGxvYWRlcikge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIGlkID0gY29udGV4dC5pZCxcbiAgICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsLFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlO1xuICAgICAgdmFyIHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZXZlbElkID0gaXNGaW5pdGVOdW1iZXIobGV2ZWwpID8gbGV2ZWwgOiBpc0Zpbml0ZU51bWJlcihpZCkgPyBpZCA6IDA7XG4gICAgICB2YXIgbGV2ZWxUeXBlID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IE0zVThQYXJzZXIucGFyc2VMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLmRhdGEsIHVybCwgbGV2ZWxJZCwgbGV2ZWxUeXBlLCAwLCB0aGlzLnZhcmlhYmxlTGlzdCk7XG5cbiAgICAgIC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAgIC8vIG5vdCBhIG1hc3RlciBwbGF5bGlzdCBidXQgYSBjaHVuay1saXN0ICh0cmFjay9sZXZlbClcbiAgICAgIC8vIFdlIGZpcmUgdGhlIG1hbmlmZXN0LWxvYWRlZCBldmVudCBhbnl3YXkgd2l0aCB0aGUgcGFyc2VkIGxldmVsLWRldGFpbHNcbiAgICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG4gICAgICBpZiAodHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCkge1xuICAgICAgICB2YXIgc2luZ2xlTGV2ZWwgPSB7XG4gICAgICAgICAgYXR0cnM6IG5ldyBBdHRyTGlzdCh7fSksXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgfTtcbiAgICAgICAgbGV2ZWxEZXRhaWxzLnJlcXVlc3RTY2hlZHVsZWQgPSBzdGF0cy5sb2FkaW5nLnN0YXJ0ICsgY29tcHV0ZVJlbG9hZEludGVydmFsKGxldmVsRGV0YWlscywgMCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgICAgICBsZXZlbHM6IFtzaW5nbGVMZXZlbF0sXG4gICAgICAgICAgYXVkaW9UcmFja3M6IFtdLFxuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICAgICAgc2Vzc2lvbktleXM6IG51bGwsXG4gICAgICAgICAgY29udGVudFN0ZWVyaW5nOiBudWxsLFxuICAgICAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgICAgICB2YXJpYWJsZUxpc3Q6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNhdmUgcGFyc2luZyB0aW1lXG4gICAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuICAgICAgY29udGV4dC5sZXZlbERldGFpbHMgPSBsZXZlbERldGFpbHM7XG4gICAgICB0aGlzLmhhbmRsZVBsYXlsaXN0TG9hZGVkKGxldmVsRGV0YWlscywgcmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgbG9hZGVyKTtcbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBlcnJvciwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxuICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmhhbmRsZU5ldHdvcmtFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdGltZW91dCwgcmVzcG9uc2UsIHN0YXRzKSB7XG4gICAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBtZXNzYWdlID0gXCJBIG5ldHdvcmsgXCIgKyAodGltZW91dCA/ICd0aW1lb3V0JyA6ICdlcnJvcicgKyAocmVzcG9uc2UgPyAnIChzdGF0dXMgJyArIHJlc3BvbnNlLmNvZGUgKyAnKScgOiAnJykpICsgXCIgb2NjdXJyZWQgd2hpbGUgbG9hZGluZyBcIiArIGNvbnRleHQudHlwZTtcbiAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwpIHtcbiAgICAgICAgbWVzc2FnZSArPSBcIjogXCIgKyBjb250ZXh0LmxldmVsICsgXCIgaWQ6IFwiICsgY29udGV4dC5pZDtcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLIHx8IGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSykge1xuICAgICAgICBtZXNzYWdlICs9IFwiIGlkOiBcIiArIGNvbnRleHQuaWQgKyBcIiBncm91cC1pZDogXFxcIlwiICsgY29udGV4dC5ncm91cElkICsgXCJcXFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLmhscy5sb2dnZXIud2FybihcIltwbGF5bGlzdC1sb2FkZXJdOiBcIiArIG1lc3NhZ2UpO1xuICAgICAgdmFyIGRldGFpbHMgPSBFcnJvckRldGFpbHMuVU5LTk9XTjtcbiAgICAgIHZhciBmYXRhbCA9IGZhbHNlO1xuICAgICAgdmFyIGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1I7XG4gICAgICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I7XG4gICAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SO1xuICAgICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjtcbiAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvckRhdGEgPSB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgZmF0YWw6IGZhdGFsLFxuICAgICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgICBsb2FkZXI6IGxvYWRlcixcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHN0YXRzOiBzdGF0c1xuICAgICAgfTtcbiAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICB2YXIgdXJsID0gKG5ldHdvcmtEZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBuZXR3b3JrRGV0YWlscy51cmwpIHx8IGNvbnRleHQudXJsO1xuICAgICAgICBlcnJvckRhdGEucmVzcG9uc2UgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgIH0sIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLmhhbmRsZVBsYXlsaXN0TG9hZGVkID0gZnVuY3Rpb24gaGFuZGxlUGxheWxpc3RMb2FkZWQobGV2ZWxEZXRhaWxzLCByZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBsb2FkZXIpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHZhciB0eXBlID0gY29udGV4dC50eXBlLFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWwsXG4gICAgICAgIGxldmVsT3JUcmFjayA9IGNvbnRleHQubGV2ZWxPclRyYWNrLFxuICAgICAgICBpZCA9IGNvbnRleHQuaWQsXG4gICAgICAgIGdyb3VwSWQgPSBjb250ZXh0Lmdyb3VwSWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgICAgdmFyIHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgIHZhciBwYXJlbnQgPSBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG4gICAgICB2YXIgbGV2ZWxJbmRleCA9IHR5cGVvZiBjb250ZXh0LmxldmVsID09PSAnbnVtYmVyJyAmJiBwYXJlbnQgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyBsZXZlbCA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBlcnJvciA9IGxldmVsRGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvcjtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aGlzLmhscy5sb2dnZXIud2FybihlcnJvciArIFwiIFwiICsgbGV2ZWxEZXRhaWxzLnVybCk7XG4gICAgICAgIGlmICghaGxzLmNvbmZpZy5pZ25vcmVQbGF5bGlzdFBhcnNpbmdFcnJvcnMpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzOiBzdGF0c1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXZlbERldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFsZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgX2Vycm9yID0gbGV2ZWxEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdObyBTZWdtZW50cyBmb3VuZCBpbiBQbGF5bGlzdCcpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBlcnJvcjogX2Vycm9yLFxuICAgICAgICAgIHJlYXNvbjogX2Vycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXgsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIHN0YXRzOiBzdGF0c1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsRGV0YWlscy5saXZlICYmIGxvYWRlcikge1xuICAgICAgICBpZiAobG9hZGVyLmdldENhY2hlQWdlKSB7XG4gICAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IGxvYWRlci5nZXRDYWNoZUFnZSgpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb2FkZXIuZ2V0Q2FjaGVBZ2UgfHwgaXNOYU4obGV2ZWxEZXRhaWxzLmFnZUhlYWRlcikpIHtcbiAgICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgICAgIGlmIChsZXZlbEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWxldmVsT3JUcmFjaykge1xuICAgICAgICAgICAgICAvLyBmYWxsLXRocm91Z2ggdG8gaGxzLmxldmVsc1swXVxuICAgICAgICAgICAgICBsZXZlbEluZGV4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbE9yVHJhY2sgIT09IGhscy5sZXZlbHNbbGV2ZWxJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGxldmVsSW5kZXggd2hlbiBsb3dlciBsZXZlbHMgd2VyZSByZW1vdmVkIGZyb20gaGxzLmxldmVsc1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkSW5kZXggPSBobHMubGV2ZWxzLmluZGV4T2YobGV2ZWxPclRyYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsSW5kZXggPSB1cGRhdGVkSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9MT0FERUQsIHtcbiAgICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICAgIGxldmVsSW5mbzogbGV2ZWxPclRyYWNrIHx8IGhscy5sZXZlbHNbMF0sXG4gICAgICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCB8fCAwLFxuICAgICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgICAgICAgIHdpdGhvdXRNdWx0aVZhcmlhbnQ6IHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICAgIHRyYWNrOiBsZXZlbE9yVHJhY2ssXG4gICAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQgfHwgJycsXG4gICAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgICAgdHJhY2s6IGxldmVsT3JUcmFjayxcbiAgICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGxheWxpc3RMb2FkZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogVGhlIGBIbHNgIGNsYXNzIGlzIHRoZSBjb3JlIG9mIHRoZSBITFMuanMgbGlicmFyeSB1c2VkIHRvIGluc3RhbnRpYXRlIHBsYXllciBpbnN0YW5jZXMuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHZhciBIbHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgICAqIEBwYXJhbSB1c2VyQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGFwcGxpZWQgb3ZlciBgSGxzLkRlZmF1bHRDb25maWdgXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGxzKHVzZXJDb25maWcpIHtcbiAgICAgIGlmICh1c2VyQ29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgICAgdXNlckNvbmZpZyA9IHt9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcnVudGltZSBjb25maWd1cmF0aW9uIHVzZWQgYnkgdGhlIHBsYXllci4gQXQgaW5zdGFudGlhdGlvbiB0aGlzIGlzIGNvbWJpbmF0aW9uIG9mIGBobHMudXNlckNvbmZpZ2AgbWVyZ2VkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBwcm92aWRlZCBvbiBwbGF5ZXIgaW5zdGFudGlhdGlvbi5cbiAgICAgICAqL1xuICAgICAgdGhpcy51c2VyQ29uZmlnID0gdm9pZCAwO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbG9nZ2VyIGZ1bmN0aW9ucyB1c2VkIGJ5IHRoaXMgcGxheWVyIGluc3RhbmNlLCBjb25maWd1cmVkIG9uIHBsYXllciBpbnN0YW50aWF0aW9uLlxuICAgICAgICovXG4gICAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgICB0aGlzLl9tYXhIZGNwTGV2ZWwgPSBudWxsO1xuICAgICAgdGhpcy5hYnJDb250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5idWZmZXJDb250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuc3VidGl0aXRsZVN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICAgIHRoaXMuX3Nlc3Npb25JZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbiA9IHZvaWQgMDtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdmFyIGxvZ2dlciA9IHRoaXMubG9nZ2VyID0gZW5hYmxlTG9ncyh1c2VyQ29uZmlnLmRlYnVnIHx8IGZhbHNlLCAnSGxzIGluc3RhbmNlJywgdXNlckNvbmZpZy5hc3NldFBsYXllcklkKTtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG1lcmdlQ29uZmlnKEhscy5EZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnLCBsb2dnZXIpO1xuICAgICAgdGhpcy51c2VyQ29uZmlnID0gdXNlckNvbmZpZztcbiAgICAgIGlmIChjb25maWcucHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgZW5hYmxlU3RyZWFtaW5nTW9kZShjb25maWcsIGxvZ2dlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvcmUgY29udHJvbGxlcnMgYW5kIG5ldHdvcmsgbG9hZGVyc1xuICAgICAgdmFyIF9BYnJDb250cm9sbGVyID0gY29uZmlnLmFickNvbnRyb2xsZXIsXG4gICAgICAgIF9CdWZmZXJDb250cm9sbGVyID0gY29uZmlnLmJ1ZmZlckNvbnRyb2xsZXIsXG4gICAgICAgIF9DYXBMZXZlbENvbnRyb2xsZXIgPSBjb25maWcuY2FwTGV2ZWxDb250cm9sbGVyLFxuICAgICAgICBfRXJyb3JDb250cm9sbGVyID0gY29uZmlnLmVycm9yQ29udHJvbGxlcixcbiAgICAgICAgX0Zwc0NvbnRyb2xsZXIgPSBjb25maWcuZnBzQ29udHJvbGxlcjtcbiAgICAgIHZhciBlcnJvckNvbnRyb2xsZXIgPSBuZXcgX0Vycm9yQ29udHJvbGxlcih0aGlzKTtcbiAgICAgIHZhciBhYnJDb250cm9sbGVyID0gdGhpcy5hYnJDb250cm9sbGVyID0gbmV3IF9BYnJDb250cm9sbGVyKHRoaXMpO1xuICAgICAgLy8gRnJhZ21lbnRUcmFja2VyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICAgIHZhciBmcmFnbWVudFRyYWNrZXIgPSBuZXcgRnJhZ21lbnRUcmFja2VyKHRoaXMpO1xuICAgICAgdmFyIF9JbnRlcnN0aXRpYWxzQ29udHJvbGxlciA9IGNvbmZpZy5pbnRlcnN0aXRpYWxzQ29udHJvbGxlcjtcbiAgICAgIHZhciBpbnRlcnN0aXRpYWxzQ29udHJvbGxlciA9IF9JbnRlcnN0aXRpYWxzQ29udHJvbGxlciA/IHRoaXMuaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgPSBuZXcgX0ludGVyc3RpdGlhbHNDb250cm9sbGVyKHRoaXMsIEhscykgOiBudWxsO1xuICAgICAgdmFyIGJ1ZmZlckNvbnRyb2xsZXIgPSB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSBuZXcgX0J1ZmZlckNvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyKTtcbiAgICAgIHZhciBjYXBMZXZlbENvbnRyb2xsZXIgPSB0aGlzLmNhcExldmVsQ29udHJvbGxlciA9IG5ldyBfQ2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuICAgICAgdmFyIGZwc0NvbnRyb2xsZXIgPSBuZXcgX0Zwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgICB2YXIgcGxheUxpc3RMb2FkZXIgPSBuZXcgUGxheWxpc3RMb2FkZXIodGhpcyk7XG4gICAgICB2YXIgX0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgPSBjb25maWcuY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICAgIC8vIEluc3RhbnRpYXRlIENvbmVudFN0ZWVyaW5nQ29udHJvbGxlciBiZWZvcmUgTGV2ZWxDb250cm9sbGVyIHRvIHJlY2VpdmUgTXVsdGl2YXJpYW50IFBsYXlsaXN0IGV2ZW50cyBmaXJzdFxuICAgICAgdmFyIGNvbnRlbnRTdGVlcmluZyA9IF9Db250ZW50U3RlZXJpbmdDb250cm9sbGVyID8gbmV3IF9Db250ZW50U3RlZXJpbmdDb250cm9sbGVyKHRoaXMpIDogbnVsbDtcbiAgICAgIHZhciBsZXZlbENvbnRyb2xsZXIgPSB0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBMZXZlbENvbnRyb2xsZXIodGhpcywgY29udGVudFN0ZWVyaW5nKTtcbiAgICAgIHZhciBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgSUQzVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuICAgICAgdmFyIGtleUxvYWRlciA9IG5ldyBLZXlMb2FkZXIodGhpcy5jb25maWcsIHRoaXMubG9nZ2VyKTtcbiAgICAgIHZhciBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IFN0cmVhbUNvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpO1xuICAgICAgdmFyIGdhcENvbnRyb2xsZXIgPSB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgR2FwQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIpO1xuXG4gICAgICAvLyBDYXAgbGV2ZWwgY29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgICAgY2FwTGV2ZWxDb250cm9sbGVyLnNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAvLyBmcHNDb250cm9sbGVyIHVzZXMgc3RyZWFtQ29udHJvbGxlciB0byBzd2l0Y2ggd2hlbiBmcmFtZXMgYXJlIGJlaW5nIGRyb3BwZWRcbiAgICAgIGZwc0NvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTtcbiAgICAgIHZhciBuZXR3b3JrQ29udHJvbGxlcnMgPSBbcGxheUxpc3RMb2FkZXIsIGxldmVsQ29udHJvbGxlciwgc3RyZWFtQ29udHJvbGxlcl07XG4gICAgICBpZiAoaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIpIHtcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnNwbGljZSgxLCAwLCBpbnRlcnN0aXRpYWxzQ29udHJvbGxlcik7XG4gICAgICB9XG4gICAgICBpZiAoY29udGVudFN0ZWVyaW5nKSB7XG4gICAgICAgIG5ldHdvcmtDb250cm9sbGVycy5zcGxpY2UoMSwgMCwgY29udGVudFN0ZWVyaW5nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuICAgICAgdmFyIGNvcmVDb21wb25lbnRzID0gW2FickNvbnRyb2xsZXIsIGJ1ZmZlckNvbnRyb2xsZXIsIGdhcENvbnRyb2xsZXIsIGNhcExldmVsQ29udHJvbGxlciwgZnBzQ29udHJvbGxlciwgaWQzVHJhY2tDb250cm9sbGVyLCBmcmFnbWVudFRyYWNrZXJdO1xuICAgICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXIsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgICB2YXIgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICAgICAgaWYgKEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKHRoaXMuYXVkaW9TdHJlYW1Db250cm9sbGVyID0gbmV3IEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzKHRoaXMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSk7XG4gICAgICB9XG4gICAgICAvLyBJbnN0YW50aWF0ZSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBiZWZvcmUgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIHRvIHJlY2VpdmUgbGV2ZWwgZXZlbnRzIGZpcnN0XG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgbmV0d29ya0NvbnRyb2xsZXJzKTtcbiAgICAgIHZhciBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyA9IGNvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICBpZiAoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MpIHtcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2godGhpcy5zdWJ0aXRpdGxlU3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikpO1xuICAgICAgfVxuICAgICAgdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICAgIGtleUxvYWRlci5lbWVDb250cm9sbGVyID0gdGhpcy5lbWVDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5lbWVDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5jbWNkQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihMYXRlbmN5Q29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuXG4gICAgICAvLyBFcnJvciBjb250cm9sbGVyIGhhbmRsZXMgZXJyb3JzIGJlZm9yZSBhbmQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzXG4gICAgICAvLyBUaGlzIGxpc3RlbmVyIHdpbGwgYmUgaW52b2tlZCBhZnRlciBhbGwgb3RoZXIgY29udHJvbGxlcnMgZXJyb3IgbGlzdGVuZXJzXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChlcnJvckNvbnRyb2xsZXIpO1xuICAgICAgdmFyIG9uRXJyb3JPdXQgPSBlcnJvckNvbnRyb2xsZXIub25FcnJvck91dDtcbiAgICAgIGlmICh0eXBlb2Ygb25FcnJvck91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9uKEV2ZW50cy5FUlJPUiwgb25FcnJvck91dCwgZXJyb3JDb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIC8vIEF1dG9zdGFydCBsb2FkIGhhbmRsZXJcbiAgICAgIHRoaXMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgcGxheUxpc3RMb2FkZXIub25NYW5pZmVzdExvYWRlZCwgcGxheUxpc3RMb2FkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcmVxdWlyZWQgTWVkaWFTb3VyY2UgRXh0ZW5zaW9ucyBhcmUgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIEhscy5pc01TRVN1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzTVNFU3VwcG9ydGVkJDEoKSB7XG4gICAgICByZXR1cm4gaXNNU0VTdXBwb3J0ZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBNZWRpYVNvdXJjZSBFeHRlbnNpb25zIGFyZSBhdmFpbGFibGUgYW5kIGlzVHlwZVN1cHBvcnRlZCBjaGVja3MgcGFzcyBmb3IgYW55IGJhc2VsaW5lIGNvZGVjcy5cbiAgICAgKi87XG4gICAgSGxzLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQkMSgpIHtcbiAgICAgIHJldHVybiBpc1N1cHBvcnRlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTWVkaWFTb3VyY2UgZ2xvYmFsIHVzZWQgZm9yIE1TRSBwbGF5YmFjayAoTWFuYWdlZE1lZGlhU291cmNlLCBNZWRpYVNvdXJjZSwgb3IgV2ViS2l0TWVkaWFTb3VyY2UpLlxuICAgICAqLztcbiAgICBIbHMuZ2V0TWVkaWFTb3VyY2UgPSBmdW5jdGlvbiBnZXRNZWRpYVNvdXJjZSQxKCkge1xuICAgICAgcmV0dXJuIGdldE1lZGlhU291cmNlKCk7XG4gICAgfTtcbiAgICB2YXIgX3Byb3RvID0gSGxzLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uY3JlYXRlQ29udHJvbGxlciA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xsZXIoQ29udHJvbGxlckNsYXNzLCBjb21wb25lbnRzKSB7XG4gICAgICBpZiAoQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVySW5zdGFuY2UgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVySW5zdGFuY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBEZWxlZ2F0ZSB0aGUgRXZlbnRFbWl0dGVyIHRocm91Z2ggdGhlIHB1YmxpYyBBUEkgb2YgSGxzLmpzXG4gICAgO1xuICAgIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIF9wcm90by5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0dGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgIHRoaXMuX2VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgICB9O1xuICAgIF9wcm90by5vZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0LCBvbmNlKTtcbiAgICB9O1xuICAgIF9wcm90by5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhldmVudCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIG5hbWUsIGV2ZW50T2JqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5lbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCk7XG4gICAgfTtcbiAgICBfcHJvdG8udHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQsIGV2ZW50T2JqZWN0KSB7XG4gICAgICBpZiAodGhpcy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgZXZlbnQsIGV2ZW50T2JqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgZXZlbnQsIGV2ZW50T2JqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignQW4gaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgaGFuZGxpbmcgZXZlbnQgJyArIGV2ZW50ICsgJy4gRXJyb3IgbWVzc2FnZTogXCInICsgZXJyb3IubWVzc2FnZSArICdcIi4gSGVyZSBpcyBhIHN0YWNrdHJhY2U6JywgZXJyb3IpO1xuICAgICAgICAgIC8vIFByZXZlbnQgcmVjdXJzaW9uIGluIGVycm9yIGV2ZW50IGhhbmRsZXJzIHRoYXQgdGhyb3cgIzU0OTdcbiAgICAgICAgICBpZiAoIXRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbikge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBmYXRhbCA9IGV2ZW50ID09PSBFdmVudHMuRVJST1I7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgICAgICAgIGZhdGFsOiBmYXRhbCxcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIGluc3RhbmNlXG4gICAgICovO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5ERVNUUk9ZSU5HLCB1bmRlZmluZWQpO1xuICAgICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmNvcmVDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb3JlQ29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZWZlcmVuY2VzIHRoYXQgY291bGQgYmUgaGVsZCBpbiBjb25maWcgb3B0aW9ucyBvciBjYWxsYmFja3NcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIGNvbmZpZy54aHJTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwID0gdW5kZWZpbmVkO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy51c2VyQ29uZmlnID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBIbHMuanMgdG8gYSBtZWRpYSBlbGVtZW50XG4gICAgICovO1xuICAgIF9wcm90by5hdHRhY2hNZWRpYSA9IGZ1bmN0aW9uIGF0dGFjaE1lZGlhKGRhdGEpIHtcbiAgICAgIGlmICghZGF0YSB8fCAnbWVkaWEnIGluIGRhdGEgJiYgIWRhdGEubWVkaWEpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiYXR0YWNoTWVkaWEgZmFpbGVkOiBpbnZhbGlkIGFyZ3VtZW50IChcIiArIGRhdGEgKyBcIilcIik7XG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5BVFRBQ0hfTUVESUFfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJhdHRhY2hNZWRpYVwiKTtcbiAgICAgIGlmICh0aGlzLl9tZWRpYSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwibWVkaWEgbXVzdCBiZSBkZXRhY2hlZCBiZWZvcmUgYXR0YWNoaW5nXCIpO1xuICAgICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICB9XG4gICAgICB2YXIgYXR0YWNoTWVkaWFTb3VyY2UgPSAnbWVkaWEnIGluIGRhdGE7XG4gICAgICB2YXIgbWVkaWEgPSBhdHRhY2hNZWRpYVNvdXJjZSA/IGRhdGEubWVkaWEgOiBkYXRhO1xuICAgICAgdmFyIGF0dGFjaGluZ0RhdGEgPSBhdHRhY2hNZWRpYVNvdXJjZSA/IGRhdGEgOiB7XG4gICAgICAgIG1lZGlhOiBtZWRpYVxuICAgICAgfTtcbiAgICAgIHRoaXMuX21lZGlhID0gbWVkaWE7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSElORywgYXR0YWNoaW5nRGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIEhscy5qcyBmcm9tIHRoZSBtZWRpYVxuICAgICAqLztcbiAgICBfcHJvdG8uZGV0YWNoTWVkaWEgPSBmdW5jdGlvbiBkZXRhY2hNZWRpYSgpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygnZGV0YWNoTWVkaWEnKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNISU5HLCB7fSk7XG4gICAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIEhUTUxNZWRpYUVsZW1lbnQsIE1lZGlhU291cmNlLCBhbmQgU291cmNlQnVmZmVycyB3aXRob3V0IHJlc2V0LCBmb3IgYXR0YWNoaW5nIHRvIGFub3RoZXIgaW5zdGFuY2VcbiAgICAgKi87XG4gICAgX3Byb3RvLnRyYW5zZmVyTWVkaWEgPSBmdW5jdGlvbiB0cmFuc2Zlck1lZGlhKCkge1xuICAgICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgICAgdmFyIHRyYW5zZmVyTWVkaWEgPSB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIudHJhbnNmZXJNZWRpYSgpO1xuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHtcbiAgICAgICAgdHJhbnNmZXJNZWRpYTogdHJhbnNmZXJNZWRpYVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJhbnNmZXJNZWRpYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNvdXJjZSBVUkwuIENhbiBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZS5cbiAgICAgKi87XG4gICAgX3Byb3RvLmxvYWRTb3VyY2UgPSBmdW5jdGlvbiBsb2FkU291cmNlKHVybCkge1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIHZhciBsb2FkZWRTb3VyY2UgPSB0aGlzLl91cmw7XG4gICAgICB2YXIgbG9hZGluZ1NvdXJjZSA9IHRoaXMuX3VybCA9IHVybFRvb2xraXRFeHBvcnRzLmJ1aWxkQWJzb2x1dGVVUkwoc2VsZi5sb2NhdGlvbi5ocmVmLCB1cmwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IG51bGw7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJsb2FkU291cmNlOlwiICsgbG9hZGluZ1NvdXJjZSk7XG4gICAgICBpZiAobWVkaWEgJiYgbG9hZGVkU291cmNlICYmIChsb2FkZWRTb3VyY2UgIT09IGxvYWRpbmdTb3VyY2UgfHwgdGhpcy5idWZmZXJDb250cm9sbGVyLmhhc1NvdXJjZVR5cGVzKCkpKSB7XG4gICAgICAgIC8vIFJlbW92ZSBhbmQgcmUtY3JlYXRlIE1lZGlhU291cmNlXG4gICAgICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgICB9XG4gICAgICAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHtcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnRseSBsb2FkZWQgVVJMXG4gICAgICovO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGxvYWRpbmcgZGF0YSBmcm9tIHRoZSBzdHJlYW0gc291cmNlLlxuICAgICAqIERlcGVuZGluZyBvbiBkZWZhdWx0IGNvbmZpZywgY2xpZW50IHN0YXJ0cyBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBhIHNvdXJjZSBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnRQb3NpdGlvbiAtIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gdG8gc3RyZWFtIGZyb20uXG4gICAgICogRGVmYXVsdHMgdG8gLTEgKE5vbmU6IHN0YXJ0cyBmcm9tIGVhcmxpZXN0IHBvaW50KVxuICAgICAqL1xuICAgIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbiwgc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24pIHtcbiAgICAgIGlmIChzdGFydFBvc2l0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIubG9nKFwic3RhcnRMb2FkKFwiICsgKHN0YXJ0UG9zaXRpb24gKyAoc2tpcFNlZWtUb1N0YXJ0UG9zaXRpb24gPyAnLCA8c2tpcCBzZWVrIHRvIHN0YXJ0PicgOiAnJykpICsgXCIpXCIpO1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzW2ldLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uLCBza2lwU2Vla1RvU3RhcnRQb3NpdGlvbik7XG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkIHx8ICF0aGlzLm5ldHdvcmtDb250cm9sbGVycykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCBsb2FkaW5nIG9mIGFueSBzdHJlYW0gZGF0YS5cbiAgICAgKi87XG4gICAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnNbaV0uc3RvcExvYWQoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCB8fCAhdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBsb2FkaW5nLCB0b2dnbGVkIHdpdGggYHN0YXJ0TG9hZCgpYCBhbmQgYHN0b3BMb2FkKClgLCBpcyBhY3RpdmUgb3Igbm90YC5cbiAgICAgKi87XG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBzdHJlYW0gY29udHJvbGxlciBzZWdtZW50IGxvYWRpbmcgYWZ0ZXIgYHBhdXNlQnVmZmVyaW5nYCBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICovXG4gICAgX3Byb3RvLnJlc3VtZUJ1ZmZlcmluZyA9IGZ1bmN0aW9uIHJlc3VtZUJ1ZmZlcmluZygpIHtcbiAgICAgIGlmICghdGhpcy5idWZmZXJpbmdFbmFibGVkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInJlc3VtZSBidWZmZXJpbmdcIik7XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoY29udHJvbGxlci5yZXN1bWVCdWZmZXJpbmcpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVzdW1lQnVmZmVyaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyBzdHJlYW0gY29udHJvbGxlciBmcm9tIGxvYWRpbmcgbmV3IHNlZ21lbnRzIHVudGlsIGByZXN1bWVCdWZmZXJpbmdgIGlzIGNhbGxlZC5cbiAgICAgKiBUaGlzIGFsbG93cyBmb3IgbWVkaWEgYnVmZmVyaW5nIHRvIGJlIHBhdXNlZCB3aXRob3V0IGludGVydXB0aW5nIHBsYXlsaXN0IGxvYWRpbmcuXG4gICAgICovO1xuICAgIF9wcm90by5wYXVzZUJ1ZmZlcmluZyA9IGZ1bmN0aW9uIHBhdXNlQnVmZmVyaW5nKCkge1xuICAgICAgaWYgKHRoaXMuYnVmZmVyaW5nRW5hYmxlZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJwYXVzZSBidWZmZXJpbmdcIik7XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoY29udHJvbGxlci5wYXVzZUJ1ZmZlcmluZykge1xuICAgICAgICAgICAgY29udHJvbGxlci5wYXVzZUJ1ZmZlcmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTd2FwIHRocm91Z2ggcG9zc2libGUgYXVkaW8gY29kZWNzIGluIHRoZSBzdHJlYW0gKGZvciBleGFtcGxlIHRvIHN3aXRjaCBmcm9tIHN0ZXJlbyB0byA1LjEpXG4gICAgICovXG4gICAgX3Byb3RvLnN3YXBBdWRpb0NvZGVjID0gZnVuY3Rpb24gc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBtZWRpYS1lbGVtZW50IGZhaWxzLCB0aGlzIGFsbG93cyB0byBkZXRhY2ggYW5kIHRoZW4gcmUtYXR0YWNoIGl0XG4gICAgICogYXMgb25lIGNhbGwgKGNvbnZlbmllbmNlIG1ldGhvZCkuXG4gICAgICpcbiAgICAgKiBBdXRvbWF0aWMgcmVjb3Zlcnkgb2YgbWVkaWEtZXJyb3JzIGJ5IHRoaXMgcHJvY2VzcyBpcyBjb25maWd1cmFibGUuXG4gICAgICovO1xuICAgIF9wcm90by5yZWNvdmVyTWVkaWFFcnJvciA9IGZ1bmN0aW9uIHJlY292ZXJNZWRpYUVycm9yKCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5fbWVkaWE7XG4gICAgICB2YXIgdGltZSA9IG1lZGlhID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9hZCh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUxldmVsID0gZnVuY3Rpb24gcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIucmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgYSBVVUlEIGZvciB0aGlzIHBsYXllciBpbnN0YW5jZVxuICAgICAqLztcbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgYXVkaW8gdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICAgKiBVcGRhdGVzIGBobHMuY29uZmlnLmF1ZGlvUHJlZmVyZW5jZWAuIFJldHVybnMgdGhlIHNlbGVjdGVkIHRyYWNrLCBvciBudWxsIHdoZW4gbm8gbWF0Y2hpbmcgdHJhY2sgaXMgZm91bmQuXG4gICAgICovXG4gICAgX3Byb3RvLnNldEF1ZGlvT3B0aW9uID0gZnVuY3Rpb24gc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRhdWRpb1RyYWNrQ29udHI7XG4gICAgICByZXR1cm4gKChfdGhpcyRhdWRpb1RyYWNrQ29udHIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYXVkaW9UcmFja0NvbnRyLnNldEF1ZGlvT3B0aW9uKGF1ZGlvT3B0aW9uKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgc2VsZWN0IHRoZSBiZXN0IG1hdGNoaW5nIHN1YnRpdGxlIHRyYWNrLCBtYWtpbmcgYSBsZXZlbCBzd2l0Y2ggd2hlbiBhIEdyb3VwIGNoYW5nZSBpcyBuZWNlc3NhcnkuXG4gICAgICogVXBkYXRlcyBgaGxzLmNvbmZpZy5zdWJ0aXRsZVByZWZlcmVuY2VgLiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB0cmFjaywgb3IgbnVsbCB3aGVuIG5vIG1hdGNoaW5nIHRyYWNrIGlzIGZvdW5kLlxuICAgICAqLztcbiAgICBfcHJvdG8uc2V0U3VidGl0bGVPcHRpb24gPSBmdW5jdGlvbiBzZXRTdWJ0aXRsZU9wdGlvbihzdWJ0aXRsZU9wdGlvbikge1xuICAgICAgdmFyIF90aGlzJHN1YnRpdGxlVHJhY2tDbztcbiAgICAgIHJldHVybiAoKF90aGlzJHN1YnRpdGxlVHJhY2tDbyA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzdWJ0aXRsZVRyYWNrQ28uc2V0U3VidGl0bGVPcHRpb24oc3VidGl0bGVPcHRpb24pKSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29tcGxldGUgbGlzdCBvZiBhdWRpbyB0cmFja3MgYWNyb3NzIGFsbCBtZWRpYSBncm91cHNcbiAgICAgKi87XG4gICAgLyoqXG4gICAgICogcmV0dXJucyBtZWRpYUNhcGFiaWxpdGllcy5kZWNvZGluZ0luZm8gZm9yIGEgdmFyaWFudC9yZW5kaXRpb25cbiAgICAgKi9cbiAgICBfcHJvdG8uZ2V0TWVkaWFEZWNvZGluZ0luZm8gPSBmdW5jdGlvbiBnZXRNZWRpYURlY29kaW5nSW5mbyhsZXZlbCwgYXVkaW9UcmFja3MpIHtcbiAgICAgIGlmIChhdWRpb1RyYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGF1ZGlvVHJhY2tzID0gdGhpcy5hbGxBdWRpb1RyYWNrcztcbiAgICAgIH1cbiAgICAgIHZhciBhdWRpb1RyYWNrc0J5R3JvdXAgPSBnZXRBdWRpb1RyYWNrc0J5R3JvdXAoYXVkaW9UcmFja3MpO1xuICAgICAgcmV0dXJuIGdldE1lZGlhRGVjb2RpbmdJbmZvUHJvbWlzZShsZXZlbCwgYXVkaW9UcmFja3NCeUdyb3VwLCBuYXZpZ2F0b3IubWVkaWFDYXBhYmlsaXRpZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhIbHMsIFt7XG4gICAgICBrZXk6IFwidXJsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIG9yIG5vdCBlbm91Z2ggaGFzIGJlZW4gYnVmZmVyZWQgdG8gc2VlayB0byBzdGFydCBwb3NpdGlvbiBvciB1c2UgYG1lZGlhLmN1cnJlbnRUaW1lYCB0byBkZXRlcm1pbmUgbmV4dCBsb2FkIHBvc2l0aW9uXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFzRW5vdWdoVG9TdGFydFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaGFzRW5vdWdoVG9TdGFydDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIHN0YXJ0UG9zaXRpb24gc2V0IG9uIHN0YXJ0TG9hZChwb3NpdGlvbikgb3Igb24gYXV0b3N0YXJ0IHdpdGggY29uZmlnLnN0YXJ0UG9zaXRpb25cbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGFydFBvc2l0aW9uXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zdGFydFBvc2l0aW9uVmFsdWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxvYWRpbmdFbmFibGVkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRlZDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHN0YXRlIG9mIGZyYWdtZW50IGxvYWRpbmcgdG9nZ2xlZCBieSBjYWxsaW5nIGBwYXVzZUJ1ZmZlcmluZygpYCBhbmQgYHJlc3VtZUJ1ZmZlcmluZygpYC5cbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJidWZmZXJpbmdFbmFibGVkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5idWZmZXJpbmdFbmFibGVkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbkZsaWdodEZyYWdtZW50c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfaW5GbGlnaHREYXRhO1xuICAgICAgICB2YXIgaW5GbGlnaHREYXRhID0gKF9pbkZsaWdodERhdGEgPSB7fSwgX2luRmxpZ2h0RGF0YVtQbGF5bGlzdExldmVsVHlwZS5NQUlOXSA9IHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbkZsaWdodEZyYWcsIF9pbkZsaWdodERhdGEpO1xuICAgICAgICBpZiAodGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpbkZsaWdodERhdGFbUGxheWxpc3RMZXZlbFR5cGUuQVVESU9dID0gdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIuaW5GbGlnaHRGcmFnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1YnRpdGl0bGVTdHJlYW1Db250cm9sbGVyKSB7XG4gICAgICAgICAgaW5GbGlnaHREYXRhW1BsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFXSA9IHRoaXMuc3VidGl0aXRsZVN0cmVhbUNvbnRyb2xsZXIuaW5GbGlnaHRGcmFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbkZsaWdodERhdGE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNlc3Npb25JZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfc2Vzc2lvbklkID0gdGhpcy5fc2Vzc2lvbklkO1xuICAgICAgICBpZiAoIV9zZXNzaW9uSWQpIHtcbiAgICAgICAgICBfc2Vzc2lvbklkID0gdGhpcy5fc2Vzc2lvbklkID0gdXVpZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2Vzc2lvbklkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIGxldmVscyAodmFyaWFudHMpIHNvcnRlZCBieSBIRENQLUxFVkVMLCBSRVNPTFVUSU9OIChoZWlnaHQpLCBGUkFNRS1SQVRFLCBDT0RFQ1MsIFZJREVPLVJBTkdFLCBhbmQgQkFORFdJRFRIXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGV2ZWxzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscztcbiAgICAgICAgcmV0dXJuIGxldmVscyA/IGxldmVscyA6IFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEByZXR1cm5zIExldmVsRGV0YWlscyBvZiBsYXN0IGxvYWRlZCBsZXZlbCAodmFyaWFudCkgb3IgYG51bGxgIHByaW9yIHRvIGxvYWRpbmcgYSBtZWRpYSBwbGF5bGlzdC5cbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsYXRlc3RMZXZlbERldGFpbHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmdldExldmVsRGV0YWlscygpIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybnMgTGV2ZWwgb2JqZWN0IG9mIHNlbGVjdGVkIGxldmVsICh2YXJpYW50KSBvciBgbnVsbGAgcHJpb3IgdG8gc2VsZWN0aW5nIGEgbGV2ZWwgb3Igb25jZSB0aGUgbGV2ZWwgaXMgcmVtb3ZlZC5cbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb2FkTGV2ZWxPYmpcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubG9hZExldmVsT2JqO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgKHZhcmlhbnQpIGN1cnJlbnRseSBwbGF5ZWRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJjdXJyZW50TGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBpbW1lZGlhdGVseS4gVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuIFRoYXQgbWVhbnMgcGxheWJhY2sgd2lsbCBpbnRlcnJ1cHQgYXQgbGVhc3Qgc2hvcnRseSB0byByZS1idWZmZXIgYW5kIHJlLXN5bmMgZXZlbnR1YWxseS4gU2V0IHRvIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uLlxuICAgICAgICovLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwic2V0IGN1cnJlbnRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW5kZXggb2YgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZCBhcyBzY2hlZHVsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXIuXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibmV4dExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAgICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSB2aWRlbyBxdWFsaXR5IGFzYXAsIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrLlxuICAgICAgICogTWF5IGFib3J0IGN1cnJlbnQgbG9hZGluZyBvZiBkYXRhLCBhbmQgZmx1c2ggcGFydHMgb2YgYnVmZmVyIChvdXRzaWRlIGN1cnJlbnRseSBwbGF5ZWQgZnJhZ21lbnQgcmVnaW9uKS5cbiAgICAgICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInNldCBuZXh0TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBvciBsYXN0IChvZiBub25lIGlzIGxvYWRlZCBjdXJyZW50bHkpIHNlZ21lbnRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb2FkTGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxuICAgICAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgcXVhbGl0eSB3aXRob3V0IGZsdXNoaW5nLCBidXQgaW50ZXJydXB0IGN1cnJlbnQgbG9hZGluZy5cbiAgICAgICAqIFRodXMgdGhlIG1vbWVudCB3aGVuIHRoZSBxdWFsaXR5IHN3aXRjaCB3aWxsIGFwcGVhciBpbiBlZmZlY3Qgd2lsbCBvbmx5IGJlIGFmdGVyIHRoZSBhbHJlYWR5IGV4aXN0aW5nIGJ1ZmZlci5cbiAgICAgICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInNldCBsb2FkTGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0TG9hZExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBsb2FkZWQgc2VnbWVudCBpbiBhIGZ1bGx5IFwibm9uLWRlc3RydWN0aXZlXCIgd2F5LlxuICAgICAgICogU2FtZSBhcyBgbG9hZExldmVsYCBidXQgd2lsbCB3YWl0IGZvciBuZXh0IHN3aXRjaCAodW50aWwgY3VycmVudCBsb2FkaW5nIGlzIGRvbmUpLlxuICAgICAgICovLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobGV2ZWwpIHtcbiAgICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiBcImZpcnN0IGxldmVsXCI6IGxpa2UgYSBkZWZhdWx0IGxldmVsLCBpZiBub3Qgc2V0LFxuICAgICAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmlyc3RMZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAgICAgKi8sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJzZXQgZmlyc3RMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB0aGUgZGVzaXJlZCBzdGFydCBsZXZlbCBmb3IgdGhlIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQuXG4gICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiAtMSBpbmRpY2F0ZXMgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbi5cbiAgICAgICAqIFNldHRpbmcgaGxzLm5leHRBdXRvTGV2ZWwgd2l0aG91dCBzZXR0aW5nIGEgc3RhcnRMZXZlbCB3aWxsIHJlc3VsdCBpblxuICAgICAgICogdGhlIG5leHRBdXRvTGV2ZWwgdmFsdWUgYmVpbmcgdXNlZCBmb3Igb25lIGZyYWdtZW50IGxvYWQuXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3RhcnRMZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBzdGFydExldmVsID0gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xICYmIHRoaXMuYWJyQ29udHJvbGxlci5mb3JjZWRBdXRvTGV2ZWwgPiAtMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIuZm9yY2VkQXV0b0xldmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAgICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAgICAgKi8sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJzZXQgc3RhcnRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgICAgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcbiAgICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciBsZXZlbCBjYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIHNldCB2aWEgYGNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZWAuXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2FwTGV2ZWxUb1BsYXllclNpemVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBsZXZlbCBjYXBwaW5nLiBJZiBkaXNhYmxlZCBhZnRlciBwcmV2aW91c2x5IGVuYWJsZWQsIGBuZXh0TGV2ZWxTd2l0Y2hgIHdpbGwgYmUgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICAgICAgICovLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc2hvdWxkU3RhcnRDYXBwaW5nKSB7XG4gICAgICAgIHZhciBuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSA9ICEhc2hvdWxkU3RhcnRDYXBwaW5nO1xuICAgICAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgIT09IHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdGFydENhcHBpbmcoKTsgLy8gSWYgY2FwcGluZyBvY2N1cnMsIG5leHRMZXZlbFN3aXRjaCB3aWxsIGhhcHBlbiBiYXNlZCBvbiBzaXplLlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpO1xuICAgICAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7IC8vIE5vdyB3ZSdyZSB1bmNhcHBlZCwgZ2V0IHRoZSBuZXh0IGxldmVsIGFzYXAuXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplID0gbmV3Q2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXV0b0xldmVsQ2FwcGluZ1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmFuZHdpZHRoIGVzdGltYXRlIGluIGJpdHMgcGVyIHNlY29uZCwgd2hlbiBhdmFpbGFibGUuIE90aGVyd2lzZSwgYE5hTmAgaXMgcmV0dXJuZWQuXG4gICAgICAgKi8sXG4gICAgICBzZXQ6XG4gICAgICAvKipcbiAgICAgICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nICE9PSBuZXdMZXZlbCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInNldCBhdXRvTGV2ZWxDYXBwaW5nOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcbiAgICAgICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5jaGVja01heEF1dG9VcGRhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYmFuZHdpZHRoRXN0aW1hdGVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgYndFc3RpbWF0b3IgPSB0aGlzLmFickNvbnRyb2xsZXIuYndFc3RpbWF0b3I7XG4gICAgICAgIGlmICghYndFc3RpbWF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBid0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHtcbiAgICAgICAgdGhpcy5hYnJDb250cm9sbGVyLnJlc2V0RXN0aW1hdG9yKGFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhYnJFd21hRGVmYXVsdEVzdGltYXRlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGJ3RXN0aW1hdG9yID0gdGhpcy5hYnJDb250cm9sbGVyLmJ3RXN0aW1hdG9yO1xuICAgICAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYndFc3RpbWF0b3IuZGVmYXVsdEVzdGltYXRlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aW1lIHRvIGZpcnN0IGJ5dGUgZXN0aW1hdGVcbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidHRmYkVzdGltYXRlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGJ3RXN0aW1hdG9yID0gdGhpcy5hYnJDb250cm9sbGVyLmJ3RXN0aW1hdG9yO1xuICAgICAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1heEhkY3BMZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhIZGNwTGV2ZWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzSGRjcExldmVsKHZhbHVlKSAmJiB0aGlzLl9tYXhIZGNwTGV2ZWwgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fbWF4SGRjcExldmVsID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuY2hlY2tNYXhBdXRvVXBkYXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSB3aGVuIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gZW5hYmxlZFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImF1dG9MZXZlbEVuYWJsZWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExldmVsIHNldCBtYW51YWxseSAoaWYgYW55KVxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1hbnVhbExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWluQXV0b0xldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICAgIG1pbkF1dG9CaXRyYXRlID0gdGhpcy5jb25maWcubWluQXV0b0JpdHJhdGU7XG4gICAgICAgIGlmICghbGV2ZWxzKSByZXR1cm4gMDtcbiAgICAgICAgdmFyIGxlbiA9IGxldmVscy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobGV2ZWxzW2ldLm1heEJpdHJhdGUgPj0gbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtYXggbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGF1dG9MZXZlbENhcHBpbmdcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXhBdXRvTGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgICAgYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuYXV0b0xldmVsQ2FwcGluZyxcbiAgICAgICAgICBtYXhIZGNwTGV2ZWwgPSB0aGlzLm1heEhkY3BMZXZlbDtcbiAgICAgICAgdmFyIG1heEF1dG9MZXZlbDtcbiAgICAgICAgaWYgKGF1dG9MZXZlbENhcHBpbmcgPT09IC0xICYmIGxldmVscyAhPSBudWxsICYmIGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhBdXRvTGV2ZWwgPSBhdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhIZGNwTGV2ZWwpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gbWF4QXV0b0xldmVsOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgaGRjcExldmVsID0gbGV2ZWxzW2ldLmF0dHJzWydIRENQLUxFVkVMJ107XG4gICAgICAgICAgICBpZiAoaGRjcExldmVsICYmIGhkY3BMZXZlbCA8PSBtYXhIZGNwTGV2ZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZpcnN0QXV0b0xldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJyQ29udHJvbGxlci5maXJzdEF1dG9MZXZlbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBuZXh0IGF1dG9tYXRpY2FsbHkgc2VsZWN0ZWQgcXVhbGl0eSBsZXZlbFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcIm5leHRBdXRvTGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhpcyBzZXR0ZXIgaXMgdXNlZCB0byBmb3JjZSBuZXh0IGF1dG8gbGV2ZWwuXG4gICAgICAgKiB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZTpcbiAgICAgICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICAgICAqIGZvcmNlZCB2YWx1ZSBpcyB2YWxpZCBmb3Igb25lIGZyYWdtZW50LiB1cG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkaW5nIGF0IGZvcmNlZCBsZXZlbCxcbiAgICAgICAqIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlci5cbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5leHRMZXZlbCkge1xuICAgICAgICB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIGRhdGV0aW1lIHZhbHVlIHJlbGF0aXZlIHRvIG1lZGlhLmN1cnJlbnRUaW1lIGZvciB0aGUgYWN0aXZlIGxldmVsIFByb2dyYW0gRGF0ZSBUaW1lIGlmIHByZXNlbnRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJwbGF5aW5nRGF0ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudFByb2dyYW1EYXRlVGltZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWFpbkZvcndhcmRCdWZmZXJJbmZvXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXhCdWZmZXJMZW5ndGhcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm1heEJ1ZmZlckxlbmd0aDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWxsQXVkaW9UcmFja3NcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hbGxBdWRpb1RyYWNrcyA6IFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgbGlzdCBvZiBzZWxlY3RhYmxlIGF1ZGlvIHRyYWNrc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImF1ZGlvVHJhY2tzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKVxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrIDogLTE7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXG4gICAgICAgKi8sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhdWRpb1RyYWNrSWQpIHtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aGUgY29tcGxldGUgbGlzdCBvZiBzdWJ0aXRsZSB0cmFja3MgYWNyb3NzIGFsbCBtZWRpYSBncm91cHNcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJhbGxTdWJ0aXRsZVRyYWNrc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLmFsbFN1YnRpdGxlVHJhY2tzIDogW107XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0XG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3VidGl0bGVUcmFja3NcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3VidGl0bGVUcmFja1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgICAgIH0sXG4gICAgICBzZXQ6XG4gICAgICAvKipcbiAgICAgICAqIHNlbGVjdCBhbiBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHNldChzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgc3VidGl0bGUgZGlzcGxheSBpcyBlbmFibGVkIG9yIG5vdFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1lZGlhXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdWJ0aXRsZURpc3BsYXlcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgICAgICovLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgbW9kZSBmb3IgTG93LUxhdGVuY3kgSExTIGxvYWRpbmdcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb3dMYXRlbmN5TW9kZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbmFibGUvZGlzYWJsZSBMb3ctTGF0ZW5jeSBITFMgcGFydCBwbGF5bGlzdCBhbmQgc2VnbWVudCBsb2FkaW5nLCBhbmQgc3RhcnQgbGl2ZSBzdHJlYW1zIGF0IHBsYXlsaXN0IFBBUlQtSE9MRC1CQUNLIHJhdGhlciB0aGFuIEhPTEQtQkFDSy5cbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG1vZGUpIHtcbiAgICAgICAgdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgPSBtb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIHN5bmMgcG9pbnQgKGllIGVkZ2Ugb2YgbGl2ZSBwb3NpdGlvbiBtaW51cyBzYWZldHkgZGVsYXkgZGVmaW5lZCBieSBgYGBobHMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25gYGApXG4gICAgICAgKiBAcmV0dXJucyBudWxsIHByaW9yIHRvIGxvYWRpbmcgbGl2ZSBQbGF5bGlzdFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImxpdmVTeW5jUG9zaXRpb25cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVzdGltYXRlZCBwb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBlZGdlIChpZSBlZGdlIG9mIGxpdmUgcGxheWxpc3QgcGx1cyB0aW1lIHN5bmMgcGxheWxpc3QgYWR2YW5jZWQpXG4gICAgICAgKiBAcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsYXRlbmN5XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGF0ZW5jeTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYmVmb3JlIHRoZSBwbGF5ZXIgc2Vla3MgZm9yd2FyZCB0byBgYGBobHMubGl2ZVN5bmNQb3NpdGlvbmBgYFxuICAgICAgICogY29uZmlndXJlZCB1c2luZyBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRgYGAgKG11bHRpcGxlIG9mIHRhcmdldCBkdXJhdGlvbikgb3IgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbmBgYFxuICAgICAgICogQHJldHVybnMgMCBiZWZvcmUgZmlyc3QgcGxheWxpc3QgaXMgbG9hZGVkXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWF4TGF0ZW5jeVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLm1heExhdGVuY3k7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGFyZ2V0IGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYXMgY2FsY3VsYXRlZCBieSB0aGUgbGF0ZW5jeSBjb250cm9sbGVyXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidGFyZ2V0TGF0ZW5jeVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3k7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobGF0ZW5jeSkge1xuICAgICAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3kgPSBsYXRlbmN5O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBlZGdlIG9mIHRoZSBjdXJyZW50IGxpdmUgcGxheWxpc3QgaXMgYWR2YW5jaW5nIG9yIDEgaWYgdGhlcmUgaXMgbm9uZVxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImRyaWZ0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIuZHJpZnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2V0IHRvIHRydWUgd2hlbiBzdGFydExvYWQgaXMgY2FsbGVkIGJlZm9yZSBNQU5JRkVTVF9QQVJTRUQgZXZlbnRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JjZVN0YXJ0TG9hZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZm9yY2VTdGFydExvYWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udGVudFN0ZWVyaW5nIHBhdGh3YXlzIGdldHRlclxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInBhdGh3YXlzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnBhdGh3YXlzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENvbnRlbnRTdGVlcmluZyBwYXRod2F5UHJpb3JpdHkgZ2V0dGVyL3NldHRlclxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInBhdGh3YXlQcmlvcml0eVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5wYXRod2F5UHJpb3JpdHk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocGF0aHdheVByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnBhdGh3YXlQcmlvcml0eSA9IHBhdGh3YXlQcmlvcml0eTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiByZXR1cm5zIHRydWUgd2hlbiBhbGwgU291cmNlQnVmZmVycyBhcmUgYnVmZmVyZWQgdG8gdGhlIGVuZFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImJ1ZmZlcmVkVG9FbmRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkYnVmZmVyQ29udHJvbGxlO1xuICAgICAgICByZXR1cm4gISEoKF90aGlzJGJ1ZmZlckNvbnRyb2xsZSA9IHRoaXMuYnVmZmVyQ29udHJvbGxlcikgIT0gbnVsbCAmJiBfdGhpcyRidWZmZXJDb250cm9sbGUuYnVmZmVyZWRUb0VuZCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogcmV0dXJucyBJbnRlcnN0aXRpYWxzIFByb2dyYW0gTWFuYWdlclxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImludGVyc3RpdGlhbHNNYW5hZ2VyXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJGludGVyc3RpdGlhbHNDbztcbiAgICAgICAgcmV0dXJuICgoX3RoaXMkaW50ZXJzdGl0aWFsc0NvID0gdGhpcy5pbnRlcnN0aXRpYWxzQ29udHJvbGxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGludGVyc3RpdGlhbHNDby5pbnRlcnN0aXRpYWxzTWFuYWdlcikgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgICBnZXQ6XG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgdmlkZW8tZGV2L2hscy5qcyBwYWNrYWdlIHZlcnNpb24uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkV2ZW50c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFdmVudHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIk1ldGFkYXRhU2NoZW1hXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhU2NoZW1hO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJFcnJvclR5cGVzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yVHlwZXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkVycm9yRGV0YWlsc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBuZXcgaW5zdGFuY2VzLlxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcIkRlZmF1bHRDb25maWdcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoIUhscy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgICAgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2UgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIG5ldyBpbnN0YW5jZXMuXG4gICAgICAgKi8sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbiAgSGxzLmRlZmF1bHRDb25maWcgPSB2b2lkIDA7XG5cbiAgcmV0dXJuIEhscztcblxufSkpO1xufSkoZmFsc2UpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hls.js/dist/hls.js\n");

/***/ })

};
;